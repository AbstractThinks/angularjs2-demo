webpackJsonp([0],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var platform_browser_dynamic_1 = __webpack_require__(1);
	var app_module_1 = __webpack_require__(23);
	platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);


/***/ },

/***/ 23:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var platform_browser_1 = __webpack_require__(21);
	var forms_1 = __webpack_require__(24);
	var http_1 = __webpack_require__(28);
	var appRouter_module_1 = __webpack_require__(29);
	var app_component_1 = __webpack_require__(108);
	__webpack_require__(109);
	// if (environment.production) {
	core_1.enableProdMode();
	// }
	var AppModule = (function () {
	    function AppModule() {
	    }
	    return AppModule;
	}());
	AppModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            forms_1.FormsModule,
	            platform_browser_1.BrowserModule,
	            http_1.HttpModule,
	            appRouter_module_1.AppRoutingModule,
	        ],
	        declarations: [
	            app_component_1.AppComponent,
	        ],
	        bootstrap: [app_component_1.AppComponent]
	    }),
	    __metadata("design:paramtypes", [])
	], AppModule);
	exports.AppModule = AppModule;


/***/ },

/***/ 24:
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.4.8
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3), __webpack_require__(25), __webpack_require__(6), __webpack_require__(7), __webpack_require__(26)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/operator/toPromise', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/observable/fromPromise'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.forms = global.ng.forms || {}),global.ng.core,global.Rx.Observable.prototype,global.Rx,global.Rx,global.Rx.Observable));
	}(this, function (exports,_angular_core,rxjs_operator_toPromise,rxjs_Subject,rxjs_Observable,rxjs_observable_fromPromise) { 'use strict';
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Base class for control directives.
	     *
	     * Only used internally in the forms module.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AbstractControlDirective = (function () {
	        function AbstractControlDirective() {
	        }
	        Object.defineProperty(AbstractControlDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw new Error('unimplemented'); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "value", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.value : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.valid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "invalid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.invalid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pending", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.pending : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "errors", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.errors : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.pristine : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.dirty : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "touched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.touched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.untouched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "disabled", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.disabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "enabled", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.enabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "statusChanges", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.statusChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valueChanges", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.valueChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.reset = function (value) {
	            if (value === void 0) { value = undefined; }
	            if (this.control)
	                this.control.reset(value);
	        };
	        /**
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.hasError(errorCode, path) : false;
	        };
	        /**
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.getError(errorCode, path) : null;
	        };
	        return AbstractControlDirective;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * A directive that contains multiple {\@link NgControl}s.
	     *
	     * Only used by the forms module.
	     *
	     * \@stable
	     */
	    var ControlContainer = (function (_super) {
	        __extends$1(ControlContainer, _super);
	        function ControlContainer() {
	            _super.apply(this, arguments);
	        }
	        Object.defineProperty(ControlContainer.prototype, "formDirective", {
	            /**
	             * Get the form to which this container belongs.
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ControlContainer.prototype, "path", {
	            /**
	             * Get the path to this container.
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        return ControlContainer;
	    }(AbstractControlDirective));
	
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }
	
	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} condition
	         * @return {?}
	         */
	        ListWrapper.findLast = function (arr, condition) {
	            for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {
	                if (condition(arr[i])) {
	                    return arr[i];
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} list
	         * @param {?} items
	         * @return {?}
	         */
	        ListWrapper.removeAll = function (list, items) {
	            for (var /** @type {?} */ i = 0; i < items.length; ++i) {
	                var /** @type {?} */ index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        /**
	         * @param {?} list
	         * @param {?} el
	         * @return {?}
	         */
	        ListWrapper.remove = function (list, el) {
	            var /** @type {?} */ index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} a
	         * @param {?} b
	         * @return {?}
	         */
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        /**
	         * @param {?} list
	         * @return {?}
	         */
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return ((flat)).concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());
	
	    var /** @type {?} */ isPromise = _angular_core.__core_private__.isPromise;
	    var /** @type {?} */ isObservable = _angular_core.__core_private__.isObservable;
	
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    function isEmptyInputValue(value) {
	        // we don't check for string here so it also works with arrays
	        return value == null || value.length === 0;
	    }
	    /**
	     * Providers for validators to be used for {@link FormControl}s in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * ### Example
	     *
	     * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	     * @stable
	     */
	    var /** @type {?} */ NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');
	    /**
	     * Providers for asynchronous validators to be used for {@link FormControl}s
	     * in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * See {@link NG_VALIDATORS} for more details.
	     *
	     * @stable
	     */
	    var /** @type {?} */ NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');
	    /**
	     * Provides a set of validators used by form controls.
	     *
	     * A validator is a function that processes a {\@link FormControl} or collection of
	     * controls and returns a map of errors. A null map means that validation has passed.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * var loginControl = new FormControl("", Validators.required)
	     * ```
	     *
	     * \@stable
	     */
	    var Validators = (function () {
	        function Validators() {
	        }
	        /**
	         * Validator that requires controls to have a non-empty value.
	         * @param {?} control
	         * @return {?}
	         */
	        Validators.required = function (control) {
	            return isEmptyInputValue(control.value) ? { 'required': true } : null;
	        };
	        /**
	         * Validator that requires control value to be true.
	         * @param {?} control
	         * @return {?}
	         */
	        Validators.requiredTrue = function (control) {
	            return control.value === true ? null : { 'required': true };
	        };
	        /**
	         * Validator that requires controls to have a value of a minimum length.
	         * @param {?} minLength
	         * @return {?}
	         */
	        Validators.minLength = function (minLength) {
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var /** @type {?} */ length = control.value ? control.value.length : 0;
	                return length < minLength ?
	                    { 'minlength': { 'requiredLength': minLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires controls to have a value of a maximum length.
	         * @param {?} maxLength
	         * @return {?}
	         */
	        Validators.maxLength = function (maxLength) {
	            return function (control) {
	                var /** @type {?} */ length = control.value ? control.value.length : 0;
	                return length > maxLength ?
	                    { 'maxlength': { 'requiredLength': maxLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires a control to match a regex to its value.
	         * @param {?} pattern
	         * @return {?}
	         */
	        Validators.pattern = function (pattern) {
	            if (!pattern)
	                return Validators.nullValidator;
	            var /** @type {?} */ regex;
	            var /** @type {?} */ regexStr;
	            if (typeof pattern === 'string') {
	                regexStr = "^" + pattern + "$";
	                regex = new RegExp(regexStr);
	            }
	            else {
	                regexStr = pattern.toString();
	                regex = pattern;
	            }
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var /** @type {?} */ value = control.value;
	                return regex.test(value) ? null :
	                    { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } };
	            };
	        };
	        /**
	         * No-op validator.
	         * @param {?} c
	         * @return {?}
	         */
	        Validators.nullValidator = function (c) { return null; };
	        /**
	         * Compose multiple validators into a single function that returns the union
	         * of the individual error maps.
	         * @param {?} validators
	         * @return {?}
	         */
	        Validators.compose = function (validators) {
	            if (!validators)
	                return null;
	            var /** @type {?} */ presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                return _mergeErrors(_executeValidators(control, presentValidators));
	            };
	        };
	        /**
	         * @param {?} validators
	         * @return {?}
	         */
	        Validators.composeAsync = function (validators) {
	            if (!validators)
	                return null;
	            var /** @type {?} */ presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                var /** @type {?} */ promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
	                return Promise.all(promises).then(_mergeErrors);
	            };
	        };
	        return Validators;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function _convertToPromise(obj) {
	        return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);
	    }
	    /**
	     * @param {?} control
	     * @param {?} validators
	     * @return {?}
	     */
	    function _executeValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    /**
	     * @param {?} control
	     * @param {?} validators
	     * @return {?}
	     */
	    function _executeAsyncValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    /**
	     * @param {?} arrayOfErrors
	     * @return {?}
	     */
	    function _mergeErrors(arrayOfErrors) {
	        var /** @type {?} */ res = arrayOfErrors.reduce(function (res, errors) {
	            return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
	        }, {});
	        return Object.keys(res).length === 0 ? null : res;
	    }
	
	    /**
	     * Used to provide a {@link ControlValueAccessor} for form controls.
	     *
	     * See {@link DefaultValueAccessor} for how to implement one.
	     * @stable
	     */
	    var /** @type {?} */ NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');
	
	    var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxControlValueAccessor; }),
	        multi: true,
	    };
	    /**
	     * The accessor for writing a value and listening to changes on a checkbox input element.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="checkbox" name="rememberLogin" ngModel>
	     *  ```
	     *
	     *  \@stable
	     */
	    var CheckboxControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function CheckboxControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        CheckboxControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
	                        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	                        providers: [CHECKBOX_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return CheckboxControlValueAccessor;
	    }());
	
	    var /** @type {?} */ DEFAULT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return DefaultValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The default accessor for writing a value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="text" name="searchQuery" ngModel>
	     *  ```
	     *
	     *  \@stable
	     */
	    var DefaultValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function DefaultValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.writeValue = function (value) {
	            var /** @type {?} */ normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        DefaultValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	                        // TODO: vsavkin replace the above selector with the one below it once
	                        // https://github.com/angular/angular/issues/3011 is implemented
	                        // selector: '[ngControl],[ngModel],[ngFormControl]',
	                        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [DEFAULT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        DefaultValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return DefaultValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function normalizeValidator(validator) {
	        if (((validator)).validate) {
	            return function (c) { return ((validator)).validate(c); };
	        }
	        else {
	            return (validator);
	        }
	    }
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function normalizeAsyncValidator(validator) {
	        if (((validator)).validate) {
	            return function (c) { return ((validator)).validate(c); };
	        }
	        else {
	            return (validator);
	        }
	    }
	
	    var /** @type {?} */ NUMBER_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return NumberValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a number value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="number" [(ngModel)]="age">
	     *  ```
	     */
	    var NumberValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function NumberValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.writeValue = function (value) {
	            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
	            var /** @type {?} */ normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        NumberValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [NUMBER_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        NumberValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return NumberValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @return {?}
	     */
	    function unimplemented() {
	        throw new Error('unimplemented');
	    }
	    /**
	     * A base class that all control directive extend.
	     * It binds a {\@link FormControl} object to a DOM element.
	     *
	     * Used internally by Angular forms.
	     *
	     * \@stable
	     * @abstract
	     */
	    var NgControl = (function (_super) {
	        __extends$2(NgControl, _super);
	        function NgControl() {
	            _super.apply(this, arguments);
	            /** @internal */
	            this._parent = null;
	            this.name = null;
	            this.valueAccessor = null;
	            /** @internal */
	            this._rawValidators = [];
	            /** @internal */
	            this._rawAsyncValidators = [];
	        }
	        Object.defineProperty(NgControl.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgControl.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @abstract
	         * @param {?} newValue
	         * @return {?}
	         */
	        NgControl.prototype.viewToModelUpdate = function (newValue) { };
	        return NgControl;
	    }(AbstractControlDirective));
	
	    var /** @type {?} */ RADIO_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RadioControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * Internal class used by Angular to uncheck radio buttons with the matching name.
	     */
	    var RadioControlRegistry = (function () {
	        function RadioControlRegistry() {
	            this._accessors = [];
	        }
	        /**
	         * @param {?} control
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.add = function (control, accessor) {
	            this._accessors.push([control, accessor]);
	        };
	        /**
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.remove = function (accessor) {
	            for (var /** @type {?} */ i = this._accessors.length - 1; i >= 0; --i) {
	                if (this._accessors[i][1] === accessor) {
	                    this._accessors.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        /**
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.select = function (accessor) {
	            var _this = this;
	            this._accessors.forEach(function (c) {
	                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                    c[1].fireUncheck(accessor.value);
	                }
	            });
	        };
	        /**
	         * @param {?} controlPair
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {
	            if (!controlPair[0].control)
	                return false;
	            return controlPair[0]._parent === accessor._control._parent &&
	                controlPair[1].name === accessor.name;
	        };
	        RadioControlRegistry.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        RadioControlRegistry.ctorParameters = function () { return []; };
	        return RadioControlRegistry;
	    }());
	    /**
	     * \@whatItDoes Writes radio control values and listens to radio control changes.
	     *
	     * Used by {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName}
	     * to keep the view synced with the {\@link FormControl} model.
	     *
	     * \@howToUse
	     *
	     * If you have imported the {\@link FormsModule} or the {\@link ReactiveFormsModule}, this
	     * value accessor will be active on any radio control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use radio buttons with form directives
	     *
	     * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons
	     * in the same group have the same `name` attribute.  Radio buttons with different `name`
	     * attributes do not affect each other.
	     *
	     * {\@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}
	     *
	     * When using radio buttons in a reactive form, radio buttons in the same group should have the
	     * same `formControlName`. You can also add a `name` attribute, but it's optional.
	     *
	     * {\@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
	     *
	     *  * **npm package**: `\@angular/forms`
	     *
	     *  \@stable
	     */
	    var RadioControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         * @param {?} _registry
	         * @param {?} _injector
	         */
	        function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this._registry = _registry;
	            this._injector = _injector;
	            this.onChange = function () { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.ngOnInit = function () {
	            this._control = this._injector.get(NgControl);
	            this._checkName();
	            this._registry.add(this._control, this);
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.writeValue = function (value) {
	            this._state = value === this.value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this._fn = fn;
	            this.onChange = function () {
	                fn(_this.value);
	                _this._registry.select(_this);
	            };
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.fireUncheck = function (value) { this.writeValue(value); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype._checkName = function () {
	            if (this.name && this.formControlName && this.name !== this.formControlName) {
	                this._throwNameError();
	            }
	            if (!this.name && this.formControlName)
	                this.name = this.formControlName;
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype._throwNameError = function () {
	            throw new Error("\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    ");
	        };
	        RadioControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
	                        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	                        providers: [RADIO_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RadioControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	            { type: RadioControlRegistry, },
	            { type: _angular_core.Injector, },
	        ]; };
	        RadioControlValueAccessor.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'formControlName': [{ type: _angular_core.Input },],
	            'value': [{ type: _angular_core.Input },],
	        };
	        return RadioControlValueAccessor;
	    }());
	
	    var /** @type {?} */ RANGE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RangeValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a range value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="range" [(ngModel)]="age" >
	     *  ```
	     */
	    var RangeValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function RangeValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', parseFloat(value));
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        RangeValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [RANGE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RangeValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return RangeValueAccessor;
	    }());
	
	    var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * @param {?} id
	     * @param {?} value
	     * @return {?}
	     */
	    function _buildValueString(id, value) {
	        if (id == null)
	            return "" + value;
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    /**
	     * @param {?} valueString
	     * @return {?}
	     */
	    function _extractId(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * \@whatItDoes Writes values and listens to changes on a select element.
	     *
	     * Used by {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName}
	     * to keep the view synced with the {\@link FormControl} model.
	     *
	     * \@howToUse
	     *
	     * If you have imported the {\@link FormsModule} or the {\@link ReactiveFormsModule}, this
	     * value accessor will be active on any select control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use select controls with form directives
	     *
	     * To use a select in a template-driven form, simply add an `ngModel` and a `name`
	     * attribute to the main `<select>` tag.
	     *
	     * If your option values are simple strings, you can bind to the normal `value` property
	     * on the option.  If your option values happen to be objects (and you'd like to save the
	     * selection in your form as an object), use `ngValue` instead:
	     *
	     * {\@example forms/ts/selectControl/select_control_example.ts region='Component'}
	     *
	     * In reactive forms, you'll also want to add your form directive (`formControlName` or
	     * `formControl`) on the main `<select>` tag. Like in the former example, you have the
	     * choice of binding to the  `value` or `ngValue` property on the select's options.
	     *
	     * {\@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
	     *
	     * Note: We listen to the 'change' event because 'input' events aren't fired
	     * for selects in Firefox and IE:
	     * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350
	     * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var SelectControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function SelectControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.writeValue = function (value) {
	            this.value = value;
	            var /** @type {?} */ id = this._getOptionId(value);
	            if (id == null) {
	                this._renderer.setElementProperty(this._elementRef.nativeElement, 'selectedIndex', -1);
	            }
	            var /** @type {?} */ valueString = _buildValueString(id, value);
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (valueString) {
	                _this.value = valueString;
	                fn(_this._getOptionValue(valueString));
	            };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id), value))
	                    return id;
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} valueString
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var /** @type {?} */ id = _extractId(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
	        };
	        SelectControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
	                        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return SelectControlValueAccessor;
	    }());
	    /**
	     * \@whatItDoes Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * \@howToUse
	     *
	     * See docs for {\@link SelectControlValueAccessor} for usage examples.
	     *
	     * \@stable
	     */
	    var NgSelectOption = (function () {
	        /**
	         * @param {?} _element
	         * @param {?} _renderer
	         * @param {?} _select
	         */
	        function NgSelectOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select)
	                this.id = this._select._registerOption();
	        }
	        Object.defineProperty(NgSelectOption.prototype, "ngValue", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._select._optionMap.set(this.id, value);
	                this._setElementValue(_buildValueString(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectOption.prototype, "value", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._setElementValue(value);
	                if (this._select)
	                    this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSelectOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /**
	         * @return {?}
	         */
	        NgSelectOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectOption.ctorParameters = function () { return [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ]; };
	        NgSelectOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectOption;
	    }());
	
	    var /** @type {?} */ SELECT_MULTIPLE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectMultipleControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * @param {?} id
	     * @param {?} value
	     * @return {?}
	     */
	    function _buildValueString$1(id, value) {
	        if (id == null)
	            return "" + value;
	        if (typeof value === 'string')
	            value = "'" + value + "'";
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    /**
	     * @param {?} valueString
	     * @return {?}
	     */
	    function _extractId$1(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * The accessor for writing a value and listening to changes on a select element.
	     *
	     * \@stable
	     */
	    var SelectMultipleControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {
	            var _this = this;
	            this.value = value;
	            var /** @type {?} */ optionSelectedStateSetter;
	            if (Array.isArray(value)) {
	                // convert values to ids
	                var /** @type {?} */ ids_1 = value.map(function (v) { return _this._getOptionId(v); });
	                optionSelectedStateSetter = function (opt, o) { opt._setSelected(ids_1.indexOf(o.toString()) > -1); };
	            }
	            else {
	                optionSelectedStateSetter = function (opt, o) { opt._setSelected(false); };
	            }
	            this._optionMap.forEach(optionSelectedStateSetter);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (_) {
	                var /** @type {?} */ selected = [];
	                if (_.hasOwnProperty('selectedOptions')) {
	                    var /** @type {?} */ options = _.selectedOptions;
	                    for (var /** @type {?} */ i = 0; i < options.length; i++) {
	                        var /** @type {?} */ opt = options.item(i);
	                        var /** @type {?} */ val = _this._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                }
	                else {
	                    var /** @type {?} */ options = (_.options);
	                    for (var /** @type {?} */ i = 0; i < options.length; i++) {
	                        var /** @type {?} */ opt = options.item(i);
	                        if (opt.selected) {
	                            var /** @type {?} */ val = _this._getOptionValue(opt.value);
	                            selected.push(val);
	                        }
	                    }
	                }
	                _this.value = selected;
	                fn(selected);
	            };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {
	            var /** @type {?} */ id = (this._idCounter++).toString();
	            this._optionMap.set(id, value);
	            return id;
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id)._value, value))
	                    return id;
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} valueString
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var /** @type {?} */ id = _extractId$1(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
	        };
	        SelectMultipleControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
	                        host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectMultipleControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return SelectMultipleControlValueAccessor;
	    }());
	    /**
	     * Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * ### Example
	     *
	     * ```
	     * <select multiple name="city" ngModel>
	     *   <option *ngFor="let c of cities" [value]="c"></option>
	     * </select>
	     * ```
	     */
	    var NgSelectMultipleOption = (function () {
	        /**
	         * @param {?} _element
	         * @param {?} _renderer
	         * @param {?} _select
	         */
	        function NgSelectMultipleOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select) {
	                this.id = this._select._registerOption(this);
	            }
	        }
	        Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._value = value;
	                this._setElementValue(_buildValueString$1(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select) {
	                    this._value = value;
	                    this._setElementValue(_buildValueString$1(this.id, value));
	                    this._select.writeValue(this._select.value);
	                }
	                else {
	                    this._setElementValue(value);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /**
	         * \@internal
	         * @param {?} selected
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype._setSelected = function (selected) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	        };
	        /**
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectMultipleOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectMultipleOption.ctorParameters = function () { return [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ]; };
	        NgSelectMultipleOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectMultipleOption;
	    }());
	
	    /**
	     * @param {?} name
	     * @param {?} parent
	     * @return {?}
	     */
	    function controlPath(name, parent) {
	        return parent.path.concat([name]);
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function setUpControl(control, dir) {
	        if (!control)
	            _throwError(dir, 'Cannot find control with');
	        if (!dir.valueAccessor)
	            _throwError(dir, 'No value accessor for form control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	        dir.valueAccessor.writeValue(control.value);
	        // view -> model
	        dir.valueAccessor.registerOnChange(function (newValue) {
	            dir.viewToModelUpdate(newValue);
	            control.markAsDirty();
	            control.setValue(newValue, { emitModelToViewChange: false });
	        });
	        // touched
	        dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
	        control.registerOnChange(function (newValue, emitModelEvent) {
	            // control -> view
	            dir.valueAccessor.writeValue(newValue);
	            // control -> ngModel
	            if (emitModelEvent)
	                dir.viewToModelUpdate(newValue);
	        });
	        if (dir.valueAccessor.setDisabledState) {
	            control.registerOnDisabledChange(function (isDisabled) { dir.valueAccessor.setDisabledState(isDisabled); });
	        }
	        // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
	        dir._rawValidators.forEach(function (validator) {
	            if (((validator)).registerOnValidatorChange)
	                ((validator)).registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (((validator)).registerOnValidatorChange)
	                ((validator)).registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function cleanUpControl(control, dir) {
	        dir.valueAccessor.registerOnChange(function () { return _noControlError(dir); });
	        dir.valueAccessor.registerOnTouched(function () { return _noControlError(dir); });
	        dir._rawValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        if (control)
	            control._clearChangeFns();
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function setUpFormContainer(control, dir) {
	        if (isBlank(control))
	            _throwError(dir, 'Cannot find control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    }
	    /**
	     * @param {?} dir
	     * @return {?}
	     */
	    function _noControlError(dir) {
	        return _throwError(dir, 'There is no FormControl instance attached to form control element with');
	    }
	    /**
	     * @param {?} dir
	     * @param {?} message
	     * @return {?}
	     */
	    function _throwError(dir, message) {
	        var /** @type {?} */ messageEnd;
	        if (dir.path.length > 1) {
	            messageEnd = "path: '" + dir.path.join(' -> ') + "'";
	        }
	        else if (dir.path[0]) {
	            messageEnd = "name: '" + dir.path + "'";
	        }
	        else {
	            messageEnd = 'unspecified name attribute';
	        }
	        throw new Error(message + " " + messageEnd);
	    }
	    /**
	     * @param {?} validators
	     * @return {?}
	     */
	    function composeValidators(validators) {
	        return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
	    }
	    /**
	     * @param {?} validators
	     * @return {?}
	     */
	    function composeAsyncValidators(validators) {
	        return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :
	            null;
	    }
	    /**
	     * @param {?} changes
	     * @param {?} viewModel
	     * @return {?}
	     */
	    function isPropertyUpdated(changes, viewModel) {
	        if (!changes.hasOwnProperty('model'))
	            return false;
	        var /** @type {?} */ change = changes['model'];
	        if (change.isFirstChange())
	            return true;
	        return !looseIdentical(viewModel, change.currentValue);
	    }
	    var /** @type {?} */ BUILTIN_ACCESSORS = [
	        CheckboxControlValueAccessor,
	        RangeValueAccessor,
	        NumberValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	    ];
	    /**
	     * @param {?} valueAccessor
	     * @return {?}
	     */
	    function isBuiltInAccessor(valueAccessor) {
	        return BUILTIN_ACCESSORS.some(function (a) { return valueAccessor.constructor === a; });
	    }
	    /**
	     * @param {?} dir
	     * @param {?} valueAccessors
	     * @return {?}
	     */
	    function selectValueAccessor(dir, valueAccessors) {
	        if (!valueAccessors)
	            return null;
	        var /** @type {?} */ defaultAccessor;
	        var /** @type {?} */ builtinAccessor;
	        var /** @type {?} */ customAccessor;
	        valueAccessors.forEach(function (v) {
	            if (v.constructor === DefaultValueAccessor) {
	                defaultAccessor = v;
	            }
	            else if (isBuiltInAccessor(v)) {
	                if (builtinAccessor)
	                    _throwError(dir, 'More than one built-in value accessor matches form control with');
	                builtinAccessor = v;
	            }
	            else {
	                if (customAccessor)
	                    _throwError(dir, 'More than one custom value accessor matches form control with');
	                customAccessor = v;
	            }
	        });
	        if (customAccessor)
	            return customAccessor;
	        if (builtinAccessor)
	            return builtinAccessor;
	        if (defaultAccessor)
	            return defaultAccessor;
	        _throwError(dir, 'No valid value accessor for form control with');
	        return null;
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * This is a base class for code shared between {\@link NgModelGroup} and {\@link FormGroupName}.
	     *
	     * \@stable
	     */
	    var AbstractFormGroupDirective = (function (_super) {
	        __extends(AbstractFormGroupDirective, _super);
	        function AbstractFormGroupDirective() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormGroup(this);
	        };
	        /**
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormGroup(this);
	            }
	        };
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "control", {
	            /**
	             * Get the {\@link FormGroup} backing this binding.
	             * @return {?}
	             */
	            get: function () { return this.formDirective.getFormGroup(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "path", {
	            /**
	             * Get the path to this control group.
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "formDirective", {
	            /**
	             * Get the {\@link Form} to which this group belongs.
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype._checkParentType = function () { };
	        return AbstractFormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var AbstractControlStatus = (function () {
	        /**
	         * @param {?} cd
	         */
	        function AbstractControlStatus(cd) {
	            this._cd = cd;
	        }
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassUntouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.untouched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassTouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.touched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPristine", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.pristine : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassDirty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.dirty : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassValid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.valid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassInvalid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.invalid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPending", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.pending : false; },
	            enumerable: true,
	            configurable: true
	        });
	        return AbstractControlStatus;
	    }());
	    var /** @type {?} */ ngControlStatusHost = {
	        '[class.ng-untouched]': 'ngClassUntouched',
	        '[class.ng-touched]': 'ngClassTouched',
	        '[class.ng-pristine]': 'ngClassPristine',
	        '[class.ng-dirty]': 'ngClassDirty',
	        '[class.ng-valid]': 'ngClassValid',
	        '[class.ng-invalid]': 'ngClassInvalid',
	        '[class.ng-pending]': 'ngClassPending',
	    };
	    /**
	     * Directive automatically applied to Angular form controls that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * \@stable
	     */
	    var NgControlStatus = (function (_super) {
	        __extends$3(NgControlStatus, _super);
	        /**
	         * @param {?} cd
	         */
	        function NgControlStatus(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatus.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost },] },
	        ];
	        /** @nocollapse */
	        NgControlStatus.ctorParameters = function () { return [
	            { type: NgControl, decorators: [{ type: _angular_core.Self },] },
	        ]; };
	        return NgControlStatus;
	    }(AbstractControlStatus));
	    /**
	     * Directive automatically applied to Angular form groups that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * \@stable
	     */
	    var NgControlStatusGroup = (function (_super) {
	        __extends$3(NgControlStatusGroup, _super);
	        /**
	         * @param {?} cd
	         */
	        function NgControlStatusGroup(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatusGroup.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
	                        host: ngControlStatusHost
	                    },] },
	        ];
	        /** @nocollapse */
	        NgControlStatusGroup.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Self },] },
	        ]; };
	        return NgControlStatusGroup;
	    }(AbstractControlStatus));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * \@Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   \@Output() open: EventEmitter<any> = new EventEmitter();
	     *   \@Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * \@stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$5(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         * @param {?=} isAsync
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        /**
	         * @param {?=} generatorOrNext
	         * @param {?=} error
	         * @param {?=} complete
	         * @return {?}
	         */
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var /** @type {?} */ schedulerFn;
	            var /** @type {?} */ errorFn = function (err) { return null; };
	            var /** @type {?} */ completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.
	     */
	    var /** @type {?} */ VALID = 'VALID';
	    /**
	     * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.
	     */
	    var /** @type {?} */ INVALID = 'INVALID';
	    /**
	     * Indicates that a FormControl is pending, i.e. that async validation is occurring and
	     * errors are not yet available for the input value.
	     */
	    var /** @type {?} */ PENDING = 'PENDING';
	    /**
	     * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor
	     * calculations of validity or value.
	     */
	    var /** @type {?} */ DISABLED = 'DISABLED';
	    /**
	     * @param {?} control
	     * @param {?} path
	     * @param {?} delimiter
	     * @return {?}
	     */
	    function _find(control, path, delimiter) {
	        if (path == null)
	            return null;
	        if (!(path instanceof Array)) {
	            path = ((path)).split(delimiter);
	        }
	        if (path instanceof Array && (path.length === 0))
	            return null;
	        return ((path)).reduce(function (v, name) {
	            if (v instanceof FormGroup) {
	                return v.controls[name] || null;
	            }
	            if (v instanceof FormArray) {
	                return v.at(/** @type {?} */ (name)) || null;
	            }
	            return null;
	        }, control);
	    }
	    /**
	     * @param {?} r
	     * @return {?}
	     */
	    function toObservable(r) {
	        return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;
	    }
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function coerceToValidator(validator) {
	        return Array.isArray(validator) ? composeValidators(validator) : validator;
	    }
	    /**
	     * @param {?} asyncValidator
	     * @return {?}
	     */
	    function coerceToAsyncValidator(asyncValidator) {
	        return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;
	    }
	    /**
	     * \@whatItDoes This is the base class for {\@link FormControl}, {\@link FormGroup}, and
	     * {\@link FormArray}.
	     *
	     * It provides some of the shared behavior that all controls and groups of controls have, like
	     * running validators, calculating status, and resetting state. It also defines the properties
	     * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
	     * instantiated directly.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AbstractControl = (function () {
	        /**
	         * @param {?} validator
	         * @param {?} asyncValidator
	         */
	        function AbstractControl(validator, asyncValidator) {
	            this.validator = validator;
	            this.asyncValidator = asyncValidator;
	            /** @internal */
	            this._onCollectionChange = function () { };
	            this._pristine = true;
	            this._touched = false;
	            /** @internal */
	            this._onDisabledChange = [];
	        }
	        Object.defineProperty(AbstractControl.prototype, "value", {
	            /**
	             * The value of the control.
	             * @return {?}
	             */
	            get: function () { return this._value; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "parent", {
	            /**
	             * The parent control.
	             * @return {?}
	             */
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "status", {
	            /**
	             * The validation status of the control. There are four possible
	             * validation statuses:
	             *
	             * * **VALID**:  control has passed all validation checks
	             * * **INVALID**: control has failed at least one validation check
	             * * **PENDING**: control is in the midst of conducting a validation check
	             * * **DISABLED**: control is exempt from validation checks
	             *
	             * These statuses are mutually exclusive, so a control cannot be
	             * both valid AND invalid or invalid AND disabled.
	             * @return {?}
	             */
	            get: function () { return this._status; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valid", {
	            /**
	             * A control is `valid` when its `status === VALID`.
	             *
	             * In order to have this status, the control must have passed all its
	             * validation checks.
	             * @return {?}
	             */
	            get: function () { return this._status === VALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "invalid", {
	            /**
	             * A control is `invalid` when its `status === INVALID`.
	             *
	             * In order to have this status, the control must have failed
	             * at least one of its validation checks.
	             * @return {?}
	             */
	            get: function () { return this._status === INVALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pending", {
	            /**
	             * A control is `pending` when its `status === PENDING`.
	             *
	             * In order to have this status, the control must be in the
	             * middle of conducting a validation check.
	             * @return {?}
	             */
	            get: function () { return this._status == PENDING; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "disabled", {
	            /**
	             * A control is `disabled` when its `status === DISABLED`.
	             *
	             * Disabled controls are exempt from validation checks and
	             * are not included in the aggregate value of their ancestor
	             * controls.
	             * @return {?}
	             */
	            get: function () { return this._status === DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "enabled", {
	            /**
	             * A control is `enabled` as long as its `status !== DISABLED`.
	             *
	             * In other words, it has a status of `VALID`, `INVALID`, or
	             * `PENDING`.
	             * @return {?}
	             */
	            get: function () { return this._status !== DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "errors", {
	            /**
	             * Returns any errors generated by failing validation. If there
	             * are no errors, it will return null.
	             * @return {?}
	             */
	            get: function () { return this._errors; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pristine", {
	            /**
	             * A control is `pristine` if the user has not yet changed
	             * the value in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             * @return {?}
	             */
	            get: function () { return this._pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "dirty", {
	            /**
	             * A control is `dirty` if the user has changed the value
	             * in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             * @return {?}
	             */
	            get: function () { return !this.pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "touched", {
	            /**
	             * A control is marked `touched` once the user has triggered
	             * a `blur` event on it.
	             * @return {?}
	             */
	            get: function () { return this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "untouched", {
	            /**
	             * A control is `untouched` if the user has not yet triggered
	             * a `blur` event on it.
	             * @return {?}
	             */
	            get: function () { return !this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valueChanges", {
	            /**
	             * Emits an event every time the value of the control changes, in
	             * the UI or programmatically.
	             * @return {?}
	             */
	            get: function () { return this._valueChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "statusChanges", {
	            /**
	             * Emits an event every time the validation status of the control
	             * is re-calculated.
	             * @return {?}
	             */
	            get: function () { return this._statusChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Sets the synchronous validators that are active on this control.  Calling
	         * this will overwrite any existing sync validators.
	         * @param {?} newValidator
	         * @return {?}
	         */
	        AbstractControl.prototype.setValidators = function (newValidator) {
	            this.validator = coerceToValidator(newValidator);
	        };
	        /**
	         * Sets the async validators that are active on this control. Calling this
	         * will overwrite any existing async validators.
	         * @param {?} newValidator
	         * @return {?}
	         */
	        AbstractControl.prototype.setAsyncValidators = function (newValidator) {
	            this.asyncValidator = coerceToAsyncValidator(newValidator);
	        };
	        /**
	         * Empties out the sync validator list.
	         * @return {?}
	         */
	        AbstractControl.prototype.clearValidators = function () { this.validator = null; };
	        /**
	         * Empties out the async validator list.
	         * @return {?}
	         */
	        AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };
	        /**
	         * Marks the control as `touched`.
	         *
	         * This will also mark all direct ancestors as `touched` to maintain
	         * the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = true;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `untouched`.
	         *
	         * If the control has any children, it will also mark all children as `untouched`
	         * to maintain the model, and re-calculate the `touched` status of all parent
	         * controls.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsUntouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = false;
	            this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `dirty`.
	         *
	         * This will also mark all direct ancestors as `dirty` to maintain
	         * the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsDirty = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = false;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsDirty({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pristine`.
	         *
	         * If the control has any children, it will also mark all children as `pristine`
	         * to maintain the model, and re-calculate the `pristine` status of all parent
	         * controls.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsPristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = true;
	            this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pending`.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsPending = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._status = PENDING;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsPending({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Disables the control. This means the control will be exempt from validation checks and
	         * excluded from the aggregate value of any parent. Its status is `DISABLED`.
	         *
	         * If the control has children, all children will be disabled to maintain the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.disable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = DISABLED;
	            this._errors = null;
	            this._forEachChild(function (control) { control.disable({ onlySelf: true }); });
	            this._updateValue();
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });
	        };
	        /**
	         * Enables the control. This means the control will be included in validation checks and
	         * the aggregate value of its parent. Its status is re-calculated based on its value and
	         * its validators.
	         *
	         * If the control has children, all children will be enabled.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.enable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = VALID;
	            this._forEachChild(function (control) { control.enable({ onlySelf: true }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });
	        };
	        /**
	         * @param {?} onlySelf
	         * @return {?}
	         */
	        AbstractControl.prototype._updateAncestors = function (onlySelf) {
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity();
	                this._parent._updatePristine();
	                this._parent._updateTouched();
	            }
	        };
	        /**
	         * @param {?} parent
	         * @return {?}
	         */
	        AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
	        /**
	         * Sets the value of the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.setValue = function (value, options) { };
	        /**
	         * Patches the value of the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.patchValue = function (value, options) { };
	        /**
	         * Resets the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?=} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.reset = function (value, options) { };
	        /**
	         * Re-calculates the value and validation status of the control.
	         *
	         * By default, it will also update the value and validity of its ancestors.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.updateValueAndValidity = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._setInitialStatus();
	            this._updateValue();
	            if (this.enabled) {
	                this._errors = this._runValidator();
	                this._status = this._calculateStatus();
	                if (this._status === VALID || this._status === PENDING) {
	                    this._runAsyncValidator(emitEvent);
	                }
	            }
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updateTreeValidity = function (_a) {
	            var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;
	            this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity({ emitEvent: emitEvent }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._runValidator = function () {
	            return this.validator ? this.validator(this) : null;
	        };
	        /**
	         * @param {?} emitEvent
	         * @return {?}
	         */
	        AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
	            var _this = this;
	            if (this.asyncValidator) {
	                this._status = PENDING;
	                this._cancelExistingSubscription();
	                var /** @type {?} */ obs = toObservable(this.asyncValidator(this));
	                if (!(isObservable(obs))) {
	                    throw new Error("expected the following validator to return Promise or Observable: " + this.asyncValidator + ". If you are using FormBuilder; did you forget to brace your validators in an array?");
	                }
	                this._asyncValidationSubscription =
	                    obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._cancelExistingSubscription = function () {
	            if (this._asyncValidationSubscription) {
	                this._asyncValidationSubscription.unsubscribe();
	            }
	        };
	        /**
	         * Sets errors on a form control.
	         *
	         * This is used when validations are run manually by the user, rather than automatically.
	         *
	         * Calling `setErrors` will also update the validity of the parent control.
	         *
	         * ### Example
	         *
	         * ```
	         * const login = new FormControl("someLogin");
	         * login.setErrors({
	         *   "notUnique": true
	         * });
	         *
	         * expect(login.valid).toEqual(false);
	         * expect(login.errors).toEqual({"notUnique": true});
	         *
	         * login.setValue("someOtherLogin");
	         *
	         * expect(login.valid).toEqual(true);
	         * ```
	         * @param {?} errors
	         * @param {?=} __1
	         * @return {?}
	         */
	        AbstractControl.prototype.setErrors = function (errors, _a) {
	            var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
	            this._errors = errors;
	            this._updateControlsErrors(emitEvent !== false);
	        };
	        /**
	         * Retrieves a child control given the control's name or path.
	         *
	         * Paths can be passed in as an array or a string delimited by a dot.
	         *
	         * To get a control nested within a `person` sub-group:
	         *
	         * * `this.form.get('person.name');`
	         *
	         * -OR-
	         *
	         * * `this.form.get(['person', 'name']);`
	         * @param {?} path
	         * @return {?}
	         */
	        AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns null or undefined.
	         *
	         * If no path is given, it checks for the error on the present control.
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControl.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            var /** @type {?} */ control = path ? this.get(path) : this;
	            return control && control._errors ? control._errors[errorCode] : null;
	        };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns false.
	         *
	         * If no path is given, it checks for the error on the present control.
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControl.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return !!this.getError(errorCode, path);
	        };
	        Object.defineProperty(AbstractControl.prototype, "root", {
	            /**
	             * Retrieves the top-level ancestor of this control.
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ x = this;
	                while (x._parent) {
	                    x = x._parent;
	                }
	                return x;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} emitEvent
	         * @return {?}
	         */
	        AbstractControl.prototype._updateControlsErrors = function (emitEvent) {
	            this._status = this._calculateStatus();
	            if (emitEvent) {
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent) {
	                this._parent._updateControlsErrors(emitEvent);
	            }
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._initObservables = function () {
	            this._valueChanges = new EventEmitter();
	            this._statusChanges = new EventEmitter();
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._calculateStatus = function () {
	            if (this._allControlsDisabled())
	                return DISABLED;
	            if (this._errors)
	                return INVALID;
	            if (this._anyControlsHaveStatus(PENDING))
	                return PENDING;
	            if (this._anyControlsHaveStatus(INVALID))
	                return INVALID;
	            return VALID;
	        };
	        /**
	         * \@internal
	         * @abstract
	         * @return {?}
	         */
	        AbstractControl.prototype._updateValue = function () { };
	        /**
	         * \@internal
	         * @abstract
	         * @param {?} cb
	         * @return {?}
	         */
	        AbstractControl.prototype._forEachChild = function (cb) { };
	        /**
	         * \@internal
	         * @abstract
	         * @param {?} condition
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControls = function (condition) { };
	        /**
	         * \@internal
	         * @abstract
	         * @return {?}
	         */
	        AbstractControl.prototype._allControlsDisabled = function () { };
	        /**
	         * \@internal
	         * @param {?} status
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsHaveStatus = function (status) {
	            return this._anyControls(function (control) { return control.status === status; });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsDirty = function () {
	            return this._anyControls(function (control) { return control.dirty; });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsTouched = function () {
	            return this._anyControls(function (control) { return control.touched; });
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updatePristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = !this._anyControlsDirty();
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updateTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = this._anyControlsTouched();
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} formState
	         * @return {?}
	         */
	        AbstractControl.prototype._isBoxedValue = function (formState) {
	            return typeof formState === 'object' && formState !== null &&
	                Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
	        };
	        /**
	         * \@internal
	         * @param {?} fn
	         * @return {?}
	         */
	        AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };
	        return AbstractControl;
	    }());
	    /**
	     * \@whatItDoes Tracks the value and validation status of an individual form control.
	     *
	     * It is one of the three fundamental building blocks of Angular forms, along with
	     * {\@link FormGroup} and {\@link FormArray}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormControl}, you can pass in an initial value as the
	     * first argument. Example:
	     *
	     * ```ts
	     * const ctrl = new FormControl('some value');
	     * console.log(ctrl.value);     // 'some value'
	     * ```
	     *
	     * You can also initialize the control with a form state object on instantiation,
	     * which includes both the value and whether or not the control is disabled.
	     * You can't use the value key without the disabled key; both are required
	     * to use this way of initialization.
	     *
	     * ```ts
	     * const ctrl = new FormControl({value: 'n/a', disabled: true});
	     * console.log(ctrl.value);     // 'n/a'
	     * console.log(ctrl.status);   // 'DISABLED'
	     * ```
	     *
	     * To include a sync validator (or an array of sync validators) with the control,
	     * pass it in as the second argument. Async validators are also supported, but
	     * have to be passed in separately as the third arg.
	     *
	     * ```ts
	     * const ctrl = new FormControl('', Validators.required);
	     * console.log(ctrl.value);     // ''
	     * console.log(ctrl.status);   // 'INVALID'
	     * ```
	     *
	     * See its superclass, {\@link AbstractControl}, for more properties and methods.
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormControl = (function (_super) {
	        __extends$6(FormControl, _super);
	        /**
	         * @param {?=} formState
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormControl(formState, validator, asyncValidator) {
	            if (formState === void 0) { formState = null; }
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));
	            /** @internal */
	            this._onChange = [];
	            this._applyFormState(formState);
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	            this._initObservables();
	        }
	        /**
	         * Set the value of the form control to `value`.
	         *
	         * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
	         * and not its parent component. This defaults to false.
	         *
	         * If `emitEvent` is `true`, this
	         * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults
	         * to true (as it falls through to `updateValueAndValidity`).
	         *
	         * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	         * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	         * specified.
	         *
	         * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the
	         * model.  This is the default behavior if `emitViewToModelChange` is not specified.
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormControl.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange, emitViewToModelChange = _b.emitViewToModelChange;
	            this._value = value;
	            if (this._onChange.length && emitModelToViewChange !== false) {
	                this._onChange.forEach(function (changeFn) { return changeFn(_this._value, emitViewToModelChange !== false); });
	            }
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Patches the value of a control.
	         *
	         * This function is functionally the same as {\@link FormControl.setValue} at this level.
	         * It exists for symmetry with {\@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,
	         * where it does behave differently.
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        FormControl.prototype.patchValue = function (value, options) {
	            if (options === void 0) { options = {}; }
	            this.setValue(value, options);
	        };
	        /**
	         * Resets the form control. This means by default:
	         *
	         * * it is marked as `pristine`
	         * * it is marked as `untouched`
	         * * value is set to null
	         *
	         * You can also reset to a specific form state by passing through a standalone
	         * value or a form state object that contains both a value and a disabled state
	         * (these are the only two properties that cannot be calculated).
	         *
	         * Ex:
	         *
	         * ```ts
	         * this.control.reset('Nancy');
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * ```
	         *
	         * OR
	         *
	         * ```
	         * this.control.reset({value: 'Nancy', disabled: true});
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * console.log(this.control.status);  // 'DISABLED'
	         * ```
	         * @param {?=} formState
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormControl.prototype.reset = function (formState, _a) {
	            if (formState === void 0) { formState = null; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._applyFormState(formState);
	            this.markAsPristine({ onlySelf: onlySelf });
	            this.markAsUntouched({ onlySelf: onlySelf });
	            this.setValue(this._value, { onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._updateValue = function () { };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormControl.prototype._anyControls = function (condition) { return false; };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._allControlsDisabled = function () { return this.disabled; };
	        /**
	         * Register a listener for change events.
	         * @param {?} fn
	         * @return {?}
	         */
	        FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._clearChangeFns = function () {
	            this._onChange = [];
	            this._onDisabledChange = [];
	            this._onCollectionChange = function () { };
	        };
	        /**
	         * Register a listener for disabled events.
	         * @param {?} fn
	         * @return {?}
	         */
	        FormControl.prototype.registerOnDisabledChange = function (fn) {
	            this._onDisabledChange.push(fn);
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormControl.prototype._forEachChild = function (cb) { };
	        /**
	         * @param {?} formState
	         * @return {?}
	         */
	        FormControl.prototype._applyFormState = function (formState) {
	            if (this._isBoxedValue(formState)) {
	                this._value = formState.value;
	                formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
	                    this.enable({ onlySelf: true, emitEvent: false });
	            }
	            else {
	                this._value = formState;
	            }
	        };
	        return FormControl;
	    }(AbstractControl));
	    /**
	     * \@whatItDoes Tracks the value and validity state of a group of {\@link FormControl}
	     * instances.
	     *
	     * A `FormGroup` aggregates the values of each child {\@link FormControl} into one object,
	     * with each control name as the key.  It calculates its status by reducing the statuses
	     * of its children. For example, if one of the controls in a group is invalid, the entire
	     * group becomes invalid.
	     *
	     * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {\@link FormControl} and {\@link FormArray}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormGroup}, pass in a collection of child controls as the first
	     * argument. The key for each child will be the name under which it is registered.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   first: new FormControl('Nancy', Validators.minLength(2)),
	     *   last: new FormControl('Drew'),
	     * });
	     *
	     * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
	     * console.log(form.status);  // 'VALID'
	     * ```
	     *
	     * You can also include group-level validators as the second arg, or group-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   password: new FormControl('', Validators.minLength(2)),
	     *   passwordConfirm: new FormControl('', Validators.minLength(2)),
	     * }, passwordMatchValidator);
	     *
	     *
	     * function passwordMatchValidator(g: FormGroup) {
	     *    return g.get('password').value === g.get('passwordConfirm').value
	     *       ? null : {'mismatch': true};
	     * }
	     * ```
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormGroup = (function (_super) {
	        __extends$6(FormGroup, _super);
	        /**
	         * @param {?} controls
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormGroup(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Registers a control with the group's list of controls.
	         *
	         * This method does not update value or validity of the control, so for
	         * most cases you'll want to use {\@link FormGroup.addControl} instead.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.registerControl = function (name, control) {
	            if (this.controls[name])
	                return this.controls[name];
	            this.controls[name] = control;
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	            return control;
	        };
	        /**
	         * Add a control to this group.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.addControl = function (name, control) {
	            this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove a control from this group.
	         * @param {?} name
	         * @return {?}
	         */
	        FormGroup.prototype.removeControl = function (name) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.setControl = function (name, control) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            if (control)
	                this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Check whether there is an enabled control with the given name in the group.
	         *
	         * It will return false for disabled controls. If you'd like to check for
	         * existence in the group only, use {\@link AbstractControl.get} instead.
	         * @param {?} controlName
	         * @return {?}
	         */
	        FormGroup.prototype.contains = function (controlName) {
	            return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
	        };
	        /**
	         *  Sets the value of the {\@link FormGroup}. It accepts an object that matches
	         *  the structure of the group, with control names as keys.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.setValue({first: 'Nancy', last: 'Drew'});
	         *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
	         *
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            Object.keys(value).forEach(function (name) {
	                _this._throwIfControlMissing(name);
	                _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {\@link FormGroup}. It accepts an object with control
	         *  names as keys, and will do its best to match the values to the correct controls
	         *  in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the group without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.patchValue({first: 'Nancy'});
	         *  console.log(form.value);   // {first: 'Nancy', last: null}
	         *
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            Object.keys(value).forEach(function (name) {
	                if (_this.controls[name]) {
	                    _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {\@link FormGroup}. This means by default:
	         *
	         * * The group and all descendants are marked `pristine`
	         * * The group and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in a map of states
	         * that matches the structure of your form, with control names as keys. The state
	         * can be a standalone value or a form state object with both a value and a disabled
	         * status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.form.reset({first: 'name', last: 'last name'});
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.form.reset({
	         *   first: {value: 'name', disabled: true},
	         *   last: 'last'
	         * });
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * console.log(this.form.get('first').status);  // 'DISABLED'
	         * ```
	         * @param {?=} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = {}; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, name) {
	                control.reset(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the {\@link FormGroup}, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the group.
	         * @return {?}
	         */
	        FormGroup.prototype.getRawValue = function () {
	            return this._reduceChildren({}, function (acc, control, name) {
	                acc[name] = control instanceof FormControl ? control.value : ((control)).getRawValue();
	                return acc;
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} name
	         * @return {?}
	         */
	        FormGroup.prototype._throwIfControlMissing = function (name) {
	            if (!Object.keys(this.controls).length) {
	                throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.controls[name]) {
	                throw new Error("Cannot find form control with name: " + name + ".");
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormGroup.prototype._forEachChild = function (cb) {
	            var _this = this;
	            Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) {
	                control.setParent(_this);
	                control._registerOnCollectionChange(_this._onCollectionChange);
	            });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormGroup.prototype._anyControls = function (condition) {
	            var _this = this;
	            var /** @type {?} */ res = false;
	            this._forEachChild(function (control, name) {
	                res = res || (_this.contains(name) && condition(control));
	            });
	            return res;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._reduceValue = function () {
	            var _this = this;
	            return this._reduceChildren({}, function (acc, control, name) {
	                if (control.enabled || _this.disabled) {
	                    acc[name] = control.value;
	                }
	                return acc;
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} initValue
	         * @param {?} fn
	         * @return {?}
	         */
	        FormGroup.prototype._reduceChildren = function (initValue, fn) {
	            var /** @type {?} */ res = initValue;
	            this._forEachChild(function (control, name) { res = fn(res, control, name); });
	            return res;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {
	                var controlName = _a[_i];
	                if (this.controls[controlName].enabled) {
	                    return false;
	                }
	            }
	            return Object.keys(this.controls).length > 0 || this.disabled;
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        FormGroup.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, name) {
	                if (value[name] === undefined) {
	                    throw new Error("Must supply a value for form control with name: '" + name + "'.");
	                }
	            });
	        };
	        return FormGroup;
	    }(AbstractControl));
	    /**
	     * \@whatItDoes Tracks the value and validity state of an array of {\@link FormControl},
	     * {\@link FormGroup} or {\@link FormArray} instances.
	     *
	     * A `FormArray` aggregates the values of each child {\@link FormControl} into an array.
	     * It calculates its status by reducing the statuses of its children. For example, if one of
	     * the controls in a `FormArray` is invalid, the entire array becomes invalid.
	     *
	     * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {\@link FormControl} and {\@link FormGroup}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormArray}, pass in an array of child controls as the first
	     * argument.
	     *
	     * ### Example
	     *
	     * ```
	     * const arr = new FormArray([
	     *   new FormControl('Nancy', Validators.minLength(2)),
	     *   new FormControl('Drew'),
	     * ]);
	     *
	     * console.log(arr.value);   // ['Nancy', 'Drew']
	     * console.log(arr.status);  // 'VALID'
	     * ```
	     *
	     * You can also include array-level validators as the second arg, or array-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Adding or removing controls
	     *
	     * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	     * in `FormArray` itself. These methods ensure the controls are properly tracked in the
	     * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	     * the `FormArray` directly, as that will result in strange and unexpected behavior such
	     * as broken change detection.
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormArray = (function (_super) {
	        __extends$6(FormArray, _super);
	        /**
	         * @param {?} controls
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormArray(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Get the {\@link AbstractControl} at the given `index` in the array.
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype.at = function (index) { return this.controls[index]; };
	        /**
	         * Insert a new {\@link AbstractControl} at the end of the array.
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.push = function (control) {
	            this.controls.push(control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Insert a new {\@link AbstractControl} at the given `index` in the array.
	         * @param {?} index
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.insert = function (index, control) {
	            this.controls.splice(index, 0, control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove the control at the given `index` in the array.
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype.removeAt = function (index) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         * @param {?} index
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.setControl = function (index, control) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            if (control) {
	                this.controls.splice(index, 0, control);
	                this._registerControl(control);
	            }
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        Object.defineProperty(FormArray.prototype, "length", {
	            /**
	             * Length of the control array.
	             * @return {?}
	             */
	            get: function () { return this.controls.length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         *  Sets the value of the {\@link FormArray}. It accepts an array that matches
	         *  the structure of the control.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.setValue(['Nancy', 'Drew']);
	         *  console.log(arr.value);   // ['Nancy', 'Drew']
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            value.forEach(function (newValue, index) {
	                _this._throwIfControlMissing(index);
	                _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {\@link FormArray}. It accepts an array that matches the
	         *  structure of the control, and will do its best to match the values to the correct
	         *  controls in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the array without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.patchValue(['Nancy']);
	         *  console.log(arr.value);   // ['Nancy', null]
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            value.forEach(function (newValue, index) {
	                if (_this.at(index)) {
	                    _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {\@link FormArray}. This means by default:
	         *
	         * * The array and all descendants are marked `pristine`
	         * * The array and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in an array of states
	         * that matches the structure of the control. The state can be a standalone value
	         * or a form state object with both a value and a disabled status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.arr.reset(['name', 'last name']);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.arr.reset([
	         *   {value: 'name', disabled: true},
	         *   'last'
	         * ]);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * console.log(this.arr.get(0).status);  // 'DISABLED'
	         * ```
	         * @param {?=} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = []; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, index) {
	                control.reset(value[index], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the array, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the array.
	         * @return {?}
	         */
	        FormArray.prototype.getRawValue = function () {
	            return this.controls.map(function (control) {
	                return control instanceof FormControl ? control.value : ((control)).getRawValue();
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype._throwIfControlMissing = function (index) {
	            if (!this.controls.length) {
	                throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.at(index)) {
	                throw new Error("Cannot find form control at index " + index);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormArray.prototype._forEachChild = function (cb) {
	            this.controls.forEach(function (control, index) { cb(control, index); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._updateValue = function () {
	            var _this = this;
	            this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })
	                .map(function (control) { return control.value; });
	        };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormArray.prototype._anyControls = function (condition) {
	            return this.controls.some(function (control) { return control.enabled && condition(control); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) { return _this._registerControl(control); });
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        FormArray.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, i) {
	                if (value[i] === undefined) {
	                    throw new Error("Must supply a value for form control at index: " + i + ".");
	                }
	            });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
	                var control = _a[_i];
	                if (control.enabled)
	                    return false;
	            }
	            return this.controls.length > 0 || this.disabled;
	        };
	        /**
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype._registerControl = function (control) {
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	        };
	        return FormArray;
	    }(AbstractControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formDirectiveProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgForm; })
	    };
	    var /** @type {?} */ resolvedPromise = Promise.resolve(null);
	    /**
	     * \@whatItDoes Creates a top-level {\@link FormGroup} instance and binds it to a form
	     * to track aggregate form value and validation status.
	     *
	     * \@howToUse
	     *
	     * As soon as you import the `FormsModule`, this directive becomes active by default on
	     * all `<form>` tags.  You don't need to add a special selector.
	     *
	     * You can export the directive into a local template variable using `ngForm` as the key
	     * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
	     * {\@link FormGroup} instance are duplicated on the directive itself, so a reference to it
	     * will give you access to the aggregate value and validity status of the form, as well as
	     * user interaction properties like `dirty` and `touched`.
	     *
	     * To register child controls with the form, you'll want to use {\@link NgModel} with a
	     * `name` attribute.  You can also use {\@link NgModelGroup} if you'd like to create
	     * sub-groups within the form.
	     *
	     * You can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     *  \@stable
	     */
	    var NgForm = (function (_super) {
	        __extends$4(NgForm, _super);
	        /**
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function NgForm(validators, asyncValidators) {
	            _super.call(this);
	            this._submitted = false;
	            this.ngSubmit = new EventEmitter();
	            this.form =
	                new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
	        }
	        Object.defineProperty(NgForm.prototype, "submitted", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "controls", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form.controls; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.addControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                dir._control = (container.registerControl(dir.name, dir.control));
	                setUpControl(dir.control, dir);
	                dir.control.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.removeControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.addFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                var /** @type {?} */ group = new FormGroup({});
	                setUpFormContainer(group, dir);
	                container.registerControl(dir.name, group);
	                group.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.removeFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @param {?} value
	         * @return {?}
	         */
	        NgForm.prototype.updateModel = function (dir, value) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ ctrl = (_this.form.get(dir.path));
	                ctrl.setValue(value);
	            });
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgForm.prototype.setValue = function (value) { this.control.setValue(value); };
	        /**
	         * @param {?} $event
	         * @return {?}
	         */
	        NgForm.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        NgForm.prototype.onReset = function () { this.resetForm(); };
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        NgForm.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /**
	         * \@internal
	         * @param {?} path
	         * @return {?}
	         */
	        NgForm.prototype._findContainer = function (path) {
	            path.pop();
	            return path.length ? (this.form.get(path)) : this.form;
	        };
	        NgForm.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
	                        providers: [formDirectiveProvider],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        outputs: ['ngSubmit'],
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgForm.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        return NgForm;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ Examples = {
	        formControlName: "\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });",
	        formGroupName: "\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });",
	        formArrayName: "\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; let i=index\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });",
	        ngModelGroup: "\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>",
	        ngModelWithFormGroup: "\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  "
	    };
	
	    var TemplateDrivenErrors = (function () {
	        function TemplateDrivenErrors() {
	        }
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.modelParentException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive \"formControlName\" instead.  Example:\n\n      " + Examples.formControlName + "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " + Examples.ngModelWithFormGroup);
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.formGroupNameException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.missingNameException = function () {
	            throw new Error("If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as 'standalone' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n      Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">");
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.modelGroupParentException = function () {
	            throw new Error("\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        return TemplateDrivenErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ modelGroupProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgModelGroup; })
	    };
	    /**
	     * \@whatItDoes Creates and binds a {\@link FormGroup} instance to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive can only be used as a child of {\@link NgForm} (or in other words,
	     * within `<form>` tags).
	     *
	     * Use this directive if you'd like to create a sub-group within a form. This can
	     * come in handy if you want to validate a sub-group of your form separately from
	     * the rest of your form, or if some values in your domain model make more sense to
	     * consume together in a nested object.
	     *
	     * Pass in the name you'd like this sub-group to have and it will become the key
	     * for the sub-group in the form's full value. You can also export the directive into
	     * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
	     *
	     * {\@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     * \@stable
	     */
	    var NgModelGroup = (function (_super) {
	        __extends$8(NgModelGroup, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function NgModelGroup(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        NgModelGroup.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelGroupParentException();
	            }
	        };
	        NgModelGroup.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },
	        ];
	        /** @nocollapse */
	        NgModelGroup.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        NgModelGroup.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['ngModelGroup',] },],
	        };
	        return NgModelGroup;
	    }(AbstractFormGroupDirective));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formControlBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return NgModel; })
	    };
	    /**
	     * `ngModel` forces an additional change detection run when its inputs change:
	     * E.g.:
	     * ```
	     * <div>{{myModel.valid}}</div>
	     * <input [(ngModel)]="myValue" #myModel="ngModel">
	     * ```
	     * I.e. `ngModel` can export itself on the element and then be used in the template.
	     * Normally, this would result in expressions before the `input` that use the exported directive
	     * to have and old value as they have been
	     * dirty checked before. As this is a very common case for `ngModel`, we added this second change
	     * detection run.
	     *
	     * Notes:
	     * - this is just one extra run no matter how many `ngModel` have been changed.
	     * - this is a general problem when using `exportAs` for directives!
	     */
	    var /** @type {?} */ resolvedPromise$1 = Promise.resolve(null);
	    /**
	     * \@whatItDoes Creates a {\@link FormControl} instance from a domain model and binds it
	     * to a form control element.
	     *
	     * The {\@link FormControl} instance will track the value, user interaction, and
	     * validation status of the control and keep the view synced with the model. If used
	     * within a parent form, the directive will also register itself with the form as a child
	     * control.
	     *
	     * \@howToUse
	     *
	     * This directive can be used by itself or as part of a larger form. All you need is the
	     * `ngModel` selector to activate it.
	     *
	     * It accepts a domain model as an optional {\@link \@Input}. If you have a one-way binding
	     * to `ngModel` with `[]` syntax, changing the value of the domain model in the component
	     * class will set the value in the view. If you have a two-way binding with `[()]` syntax
	     * (also known as 'banana-box syntax'), the value in the UI will always be synced back to
	     * the domain model in your class as well.
	     *
	     * If you wish to inspect the properties of the associated {\@link FormControl} (like
	     * validity state), you can also export the directive into a local template variable using
	     * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the
	     * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)
	     * will fall through to the control anyway, so you can access them directly. You can see a
	     * full list of properties directly available in {\@link AbstractControlDirective}.
	     *
	     * The following is an example of a simple standalone control using `ngModel`:
	     *
	     * {\@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
	     *
	     * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
	     * so that the control can be registered with the parent form under that name.
	     *
	     * It's worth noting that in the context of a parent form, you often can skip one-way or
	     * two-way binding because the parent form will sync the value for you. You can access
	     * its properties by exporting it into a local template variable using `ngForm` (ex:
	     * `#f="ngForm"`). Then you can pass it where it needs to go on submit.
	     *
	     * If you do need to populate initial values into your form, using a one-way binding for
	     * `ngModel` tends to be sufficient as long as you use the exported form's value rather
	     * than the domain model's value on submit.
	     *
	     * Take a look at an example of using `ngModel` within a form:
	     *
	     * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * To see `ngModel` examples with different form control types, see:
	     *
	     * * Radio buttons: {\@link RadioControlValueAccessor}
	     * * Selects: {\@link SelectControlValueAccessor}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: `FormsModule`
	     *
	     *  \@stable
	     */
	    var NgModel = (function (_super) {
	        __extends$7(NgModel, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function NgModel(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            /** @internal */
	            this._control = new FormControl();
	            /** @internal */
	            this._registered = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgModel.prototype.ngOnChanges = function (changes) {
	            this._checkForErrors();
	            if (!this._registered)
	                this._setUpControl();
	            if ('isDisabled' in changes) {
	                this._updateDisabled(changes);
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this._updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };
	        Object.defineProperty(NgModel.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._parent ? controlPath(this.name, this._parent) : [this.name];
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        NgModel.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._setUpControl = function () {
	            this._isStandalone() ? this._setUpStandalone() :
	                this.formDirective.addControl(this);
	            this._registered = true;
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._isStandalone = function () {
	            return !this._parent || (this.options && this.options.standalone);
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._setUpStandalone = function () {
	            setUpControl(this._control, this);
	            this._control.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkForErrors = function () {
	            if (!this._isStandalone()) {
	                this._checkParentType();
	            }
	            this._checkName();
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                TemplateDrivenErrors.formGroupNameException();
	            }
	            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelParentException();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkName = function () {
	            if (this.options && this.options.name)
	                this.name = this.options.name;
	            if (!this._isStandalone() && !this.name) {
	                TemplateDrivenErrors.missingNameException();
	            }
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgModel.prototype._updateValue = function (value) {
	            var _this = this;
	            resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgModel.prototype._updateDisabled = function (changes) {
	            var _this = this;
	            var /** @type {?} */ disabledValue = changes['isDisabled'].currentValue;
	            var /** @type {?} */ isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');
	            resolvedPromise$1.then(function () {
	                if (isDisabled && !_this.control.disabled) {
	                    _this.control.disable();
	                }
	                else if (!isDisabled && _this.control.disabled) {
	                    _this.control.enable();
	                }
	            });
	        };
	        NgModel.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[ngModel]:not([formControlName]):not([formControl])',
	                        providers: [formControlBinding],
	                        exportAs: 'ngModel'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgModel.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        NgModel.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'options': [{ type: _angular_core.Input, args: ['ngModelOptions',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	        };
	        return NgModel;
	    }(NgControl));
	
	    var ReactiveErrors = (function () {
	        function ReactiveErrors() {
	        }
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.controlParentException = function () {
	            throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formControlName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.ngModelGroupException = function () {
	            throw new Error("formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        " + Examples.formGroupName + "\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        " + Examples.ngModelGroup);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.missingFormException = function () {
	            throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + Examples.formControlName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.groupParentException = function () {
	            throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formGroupName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.arrayParentException = function () {
	            throw new Error("formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " + Examples.formArrayName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.disabledAttrWarning = function () {
	            console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ");
	        };
	        return ReactiveErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formControlBinding$1 = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlDirective; })
	    };
	    /**
	     * \@whatItDoes Syncs a standalone {\@link FormControl} instance to a form control element.
	     *
	     * In other words, this directive ensures that any values written to the {\@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {\@link FormControl} instance (view -> model).
	     *
	     * \@howToUse
	     *
	     * Use this directive if you'd like to create and manage a {\@link FormControl} instance directly.
	     * Simply create a {\@link FormControl}, save it to your component class, and pass it into the
	     * {\@link FormControlDirective}.
	     *
	     * This directive is designed to be used as a standalone control.  Unlike {\@link FormControlName},
	     * it does not require that your {\@link FormControl} instance be part of any parent
	     * {\@link FormGroup}, and it won't be registered to any {\@link FormGroupDirective} that
	     * exists above it.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormControl} instance. See a full list of available properties in
	     * {\@link AbstractControl}.
	     *
	     * **Set the value**: You can pass in an initial value when instantiating the {\@link FormControl},
	     * or you can set it programmatically later using {\@link AbstractControl.setValue} or
	     * {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     *  \@stable
	     */
	    var FormControlDirective = (function (_super) {
	        __extends$9(FormControlDirective, _super);
	        /**
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function FormControlDirective(validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this.update = new EventEmitter();
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlDirective.prototype, "isDisabled", {
	            /**
	             * @param {?} isDisabled
	             * @return {?}
	             */
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlDirective.prototype.ngOnChanges = function (changes) {
	            if (this._isControlChanged(changes)) {
	                setUpControl(this.form, this);
	                if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                    this.valueAccessor.setDisabledState(true);
	                }
	                this.form.updateValueAndValidity({ emitEvent: false });
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.form.setValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        Object.defineProperty(FormControlDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        FormControlDirective.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlDirective.prototype._isControlChanged = function (changes) {
	            return changes.hasOwnProperty('form');
	        };
	        FormControlDirective.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },
	        ];
	        /** @nocollapse */
	        FormControlDirective.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        FormControlDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formControl',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlDirective;
	    }(NgControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formDirectiveProvider$1 = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupDirective; })
	    };
	    /**
	     * \@whatItDoes Binds an existing {\@link FormGroup} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive accepts an existing {\@link FormGroup} instance. It will then use this
	     * {\@link FormGroup} instance to match any child {\@link FormControl}, {\@link FormGroup},
	     * and {\@link FormArray} instances to child {\@link FormControlName}, {\@link FormGroupName},
	     * and {\@link FormArrayName} directives.
	     *
	     * **Set value**: You can set the form's initial value when instantiating the
	     * {\@link FormGroup}, or you can set it programmatically later using the {\@link FormGroup}'s
	     * {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue} methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe
	     * to the {\@link FormGroup}'s {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * its {\@link AbstractControl.statusChanges} event to be notified when the validation status is
	     * re-calculated.
	     *
	     * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     *  \@stable
	     */
	    var FormGroupDirective = (function (_super) {
	        __extends$11(FormGroupDirective, _super);
	        /**
	         * @param {?} _validators
	         * @param {?} _asyncValidators
	         */
	        function FormGroupDirective(_validators, _asyncValidators) {
	            _super.call(this);
	            this._validators = _validators;
	            this._asyncValidators = _asyncValidators;
	            this._submitted = false;
	            this.directives = [];
	            this.form = null;
	            this.ngSubmit = new EventEmitter();
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormGroupDirective.prototype.ngOnChanges = function (changes) {
	            this._checkFormPresent();
	            if (changes.hasOwnProperty('form')) {
	                this._updateValidators();
	                this._updateDomValue();
	                this._updateRegistrations();
	            }
	        };
	        Object.defineProperty(FormGroupDirective.prototype, "submitted", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addControl = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpControl(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	            this.directives.push(dir);
	            return ctrl;
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeControl = function (dir) { ListWrapper.remove(this.directives, dir); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addFormGroup = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeFormGroup = function (dir) { };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addFormArray = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeFormArray = function (dir) { };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getFormArray = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @param {?} value
	         * @return {?}
	         */
	        FormGroupDirective.prototype.updateModel = function (dir, value) {
	            var /** @type {?} */ ctrl = (this.form.get(dir.path));
	            ctrl.setValue(value);
	        };
	        /**
	         * @param {?} $event
	         * @return {?}
	         */
	        FormGroupDirective.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype.onReset = function () { this.resetForm(); };
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        FormGroupDirective.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateDomValue = function () {
	            var _this = this;
	            this.directives.forEach(function (dir) {
	                var /** @type {?} */ newCtrl = _this.form.get(dir.path);
	                if (dir._control !== newCtrl) {
	                    cleanUpControl(dir._control, dir);
	                    if (newCtrl)
	                        setUpControl(newCtrl, dir);
	                    dir._control = newCtrl;
	                }
	            });
	            this.form._updateTreeValidity({ emitEvent: false });
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateRegistrations = function () {
	            var _this = this;
	            this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });
	            if (this._oldForm)
	                this._oldForm._registerOnCollectionChange(function () { });
	            this._oldForm = this.form;
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateValidators = function () {
	            var /** @type {?} */ sync = composeValidators(this._validators);
	            this.form.validator = Validators.compose([this.form.validator, sync]);
	            var /** @type {?} */ async = composeAsyncValidators(this._asyncValidators);
	            this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._checkFormPresent = function () {
	            if (!this.form) {
	                ReactiveErrors.missingFormException();
	            }
	        };
	        FormGroupDirective.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroup]',
	                        providers: [formDirectiveProvider$1],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        FormGroupDirective.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormGroupDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formGroup',] },],
	            'ngSubmit': [{ type: _angular_core.Output },],
	        };
	        return FormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formGroupNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupName; })
	    };
	    /**
	     * \@whatItDoes Syncs a nested {\@link FormGroup} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive can only be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {\@link FormGroup} you want to link, and
	     * will look for a {\@link FormGroup} registered with that name in the parent
	     * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
	     *
	     * Nested form groups can come in handy when you want to validate a sub-group of a
	     * form separately from the rest or when you'd like to group the values of certain
	     * controls into their own nested object.
	     *
	     * **Access the group**: You can access the associated {\@link FormGroup} using the
	     * {\@link AbstractControl.get} method. Ex: `this.form.get('name')`.
	     *
	     * You can also access individual controls within the group using dot syntax.
	     * Ex: `this.form.get('name.first')`
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormGroup}. See a full list of available properties in {\@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {\@link FormGroup}, or you can set it programmatically later using
	     * {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the group, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * \@stable
	     */
	    var FormGroupName = (function (_super) {
	        __extends$12(FormGroupName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function FormGroupName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroupName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.groupParentException();
	            }
	        };
	        FormGroupName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormGroupName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormGroupName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formGroupName',] },],
	        };
	        return FormGroupName;
	    }(AbstractFormGroupDirective));
	    var /** @type {?} */ formArrayNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormArrayName; })
	    };
	    /**
	     * \@whatItDoes Syncs a nested {\@link FormArray} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {\@link FormArray} you want to link, and
	     * will look for a {\@link FormArray} registered with that name in the parent
	     * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
	     *
	     * Nested form arrays can come in handy when you have a group of form controls but
	     * you're not sure how many there will be. Form arrays allow you to create new
	     * form controls dynamically.
	     *
	     * **Access the array**: You can access the associated {\@link FormArray} using the
	     * {\@link AbstractControl.get} method on the parent {\@link FormGroup}.
	     * Ex: `this.form.get('cities')`.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormArray}. See a full list of available properties in {\@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {\@link FormArray}, or you can set the value programmatically later using the
	     * {\@link FormArray}'s {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}
	     * methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the array, you can
	     * subscribe to the {\@link FormArray}'s {\@link AbstractControl.valueChanges} event.  You can also
	     * listen to its {\@link AbstractControl.statusChanges} event to be notified when the validation
	     * status is re-calculated.
	     *
	     * **Add new controls**: You can add new controls to the {\@link FormArray} dynamically by
	     * calling its {\@link FormArray.push} method.
	     *  Ex: `this.form.get('cities').push(new FormControl());`
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * \@stable
	     */
	    var FormArrayName = (function (_super) {
	        __extends$12(FormArrayName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function FormArrayName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormArray(this);
	        };
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormArray(this);
	            }
	        };
	        Object.defineProperty(FormArrayName.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.formDirective.getFormArray(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._parent ? (this._parent.formDirective) : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.arrayParentException();
	            }
	        };
	        FormArrayName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormArrayName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormArrayName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formArrayName',] },],
	        };
	        return FormArrayName;
	    }(ControlContainer));
	    /**
	     * @param {?} parent
	     * @return {?}
	     */
	    function _hasInvalidParent(parent) {
	        return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
	            !(parent instanceof FormArrayName);
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ controlNameBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlName; })
	    };
	    /**
	     * \@whatItDoes Syncs a {\@link FormControl} in an existing {\@link FormGroup} to a form control
	     * element by name.
	     *
	     * In other words, this directive ensures that any values written to the {\@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {\@link FormControl} instance (view -> model).
	     *
	     * \@howToUse
	     *
	     * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the {\@link FormControl} instance you want to
	     * link, and will look for a {\@link FormControl} registered with that name in the
	     * closest {\@link FormGroup} or {\@link FormArray} above it.
	     *
	     * **Access the control**: You can access the {\@link FormControl} associated with
	     * this directive by using the {\@link AbstractControl.get} method.
	     * Ex: `this.form.get('first');`
	     *
	     * **Get value**: the `value` property is always synced and available on the {\@link FormControl}.
	     * See a full list of available properties in {\@link AbstractControl}.
	     *
	     *  **Set value**: You can set an initial value for the control when instantiating the
	     *  {\@link FormControl}, or you can set it programmatically later using
	     *  {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * To see `formControlName` examples with different form control types, see:
	     *
	     * * Radio buttons: {\@link RadioControlValueAccessor}
	     * * Selects: {\@link SelectControlValueAccessor}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     *  \@stable
	     */
	    var FormControlName = (function (_super) {
	        __extends$10(FormControlName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function FormControlName(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this._added = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlName.prototype, "isDisabled", {
	            /**
	             * @param {?} isDisabled
	             * @return {?}
	             */
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlName.prototype.ngOnChanges = function (changes) {
	            if (!this._added)
	                this._setUpControl();
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.viewModel = this.model;
	                this.formDirective.updateModel(this, this.model);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeControl(this);
	            }
	        };
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        FormControlName.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        Object.defineProperty(FormControlName.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype._checkParentType = function () {
	            if (!(this._parent instanceof FormGroupName) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                ReactiveErrors.ngModelGroupException();
	            }
	            else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&
	                !(this._parent instanceof FormArrayName)) {
	                ReactiveErrors.controlParentException();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype._setUpControl = function () {
	            this._checkParentType();
	            this._control = this.formDirective.addControl(this);
	            if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                this.valueAccessor.setDisabledState(true);
	            }
	            this._added = true;
	        };
	        FormControlName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },
	        ];
	        /** @nocollapse */
	        FormControlName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        FormControlName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formControlName',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlName;
	    }(NgControl));
	
	    var __extends$13 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return RequiredValidator; }),
	        multi: true
	    };
	    var /** @type {?} */ CHECKBOX_REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxRequiredValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `required` validator to any controls marked with the
	     * `required` attribute, via the {\@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input name="fullName" ngModel required>
	     * ```
	     *
	     * \@stable
	     */
	    var RequiredValidator = (function () {
	        function RequiredValidator() {
	        }
	        Object.defineProperty(RequiredValidator.prototype, "required", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._required; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._required = value != null && value !== false && "" + value !== 'false';
	                if (this._onChange)
	                    this._onChange();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        RequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.required(c) : null;
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        RequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',
	                        providers: [REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        RequiredValidator.ctorParameters = function () { return []; };
	        RequiredValidator.propDecorators = {
	            'required': [{ type: _angular_core.Input },],
	        };
	        return RequiredValidator;
	    }());
	    /**
	     * A Directive that adds the `required` validator to checkbox controls marked with the
	     * `required` attribute, via the {\@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input type="checkbox" name="active" ngModel required>
	     * ```
	     *
	     * \@experimental
	     */
	    var CheckboxRequiredValidator = (function (_super) {
	        __extends$13(CheckboxRequiredValidator, _super);
	        function CheckboxRequiredValidator() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        CheckboxRequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.requiredTrue(c) : null;
	        };
	        CheckboxRequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',
	                        providers: [CHECKBOX_REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxRequiredValidator.ctorParameters = function () { return []; };
	        return CheckboxRequiredValidator;
	    }(RequiredValidator));
	    /**
	     * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='min'}
	     */
	    var /** @type {?} */ MIN_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MinLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {\@link MinLengthValidator} for any `formControlName`,
	     * `formControl`, or control with `ngModel` that also has a `minlength` attribute.
	     *
	     * \@stable
	     */
	    var MinLengthValidator = (function () {
	        function MinLengthValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        MinLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('minlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        MinLengthValidator.prototype.validate = function (c) {
	            return this.minlength == null ? null : this._validator(c);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        MinLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.minLength(parseInt(this.minlength, 10));
	        };
	        MinLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
	                        providers: [MIN_LENGTH_VALIDATOR],
	                        host: { '[attr.minlength]': 'minlength ? minlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MinLengthValidator.ctorParameters = function () { return []; };
	        MinLengthValidator.propDecorators = {
	            'minlength': [{ type: _angular_core.Input },],
	        };
	        return MinLengthValidator;
	    }());
	    /**
	     * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='max'}
	     */
	    var /** @type {?} */ MAX_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MaxLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {\@link MaxLengthValidator} for any `formControlName,
	     * `formControl`,
	     * or control with `ngModel` that also has a `maxlength` attribute.
	     *
	     * \@stable
	     */
	    var MaxLengthValidator = (function () {
	        function MaxLengthValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('maxlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.validate = function (c) {
	            return this.maxlength != null ? this._validator(c) : null;
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        MaxLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.maxLength(parseInt(this.maxlength, 10));
	        };
	        MaxLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
	                        providers: [MAX_LENGTH_VALIDATOR],
	                        host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MaxLengthValidator.ctorParameters = function () { return []; };
	        MaxLengthValidator.propDecorators = {
	            'maxlength': [{ type: _angular_core.Input },],
	        };
	        return MaxLengthValidator;
	    }());
	    var /** @type {?} */ PATTERN_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return PatternValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `pattern` validator to any controls marked with the
	     * `pattern` attribute, via the {\@link NG_VALIDATORS} binding. Uses attribute value
	     * as the regex to validate Control value against.  Follows pattern attribute
	     * semantics; i.e. regex must match entire Control value.
	     *
	     * ### Example
	     *
	     * ```
	     * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel>
	     * ```
	     * \@stable
	     */
	    var PatternValidator = (function () {
	        function PatternValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        PatternValidator.prototype.ngOnChanges = function (changes) {
	            if ('pattern' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        PatternValidator.prototype.validate = function (c) { return this._validator(c); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };
	        PatternValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
	                        providers: [PATTERN_VALIDATOR],
	                        host: { '[attr.pattern]': 'pattern ? pattern : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        PatternValidator.ctorParameters = function () { return []; };
	        PatternValidator.propDecorators = {
	            'pattern': [{ type: _angular_core.Input },],
	        };
	        return PatternValidator;
	    }());
	
	    /**
	     * \@whatItDoes Creates an {\@link AbstractControl} from a user-specified configuration.
	     *
	     * It is essentially syntactic sugar that shortens the `new FormGroup()`,
	     * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger
	     * forms.
	     *
	     * \@howToUse
	     *
	     * To use, inject `FormBuilder` into your component class. You can then call its methods
	     * directly.
	     *
	     * {\@example forms/ts/formBuilder/form_builder_example.ts region='Component'}
	     *
	     *  * **npm package**: `\@angular/forms`
	     *
	     *  * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     * \@stable
	     */
	    var FormBuilder = (function () {
	        function FormBuilder() {
	        }
	        /**
	         * Construct a new {\@link FormGroup} with the given map of configuration.
	         * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.
	         *
	         * See the {\@link FormGroup} constructor for more details.
	         * @param {?} controlsConfig
	         * @param {?=} extra
	         * @return {?}
	         */
	        FormBuilder.prototype.group = function (controlsConfig, extra) {
	            if (extra === void 0) { extra = null; }
	            var /** @type {?} */ controls = this._reduceControls(controlsConfig);
	            var /** @type {?} */ validator = isPresent(extra) ? extra['validator'] : null;
	            var /** @type {?} */ asyncValidator = isPresent(extra) ? extra['asyncValidator'] : null;
	            return new FormGroup(controls, validator, asyncValidator);
	        };
	        /**
	         * Construct a new {\@link FormControl} with the given `formState`,`validator`, and
	         * `asyncValidator`.
	         *
	         * `formState` can either be a standalone value for the form control or an object
	         * that contains both a value and a disabled status.
	         *
	         * @param {?} formState
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         * @return {?}
	         */
	        FormBuilder.prototype.control = function (formState, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            return new FormControl(formState, validator, asyncValidator);
	        };
	        /**
	         * Construct a {\@link FormArray} from the given `controlsConfig` array of
	         * configuration, with the given optional `validator` and `asyncValidator`.
	         * @param {?} controlsConfig
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         * @return {?}
	         */
	        FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
	            var _this = this;
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            var /** @type {?} */ controls = controlsConfig.map(function (c) { return _this._createControl(c); });
	            return new FormArray(controls, validator, asyncValidator);
	        };
	        /**
	         * \@internal
	         * @param {?} controlsConfig
	         * @return {?}
	         */
	        FormBuilder.prototype._reduceControls = function (controlsConfig) {
	            var _this = this;
	            var /** @type {?} */ controls = {};
	            Object.keys(controlsConfig).forEach(function (controlName) {
	                controls[controlName] = _this._createControl(controlsConfig[controlName]);
	            });
	            return controls;
	        };
	        /**
	         * \@internal
	         * @param {?} controlConfig
	         * @return {?}
	         */
	        FormBuilder.prototype._createControl = function (controlConfig) {
	            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||
	                controlConfig instanceof FormArray) {
	                return controlConfig;
	            }
	            else if (Array.isArray(controlConfig)) {
	                var /** @type {?} */ value = controlConfig[0];
	                var /** @type {?} */ validator = controlConfig.length > 1 ? controlConfig[1] : null;
	                var /** @type {?} */ asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	                return this.control(value, validator, asyncValidator);
	            }
	            else {
	                return this.control(controlConfig);
	            }
	        };
	        FormBuilder.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        FormBuilder.ctorParameters = function () { return []; };
	        return FormBuilder;
	    }());
	
	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.8');
	
	    var /** @type {?} */ SHARED_FORM_DIRECTIVES = [
	        NgSelectOption,
	        NgSelectMultipleOption,
	        DefaultValueAccessor,
	        NumberValueAccessor,
	        RangeValueAccessor,
	        CheckboxControlValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	        NgControlStatus,
	        NgControlStatusGroup,
	        RequiredValidator,
	        MinLengthValidator,
	        MaxLengthValidator,
	        PatternValidator,
	        CheckboxRequiredValidator,
	    ];
	    var /** @type {?} */ TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
	    var /** @type {?} */ REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
	    /**
	     * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
	     */
	    var InternalFormsSharedModule = (function () {
	        function InternalFormsSharedModule() {
	        }
	        InternalFormsSharedModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: SHARED_FORM_DIRECTIVES,
	                        exports: SHARED_FORM_DIRECTIVES,
	                    },] },
	        ];
	        /** @nocollapse */
	        InternalFormsSharedModule.ctorParameters = function () { return []; };
	        return InternalFormsSharedModule;
	    }());
	
	    /**
	     * The ng module for forms.
	     * \@stable
	     */
	    var FormsModule = (function () {
	        function FormsModule() {
	        }
	        FormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: TEMPLATE_DRIVEN_DIRECTIVES,
	                        providers: [RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        FormsModule.ctorParameters = function () { return []; };
	        return FormsModule;
	    }());
	    /**
	     * The ng module for reactive forms.
	     * \@stable
	     */
	    var ReactiveFormsModule = (function () {
	        function ReactiveFormsModule() {
	        }
	        ReactiveFormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [REACTIVE_DRIVEN_DIRECTIVES],
	                        providers: [FormBuilder, RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        ReactiveFormsModule.ctorParameters = function () { return []; };
	        return ReactiveFormsModule;
	    }());
	
	    exports.AbstractControlDirective = AbstractControlDirective;
	    exports.AbstractFormGroupDirective = AbstractFormGroupDirective;
	    exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
	    exports.ControlContainer = ControlContainer;
	    exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;
	    exports.DefaultValueAccessor = DefaultValueAccessor;
	    exports.NgControl = NgControl;
	    exports.NgControlStatus = NgControlStatus;
	    exports.NgControlStatusGroup = NgControlStatusGroup;
	    exports.NgForm = NgForm;
	    exports.NgModel = NgModel;
	    exports.NgModelGroup = NgModelGroup;
	    exports.RadioControlValueAccessor = RadioControlValueAccessor;
	    exports.FormControlDirective = FormControlDirective;
	    exports.FormControlName = FormControlName;
	    exports.FormGroupDirective = FormGroupDirective;
	    exports.FormArrayName = FormArrayName;
	    exports.FormGroupName = FormGroupName;
	    exports.NgSelectOption = NgSelectOption;
	    exports.SelectControlValueAccessor = SelectControlValueAccessor;
	    exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
	    exports.CheckboxRequiredValidator = CheckboxRequiredValidator;
	    exports.MaxLengthValidator = MaxLengthValidator;
	    exports.MinLengthValidator = MinLengthValidator;
	    exports.PatternValidator = PatternValidator;
	    exports.RequiredValidator = RequiredValidator;
	    exports.FormBuilder = FormBuilder;
	    exports.AbstractControl = AbstractControl;
	    exports.FormArray = FormArray;
	    exports.FormControl = FormControl;
	    exports.FormGroup = FormGroup;
	    exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
	    exports.NG_VALIDATORS = NG_VALIDATORS;
	    exports.Validators = Validators;
	    exports.VERSION = VERSION;
	    exports.FormsModule = FormsModule;
	    exports.ReactiveFormsModule = ReactiveFormsModule;
	
	}));

/***/ },

/***/ 29:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var router_1 = __webpack_require__(30);
	var login_module_1 = __webpack_require__(61);
	var login1_component_1 = __webpack_require__(62);
	var content_module_1 = __webpack_require__(100);
	var appContentRouter_module_1 = __webpack_require__(101);
	var appRoutes = [
	    { path: '', redirectTo: 'login', pathMatch: 'full' },
	    { path: 'login', component: login1_component_1.Login1Component }
	].concat(appContentRouter_module_1.appContentRoutes);
	var AppRoutingModule = (function () {
	    function AppRoutingModule() {
	    }
	    return AppRoutingModule;
	}());
	AppRoutingModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            router_1.RouterModule.forRoot(appRoutes, { useHash: true }),
	            login_module_1.appLoginModule,
	            content_module_1.appContentModule,
	        ],
	        declarations: [],
	        exports: [
	            router_1.RouterModule
	        ],
	    }),
	    __metadata("design:paramtypes", [])
	], AppRoutingModule);
	exports.AppRoutingModule = AppRoutingModule;


/***/ },

/***/ 61:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var login1_component_1 = __webpack_require__(62);
	var material_1 = __webpack_require__(64);
	var flex_layout_1 = __webpack_require__(99);
	var appLoginModule = (function () {
	    function appLoginModule() {
	    }
	    return appLoginModule;
	}());
	appLoginModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            material_1.MaterialModule.forRoot(),
	            flex_layout_1.FlexLayoutModule.forRoot(),
	        ],
	        declarations: [
	            login1_component_1.Login1Component,
	        ],
	        exports: [
	            login1_component_1.Login1Component
	        ],
	    })
	], appLoginModule);
	exports.appLoginModule = appLoginModule;


/***/ },

/***/ 62:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var Login1Component = (function () {
	    function Login1Component() {
	    }
	    return Login1Component;
	}());
	Login1Component = __decorate([
	    core_1.Component({
	        selector: 'login1-form',
	        template: __webpack_require__(63),
	    })
	], Login1Component);
	exports.Login1Component = Login1Component;


/***/ },

/***/ 63:
/***/ function(module, exports) {

	module.exports = "<div class=\"login-form-container\" fxLayout=\"column\" fxLayoutAlign=\"center center\" >\r\n\t<form class=\"flex-item login-form\" fxLayout=\"column\" fxLayoutAlign=\"center center\">\r\n\t\t<md-input-container>\r\n\t\t  <input mdInput placeholder=\"  \" value=\"Sushi\">\r\n\t\t</md-input-container>\r\n\t\t<md-input-container>\r\n\t\t  <input mdInput placeholder=\"  \" value=\"Sushi\">\r\n\t\t</md-input-container>\r\n\t\t<div fxLayout=\"row\" fxLayoutAlign=\"space-around center\"> \r\n\t\t  \t<button md-raised-button>  </button>\r\n\t\t  \t<button md-raised-button>  </button>\r\n\t\t</div>\r\n\t</form>\r\n</div>\r\n\r\n\r\n\r\n";

/***/ },

/***/ 64:
/***/ function(module, exports, __webpack_require__) {

	/**
	  * @license Angular Material v2.0.0-beta.2
	  * Copyright (c) 2017 Google, Inc. https://material.angular.io/
	  * License: MIT
	  */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3), __webpack_require__(22), __webpack_require__(6), __webpack_require__(7), __webpack_require__(65), __webpack_require__(68), __webpack_require__(21), __webpack_require__(24), __webpack_require__(75), __webpack_require__(78), __webpack_require__(28), __webpack_require__(79), __webpack_require__(82), __webpack_require__(83), __webpack_require__(84), __webpack_require__(85), __webpack_require__(87), __webpack_require__(91), __webpack_require__(93), __webpack_require__(94), __webpack_require__(97)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/add/observable/fromEvent', 'rxjs/add/operator/auditTime', '@angular/platform-browser', '@angular/forms', 'rxjs/add/operator/startWith', 'rxjs/add/operator/first', '@angular/http', 'rxjs/add/observable/forkJoin', 'rxjs/add/observable/of', 'rxjs/add/operator/map', 'rxjs/add/operator/filter', 'rxjs/add/operator/do', 'rxjs/add/operator/share', 'rxjs/add/operator/finally', 'rxjs/add/operator/catch', 'rxjs/add/observable/merge', 'rxjs/add/operator/switchMap'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}),global.ng.core,global.ng.common,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.ng.platformBrowser,global.ng.forms,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.http,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable,global.Rx.Observable.prototype));
	}(this, (function (exports,_angular_core,_angular_common,rxjs_Subject,rxjs_Observable,rxjs_add_observable_fromEvent,rxjs_add_operator_auditTime,_angular_platformBrowser,_angular_forms,rxjs_add_operator_startWith,rxjs_add_operator_first,_angular_http,rxjs_add_observable_forkJoin,rxjs_add_observable_of,rxjs_add_operator_map,rxjs_add_operator_filter,rxjs_add_operator_do,rxjs_add_operator_share,rxjs_add_operator_finally,rxjs_add_operator_catch,rxjs_add_observable_merge,rxjs_add_operator_switchMap) { 'use strict';
	
	var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$2 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var MATERIAL_COMPATIBILITY_MODE = new _angular_core.OpaqueToken('md-compatibility-mode');
	/** Selector that matches all elements that may have style collisions with AngularJS Material. */
	var MAT_ELEMENTS_SELECTOR = "\n  [mat-button],\n  [mat-dialog-actions],\n  [mat-dialog-close],\n  [mat-dialog-content],\n  [mat-dialog-title],\n  [mat-fab],\n  [mat-icon-button],\n  [mat-menu-trigger-for],\n  [mat-mini-fab],\n  [mat-raised-button],\n  [mat-tab-label],\n  [mat-tab-link],\n  [mat-tab-nav-bar],\n  [matTooltip],\n  mat-autocomplete,\n  mat-button-toggle,\n  mat-button-toggle-group,\n  mat-button-toggle,\n  mat-card,\n  mat-card-actions,\n  mat-card-content,\n  mat-card-footer,\n  mat-card-header,\n  mat-card-subtitle,\n  mat-card-title,\n  mat-card-title-group,\n  mat-checkbox,\n  mat-chip,\n  mat-dialog-actions,\n  mat-dialog-container,\n  mat-dialog-content,\n  mat-divider,\n  mat-grid-list,\n  mat-grid-tile,\n  mat-grid-tile-footer,\n  mat-grid-tile-header,\n  mat-hint,\n  mat-icon,\n  mat-ink-bar,\n  mat-list,\n  mat-list-item,\n  mat-menu,\n  mat-nav-list,\n  mat-option,\n  mat-placeholder,\n  mat-progress-bar,\n  mat-progress-circle,\n  mat-pseudo-checkbox,\n  mat-radio-button,\n  mat-radio-group,\n  mat-select,\n  mat-sidenav,\n  mat-sidenav-container,\n  mat-slider,\n  mat-spinner,\n  mat-tab,\n  mat-tab-body,\n  mat-tab-header,\n  mat-tab-group,\n  mat-toolbar";
	/** Selector that matches all elements that may have style collisions with AngularJS Material. */
	var MD_ELEMENTS_SELECTOR = "  \n  [md-button],\n  [md-dialog-actions],\n  [md-dialog-close],\n  [md-dialog-content],\n  [md-dialog-title],\n  [md-fab],\n  [md-icon-button],\n  [md-menu-trigger-for],\n  [md-mini-fab],\n  [md-raised-button],\n  [md-tab-label],\n  [md-tab-link],\n  [md-tab-nav-bar],\n  [mdTooltip],\n  md-autocomplete,\n  md-button-toggle,\n  md-button-toggle-group,\n  md-button-toggle,\n  md-card,\n  md-card-actions,\n  md-card-content,\n  md-card-footer,\n  md-card-header,\n  md-card-subtitle,\n  md-card-title,\n  md-card-title-group,\n  md-checkbox,\n  md-chip,\n  md-dialog-actions,\n  md-dialog-container,\n  md-dialog-content,\n  md-divider,\n  md-grid-list,\n  md-grid-tile,\n  md-grid-tile-footer,\n  md-grid-tile-header,\n  md-hint,\n  md-icon,\n  md-ink-bar,\n  md-list,\n  md-list-item,\n  md-menu,\n  md-nav-list,\n  md-option,\n  md-placeholder,\n  md-progress-bar,\n  md-progress-circle,\n  md-pseudo-checkbox,\n  md-radio-button,\n  md-radio-group,\n  md-select,\n  md-sidenav,\n  md-sidenav-container,\n  md-slider,\n  md-spinner,\n  md-tab,\n  md-tab-body,\n  md-tab-header,\n  md-tab-group,\n  md-toolbar";
	/** Directive that enforces that the `mat-` prefix cannot be used. */
	var MatPrefixRejector = (function () {
	    function MatPrefixRejector(isCompatibilityMode) {
	        if (!isCompatibilityMode) {
	            throw Error('The "mat-" prefix cannot be used out of ng-material v1 compatibility mode.');
	        }
	    }
	    MatPrefixRejector = __decorate$2([
	        _angular_core.Directive({ selector: MAT_ELEMENTS_SELECTOR }),
	        __param(0, _angular_core.Optional()),
	        __param(0, _angular_core.Inject(MATERIAL_COMPATIBILITY_MODE)), 
	        __metadata$2('design:paramtypes', [Boolean])
	    ], MatPrefixRejector);
	    return MatPrefixRejector;
	}());
	/** Directive that enforces that the `md-` prefix cannot be used. */
	var MdPrefixRejector = (function () {
	    function MdPrefixRejector(isCompatibilityMode) {
	        if (isCompatibilityMode) {
	            throw Error('The "md-" prefix cannot be used in ng-material v1 compatibility mode.');
	        }
	    }
	    MdPrefixRejector = __decorate$2([
	        _angular_core.Directive({ selector: MD_ELEMENTS_SELECTOR }),
	        __param(0, _angular_core.Optional()),
	        __param(0, _angular_core.Inject(MATERIAL_COMPATIBILITY_MODE)), 
	        __metadata$2('design:paramtypes', [Boolean])
	    ], MdPrefixRejector);
	    return MdPrefixRejector;
	}());
	/**
	 * Module that enforces the default compatibility mode settings. When this module is loaded
	 * without NoConflictStyleCompatibilityMode also being imported, it will throw an error if
	 * there are any uses of the `mat-` prefix.
	 */
	var CompatibilityModule = (function () {
	    function CompatibilityModule() {
	    }
	    CompatibilityModule.forRoot = function () {
	        return {
	            ngModule: CompatibilityModule,
	            providers: [],
	        };
	    };
	    CompatibilityModule = __decorate$2([
	        _angular_core.NgModule({
	            declarations: [MatPrefixRejector, MdPrefixRejector],
	            exports: [MatPrefixRejector, MdPrefixRejector],
	        }), 
	        __metadata$2('design:paramtypes', [])
	    ], CompatibilityModule);
	    return CompatibilityModule;
	}());
	/**
	 * Module that enforces "no-conflict" compatibility mode settings. When this module is loaded,
	 * it will throw an error if there are any uses of the `md-` prefix.
	 */
	var NoConflictStyleCompatibilityMode = (function () {
	    function NoConflictStyleCompatibilityMode() {
	    }
	    NoConflictStyleCompatibilityMode = __decorate$2([
	        _angular_core.NgModule({
	            providers: [{
	                    provide: MATERIAL_COMPATIBILITY_MODE, useValue: true,
	                }],
	        }), 
	        __metadata$2('design:paramtypes', [])
	    ], NoConflictStyleCompatibilityMode);
	    return NoConflictStyleCompatibilityMode;
	}());
	
	var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$1 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Shared directive to count lines inside a text area, such as a list item.
	 * Line elements can be extracted with a @ContentChildren(MdLine) query, then
	 * counted by checking the query list's length.
	 */
	var MdLine = (function () {
	    function MdLine() {
	    }
	    MdLine = __decorate$1([
	        _angular_core.Directive({
	            selector: '[md-line], [mat-line]',
	            host: {
	                '[class.mat-line]': 'true'
	            }
	        }), 
	        __metadata$1('design:paramtypes', [])
	    ], MdLine);
	    return MdLine;
	}());
	/**
	 * Helper that takes a query list of lines and sets the correct class on the host.
	 * @docs-private
	 */
	var MdLineSetter = (function () {
	    function MdLineSetter(_lines, _renderer, _element) {
	        var _this = this;
	        this._lines = _lines;
	        this._renderer = _renderer;
	        this._element = _element;
	        this._setLineClass(this._lines.length);
	        this._lines.changes.subscribe(function () {
	            _this._setLineClass(_this._lines.length);
	        });
	    }
	    MdLineSetter.prototype._setLineClass = function (count) {
	        this._resetClasses();
	        if (count === 2 || count === 3) {
	            this._setClass("mat-" + count + "-line", true);
	        }
	        else if (count > 3) {
	            this._setClass("mat-multi-line", true);
	        }
	    };
	    MdLineSetter.prototype._resetClasses = function () {
	        this._setClass('mat-2-line', false);
	        this._setClass('mat-3-line', false);
	        this._setClass('mat-multi-line', false);
	    };
	    MdLineSetter.prototype._setClass = function (className, bool) {
	        this._renderer.setElementClass(this._element.nativeElement, className, bool);
	    };
	    return MdLineSetter;
	}());
	var MdLineModule = (function () {
	    function MdLineModule() {
	    }
	    MdLineModule = __decorate$1([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [MdLine, CompatibilityModule],
	            declarations: [MdLine],
	        }), 
	        __metadata$1('design:paramtypes', [])
	    ], MdLineModule);
	    return MdLineModule;
	}());
	
	var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$3 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive to listen for changes of direction of part of the DOM.
	 *
	 * Applications should use this directive instead of the native attribute so that Material
	 * components can listen on changes of direction.
	 */
	var Dir = (function () {
	    function Dir() {
	        /** Layout direction of the element. */
	        this._dir = 'ltr';
	        /** Event emitted when the direction changes. */
	        this.dirChange = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(Dir.prototype, "dir", {
	        /** @docs-private */
	        get: function () {
	            return this._dir;
	        },
	        set: function (v) {
	            var old = this._dir;
	            this._dir = v;
	            if (old != this._dir) {
	                this.dirChange.emit();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Dir.prototype, "value", {
	        /** Current layout direction of the element. */
	        get: function () { return this.dir; },
	        set: function (v) { this.dir = v; },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$3([
	        _angular_core.Input('dir'), 
	        __metadata$3('design:type', String)
	    ], Dir.prototype, "_dir", void 0);
	    __decorate$3([
	        _angular_core.Output(), 
	        __metadata$3('design:type', Object)
	    ], Dir.prototype, "dirChange", void 0);
	    __decorate$3([
	        _angular_core.HostBinding('attr.dir'), 
	        __metadata$3('design:type', String)
	    ], Dir.prototype, "dir", null);
	    Dir = __decorate$3([
	        _angular_core.Directive({
	            selector: '[dir]',
	            // TODO(hansl): maybe `$implicit` isn't the best option here, but for now that's the best we got.
	            exportAs: '$implicit'
	        }), 
	        __metadata$3('design:paramtypes', [])
	    ], Dir);
	    return Dir;
	}());
	var RtlModule = (function () {
	    function RtlModule() {
	    }
	    /** @deprecated */
	    RtlModule.forRoot = function () {
	        return {
	            ngModule: RtlModule,
	            providers: []
	        };
	    };
	    RtlModule = __decorate$3([
	        _angular_core.NgModule({
	            exports: [Dir],
	            declarations: [Dir]
	        }), 
	        __metadata$3('design:paramtypes', [])
	    ], RtlModule);
	    return RtlModule;
	}());
	
	var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$4 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive that triggers a callback whenever the content of
	 * its associated element has changed.
	 */
	var ObserveContent = (function () {
	    function ObserveContent(_elementRef) {
	        this._elementRef = _elementRef;
	        /** Event emitted for each change in the element's content. */
	        this.event = new _angular_core.EventEmitter();
	    }
	    ObserveContent.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._observer = new MutationObserver(function (mutations) { return mutations.forEach(function () { return _this.event.emit(); }); });
	        this._observer.observe(this._elementRef.nativeElement, {
	            characterData: true,
	            childList: true,
	            subtree: true
	        });
	    };
	    ObserveContent.prototype.ngOnDestroy = function () {
	        if (this._observer) {
	            this._observer.disconnect();
	        }
	    };
	    __decorate$4([
	        _angular_core.Output('cdkObserveContent'), 
	        __metadata$4('design:type', Object)
	    ], ObserveContent.prototype, "event", void 0);
	    ObserveContent = __decorate$4([
	        _angular_core.Directive({
	            selector: '[cdkObserveContent]'
	        }), 
	        __metadata$4('design:paramtypes', [_angular_core.ElementRef])
	    ], ObserveContent);
	    return ObserveContent;
	}());
	var ObserveContentModule = (function () {
	    function ObserveContentModule() {
	    }
	    /** @deprecated */
	    ObserveContentModule.forRoot = function () {
	        return {
	            ngModule: ObserveContentModule,
	            providers: []
	        };
	    };
	    ObserveContentModule = __decorate$4([
	        _angular_core.NgModule({
	            exports: [ObserveContent],
	            declarations: [ObserveContent]
	        }), 
	        __metadata$4('design:paramtypes', [])
	    ], ObserveContentModule);
	    return ObserveContentModule;
	}());
	
	// Due to a bug in the ChromeDriver, Angular keyboard events are not triggered by `sendKeys`
	// during E2E tests when using dot notation such as `(keydown.rightArrow)`. To get around this,
	// we are temporarily using a single (keydown) handler.
	// See: https://github.com/angular/angular/issues/9419
	var UP_ARROW = 38;
	var DOWN_ARROW = 40;
	var RIGHT_ARROW = 39;
	var LEFT_ARROW = 37;
	var PAGE_UP = 33;
	var PAGE_DOWN = 34;
	var HOME = 36;
	var END = 35;
	var ENTER = 13;
	var SPACE = 32;
	var TAB = 9;
	var ESCAPE = 27;
	var BACKSPACE = 8;
	var DELETE = 46;
	
	/** Coerces a data-bound value (typically a string) to a boolean. */
	function coerceBooleanProperty(value) {
	    return value != null && "" + value !== 'false';
	}
	
	/** Fade-in speed in pixels per second. Can be modified with the speedFactor option. */
	var RIPPLE_SPEED_PX_PER_SECOND = 170;
	/** Fade-out speed for the ripples in milliseconds. This can't be modified by the speedFactor. */
	var RIPPLE_FADE_OUT_DURATION = 600;
	/**
	 * Returns the distance from the point (x, y) to the furthest corner of a rectangle.
	 */
	var distanceToFurthestCorner = function (x, y, rect) {
	    var distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));
	    var distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
	    return Math.sqrt(distX * distX + distY * distY);
	};
	/**
	 * Helper service that performs DOM manipulations. Not intended to be used outside this module.
	 * The constructor takes a reference to the ripple directive's host element and a map of DOM
	 * event handlers to be installed on the element that triggers ripple animations.
	 * This will eventually become a custom renderer once Angular support exists.
	 * @docs-private
	 */
	var RippleRenderer = (function () {
	    function RippleRenderer(_elementRef, _ngZone, _ruler) {
	        this._ngZone = _ngZone;
	        this._ruler = _ruler;
	        /** Whether the mouse is currently down or not. */
	        this._isMousedown = false;
	        /** Currently active ripples that will be closed on mouseup. */
	        this._activeRipples = [];
	        /** Events to be registered on the trigger element. */
	        this._triggerEvents = new Map();
	        /** Ripple config for all ripples created by events. */
	        this.rippleConfig = {};
	        /** Whether mouse ripples should be created or not. */
	        this.rippleDisabled = false;
	        this._containerElement = _elementRef.nativeElement;
	        // Specify events which need to be registered on the trigger.
	        this._triggerEvents.set('mousedown', this.onMousedown.bind(this));
	        this._triggerEvents.set('mouseup', this.onMouseup.bind(this));
	        this._triggerEvents.set('mouseleave', this.onMouseLeave.bind(this));
	        // By default use the host element as trigger element.
	        this.setTriggerElement(this._containerElement);
	    }
	    /** Fades in a ripple at the given coordinates. */
	    RippleRenderer.prototype.fadeInRipple = function (pageX, pageY, config) {
	        var _this = this;
	        if (config === void 0) { config = {}; }
	        var containerRect = this._containerElement.getBoundingClientRect();
	        if (config.centered) {
	            pageX = containerRect.left + containerRect.width / 2;
	            pageY = containerRect.top + containerRect.height / 2;
	        }
	        else {
	            // Subtract scroll values from the coordinates because calculations below
	            // are always relative to the viewport rectangle.
	            var scrollPosition = this._ruler.getViewportScrollPosition();
	            pageX -= scrollPosition.left;
	            pageY -= scrollPosition.top;
	        }
	        var radius = config.radius || distanceToFurthestCorner(pageX, pageY, containerRect);
	        var duration = 1 / (config.speedFactor || 1) * (radius / RIPPLE_SPEED_PX_PER_SECOND);
	        var offsetX = pageX - containerRect.left;
	        var offsetY = pageY - containerRect.top;
	        var ripple = document.createElement('div');
	        ripple.classList.add('mat-ripple-element');
	        ripple.style.left = (offsetX - radius) + "px";
	        ripple.style.top = (offsetY - radius) + "px";
	        ripple.style.height = radius * 2 + "px";
	        ripple.style.width = radius * 2 + "px";
	        // If the color is not set, the default CSS color will be used.
	        ripple.style.backgroundColor = config.color;
	        ripple.style.transitionDuration = duration + "s";
	        this._containerElement.appendChild(ripple);
	        // By default the browser does not recalculate the styles of dynamically created
	        // ripple elements. This is critical because then the `scale` would not animate properly.
	        this._enforceStyleRecalculation(ripple);
	        ripple.style.transform = 'scale(1)';
	        // Wait for the ripple to be faded in. Once it's faded in, the ripple can be hidden immediately
	        // if the mouse is released.
	        this.runTimeoutOutsideZone(function () {
	            _this._isMousedown ? _this._activeRipples.push(ripple) : _this.fadeOutRipple(ripple);
	        }, duration * 1000);
	    };
	    /** Fades out a ripple element. */
	    RippleRenderer.prototype.fadeOutRipple = function (ripple) {
	        ripple.style.transitionDuration = RIPPLE_FADE_OUT_DURATION + "ms";
	        ripple.style.opacity = '0';
	        // Once the ripple faded out, the ripple can be safely removed from the DOM.
	        this.runTimeoutOutsideZone(function () {
	            ripple.parentNode.removeChild(ripple);
	        }, RIPPLE_FADE_OUT_DURATION);
	    };
	    /** Sets the trigger element and registers the mouse events. */
	    RippleRenderer.prototype.setTriggerElement = function (element) {
	        var _this = this;
	        // Remove all previously register event listeners from the trigger element.
	        if (this._triggerElement) {
	            this._triggerEvents.forEach(function (fn, type) { return _this._triggerElement.removeEventListener(type, fn); });
	        }
	        if (element) {
	            // If the element is not null, register all event listeners on the trigger element.
	            this._triggerEvents.forEach(function (fn, type) { return element.addEventListener(type, fn); });
	        }
	        this._triggerElement = element;
	    };
	    /** Listener being called on mousedown event. */
	    RippleRenderer.prototype.onMousedown = function (event) {
	        if (this.rippleDisabled) {
	            return;
	        }
	        this._isMousedown = true;
	        this.fadeInRipple(event.pageX, event.pageY, this.rippleConfig);
	    };
	    /** Listener being called on mouseup event. */
	    RippleRenderer.prototype.onMouseup = function () {
	        var _this = this;
	        this._isMousedown = false;
	        this._activeRipples.forEach(function (ripple) { return _this.fadeOutRipple(ripple); });
	        this._activeRipples = [];
	    };
	    /** Listener being called on mouseleave event. */
	    RippleRenderer.prototype.onMouseLeave = function () {
	        if (this._isMousedown) {
	            this.onMouseup();
	        }
	    };
	    /** Runs a timeout outside of the Angular zone to avoid triggering the change detection. */
	    RippleRenderer.prototype.runTimeoutOutsideZone = function (fn, delay) {
	        if (delay === void 0) { delay = 0; }
	        this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });
	    };
	    /** Enforces a style recalculation of a DOM element by computing its styles. */
	    // TODO(devversion): Move into global utility function.
	    RippleRenderer.prototype._enforceStyleRecalculation = function (element) {
	        // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.
	        // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.
	        // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
	        window.getComputedStyle(element).getPropertyValue('opacity');
	    };
	    return RippleRenderer;
	}());
	
	var __decorate$8 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$8 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Time in ms to throttle the scrolling events by default. */
	var DEFAULT_SCROLL_TIME = 20;
	/**
	 * Service contained all registered Scrollable references and emits an event when any one of the
	 * Scrollable references emit a scrolled event.
	 */
	var ScrollDispatcher = (function () {
	    function ScrollDispatcher() {
	        var _this = this;
	        /** Subject for notifying that a registered scrollable reference element has been scrolled. */
	        this._scrolled = new rxjs_Subject.Subject();
	        /**
	         * Map of all the scrollable references that are registered with the service and their
	         * scroll event subscriptions.
	         */
	        this.scrollableReferences = new Map();
	        // By default, notify a scroll event when the document is scrolled or the window is resized.
	        rxjs_Observable.Observable.fromEvent(window.document, 'scroll').subscribe(function () { return _this._notify(); });
	        rxjs_Observable.Observable.fromEvent(window, 'resize').subscribe(function () { return _this._notify(); });
	    }
	    /**
	     * Registers a Scrollable with the service and listens for its scrolled events. When the
	     * scrollable is scrolled, the service emits the event in its scrolled observable.
	     *
	     * @param scrollable Scrollable instance to be registered.
	     */
	    ScrollDispatcher.prototype.register = function (scrollable) {
	        var _this = this;
	        var scrollSubscription = scrollable.elementScrolled().subscribe(function () { return _this._notify(); });
	        this.scrollableReferences.set(scrollable, scrollSubscription);
	    };
	    /**
	     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
	     *
	     * @param scrollable Scrollable instance to be deregistered.
	     */
	    ScrollDispatcher.prototype.deregister = function (scrollable) {
	        this.scrollableReferences.get(scrollable).unsubscribe();
	        this.scrollableReferences.delete(scrollable);
	    };
	    /**
	     * Returns an observable that emits an event whenever any of the registered Scrollable
	     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
	     * to override the default "throttle" time.
	     */
	    ScrollDispatcher.prototype.scrolled = function (auditTimeInMs) {
	        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }
	        // In the case of a 0ms delay, return the observable without auditTime since it does add
	        // a perceptible delay in processing overhead.
	        if (auditTimeInMs == 0) {
	            return this._scrolled.asObservable();
	        }
	        return this._scrolled.asObservable().auditTime(auditTimeInMs);
	    };
	    /** Returns all registered Scrollables that contain the provided element. */
	    ScrollDispatcher.prototype.getScrollContainers = function (elementRef) {
	        var _this = this;
	        var scrollingContainers = [];
	        this.scrollableReferences.forEach(function (subscription, scrollable) {
	            if (_this.scrollableContainsElement(scrollable, elementRef)) {
	                scrollingContainers.push(scrollable);
	            }
	        });
	        return scrollingContainers;
	    };
	    /** Returns true if the element is contained within the provided Scrollable. */
	    ScrollDispatcher.prototype.scrollableContainsElement = function (scrollable, elementRef) {
	        var element = elementRef.nativeElement;
	        var scrollableElement = scrollable.getElementRef().nativeElement;
	        // Traverse through the element parents until we reach null, checking if any of the elements
	        // are the scrollable's element.
	        do {
	            if (element == scrollableElement) {
	                return true;
	            }
	        } while (element = element.parentElement);
	    };
	    /** Sends a notification that a scroll event has been fired. */
	    ScrollDispatcher.prototype._notify = function () {
	        this._scrolled.next();
	    };
	    ScrollDispatcher = __decorate$8([
	        _angular_core.Injectable(), 
	        __metadata$8('design:paramtypes', [])
	    ], ScrollDispatcher);
	    return ScrollDispatcher;
	}());
	function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {
	    return parentDispatcher || new ScrollDispatcher();
	}
	var SCROLL_DISPATCHER_PROVIDER = {
	    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.
	    provide: ScrollDispatcher,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), ScrollDispatcher]],
	    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY
	};
	
	var __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$7 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Simple utility for getting the bounds of the browser viewport.
	 * @docs-private
	 */
	var ViewportRuler = (function () {
	    function ViewportRuler(scrollDispatcher) {
	        var _this = this;
	        // Initially cache the document rectangle.
	        this._cacheViewportGeometry();
	        // Subscribe to scroll and resize events and update the document rectangle on changes.
	        scrollDispatcher.scrolled().subscribe(function () { return _this._cacheViewportGeometry(); });
	    }
	    /** Gets a ClientRect for the viewport's bounds. */
	    ViewportRuler.prototype.getViewportRect = function (documentRect) {
	        if (documentRect === void 0) { documentRect = this._documentRect; }
	        // Use the document element's bounding rect rather than the window scroll properties
	        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
	        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
	        // conceptual viewports. Under most circumstances these viewports are equivalent, but they
	        // can disagree when the page is pinch-zoomed (on devices that support touch).
	        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
	        // We use the documentElement instead of the body because, by default (without a css reset)
	        // browsers typically give the document body an 8px margin, which is not included in
	        // getBoundingClientRect().
	        var scrollPosition = this.getViewportScrollPosition(documentRect);
	        var height = window.innerHeight;
	        var width = window.innerWidth;
	        return {
	            top: scrollPosition.top,
	            left: scrollPosition.left,
	            bottom: scrollPosition.top + height,
	            right: scrollPosition.left + width,
	            height: height,
	            width: width,
	        };
	    };
	    /**
	     * Gets the (top, left) scroll position of the viewport.
	     * @param documentRect
	     */
	    ViewportRuler.prototype.getViewportScrollPosition = function (documentRect) {
	        if (documentRect === void 0) { documentRect = this._documentRect; }
	        // The top-left-corner of the viewport is determined by the scroll position of the document
	        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
	        // whether `document.body` or `document.documentElement` is the scrolled element, so reading
	        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
	        // `document.documentElement` works consistently, where the `top` and `left` values will
	        // equal negative the scroll position.
	        var top = -documentRect.top || document.body.scrollTop || window.scrollY || 0;
	        var left = -documentRect.left || document.body.scrollLeft || window.scrollX || 0;
	        return { top: top, left: left };
	    };
	    /** Caches the latest client rectangle of the document element. */
	    ViewportRuler.prototype._cacheViewportGeometry = function () {
	        this._documentRect = document.documentElement.getBoundingClientRect();
	    };
	    ViewportRuler = __decorate$7([
	        _angular_core.Injectable(), 
	        __metadata$7('design:paramtypes', [ScrollDispatcher])
	    ], ViewportRuler);
	    return ViewportRuler;
	}());
	function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, scrollDispatcher) {
	    return parentRuler || new ViewportRuler(scrollDispatcher);
	}
	var VIEWPORT_RULER_PROVIDER = {
	    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.
	    provide: ViewportRuler,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), ViewportRuler], ScrollDispatcher],
	    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY
	};
	
	var __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$6 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdRipple = (function () {
	    function MdRipple(elementRef, ngZone, ruler) {
	        /**
	         * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius
	         * will be the distance from the center of the ripple to the furthest corner of the host element's
	         * bounding rectangle.
	         */
	        this.radius = 0;
	        /**
	         * If set, the normal duration of ripple animations is divided by this value. For example,
	         * setting it to 0.5 will cause the animations to take twice as long.
	         * A changed speedFactor will not modify the fade-out duration of the ripples.
	         */
	        this.speedFactor = 1;
	        this._rippleRenderer = new RippleRenderer(elementRef, ngZone, ruler);
	    }
	    MdRipple.prototype.ngOnChanges = function (changes) {
	        if (changes['trigger'] && this.trigger) {
	            this._rippleRenderer.setTriggerElement(this.trigger);
	        }
	        this._rippleRenderer.rippleDisabled = this.disabled;
	        this._updateRippleConfig();
	    };
	    MdRipple.prototype.ngOnDestroy = function () {
	        // Set the trigger element to null to cleanup all listeners.
	        this._rippleRenderer.setTriggerElement(null);
	    };
	    /** Launches a manual ripple at the specified position. */
	    MdRipple.prototype.launch = function (pageX, pageY, config) {
	        this._rippleRenderer.fadeInRipple(pageX, pageY, config);
	    };
	    /** Updates the ripple configuration with the input values. */
	    MdRipple.prototype._updateRippleConfig = function () {
	        this._rippleRenderer.rippleConfig = {
	            centered: this.centered,
	            speedFactor: this.speedFactor,
	            radius: this.radius,
	            color: this.color
	        };
	    };
	    __decorate$6([
	        _angular_core.Input('mdRippleTrigger'), 
	        __metadata$6('design:type', Object)
	    ], MdRipple.prototype, "trigger", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleCentered'), 
	        __metadata$6('design:type', Boolean)
	    ], MdRipple.prototype, "centered", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleDisabled'), 
	        __metadata$6('design:type', Boolean)
	    ], MdRipple.prototype, "disabled", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleRadius'), 
	        __metadata$6('design:type', Number)
	    ], MdRipple.prototype, "radius", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleSpeedFactor'), 
	        __metadata$6('design:type', Number)
	    ], MdRipple.prototype, "speedFactor", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleColor'), 
	        __metadata$6('design:type', String)
	    ], MdRipple.prototype, "color", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleUnbounded'), 
	        __metadata$6('design:type', Boolean)
	    ], MdRipple.prototype, "unbounded", void 0);
	    MdRipple = __decorate$6([
	        _angular_core.Directive({
	            selector: '[md-ripple], [mat-ripple]',
	            host: {
	                '[class.mat-ripple]': 'true',
	                '[class.mat-ripple-unbounded]': 'unbounded'
	            }
	        }), 
	        __metadata$6('design:paramtypes', [_angular_core.ElementRef, _angular_core.NgZone, ViewportRuler])
	    ], MdRipple);
	    return MdRipple;
	}());
	var MdRippleModule = (function () {
	    function MdRippleModule() {
	    }
	    /** @deprecated */
	    MdRippleModule.forRoot = function () {
	        return {
	            ngModule: MdRippleModule,
	            providers: []
	        };
	    };
	    MdRippleModule = __decorate$6([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [MdRipple, CompatibilityModule],
	            declarations: [MdRipple],
	            providers: [VIEWPORT_RULER_PROVIDER, SCROLL_DISPATCHER_PROVIDER],
	        }), 
	        __metadata$6('design:paramtypes', [])
	    ], MdRippleModule);
	    return MdRippleModule;
	}());
	
	var __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$5 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Option IDs need to be unique across components, so this counter exists outside of
	 * the component definition.
	 */
	var _uniqueIdCounter = 0;
	/** Event object emitted by MdOption when selected. */
	var MdOptionSelectEvent = (function () {
	    function MdOptionSelectEvent(source, isUserInput) {
	        if (isUserInput === void 0) { isUserInput = false; }
	        this.source = source;
	        this.isUserInput = isUserInput;
	    }
	    return MdOptionSelectEvent;
	}());
	/**
	 * Single option inside of a `<md-select>` element.
	 */
	var MdOption = (function () {
	    function MdOption(_element, _renderer) {
	        this._element = _element;
	        this._renderer = _renderer;
	        this._selected = false;
	        this._active = false;
	        /** Whether the option is disabled.  */
	        this._disabled = false;
	        this._id = "md-option-" + _uniqueIdCounter++;
	        /** Event emitted when the option is selected. */
	        this.onSelect = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(MdOption.prototype, "id", {
	        /** The unique ID of the option. */
	        get: function () { return this._id; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "disabled", {
	        /** Whether the option is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "selected", {
	        /** Whether or not the option is currently selected. */
	        get: function () {
	            return this._selected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "active", {
	        /**
	         * Whether or not the option is currently active and ready to be selected.
	         * An active option displays styles as if it is focused, but the
	         * focus is actually retained somewhere else. This comes in handy
	         * for components like autocomplete where focus must remain on the input.
	         */
	        get: function () {
	            return this._active;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "viewValue", {
	        /**
	         * The displayed value of the option. It is necessary to show the selected option in the
	         * select's trigger.
	         */
	        get: function () {
	            // TODO(kara): Add input property alternative for node envs.
	            return this._getHostElement().textContent.trim();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Selects the option. */
	    MdOption.prototype.select = function () {
	        this._selected = true;
	        this.onSelect.emit(new MdOptionSelectEvent(this, false));
	    };
	    /** Deselects the option. */
	    MdOption.prototype.deselect = function () {
	        this._selected = false;
	    };
	    /** Sets focus onto this option. */
	    MdOption.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._getHostElement(), 'focus');
	    };
	    /**
	     * This method sets display styles on the option to make it appear
	     * active. This is used by the ActiveDescendantKeyManager so key
	     * events will display the proper options as active on arrow key events.
	     */
	    MdOption.prototype.setActiveStyles = function () {
	        var _this = this;
	        Promise.resolve(null).then(function () { return _this._active = true; });
	    };
	    /**
	     * This method removes display styles on the option that made it appear
	     * active. This is used by the ActiveDescendantKeyManager so key
	     * events will display the proper options as active on arrow key events.
	     */
	    MdOption.prototype.setInactiveStyles = function () {
	        var _this = this;
	        Promise.resolve(null).then(function () { return _this._active = false; });
	    };
	    /** Ensures the option is selected when activated from the keyboard. */
	    MdOption.prototype._handleKeydown = function (event) {
	        if (event.keyCode === ENTER || event.keyCode === SPACE) {
	            this._selectViaInteraction();
	        }
	    };
	    /**
	     * Selects the option while indicating the selection came from the user. Used to
	     * determine if the select's view -> model callback should be invoked.
	     */
	    MdOption.prototype._selectViaInteraction = function () {
	        if (!this.disabled) {
	            this._selected = true;
	            this.onSelect.emit(new MdOptionSelectEvent(this, true));
	        }
	    };
	    /** Returns the correct tabindex for the option depending on disabled state. */
	    MdOption.prototype._getTabIndex = function () {
	        return this.disabled ? '-1' : '0';
	    };
	    MdOption.prototype._getHostElement = function () {
	        return this._element.nativeElement;
	    };
	    __decorate$5([
	        _angular_core.Input(), 
	        __metadata$5('design:type', Object)
	    ], MdOption.prototype, "value", void 0);
	    __decorate$5([
	        _angular_core.Input(), 
	        __metadata$5('design:type', Object)
	    ], MdOption.prototype, "disabled", null);
	    __decorate$5([
	        _angular_core.Output(), 
	        __metadata$5('design:type', Object)
	    ], MdOption.prototype, "onSelect", void 0);
	    MdOption = __decorate$5([
	        _angular_core.Component({selector: 'md-option, mat-option',
	            host: {
	                'role': 'option',
	                '[attr.tabindex]': '_getTabIndex()',
	                '[class.mat-selected]': 'selected',
	                '[class.mat-active]': 'active',
	                '[id]': 'id',
	                '[attr.aria-selected]': 'selected.toString()',
	                '[attr.aria-disabled]': 'disabled.toString()',
	                '[class.mat-option-disabled]': 'disabled',
	                '(click)': '_selectViaInteraction()',
	                '(keydown)': '_handleKeydown($event)',
	                '[class.mat-option]': 'true',
	            },
	            template: "<ng-content></ng-content><div class=\"mat-option-ripple\" *ngIf=\"!disabled\" md-ripple [mdRippleTrigger]=\"_getHostElement()\"></div>",
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$5('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdOption);
	    return MdOption;
	}());
	var MdOptionModule = (function () {
	    function MdOptionModule() {
	    }
	    MdOptionModule.forRoot = function () {
	        return {
	            ngModule: MdOptionModule,
	            providers: []
	        };
	    };
	    MdOptionModule = __decorate$5([
	        _angular_core.NgModule({
	            imports: [MdRippleModule, _angular_common.CommonModule],
	            exports: [MdOption],
	            declarations: [MdOption]
	        }), 
	        __metadata$5('design:paramtypes', [])
	    ], MdOptionModule);
	    return MdOptionModule;
	}());
	
	// TODO(kara): Revisit why error messages are not being properly set.
	var __extends$3 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Wrapper around Error that sets the error message.
	 * @docs-private
	 */
	var MdError = (function (_super) {
	    __extends$3(MdError, _super);
	    function MdError(value) {
	        _super.call(this);
	        this.message = value;
	    }
	    return MdError;
	}(Error));
	
	var __extends$2 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when attempting to attach a null portal to a host.
	 * @docs-private
	 */
	var NullPortalError = (function (_super) {
	    __extends$2(NullPortalError, _super);
	    function NullPortalError() {
	        _super.call(this, 'Must provide a portal to attach');
	    }
	    return NullPortalError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach a portal to a host that is already attached.
	 * @docs-private
	 */
	var PortalAlreadyAttachedError = (function (_super) {
	    __extends$2(PortalAlreadyAttachedError, _super);
	    function PortalAlreadyAttachedError() {
	        _super.call(this, 'Host already has a portal attached');
	    }
	    return PortalAlreadyAttachedError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach a portal to an already-disposed host.
	 * @docs-private
	 */
	var PortalHostAlreadyDisposedError = (function (_super) {
	    __extends$2(PortalHostAlreadyDisposedError, _super);
	    function PortalHostAlreadyDisposedError() {
	        _super.call(this, 'This PortalHost has already been disposed');
	    }
	    return PortalHostAlreadyDisposedError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach an unknown portal type.
	 * @docs-private
	 */
	var UnknownPortalTypeError = (function (_super) {
	    __extends$2(UnknownPortalTypeError, _super);
	    function UnknownPortalTypeError() {
	        _super.call(this, 'Attempting to attach an unknown Portal type. ' +
	            'BasePortalHost accepts either a ComponentPortal or a TemplatePortal.');
	    }
	    return UnknownPortalTypeError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach a portal to a null host.
	 * @docs-private
	 */
	var NullPortalHostError = (function (_super) {
	    __extends$2(NullPortalHostError, _super);
	    function NullPortalHostError() {
	        _super.call(this, 'Attempting to attach a portal to a null PortalHost');
	    }
	    return NullPortalHostError;
	}(MdError));
	/**
	 * Exception thrown when attempting to detach a portal that is not attached.
	 * @docs-private
	 */
	var NoPortalAttachedError = (function (_super) {
	    __extends$2(NoPortalAttachedError, _super);
	    function NoPortalAttachedError() {
	        _super.call(this, 'Attempting to detach a portal that is not attached to a host');
	    }
	    return NoPortalAttachedError;
	}(MdError));
	
	var __extends$1 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * A `Portal` is something that you want to render somewhere else.
	 * It can be attach to / detached from a `PortalHost`.
	 */
	var Portal = (function () {
	    function Portal() {
	    }
	    /** Attach this portal to a host. */
	    Portal.prototype.attach = function (host) {
	        if (host == null) {
	            throw new NullPortalHostError();
	        }
	        if (host.hasAttached()) {
	            throw new PortalAlreadyAttachedError();
	        }
	        this._attachedHost = host;
	        return host.attach(this);
	    };
	    /** Detach this portal from its host */
	    Portal.prototype.detach = function () {
	        var host = this._attachedHost;
	        if (host == null) {
	            throw new NoPortalAttachedError();
	        }
	        this._attachedHost = null;
	        return host.detach();
	    };
	    Object.defineProperty(Portal.prototype, "isAttached", {
	        /** Whether this portal is attached to a host. */
	        get: function () {
	            return this._attachedHost != null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the PortalHost reference without performing `attach()`. This is used directly by
	     * the PortalHost when it is performing an `attach()` or `detach()`.
	     */
	    Portal.prototype.setAttachedHost = function (host) {
	        this._attachedHost = host;
	    };
	    return Portal;
	}());
	/**
	 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
	 */
	var ComponentPortal = (function (_super) {
	    __extends$1(ComponentPortal, _super);
	    function ComponentPortal(component, viewContainerRef, injector) {
	        if (viewContainerRef === void 0) { viewContainerRef = null; }
	        if (injector === void 0) { injector = null; }
	        _super.call(this);
	        this.component = component;
	        this.viewContainerRef = viewContainerRef;
	        this.injector = injector;
	    }
	    return ComponentPortal;
	}(Portal));
	/**
	 * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
	 */
	var TemplatePortal = (function (_super) {
	    __extends$1(TemplatePortal, _super);
	    function TemplatePortal(template, viewContainerRef) {
	        _super.call(this);
	        /**
	         * Additional locals for the instantiated embedded view.
	         * These locals can be seen as "exports" for the template, such as how ngFor has
	         * index / event / odd.
	         * See https://angular.io/docs/ts/latest/api/core/EmbeddedViewRef-class.html
	         */
	        this.locals = new Map();
	        this.templateRef = template;
	        this.viewContainerRef = viewContainerRef;
	    }
	    Object.defineProperty(TemplatePortal.prototype, "origin", {
	        get: function () {
	            return this.templateRef.elementRef;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TemplatePortal.prototype.attach = function (host, locals) {
	        this.locals = locals == null ? new Map() : locals;
	        return _super.prototype.attach.call(this, host);
	    };
	    TemplatePortal.prototype.detach = function () {
	        this.locals = new Map();
	        return _super.prototype.detach.call(this);
	    };
	    return TemplatePortal;
	}(Portal));
	/**
	 * Partial implementation of PortalHost that only deals with attaching either a
	 * ComponentPortal or a TemplatePortal.
	 */
	var BasePortalHost = (function () {
	    function BasePortalHost() {
	        /** Whether this host has already been permanently disposed. */
	        this._isDisposed = false;
	    }
	    /** Whether this host has an attached portal. */
	    BasePortalHost.prototype.hasAttached = function () {
	        return this._attachedPortal != null;
	    };
	    BasePortalHost.prototype.attach = function (portal) {
	        if (portal == null) {
	            throw new NullPortalError();
	        }
	        if (this.hasAttached()) {
	            throw new PortalAlreadyAttachedError();
	        }
	        if (this._isDisposed) {
	            throw new PortalHostAlreadyDisposedError();
	        }
	        if (portal instanceof ComponentPortal) {
	            this._attachedPortal = portal;
	            return this.attachComponentPortal(portal);
	        }
	        else if (portal instanceof TemplatePortal) {
	            this._attachedPortal = portal;
	            return this.attachTemplatePortal(portal);
	        }
	        throw new UnknownPortalTypeError();
	    };
	    BasePortalHost.prototype.detach = function () {
	        if (this._attachedPortal) {
	            this._attachedPortal.setAttachedHost(null);
	        }
	        this._attachedPortal = null;
	        if (this._disposeFn != null) {
	            this._disposeFn();
	            this._disposeFn = null;
	        }
	    };
	    BasePortalHost.prototype.dispose = function () {
	        if (this.hasAttached()) {
	            this.detach();
	        }
	        this._isDisposed = true;
	    };
	    BasePortalHost.prototype.setDisposeFn = function (fn) {
	        this._disposeFn = fn;
	    };
	    return BasePortalHost;
	}());
	
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$9 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$9 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
	 * the directive instance itself can be attached to a host, enabling declarative use of portals.
	 *
	 * Usage:
	 * <template portal #greeting>
	 *   <p> Hello {{name}} </p>
	 * </template>
	 */
	var TemplatePortalDirective = (function (_super) {
	    __extends(TemplatePortalDirective, _super);
	    function TemplatePortalDirective(templateRef, viewContainerRef) {
	        _super.call(this, templateRef, viewContainerRef);
	    }
	    TemplatePortalDirective = __decorate$9([
	        _angular_core.Directive({
	            selector: '[cdk-portal], [portal]',
	            exportAs: 'cdkPortal',
	        }), 
	        __metadata$9('design:paramtypes', [_angular_core.TemplateRef, _angular_core.ViewContainerRef])
	    ], TemplatePortalDirective);
	    return TemplatePortalDirective;
	}(TemplatePortal));
	/**
	 * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be
	 * directly attached to it, enabling declarative use.
	 *
	 * Usage:
	 * <template [cdkPortalHost]="greeting"></template>
	 */
	var PortalHostDirective = (function (_super) {
	    __extends(PortalHostDirective, _super);
	    function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {
	        _super.call(this);
	        this._componentFactoryResolver = _componentFactoryResolver;
	        this._viewContainerRef = _viewContainerRef;
	    }
	    Object.defineProperty(PortalHostDirective.prototype, "_deprecatedPortal", {
	        /** @deprecated */
	        get: function () { return this.portal; },
	        set: function (v) { this.portal = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PortalHostDirective.prototype, "portal", {
	        /** Portal associated with the Portal host. */
	        get: function () {
	            return this._portal;
	        },
	        set: function (p) {
	            if (p) {
	                this._replaceAttachedPortal(p);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PortalHostDirective.prototype.ngOnDestroy = function () {
	        this.dispose();
	    };
	    /**
	     * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.
	     *
	     * @param portal Portal to be attached to the portal host.
	     */
	    PortalHostDirective.prototype.attachComponentPortal = function (portal) {
	        portal.setAttachedHost(this);
	        // If the portal specifies an origin, use that as the logical location of the component
	        // in the application tree. Otherwise use the location of this PortalHost.
	        var viewContainerRef = portal.viewContainerRef != null ?
	            portal.viewContainerRef :
	            this._viewContainerRef;
	        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
	        var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);
	        this.setDisposeFn(function () { return ref.destroy(); });
	        return ref;
	    };
	    /**
	     * Attach the given TemplatePortal to this PortlHost as an embedded View.
	     * @param portal Portal to be attached.
	     */
	    PortalHostDirective.prototype.attachTemplatePortal = function (portal) {
	        var _this = this;
	        portal.setAttachedHost(this);
	        this._viewContainerRef.createEmbeddedView(portal.templateRef);
	        this.setDisposeFn(function () { return _this._viewContainerRef.clear(); });
	        // TODO(jelbourn): return locals from view
	        return new Map();
	    };
	    /** Detaches the currently attached Portal (if there is one) and attaches the given Portal. */
	    PortalHostDirective.prototype._replaceAttachedPortal = function (p) {
	        if (this.hasAttached()) {
	            this.detach();
	        }
	        if (p) {
	            this.attach(p);
	            this._portal = p;
	        }
	    };
	    __decorate$9([
	        _angular_core.Input('portalHost'), 
	        __metadata$9('design:type', Object)
	    ], PortalHostDirective.prototype, "_deprecatedPortal", null);
	    PortalHostDirective = __decorate$9([
	        _angular_core.Directive({
	            selector: '[cdkPortalHost], [portalHost]',
	            inputs: ['portal: cdkPortalHost']
	        }), 
	        __metadata$9('design:paramtypes', [_angular_core.ComponentFactoryResolver, _angular_core.ViewContainerRef])
	    ], PortalHostDirective);
	    return PortalHostDirective;
	}(BasePortalHost));
	var PortalModule = (function () {
	    function PortalModule() {
	    }
	    /** @deprecated */
	    PortalModule.forRoot = function () {
	        return {
	            ngModule: PortalModule,
	            providers: []
	        };
	    };
	    PortalModule = __decorate$9([
	        _angular_core.NgModule({
	            exports: [TemplatePortalDirective, PortalHostDirective],
	            declarations: [TemplatePortalDirective, PortalHostDirective],
	        }), 
	        __metadata$9('design:paramtypes', [])
	    ], PortalModule);
	    return PortalModule;
	}());
	
	/**
	 * OverlayState is a bag of values for either the initial configuration or current state of an
	 * overlay.
	 */
	var OverlayState = (function () {
	    function OverlayState() {
	        /** Whether the overlay has a backdrop. */
	        this.hasBackdrop = false;
	        /** Custom class to add to the backdrop **/
	        this.backdropClass = 'cdk-overlay-dark-backdrop';
	        /** The direction of the text in the overlay panel. */
	        this.direction = 'ltr';
	    }
	    return OverlayState;
	}());
	
	var __extends$4 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular
	 * application context.
	 *
	 * This is the only part of the portal core that directly touches the DOM.
	 */
	var DomPortalHost = (function (_super) {
	    __extends$4(DomPortalHost, _super);
	    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {
	        _super.call(this);
	        this._hostDomElement = _hostDomElement;
	        this._componentFactoryResolver = _componentFactoryResolver;
	        this._appRef = _appRef;
	        this._defaultInjector = _defaultInjector;
	    }
	    /**
	     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
	     * @param portal Portal to be attached
	     */
	    DomPortalHost.prototype.attachComponentPortal = function (portal) {
	        var _this = this;
	        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
	        var componentRef;
	        // If the portal specifies a ViewContainerRef, we will use that as the attachment point
	        // for the component (in terms of Angular's component tree, not rendering).
	        // When the ViewContainerRef is missing, we use the factory to create the component directly
	        // and then manually attach the view to the application.
	        if (portal.viewContainerRef) {
	            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);
	            this.setDisposeFn(function () { return componentRef.destroy(); });
	        }
	        else {
	            componentRef = componentFactory.create(portal.injector || this._defaultInjector);
	            this._appRef.attachView(componentRef.hostView);
	            this.setDisposeFn(function () {
	                _this._appRef.detachView(componentRef.hostView);
	                componentRef.destroy();
	            });
	        }
	        // At this point the component has been instantiated, so we move it to the location in the DOM
	        // where we want it to be rendered.
	        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));
	        return componentRef;
	    };
	    /**
	     * Attaches a template portal to the DOM as an embedded view.
	     * @param portal Portal to be attached.
	     */
	    DomPortalHost.prototype.attachTemplatePortal = function (portal) {
	        var _this = this;
	        var viewContainer = portal.viewContainerRef;
	        var viewRef = viewContainer.createEmbeddedView(portal.templateRef);
	        // The method `createEmbeddedView` will add the view as a child of the viewContainer.
	        // But for the DomPortalHost the view can be added everywhere in the DOM (e.g Overlay Container)
	        // To move the view to the specified host element. We just re-append the existing root nodes.
	        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });
	        this.setDisposeFn((function () {
	            var index = viewContainer.indexOf(viewRef);
	            if (index !== -1) {
	                viewContainer.remove(index);
	            }
	        }));
	        // TODO(jelbourn): Return locals from view.
	        return new Map();
	    };
	    /**
	     * Clears out a portal from the DOM.
	     */
	    DomPortalHost.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        if (this._hostDomElement.parentNode != null) {
	            this._hostDomElement.parentNode.removeChild(this._hostDomElement);
	        }
	    };
	    /** Gets the root HTMLElement for an instantiated component. */
	    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {
	        return componentRef.hostView.rootNodes[0];
	    };
	    return DomPortalHost;
	}(BasePortalHost));
	
	/**
	 * Reference to an overlay that has been created with the Overlay service.
	 * Used to manipulate or dispose of said overlay.
	 */
	var OverlayRef = (function () {
	    function OverlayRef(_portalHost, _pane, _state, _ngZone) {
	        this._portalHost = _portalHost;
	        this._pane = _pane;
	        this._state = _state;
	        this._ngZone = _ngZone;
	        this._backdropElement = null;
	        this._backdropClick = new rxjs_Subject.Subject();
	    }
	    Object.defineProperty(OverlayRef.prototype, "overlayElement", {
	        /** The overlay's HTML element */
	        get: function () {
	            return this._pane;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Attaches the overlay to a portal instance and adds the backdrop.
	     * @param portal Portal instance to which to attach the overlay.
	     * @returns The portal attachment result.
	     */
	    OverlayRef.prototype.attach = function (portal) {
	        if (this._state.hasBackdrop) {
	            this._attachBackdrop();
	        }
	        var attachResult = this._portalHost.attach(portal);
	        // Update the pane element with the given state configuration.
	        this.updateSize();
	        this.updateDirection();
	        this.updatePosition();
	        // Enable pointer events for the overlay pane element.
	        this._togglePointerEvents(true);
	        return attachResult;
	    };
	    /**
	     * Detaches an overlay from a portal.
	     * @returns Resolves when the overlay has been detached.
	     */
	    OverlayRef.prototype.detach = function () {
	        this._detachBackdrop();
	        // When the overlay is detached, the pane element should disable pointer events.
	        // This is necessary because otherwise the pane element will cover the page and disable
	        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
	        this._togglePointerEvents(false);
	        return this._portalHost.detach();
	    };
	    /**
	     * Cleans up the overlay from the DOM.
	     */
	    OverlayRef.prototype.dispose = function () {
	        if (this._state.positionStrategy) {
	            this._state.positionStrategy.dispose();
	        }
	        this._detachBackdrop();
	        this._portalHost.dispose();
	    };
	    /**
	     * Checks whether the overlay has been attached.
	     */
	    OverlayRef.prototype.hasAttached = function () {
	        return this._portalHost.hasAttached();
	    };
	    /**
	     * Returns an observable that emits when the backdrop has been clicked.
	     */
	    OverlayRef.prototype.backdropClick = function () {
	        return this._backdropClick.asObservable();
	    };
	    /**
	     * Gets the current state config of the overlay.
	     */
	    OverlayRef.prototype.getState = function () {
	        return this._state;
	    };
	    /** Updates the position of the overlay based on the position strategy. */
	    OverlayRef.prototype.updatePosition = function () {
	        if (this._state.positionStrategy) {
	            this._state.positionStrategy.apply(this._pane);
	        }
	    };
	    /** Updates the text direction of the overlay panel. **/
	    OverlayRef.prototype.updateDirection = function () {
	        this._pane.setAttribute('dir', this._state.direction);
	    };
	    /** Updates the size of the overlay based on the overlay config. */
	    OverlayRef.prototype.updateSize = function () {
	        if (this._state.width || this._state.width === 0) {
	            this._pane.style.width = formatCssUnit(this._state.width);
	        }
	        if (this._state.height || this._state.height === 0) {
	            this._pane.style.height = formatCssUnit(this._state.height);
	        }
	        if (this._state.minWidth || this._state.minWidth === 0) {
	            this._pane.style.minWidth = formatCssUnit(this._state.minWidth);
	        }
	        if (this._state.minHeight || this._state.minHeight === 0) {
	            this._pane.style.minHeight = formatCssUnit(this._state.minHeight);
	        }
	    };
	    /** Toggles the pointer events for the overlay pane element. */
	    OverlayRef.prototype._togglePointerEvents = function (enablePointer) {
	        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
	    };
	    /** Attaches a backdrop for this overlay. */
	    OverlayRef.prototype._attachBackdrop = function () {
	        var _this = this;
	        this._backdropElement = document.createElement('div');
	        this._backdropElement.classList.add('cdk-overlay-backdrop');
	        this._backdropElement.classList.add(this._state.backdropClass);
	        // Insert the backdrop before the pane in the DOM order,
	        // in order to handle stacked overlays properly.
	        this._pane.parentElement.insertBefore(this._backdropElement, this._pane);
	        // Forward backdrop clicks such that the consumer of the overlay can perform whatever
	        // action desired when such a click occurs (usually closing the overlay).
	        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });
	        // Add class to fade-in the backdrop after one frame.
	        requestAnimationFrame(function () {
	            if (_this._backdropElement) {
	                _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');
	            }
	        });
	    };
	    /** Detaches the backdrop (if any) associated with the overlay. */
	    OverlayRef.prototype._detachBackdrop = function () {
	        var _this = this;
	        var backdropToDetach = this._backdropElement;
	        if (backdropToDetach) {
	            var finishDetach_1 = function () {
	                // It may not be attached to anything in certain cases (e.g. unit tests).
	                if (backdropToDetach && backdropToDetach.parentNode) {
	                    backdropToDetach.parentNode.removeChild(backdropToDetach);
	                }
	                // It is possible that a new portal has been attached to this overlay since we started
	                // removing the backdrop. If that is the case, only clear the backdrop reference if it
	                // is still the same instance that we started to remove.
	                if (_this._backdropElement == backdropToDetach) {
	                    _this._backdropElement = null;
	                }
	            };
	            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');
	            backdropToDetach.classList.remove(this._state.backdropClass);
	            backdropToDetach.addEventListener('transitionend', finishDetach_1);
	            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
	            // In this case we make it unclickable and we try to remove it after a delay.
	            backdropToDetach.style.pointerEvents = 'none';
	            // Run this outside the Angular zone because there's nothing that Angular cares about.
	            // If it were to run inside the Angular zone, every test that used Overlay would have to be
	            // either async or fakeAsync.
	            this._ngZone.runOutsideAngular(function () {
	                setTimeout(finishDetach_1, 500);
	            });
	        }
	    };
	    return OverlayRef;
	}());
	function formatCssUnit(value) {
	    return typeof value === 'string' ? value : value + "px";
	}
	
	var __decorate$13 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$13 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$2 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** The points of the origin element and the overlay element to connect. */
	var ConnectionPositionPair = (function () {
	    function ConnectionPositionPair(origin, overlay) {
	        this.originX = origin.originX;
	        this.originY = origin.originY;
	        this.overlayX = overlay.overlayX;
	        this.overlayY = overlay.overlayY;
	    }
	    return ConnectionPositionPair;
	}());
	/**
	 * Set of properties regarding the position of the origin and overlay relative to the viewport
	 * with respect to the containing Scrollable elements.
	 *
	 * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
	 * bounds of any one of the strategy's Scrollable's bounding client rectangle.
	 *
	 * The overlay and origin are outside view if there is no overlap between their bounding client
	 * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
	 *
	 *       -----------                    -----------
	 *       | outside |                    | clipped |
	 *       |  view   |              --------------------------
	 *       |         |              |     |         |        |
	 *       ----------               |     -----------        |
	 *  --------------------------    |                        |
	 *  |                        |    |      Scrollable        |
	 *  |                        |    |                        |
	 *  |                        |     --------------------------
	 *  |      Scrollable        |
	 *  |                        |
	 *  --------------------------
	 */
	var ScrollableViewProperties = (function () {
	    function ScrollableViewProperties() {
	    }
	    return ScrollableViewProperties;
	}());
	/** The change event emitted by the strategy when a fallback position is used. */
	var ConnectedOverlayPositionChange = (function () {
	    function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {
	        this.connectionPair = connectionPair;
	        this.scrollableViewProperties = scrollableViewProperties;
	    }
	    ConnectedOverlayPositionChange = __decorate$13([
	        __param$2(1, _angular_core.Optional()), 
	        __metadata$13('design:paramtypes', [ConnectionPositionPair, ScrollableViewProperties])
	    ], ConnectedOverlayPositionChange);
	    return ConnectedOverlayPositionChange;
	}());
	
	/**
	 * A strategy for positioning overlays. Using this strategy, an overlay is given an
	 * implicit position relative some origin element. The relative position is defined in terms of
	 * a point on the origin element that is connected to a point on the overlay element. For example,
	 * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
	 * of the overlay.
	 */
	var ConnectedPositionStrategy = (function () {
	    function ConnectedPositionStrategy(_connectedTo, _originPos, _overlayPos, _viewportRuler) {
	        this._connectedTo = _connectedTo;
	        this._originPos = _originPos;
	        this._overlayPos = _overlayPos;
	        this._viewportRuler = _viewportRuler;
	        this._dir = 'ltr';
	        /** The offset in pixels for the overlay connection point on the x-axis */
	        this._offsetX = 0;
	        /** The offset in pixels for the overlay connection point on the y-axis */
	        this._offsetY = 0;
	        /** The Scrollable containers used to check scrollable view properties on position change. */
	        this.scrollables = [];
	        /** Ordered list of preferred positions, from most to least desirable. */
	        this._preferredPositions = [];
	        this._onPositionChange = new rxjs_Subject.Subject();
	        this._origin = this._connectedTo.nativeElement;
	        this.withFallbackPosition(_originPos, _overlayPos);
	    }
	    Object.defineProperty(ConnectedPositionStrategy.prototype, "_isRtl", {
	        /** Whether the we're dealing with an RTL context */
	        get: function () {
	            return this._dir === 'rtl';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedPositionStrategy.prototype, "onPositionChange", {
	        /** Emits an event when the connection point changes. */
	        get: function () {
	            return this._onPositionChange.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedPositionStrategy.prototype, "positions", {
	        /** Ordered list of preferred positions, from most to least desirable. */
	        get: function () {
	            return this._preferredPositions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * To be used to for any cleanup after the element gets destroyed.
	     */
	    ConnectedPositionStrategy.prototype.dispose = function () { };
	    /**
	     * Updates the position of the overlay element, using whichever preferred position relative
	     * to the origin fits on-screen.
	     * @docs-private
	     *
	     * @param element Element to which to apply the CSS styles.
	     * @returns Resolves when the styles have been applied.
	     */
	    ConnectedPositionStrategy.prototype.apply = function (element) {
	        // Cache the overlay pane element in case re-calculating position is necessary
	        this._pane = element;
	        // We need the bounding rects for the origin and the overlay to determine how to position
	        // the overlay relative to the origin.
	        var originRect = this._origin.getBoundingClientRect();
	        var overlayRect = element.getBoundingClientRect();
	        // We use the viewport rect to determine whether a position would go off-screen.
	        var viewportRect = this._viewportRuler.getViewportRect();
	        // Fallback point if none of the fallbacks fit into the viewport.
	        var fallbackPoint = null;
	        // We want to place the overlay in the first of the preferred positions such that the
	        // overlay fits on-screen.
	        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {
	            var pos = _a[_i];
	            // Get the (x, y) point of connection on the origin, and then use that to get the
	            // (top, left) coordinate for the overlay at `pos`.
	            var originPoint = this._getOriginConnectionPoint(originRect, pos);
	            var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);
	            // If the overlay in the calculated position fits on-screen, put it there and we're done.
	            if (overlayPoint.fitsInViewport) {
	                this._setElementPosition(element, overlayPoint);
	                // Save the last connected position in case the position needs to be re-calculated.
	                this._lastConnectedPosition = pos;
	                // Notify that the position has been changed along with its change properties.
	                var scrollableViewProperties = this.getScrollableViewProperties(element);
	                var positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);
	                this._onPositionChange.next(positionChange);
	                return Promise.resolve(null);
	            }
	            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {
	                fallbackPoint = overlayPoint;
	            }
	        }
	        // If none of the preferred positions were in the viewport, take the one
	        // with the largest visible area.
	        this._setElementPosition(element, fallbackPoint);
	        return Promise.resolve(null);
	    };
	    /**
	     * This re-aligns the overlay element with the trigger in its last calculated position,
	     * even if a position higher in the "preferred positions" list would now fit. This
	     * allows one to re-align the panel without changing the orientation of the panel.
	     */
	    ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {
	        var originRect = this._origin.getBoundingClientRect();
	        var overlayRect = this._pane.getBoundingClientRect();
	        var viewportRect = this._viewportRuler.getViewportRect();
	        var originPoint = this._getOriginConnectionPoint(originRect, this._lastConnectedPosition);
	        var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, this._lastConnectedPosition);
	        this._setElementPosition(this._pane, overlayPoint);
	    };
	    /**
	     * Sets the list of Scrollable containers that host the origin element so that
	     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
	     * Scrollable must be an ancestor element of the strategy's origin element.
	     */
	    ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {
	        this.scrollables = scrollables;
	    };
	    /**
	     * Adds a new preferred fallback position.
	     * @param originPos
	     * @param overlayPos
	     */
	    ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos) {
	        this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));
	        return this;
	    };
	    /**
	     * Sets the layout direction so the overlay's position can be adjusted to match.
	     * @param dir New layout direction.
	     */
	    ConnectedPositionStrategy.prototype.withDirection = function (dir) {
	        this._dir = dir;
	        return this;
	    };
	    /**
	     * Sets an offset for the overlay's connection point on the x-axis
	     * @param offset New offset in the X axis.
	     */
	    ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {
	        this._offsetX = offset;
	        return this;
	    };
	    /**
	     * Sets an offset for the overlay's connection point on the y-axis
	     * @param  offset New offset in the Y axis.
	     */
	    ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {
	        this._offsetY = offset;
	        return this;
	    };
	    /**
	     * Gets the horizontal (x) "start" dimension based on whether the overlay is in an RTL context.
	     * @param rect
	     */
	    ConnectedPositionStrategy.prototype._getStartX = function (rect) {
	        return this._isRtl ? rect.right : rect.left;
	    };
	    /**
	     * Gets the horizontal (x) "end" dimension based on whether the overlay is in an RTL context.
	     * @param rect
	     */
	    ConnectedPositionStrategy.prototype._getEndX = function (rect) {
	        return this._isRtl ? rect.left : rect.right;
	    };
	    /**
	     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
	     * @param originRect
	     * @param pos
	     */
	    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = function (originRect, pos) {
	        var originStartX = this._getStartX(originRect);
	        var originEndX = this._getEndX(originRect);
	        var x;
	        if (pos.originX == 'center') {
	            x = originStartX + (originRect.width / 2);
	        }
	        else {
	            x = pos.originX == 'start' ? originStartX : originEndX;
	        }
	        var y;
	        if (pos.originY == 'center') {
	            y = originRect.top + (originRect.height / 2);
	        }
	        else {
	            y = pos.originY == 'top' ? originRect.top : originRect.bottom;
	        }
	        return { x: x, y: y };
	    };
	    /**
	     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
	     * origin point to which the overlay should be connected, as well as how much of the element
	     * would be inside the viewport at that position.
	     */
	    ConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, viewportRect, pos) {
	        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position
	        // relative to the origin point.
	        var overlayStartX;
	        if (pos.overlayX == 'center') {
	            overlayStartX = -overlayRect.width / 2;
	        }
	        else if (pos.overlayX === 'start') {
	            overlayStartX = this._isRtl ? -overlayRect.width : 0;
	        }
	        else {
	            overlayStartX = this._isRtl ? 0 : -overlayRect.width;
	        }
	        var overlayStartY;
	        if (pos.overlayY == 'center') {
	            overlayStartY = -overlayRect.height / 2;
	        }
	        else {
	            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
	        }
	        // The (x, y) coordinates of the overlay.
	        var x = originPoint.x + overlayStartX + this._offsetX;
	        var y = originPoint.y + overlayStartY + this._offsetY;
	        // How much the overlay would overflow at this position, on each side.
	        var leftOverflow = 0 - x;
	        var rightOverflow = (x + overlayRect.width) - viewportRect.width;
	        var topOverflow = 0 - y;
	        var bottomOverflow = (y + overlayRect.height) - viewportRect.height;
	        // Visible parts of the element on each axis.
	        var visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);
	        var visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);
	        // The area of the element that's within the viewport.
	        var visibleArea = visibleWidth * visibleHeight;
	        var fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;
	        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };
	    };
	    /**
	     * Gets the view properties of the trigger and overlay, including whether they are clipped
	     * or completely outside the view of any of the strategy's scrollables.
	     */
	    ConnectedPositionStrategy.prototype.getScrollableViewProperties = function (overlay) {
	        var _this = this;
	        var originBounds = this._getElementBounds(this._origin);
	        var overlayBounds = this._getElementBounds(overlay);
	        var scrollContainerBounds = this.scrollables.map(function (scrollable) {
	            return _this._getElementBounds(scrollable.getElementRef().nativeElement);
	        });
	        return {
	            isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),
	            isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),
	            isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),
	            isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),
	        };
	    };
	    /** Whether the element is completely out of the view of any of the containers. */
	    ConnectedPositionStrategy.prototype.isElementOutsideView = function (elementBounds, containersBounds) {
	        return containersBounds.some(function (containerBounds) {
	            var outsideAbove = elementBounds.bottom < containerBounds.top;
	            var outsideBelow = elementBounds.top > containerBounds.bottom;
	            var outsideLeft = elementBounds.right < containerBounds.left;
	            var outsideRight = elementBounds.left > containerBounds.right;
	            return outsideAbove || outsideBelow || outsideLeft || outsideRight;
	        });
	    };
	    /** Whether the element is clipped by any of the containers. */
	    ConnectedPositionStrategy.prototype.isElementClipped = function (elementBounds, containersBounds) {
	        return containersBounds.some(function (containerBounds) {
	            var clippedAbove = elementBounds.top < containerBounds.top;
	            var clippedBelow = elementBounds.bottom > containerBounds.bottom;
	            var clippedLeft = elementBounds.left < containerBounds.left;
	            var clippedRight = elementBounds.right > containerBounds.right;
	            return clippedAbove || clippedBelow || clippedLeft || clippedRight;
	        });
	    };
	    /**
	     * Physically positions the overlay element to the given coordinate.
	     * @param element
	     * @param overlayPoint
	     */
	    ConnectedPositionStrategy.prototype._setElementPosition = function (element, overlayPoint) {
	        element.style.left = overlayPoint.x + 'px';
	        element.style.top = overlayPoint.y + 'px';
	    };
	    /** Returns the bounding positions of the provided element with respect to the viewport. */
	    ConnectedPositionStrategy.prototype._getElementBounds = function (element) {
	        var boundingClientRect = element.getBoundingClientRect();
	        return {
	            top: boundingClientRect.top,
	            right: boundingClientRect.left + boundingClientRect.width,
	            bottom: boundingClientRect.top + boundingClientRect.height,
	            left: boundingClientRect.left
	        };
	    };
	    /**
	     * Subtracts the amount that an element is overflowing on an axis from it's length.
	     */
	    ConnectedPositionStrategy.prototype._subtractOverflows = function (length) {
	        var overflows = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            overflows[_i - 1] = arguments[_i];
	        }
	        return overflows.reduce(function (currentValue, currentOverflow) {
	            return currentValue - Math.max(currentOverflow, 0);
	        }, length);
	    };
	    return ConnectedPositionStrategy;
	}());
	
	/**
	 * A strategy for positioning overlays. Using this strategy, an overlay is given an
	 * explicit position relative to the browser's viewport. We use flexbox, instead of
	 * transforms, in order to avoid issues with subpixel rendering which can cause the
	 * element to become blurry.
	 */
	var GlobalPositionStrategy = (function () {
	    function GlobalPositionStrategy() {
	        this._cssPosition = 'static';
	        this._topOffset = '';
	        this._bottomOffset = '';
	        this._leftOffset = '';
	        this._rightOffset = '';
	        this._alignItems = '';
	        this._justifyContent = '';
	        this._width = '';
	        this._height = '';
	    }
	    /**
	     * Sets the top position of the overlay. Clears any previously set vertical position.
	     * @param value New top offset.
	     */
	    GlobalPositionStrategy.prototype.top = function (value) {
	        this._bottomOffset = '';
	        this._topOffset = value;
	        this._alignItems = 'flex-start';
	        return this;
	    };
	    /**
	     * Sets the left position of the overlay. Clears any previously set horizontal position.
	     * @param value New left offset.
	     */
	    GlobalPositionStrategy.prototype.left = function (value) {
	        this._rightOffset = '';
	        this._leftOffset = value;
	        this._justifyContent = 'flex-start';
	        return this;
	    };
	    /**
	     * Sets the bottom position of the overlay. Clears any previously set vertical position.
	     * @param value New bottom offset.
	     */
	    GlobalPositionStrategy.prototype.bottom = function (value) {
	        this._topOffset = '';
	        this._bottomOffset = value;
	        this._alignItems = 'flex-end';
	        return this;
	    };
	    /**
	     * Sets the right position of the overlay. Clears any previously set horizontal position.
	     * @param value New right offset.
	     */
	    GlobalPositionStrategy.prototype.right = function (value) {
	        this._leftOffset = '';
	        this._rightOffset = value;
	        this._justifyContent = 'flex-end';
	        return this;
	    };
	    /**
	     * Sets the overlay width and clears any previously set width.
	     * @param value New width for the overlay
	     */
	    GlobalPositionStrategy.prototype.width = function (value) {
	        this._width = value;
	        // When the width is 100%, we should reset the `left` and the offset,
	        // in order to ensure that the element is flush against the viewport edge.
	        if (value === '100%') {
	            this.left('0px');
	        }
	        return this;
	    };
	    /**
	     * Sets the overlay height and clears any previously set height.
	     * @param value New height for the overlay
	     */
	    GlobalPositionStrategy.prototype.height = function (value) {
	        this._height = value;
	        // When the height is 100%, we should reset the `top` and the offset,
	        // in order to ensure that the element is flush against the viewport edge.
	        if (value === '100%') {
	            this.top('0px');
	        }
	        return this;
	    };
	    /**
	     * Centers the overlay horizontally with an optional offset.
	     * Clears any previously set horizontal position.
	     *
	     * @param offset Overlay offset from the horizontal center.
	     */
	    GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {
	        if (offset === void 0) { offset = ''; }
	        this.left(offset);
	        this._justifyContent = 'center';
	        return this;
	    };
	    /**
	     * Centers the overlay vertically with an optional offset.
	     * Clears any previously set vertical position.
	     *
	     * @param offset Overlay offset from the vertical center.
	     */
	    GlobalPositionStrategy.prototype.centerVertically = function (offset) {
	        if (offset === void 0) { offset = ''; }
	        this.top(offset);
	        this._alignItems = 'center';
	        return this;
	    };
	    /**
	     * Apply the position to the element.
	     * @docs-private
	     *
	     * @param element Element to which to apply the CSS.
	     * @returns Resolved when the styles have been applied.
	     */
	    GlobalPositionStrategy.prototype.apply = function (element) {
	        if (!this._wrapper) {
	            this._wrapper = document.createElement('div');
	            this._wrapper.classList.add('cdk-global-overlay-wrapper');
	            element.parentNode.insertBefore(this._wrapper, element);
	            this._wrapper.appendChild(element);
	        }
	        var styles = element.style;
	        var parentStyles = element.parentNode.style;
	        styles.position = this._cssPosition;
	        styles.marginTop = this._topOffset;
	        styles.marginLeft = this._leftOffset;
	        styles.marginBottom = this._bottomOffset;
	        styles.marginRight = this._rightOffset;
	        styles.width = this._width;
	        styles.height = this._height;
	        parentStyles.justifyContent = this._justifyContent;
	        parentStyles.alignItems = this._alignItems;
	        return Promise.resolve(null);
	    };
	    /**
	     * Removes the wrapper element from the DOM.
	     */
	    GlobalPositionStrategy.prototype.dispose = function () {
	        if (this._wrapper && this._wrapper.parentNode) {
	            this._wrapper.parentNode.removeChild(this._wrapper);
	            this._wrapper = null;
	        }
	    };
	    return GlobalPositionStrategy;
	}());
	
	var __decorate$12 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$12 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Builder for overlay position strategy. */
	var OverlayPositionBuilder = (function () {
	    function OverlayPositionBuilder(_viewportRuler) {
	        this._viewportRuler = _viewportRuler;
	    }
	    /**
	     * Creates a global position strategy.
	     */
	    OverlayPositionBuilder.prototype.global = function () {
	        return new GlobalPositionStrategy();
	    };
	    /**
	     * Creates a relative position strategy.
	     * @param elementRef
	     * @param originPos
	     * @param overlayPos
	     */
	    OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {
	        return new ConnectedPositionStrategy(elementRef, originPos, overlayPos, this._viewportRuler);
	    };
	    OverlayPositionBuilder = __decorate$12([
	        _angular_core.Injectable(), 
	        __metadata$12('design:paramtypes', [ViewportRuler])
	    ], OverlayPositionBuilder);
	    return OverlayPositionBuilder;
	}());
	
	var __decorate$14 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$14 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * The OverlayContainer is the container in which all overlays will load.
	 * It should be provided in the root component to ensure it is properly shared.
	 */
	var OverlayContainer = (function () {
	    function OverlayContainer() {
	    }
	    /**
	     * This method returns the overlay container element.  It will lazily
	     * create the element the first time  it is called to facilitate using
	     * the container in non-browser environments.
	     * @returns the container element
	     */
	    OverlayContainer.prototype.getContainerElement = function () {
	        if (!this._containerElement) {
	            this._createContainer();
	        }
	        return this._containerElement;
	    };
	    /**
	     * Create the overlay container element, which is simply a div
	     * with the 'cdk-overlay-container' class on the document body.
	     */
	    OverlayContainer.prototype._createContainer = function () {
	        var container = document.createElement('div');
	        container.classList.add('cdk-overlay-container');
	        document.body.appendChild(container);
	        this._containerElement = container;
	    };
	    OverlayContainer = __decorate$14([
	        _angular_core.Injectable(), 
	        __metadata$14('design:paramtypes', [])
	    ], OverlayContainer);
	    return OverlayContainer;
	}());
	function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {
	    return parentContainer || new OverlayContainer();
	}
	
	var OVERLAY_CONTAINER_PROVIDER = {
	    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
	    provide: OverlayContainer,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), OverlayContainer]],
	    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY
	};
	
	var __decorate$11 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$11 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Next overlay unique ID. */
	var nextUniqueId = 0;
	/** The default state for newly created overlays. */
	var defaultState = new OverlayState();
	/**
	 * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
	 * used as a low-level building building block for other components. Dialogs, tooltips, menus,
	 * selects, etc. can all be built using overlays. The service should primarily be used by authors
	 * of re-usable components rather than developers building end-user applications.
	 *
	 * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.
	 */
	var Overlay = (function () {
	    function Overlay(_overlayContainer, _componentFactoryResolver, _positionBuilder, _appRef, _injector, _ngZone) {
	        this._overlayContainer = _overlayContainer;
	        this._componentFactoryResolver = _componentFactoryResolver;
	        this._positionBuilder = _positionBuilder;
	        this._appRef = _appRef;
	        this._injector = _injector;
	        this._ngZone = _ngZone;
	    }
	    /**
	     * Creates an overlay.
	     * @param state State to apply to the overlay.
	     * @returns Reference to the created overlay.
	     */
	    Overlay.prototype.create = function (state$$1) {
	        if (state$$1 === void 0) { state$$1 = defaultState; }
	        return this._createOverlayRef(this._createPaneElement(), state$$1);
	    };
	    /**
	     * Returns a position builder that can be used, via fluent API,
	     * to construct and configure a position strategy.
	     */
	    Overlay.prototype.position = function () {
	        return this._positionBuilder;
	    };
	    /**
	     * Creates the DOM element for an overlay and appends it to the overlay container.
	     * @returns Newly-created pane element
	     */
	    Overlay.prototype._createPaneElement = function () {
	        var pane = document.createElement('div');
	        pane.id = "cdk-overlay-" + nextUniqueId++;
	        pane.classList.add('cdk-overlay-pane');
	        this._overlayContainer.getContainerElement().appendChild(pane);
	        return pane;
	    };
	    /**
	     * Create a DomPortalHost into which the overlay content can be loaded.
	     * @param pane The DOM element to turn into a portal host.
	     * @returns A portal host for the given DOM element.
	     */
	    Overlay.prototype._createPortalHost = function (pane) {
	        return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef, this._injector);
	    };
	    /**
	     * Creates an OverlayRef for an overlay in the given DOM element.
	     * @param pane DOM element for the overlay
	     * @param state
	     */
	    Overlay.prototype._createOverlayRef = function (pane, state$$1) {
	        return new OverlayRef(this._createPortalHost(pane), pane, state$$1, this._ngZone);
	    };
	    Overlay = __decorate$11([
	        _angular_core.Injectable(), 
	        __metadata$11('design:paramtypes', [OverlayContainer, _angular_core.ComponentFactoryResolver, OverlayPositionBuilder, _angular_core.ApplicationRef, _angular_core.Injector, _angular_core.NgZone])
	    ], Overlay);
	    return Overlay;
	}());
	/** Providers for Overlay and its related injectables. */
	var OVERLAY_PROVIDERS = [
	    Overlay,
	    OverlayPositionBuilder,
	    VIEWPORT_RULER_PROVIDER,
	    SCROLL_DISPATCHER_PROVIDER,
	    OVERLAY_CONTAINER_PROVIDER,
	];
	
	var __decorate$15 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$15 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Sends an event when the directive's element is scrolled. Registers itself with the
	 * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
	 * can be listened to through the service.
	 */
	var Scrollable = (function () {
	    function Scrollable(_elementRef, _scroll) {
	        this._elementRef = _elementRef;
	        this._scroll = _scroll;
	    }
	    Scrollable.prototype.ngOnInit = function () {
	        this._scroll.register(this);
	    };
	    Scrollable.prototype.ngOnDestroy = function () {
	        this._scroll.deregister(this);
	    };
	    /**
	     * Returns observable that emits when a scroll event is fired on the host element.
	     */
	    Scrollable.prototype.elementScrolled = function () {
	        return rxjs_Observable.Observable.fromEvent(this._elementRef.nativeElement, 'scroll');
	    };
	    Scrollable.prototype.getElementRef = function () {
	        return this._elementRef;
	    };
	    Scrollable = __decorate$15([
	        _angular_core.Directive({
	            selector: '[cdk-scrollable]'
	        }), 
	        __metadata$15('design:paramtypes', [_angular_core.ElementRef, ScrollDispatcher])
	    ], Scrollable);
	    return Scrollable;
	}());
	
	var __decorate$10 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$10 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** Default set of positions for the overlay. Follows the behavior of a dropdown. */
	var defaultPositionList = [
	    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
	    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
	];
	/**
	 * Directive applied to an element to make it usable as an origin for an Overlay using a
	 * ConnectedPositionStrategy.
	 */
	var OverlayOrigin = (function () {
	    function OverlayOrigin(elementRef) {
	        this.elementRef = elementRef;
	    }
	    OverlayOrigin = __decorate$10([
	        _angular_core.Directive({
	            selector: '[cdk-overlay-origin], [overlay-origin]',
	            exportAs: 'cdkOverlayOrigin',
	        }), 
	        __metadata$10('design:paramtypes', [_angular_core.ElementRef])
	    ], OverlayOrigin);
	    return OverlayOrigin;
	}());
	/**
	 * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.
	 */
	var ConnectedOverlayDirective = (function () {
	    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
	    function ConnectedOverlayDirective(_overlay, templateRef, viewContainerRef, _dir) {
	        this._overlay = _overlay;
	        this._dir = _dir;
	        this._open = false;
	        this._hasBackdrop = false;
	        this._offsetX = 0;
	        this._offsetY = 0;
	        /** Event emitted when the backdrop is clicked. */
	        this.backdropClick = new _angular_core.EventEmitter();
	        /** Event emitted when the position has changed. */
	        this.positionChange = new _angular_core.EventEmitter();
	        /** Event emitted when the overlay has been attached. */
	        this.attach = new _angular_core.EventEmitter();
	        /** Event emitted when the overlay has been detached. */
	        this.detach = new _angular_core.EventEmitter();
	        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
	    }
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetX", {
	        /** The offset in pixels for the overlay connection point on the x-axis */
	        get: function () {
	            return this._offsetX;
	        },
	        set: function (offsetX) {
	            this._offsetX = offsetX;
	            if (this._position) {
	                this._position.withOffsetX(offsetX);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetY", {
	        /** The offset in pixels for the overlay connection point on the y-axis */
	        get: function () {
	            return this._offsetY;
	        },
	        set: function (offsetY) {
	            this._offsetY = offsetY;
	            if (this._position) {
	                this._position.withOffsetY(offsetY);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "hasBackdrop", {
	        /** Whether or not the overlay should attach a backdrop. */
	        get: function () {
	            return this._hasBackdrop;
	        },
	        set: function (value) {
	            this._hasBackdrop = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "open", {
	        get: function () {
	            return this._open;
	        },
	        set: function (value) {
	            value ? this._attachOverlay() : this._detachOverlay();
	            this._open = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "overlayRef", {
	        /** The associated overlay reference. */
	        get: function () {
	            return this._overlayRef;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "dir", {
	        /** The element's layout direction. */
	        get: function () {
	            return this._dir ? this._dir.value : 'ltr';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {
	        this._destroyOverlay();
	    };
	    /** Creates an overlay */
	    ConnectedOverlayDirective.prototype._createOverlay = function () {
	        if (!this.positions || !this.positions.length) {
	            this.positions = defaultPositionList;
	        }
	        this._overlayRef = this._overlay.create(this._buildConfig());
	    };
	    /** Builds the overlay config based on the directive's inputs */
	    ConnectedOverlayDirective.prototype._buildConfig = function () {
	        var overlayConfig = new OverlayState();
	        if (this.width || this.width === 0) {
	            overlayConfig.width = this.width;
	        }
	        if (this.height || this.height === 0) {
	            overlayConfig.height = this.height;
	        }
	        if (this.minWidth || this.minWidth === 0) {
	            overlayConfig.minWidth = this.minWidth;
	        }
	        if (this.minHeight || this.minHeight === 0) {
	            overlayConfig.minHeight = this.minHeight;
	        }
	        overlayConfig.hasBackdrop = this.hasBackdrop;
	        if (this.backdropClass) {
	            overlayConfig.backdropClass = this.backdropClass;
	        }
	        this._position = this._createPositionStrategy();
	        overlayConfig.positionStrategy = this._position;
	        overlayConfig.direction = this.dir;
	        return overlayConfig;
	    };
	    /** Returns the position strategy of the overlay to be set on the overlay config */
	    ConnectedOverlayDirective.prototype._createPositionStrategy = function () {
	        var pos = this.positions[0];
	        var originPoint = { originX: pos.originX, originY: pos.originY };
	        var overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };
	        var strategy = this._overlay.position()
	            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)
	            .withDirection(this.dir)
	            .withOffsetX(this.offsetX)
	            .withOffsetY(this.offsetY);
	        this._handlePositionChanges(strategy);
	        return strategy;
	    };
	    ConnectedOverlayDirective.prototype._handlePositionChanges = function (strategy) {
	        var _this = this;
	        for (var i = 1; i < this.positions.length; i++) {
	            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });
	        }
	        this._positionSubscription =
	            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });
	    };
	    /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
	    ConnectedOverlayDirective.prototype._attachOverlay = function () {
	        var _this = this;
	        if (!this._overlayRef) {
	            this._createOverlay();
	        }
	        if (!this._overlayRef.hasAttached()) {
	            this._overlayRef.attach(this._templatePortal);
	            this.attach.emit();
	        }
	        if (this.hasBackdrop) {
	            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
	                _this.backdropClick.emit();
	            });
	        }
	    };
	    /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
	    ConnectedOverlayDirective.prototype._detachOverlay = function () {
	        if (this._overlayRef) {
	            this._overlayRef.detach();
	            this.detach.emit();
	        }
	        if (this._backdropSubscription) {
	            this._backdropSubscription.unsubscribe();
	            this._backdropSubscription = null;
	        }
	    };
	    /** Destroys the overlay created by this directive. */
	    ConnectedOverlayDirective.prototype._destroyOverlay = function () {
	        if (this._overlayRef) {
	            this._overlayRef.dispose();
	        }
	        if (this._backdropSubscription) {
	            this._backdropSubscription.unsubscribe();
	        }
	        if (this._positionSubscription) {
	            this._positionSubscription.unsubscribe();
	        }
	    };
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', OverlayOrigin)
	    ], ConnectedOverlayDirective.prototype, "origin", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Array)
	    ], ConnectedOverlayDirective.prototype, "positions", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Number)
	    ], ConnectedOverlayDirective.prototype, "offsetX", null);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "offsetY", null);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "width", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "height", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "minWidth", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "minHeight", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', String)
	    ], ConnectedOverlayDirective.prototype, "backdropClass", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "hasBackdrop", null);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "open", null);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "backdropClick", void 0);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "positionChange", void 0);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "attach", void 0);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "detach", void 0);
	    ConnectedOverlayDirective = __decorate$10([
	        _angular_core.Directive({
	            selector: '[cdk-connected-overlay], [connected-overlay]',
	            exportAs: 'cdkConnectedOverlay'
	        }),
	        __param$1(3, _angular_core.Optional()), 
	        __metadata$10('design:paramtypes', [Overlay, _angular_core.TemplateRef, _angular_core.ViewContainerRef, Dir])
	    ], ConnectedOverlayDirective);
	    return ConnectedOverlayDirective;
	}());
	var OverlayModule = (function () {
	    function OverlayModule() {
	    }
	    /** @deprecated */
	    OverlayModule.forRoot = function () {
	        return {
	            ngModule: OverlayModule,
	            providers: [],
	        };
	    };
	    OverlayModule = __decorate$10([
	        _angular_core.NgModule({
	            imports: [PortalModule],
	            exports: [ConnectedOverlayDirective, OverlayOrigin, Scrollable],
	            declarations: [ConnectedOverlayDirective, OverlayOrigin, Scrollable],
	            providers: [OVERLAY_PROVIDERS],
	        }), 
	        __metadata$10('design:paramtypes', [])
	    ], OverlayModule);
	    return OverlayModule;
	}());
	
	var __decorate$19 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$19 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Whether the current platform supports the V8 Break Iterator. The V8 check
	// is necessary to detect all Blink based browsers.
	var hasV8BreakIterator = typeof (window) !== 'undefined' ?
	    (window.Intl && window.Intl.v8BreakIterator) :
	    (typeof (Intl) !== 'undefined' && Intl.v8BreakIterator);
	/**
	 * Service to detect the current platform by comparing the userAgent strings and
	 * checking browser-specific global properties.
	 * @docs-private
	 */
	var Platform = (function () {
	    function Platform() {
	        /** Layout Engines */
	        this.EDGE = /(edge)/i.test(navigator.userAgent);
	        this.TRIDENT = /(msie|trident)/i.test(navigator.userAgent);
	        // EdgeHTML and Trident mock Blink specific things and need to excluded from this check.
	        this.BLINK = !!(window.chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT;
	        // Webkit is part of the userAgent in EdgeHTML Blink and Trident, so we need to
	        // ensure that Webkit runs standalone and is not use as another engines base.
	        this.WEBKIT = /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
	        /** Browsers and Platform Types */
	        this.IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
	        // It's difficult to detect the plain Gecko engine, because most of the browsers identify
	        // them self as Gecko-like browsers and modify the userAgent's according to that.
	        // Since we only cover one explicit Firefox case, we can simply check for Firefox
	        // instead of having an unstable check for Gecko.
	        this.FIREFOX = /(firefox|minefield)/i.test(navigator.userAgent);
	        // Trident on mobile adds the android platform to the userAgent to trick detections.
	        this.ANDROID = /android/i.test(navigator.userAgent) && !this.TRIDENT;
	    }
	    Platform = __decorate$19([
	        _angular_core.Injectable(), 
	        __metadata$19('design:paramtypes', [])
	    ], Platform);
	    return Platform;
	}());
	
	var __decorate$18 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$18 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * The InteractivityChecker leans heavily on the ally.js accessibility utilities.
	 * Methods like `isTabbable` are only covering specific edge-cases for the browsers which are
	 * supported.
	 */
	/**
	 * Utility for checking the interactivity of an element, such as whether is is focusable or
	 * tabbable.
	 */
	var InteractivityChecker = (function () {
	    function InteractivityChecker(_platform) {
	        this._platform = _platform;
	    }
	    /**
	     * Gets whether an element is disabled.
	     *
	     * @param element Element to be checked.
	     * @returns Whether the element is disabled.
	     */
	    InteractivityChecker.prototype.isDisabled = function (element) {
	        // This does not capture some cases, such as a non-form control with a disabled attribute or
	        // a form control inside of a disabled form, but should capture the most common cases.
	        return element.hasAttribute('disabled');
	    };
	    /**
	     * Gets whether an element is visible for the purposes of interactivity.
	     *
	     * This will capture states like `display: none` and `visibility: hidden`, but not things like
	     * being clipped by an `overflow: hidden` parent or being outside the viewport.
	     *
	     * @returns Whether the element is visible.
	     */
	    InteractivityChecker.prototype.isVisible = function (element) {
	        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';
	    };
	    /**
	     * Gets whether an element can be reached via Tab key.
	     * Assumes that the element has already been checked with isFocusable.
	     *
	     * @param element Element to be checked.
	     * @returns Whether the element is tabbable.
	     */
	    InteractivityChecker.prototype.isTabbable = function (element) {
	        var frameElement = getWindow(element).frameElement;
	        if (frameElement) {
	            var frameType = frameElement && frameElement.nodeName.toLowerCase();
	            // Frame elements inherit their tabindex onto all child elements.
	            if (getTabIndexValue(frameElement) === -1) {
	                return false;
	            }
	            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.
	            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {
	                return false;
	            }
	            // Webkit and Blink disable tabbing to an element inside of an invisible frame.
	            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {
	                return false;
	            }
	        }
	        var nodeName = element.nodeName.toLowerCase();
	        var tabIndexValue = getTabIndexValue(element);
	        if (element.hasAttribute('contenteditable')) {
	            return tabIndexValue !== -1;
	        }
	        if (nodeName === 'iframe') {
	            // The frames may be tabbable depending on content, but it's not possibly to reliably
	            // investigate the content of the frames.
	            return false;
	        }
	        if (nodeName === 'audio') {
	            if (!element.hasAttribute('controls')) {
	                // By default an <audio> element without the controls enabled is not tabbable.
	                return false;
	            }
	            else if (this._platform.BLINK) {
	                // In Blink <audio controls> elements are always tabbable.
	                return true;
	            }
	        }
	        if (nodeName === 'video') {
	            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {
	                // In Trident a <video> element without the controls enabled is not tabbable.
	                return false;
	            }
	            else if (this._platform.BLINK || this._platform.FIREFOX) {
	                // In Chrome and Firefox <video controls> elements are always tabbable.
	                return true;
	            }
	        }
	        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {
	            // In all Blink and WebKit based browsers <object> elements are never tabbable.
	            return false;
	        }
	        // In iOS the browser only considers some specific elements as tabbable.
	        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
	            return false;
	        }
	        return element.tabIndex >= 0;
	    };
	    /**
	     * Gets whether an element can be focused by the user.
	     *
	     * @param element Element to be checked.
	     * @returns Whether the element is focusable.
	     */
	    InteractivityChecker.prototype.isFocusable = function (element) {
	        // Perform checks in order of left to most expensive.
	        // Again, naive approach that does not capture many edge cases and browser quirks.
	        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);
	    };
	    InteractivityChecker = __decorate$18([
	        _angular_core.Injectable(), 
	        __metadata$18('design:paramtypes', [Platform])
	    ], InteractivityChecker);
	    return InteractivityChecker;
	}());
	/** Checks whether the specified element has any geometry / rectangles. */
	function hasGeometry(element) {
	    // Use logic from jQuery to check for an invisible element.
	    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12
	    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
	}
	/** Gets whether an element's  */
	function isNativeFormElement(element) {
	    var nodeName = element.nodeName.toLowerCase();
	    return nodeName === 'input' ||
	        nodeName === 'select' ||
	        nodeName === 'button' ||
	        nodeName === 'textarea';
	}
	/** Gets whether an element is an <input type="hidden">. */
	function isHiddenInput(element) {
	    return isInputElement(element) && element.type == 'hidden';
	}
	/** Gets whether an element is an anchor that has an href attribute. */
	function isAnchorWithHref(element) {
	    return isAnchorElement(element) && element.hasAttribute('href');
	}
	/** Gets whether an element is an input element. */
	function isInputElement(element) {
	    return element.nodeName == 'input';
	}
	/** Gets whether an element is an anchor element. */
	function isAnchorElement(element) {
	    return element.nodeName.toLowerCase() == 'a';
	}
	/** Gets whether an element has a valid tabindex. */
	function hasValidTabIndex(element) {
	    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {
	        return false;
	    }
	    var tabIndex = element.getAttribute('tabindex');
	    // IE11 parses tabindex="" as the value "-32768"
	    if (tabIndex == '-32768') {
	        return false;
	    }
	    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
	}
	/**
	 * Returns the parsed tabindex from the element attributes instead of returning the
	 * evaluated tabindex from the browsers defaults.
	 */
	function getTabIndexValue(element) {
	    if (!hasValidTabIndex(element)) {
	        return null;
	    }
	    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
	    var tabIndex = parseInt(element.getAttribute('tabindex'), 10);
	    return isNaN(tabIndex) ? -1 : tabIndex;
	}
	/** Checks whether the specified element is potentially tabbable on iOS */
	function isPotentiallyTabbableIOS(element) {
	    var nodeName = element.nodeName.toLowerCase();
	    var inputType = nodeName === 'input' && element.type;
	    return inputType === 'text'
	        || inputType === 'password'
	        || nodeName === 'select'
	        || nodeName === 'textarea';
	}
	/**
	 * Gets whether an element is potentially focusable without taking current visible/disabled state
	 * into account.
	 */
	function isPotentiallyFocusable(element) {
	    // Inputs are potentially focusable *unless* they're type="hidden".
	    if (isHiddenInput(element)) {
	        return false;
	    }
	    return isNativeFormElement(element) ||
	        isAnchorWithHref(element) ||
	        element.hasAttribute('contenteditable') ||
	        hasValidTabIndex(element);
	}
	/** Gets the parent window of a DOM node with regards of being inside of an iframe. */
	function getWindow(node) {
	    return node.ownerDocument.defaultView || window;
	}
	
	var __decorate$17 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$17 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive for trapping focus within a region.
	 *
	 * NOTE: This directive currently uses a very simple (naive) approach to focus trapping.
	 * It assumes that the tab order is the same as DOM order, which is not necessarily true.
	 * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.
	 * This will be replaced with a more intelligent solution before the library is considered stable.
	 */
	var FocusTrap = (function () {
	    function FocusTrap(_checker, _ngZone) {
	        this._checker = _checker;
	        this._ngZone = _ngZone;
	        this._disabled = false;
	    }
	    Object.defineProperty(FocusTrap.prototype, "disabled", {
	        /** Whether the focus trap is active. */
	        get: function () { return this._disabled; },
	        set: function (val) { this._disabled = coerceBooleanProperty(val); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Waits for microtask queue to empty, then focuses the first tabbable element within the focus
	     * trap region.
	     */
	    FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {
	        var _this = this;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this.focusFirstTabbableElement();
	        });
	    };
	    /**
	     * Waits for microtask queue to empty, then focuses the last tabbable element within the focus
	     * trap region.
	     */
	    FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {
	        var _this = this;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this.focusLastTabbableElement();
	        });
	    };
	    /**
	     * Focuses the first tabbable element within the focus trap region.
	     */
	    FocusTrap.prototype.focusFirstTabbableElement = function () {
	        var rootElement = this.trappedContent.nativeElement;
	        var redirectToElement = rootElement.querySelector('[cdk-focus-start]') ||
	            this._getFirstTabbableElement(rootElement);
	        if (redirectToElement) {
	            redirectToElement.focus();
	        }
	    };
	    /**
	     * Focuses the last tabbable element within the focus trap region.
	     */
	    FocusTrap.prototype.focusLastTabbableElement = function () {
	        var rootElement = this.trappedContent.nativeElement;
	        var focusTargets = rootElement.querySelectorAll('[cdk-focus-end]');
	        var redirectToElement = null;
	        if (focusTargets.length) {
	            redirectToElement = focusTargets[focusTargets.length - 1];
	        }
	        else {
	            redirectToElement = this._getLastTabbableElement(rootElement);
	        }
	        if (redirectToElement) {
	            redirectToElement.focus();
	        }
	    };
	    /** Get the first tabbable element from a DOM subtree (inclusive). */
	    FocusTrap.prototype._getFirstTabbableElement = function (root) {
	        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
	            return root;
	        }
	        // Iterate in DOM order.
	        var childCount = root.children.length;
	        for (var i = 0; i < childCount; i++) {
	            var tabbableChild = this._getFirstTabbableElement(root.children[i]);
	            if (tabbableChild) {
	                return tabbableChild;
	            }
	        }
	        return null;
	    };
	    /** Get the last tabbable element from a DOM subtree (inclusive). */
	    FocusTrap.prototype._getLastTabbableElement = function (root) {
	        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
	            return root;
	        }
	        // Iterate in reverse DOM order.
	        for (var i = root.children.length - 1; i >= 0; i--) {
	            var tabbableChild = this._getLastTabbableElement(root.children[i]);
	            if (tabbableChild) {
	                return tabbableChild;
	            }
	        }
	        return null;
	    };
	    __decorate$17([
	        _angular_core.ViewChild('trappedContent'), 
	        __metadata$17('design:type', _angular_core.ElementRef)
	    ], FocusTrap.prototype, "trappedContent", void 0);
	    __decorate$17([
	        _angular_core.Input(), 
	        __metadata$17('design:type', Boolean)
	    ], FocusTrap.prototype, "disabled", null);
	    FocusTrap = __decorate$17([
	        _angular_core.Component({selector: 'cdk-focus-trap, focus-trap',
	            template: "<div *ngIf=\"!disabled\" tabindex=\"0\" (focus)=\"focusLastTabbableElement()\"></div><div #trappedContent class=\"cdk-focus-trap-content\"><ng-content></ng-content></div><div *ngIf=\"!disabled\" tabindex=\"0\" (focus)=\"focusFirstTabbableElement()\"></div>",
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$17('design:paramtypes', [InteractivityChecker, _angular_core.NgZone])
	    ], FocusTrap);
	    return FocusTrap;
	}());
	
	var __decorate$20 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$20 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$3 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var LIVE_ANNOUNCER_ELEMENT_TOKEN = new _angular_core.OpaqueToken('liveAnnouncerElement');
	var LiveAnnouncer = (function () {
	    function LiveAnnouncer(elementToken) {
	        // We inject the live element as `any` because the constructor signature cannot reference
	        // browser globals (HTMLElement) on non-browser environments, since having a class decorator
	        // causes TypeScript to preserve the constructor signature types.
	        this._liveElement = elementToken || this._createLiveElement();
	    }
	    /**
	     * Announces a message to screenreaders.
	     * @param message Message to be announced to the screenreader
	     * @param politeness The politeness of the announcer element
	     */
	    LiveAnnouncer.prototype.announce = function (message, politeness) {
	        var _this = this;
	        if (politeness === void 0) { politeness = 'polite'; }
	        this._liveElement.textContent = '';
	        // TODO: ensure changing the politeness works on all environments we support.
	        this._liveElement.setAttribute('aria-live', politeness);
	        // This 100ms timeout is necessary for some browser + screen-reader combinations:
	        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
	        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
	        //   second time without clearing and then using a non-zero delay.
	        // (using JAWS 17 at time of this writing).
	        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);
	    };
	    /** Removes the aria-live element from the DOM. */
	    LiveAnnouncer.prototype._removeLiveElement = function () {
	        if (this._liveElement && this._liveElement.parentNode) {
	            this._liveElement.parentNode.removeChild(this._liveElement);
	        }
	    };
	    LiveAnnouncer.prototype._createLiveElement = function () {
	        var liveEl = document.createElement('div');
	        liveEl.classList.add('cdk-visually-hidden');
	        liveEl.setAttribute('aria-atomic', 'true');
	        liveEl.setAttribute('aria-live', 'polite');
	        document.body.appendChild(liveEl);
	        return liveEl;
	    };
	    LiveAnnouncer = __decorate$20([
	        _angular_core.Injectable(),
	        __param$3(0, _angular_core.Optional()),
	        __param$3(0, _angular_core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)), 
	        __metadata$20('design:paramtypes', [Object])
	    ], LiveAnnouncer);
	    return LiveAnnouncer;
	}());
	function LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement) {
	    return parentDispatcher || new LiveAnnouncer(liveElement);
	}
	
	var LIVE_ANNOUNCER_PROVIDER = {
	    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.
	    provide: LiveAnnouncer,
	    deps: [
	        [new _angular_core.Optional(), new _angular_core.SkipSelf(), LiveAnnouncer],
	        [new _angular_core.Optional(), new _angular_core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)]
	    ],
	    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY
	};
	
	var supportedInputTypes;
	/** @returns The input types supported by this browser. */
	function getSupportedInputTypes() {
	    if (!supportedInputTypes) {
	        var featureTestInput_1 = document.createElement('input');
	        supportedInputTypes = new Set([
	            // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after
	            // first changing it to something else:
	            // The specified value "" does not conform to the required format.
	            // The format is "#rrggbb" where rr, gg, bb are two-digit hexadecimal numbers.
	            'color',
	            'button',
	            'checkbox',
	            'date',
	            'datetime-local',
	            'email',
	            'file',
	            'hidden',
	            'image',
	            'month',
	            'number',
	            'password',
	            'radio',
	            'range',
	            'reset',
	            'search',
	            'submit',
	            'tel',
	            'text',
	            'time',
	            'url',
	            'week',
	        ].filter(function (value) {
	            featureTestInput_1.setAttribute('type', value);
	            return featureTestInput_1.type === value;
	        }));
	    }
	    return supportedInputTypes;
	}
	
	var __decorate$21 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$21 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var PlatformModule = (function () {
	    function PlatformModule() {
	    }
	    /** @deprecated */
	    PlatformModule.forRoot = function () {
	        return {
	            ngModule: PlatformModule,
	            providers: [],
	        };
	    };
	    PlatformModule = __decorate$21([
	        _angular_core.NgModule({
	            providers: [Platform]
	        }), 
	        __metadata$21('design:paramtypes', [])
	    ], PlatformModule);
	    return PlatformModule;
	}());
	
	var __decorate$16 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$16 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var A11yModule = (function () {
	    function A11yModule() {
	    }
	    /** @deprecated */
	    A11yModule.forRoot = function () {
	        return {
	            ngModule: A11yModule,
	            providers: [],
	        };
	    };
	    A11yModule = __decorate$16([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, PlatformModule],
	            declarations: [FocusTrap],
	            exports: [FocusTrap],
	            providers: [InteractivityChecker, LIVE_ANNOUNCER_PROVIDER]
	        }), 
	        __metadata$16('design:paramtypes', [])
	    ], A11yModule);
	    return A11yModule;
	}());
	
	var __decorate$23 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$23 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Component that shows a simplified checkbox without including any kind of "real" checkbox.
	 * Meant to be used when the checkbox is purely decorative and a large number of them will be
	 * included, such as for the options in a multi-select. Uses no SVGs or complex animations.
	 *
	 * Note that this component will be completely invisible to screen-reader users. This is *not*
	 * interchangeable with <md-checkbox> and should *not* be used if the user would directly interact
	 * with the checkbox. The pseudo-checkbox should only be used as an implementation detail of
	 * more complex components that appropriately handle selected / checked state.
	 * @docs-private
	 */
	var MdPseudoCheckbox = (function () {
	    function MdPseudoCheckbox(_elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** Display state of the checkbox. */
	        this.state = 'unchecked';
	        /** Whether the checkbox is disabled. */
	        this.disabled = false;
	        this.color = 'accent';
	    }
	    Object.defineProperty(MdPseudoCheckbox.prototype, "color", {
	        /** Color of the checkbox. */
	        get: function () { return this._color; },
	        set: function (value) {
	            if (value) {
	                var nativeElement = this._elementRef.nativeElement;
	                this._renderer.setElementClass(nativeElement, "mat-" + this.color, false);
	                this._renderer.setElementClass(nativeElement, "mat-" + value, true);
	                this._color = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    __decorate$23([
	        _angular_core.Input(), 
	        __metadata$23('design:type', String)
	    ], MdPseudoCheckbox.prototype, "state", void 0);
	    __decorate$23([
	        _angular_core.Input(), 
	        __metadata$23('design:type', Boolean)
	    ], MdPseudoCheckbox.prototype, "disabled", void 0);
	    __decorate$23([
	        _angular_core.Input(), 
	        __metadata$23('design:type', String)
	    ], MdPseudoCheckbox.prototype, "color", null);
	    MdPseudoCheckbox = __decorate$23([
	        _angular_core.Component({encapsulation: _angular_core.ViewEncapsulation.None,
	            selector: 'md-pseudo-checkbox, mat-pseudo-checkbox',
	            styles: [".mat-pseudo-checkbox{width:20px;height:20px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;transition:border-color 90ms cubic-bezier(0,0,.2,.1),background-color 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:'';border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:9px;left:2px;width:16px;opacity:1}.mat-pseudo-checkbox-checked::after{top:5px;left:3px;width:12px;height:5px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1}"],
	            template: '',
	            host: {
	                '[class.mat-pseudo-checkbox]': 'true',
	                '[class.mat-pseudo-checkbox-indeterminate]': 'state === "indeterminate"',
	                '[class.mat-pseudo-checkbox-checked]': 'state === "checked"',
	                '[class.mat-pseudo-checkbox-disabled]': 'disabled',
	            },
	        }), 
	        __metadata$23('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdPseudoCheckbox);
	    return MdPseudoCheckbox;
	}());
	
	var __decorate$22 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$22 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdSelectionModule = (function () {
	    function MdSelectionModule() {
	    }
	    MdSelectionModule = __decorate$22([
	        _angular_core.NgModule({
	            exports: [MdPseudoCheckbox],
	            declarations: [MdPseudoCheckbox]
	        }), 
	        __metadata$22('design:paramtypes', [])
	    ], MdSelectionModule);
	    return MdSelectionModule;
	}());
	
	var __decorate$24 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$24 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// "Polyfill" for `Node.replaceWith()`.
	// cf. https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/replaceWith
	function _replaceWith(toReplaceEl, otherEl) {
	    toReplaceEl.parentElement.replaceChild(otherEl, toReplaceEl);
	}
	/** @docs-private */
	var DomProjectionHost = (function () {
	    function DomProjectionHost(ref) {
	        this.ref = ref;
	    }
	    DomProjectionHost = __decorate$24([
	        _angular_core.Directive({
	            selector: 'cdk-dom-projection-host'
	        }), 
	        __metadata$24('design:paramtypes', [_angular_core.ElementRef])
	    ], DomProjectionHost);
	    return DomProjectionHost;
	}());
	/** @docs-private */
	var DomProjection = (function () {
	    function DomProjection() {
	    }
	    /**
	     * Project an element into a host element.
	     * Replace a host element by another element. This also replaces the children of the element
	     * by the children of the host.
	     *
	     * It should be used like this:
	     *
	     * ```
	     *   @Component({
	     *     template: `<div>
	     *       <cdk-dom-projection-host>
	     *         <div>other</div>
	     *         <ng-content></ng-content>
	     *       </cdk-dom-projection-host>
	     *     </div>`
	     *   })
	     *   class Cmpt {
	     *     constructor(private _projector: DomProjection, private _el: ElementRef) {}
	     *     ngOnInit() { this._projector.project(this._el, this._projector); }
	     *   }
	     * ```
	     *
	     * This component will move the content of the element it's applied to in the outer div. Because
	     * `project()` also move the children of the host inside the projected element, the element will
	     * contain the `<div>other</div>` HTML as well as its own children.
	     *
	     * Note: without `<ng-content></ng-content>` the projection will project an empty element.
	     *
	     * @param ref ElementRef to be projected.
	     * @param host Projection host into which to project the `ElementRef`.
	     */
	    DomProjection.prototype.project = function (ref, host) {
	        var projectedEl = ref.nativeElement;
	        var hostEl = host.ref.nativeElement;
	        var childNodes = projectedEl.childNodes;
	        var child = childNodes[0];
	        // We hoist all of the projected element's children out into the projected elements position
	        // because we *only* want to move the projected element and not its children.
	        _replaceWith(projectedEl, child);
	        var l = childNodes.length;
	        while (l--) {
	            child.parentNode.insertBefore(childNodes[0], child.nextSibling);
	            child = child.nextSibling; // nextSibling is now the childNodes[0].
	        }
	        // Insert all host children under the projectedEl, then replace host by component.
	        l = hostEl.childNodes.length;
	        while (l--) {
	            projectedEl.appendChild(hostEl.childNodes[0]);
	        }
	        _replaceWith(hostEl, projectedEl);
	        // At this point the host is replaced by the component. Nothing else to be done.
	    };
	    DomProjection = __decorate$24([
	        _angular_core.Injectable(), 
	        __metadata$24('design:paramtypes', [])
	    ], DomProjection);
	    return DomProjection;
	}());
	/** @docs-private */
	var ProjectionModule = (function () {
	    function ProjectionModule() {
	    }
	    /** @deprecated */
	    ProjectionModule.forRoot = function () {
	        return {
	            ngModule: ProjectionModule,
	        };
	    };
	    ProjectionModule = __decorate$24([
	        _angular_core.NgModule({
	            exports: [DomProjectionHost],
	            declarations: [DomProjectionHost],
	            providers: [DomProjection],
	        }), 
	        __metadata$24('design:paramtypes', [])
	    ], ProjectionModule);
	    return ProjectionModule;
	}());
	
	var __extends$5 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$25 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$25 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * The FullscreenOverlayContainer is the alternative to OverlayContainer
	 * that supports correct displaying of overlay elements in Fullscreen mode
	 * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
	 * It should be provided in the root component that way:
	 * providers: [
	 *   {provide: OverlayContainer, useClass: FullscreenOverlayContainer}
	 * ],
	 */
	var FullscreenOverlayContainer = (function (_super) {
	    __extends$5(FullscreenOverlayContainer, _super);
	    function FullscreenOverlayContainer() {
	        _super.apply(this, arguments);
	    }
	    FullscreenOverlayContainer.prototype._createContainer = function () {
	        var _this = this;
	        _super.prototype._createContainer.call(this);
	        this._adjustParentForFullscreenChange();
	        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });
	    };
	    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {
	        if (!this._containerElement) {
	            return;
	        }
	        var fullscreenElement = this.getFullscreenElement();
	        var parent = fullscreenElement || document.body;
	        parent.appendChild(this._containerElement);
	    };
	    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {
	        if (document.fullscreenEnabled) {
	            document.addEventListener('fullscreenchange', fn);
	        }
	        else if (document.webkitFullscreenEnabled) {
	            document.addEventListener('webkitfullscreenchange', fn);
	        }
	        else if (document.mozFullScreenEnabled) {
	            document.addEventListener('mozfullscreenchange', fn);
	        }
	        else if (document.msFullscreenEnabled) {
	            document.addEventListener('MSFullscreenChange', fn);
	        }
	    };
	    /**
	     * When the page is put into fullscreen mode, a specific element is specified.
	     * Only that element and its children are visible when in fullscreen mode.
	    */
	    FullscreenOverlayContainer.prototype.getFullscreenElement = function () {
	        return document.fullscreenElement ||
	            document.webkitFullscreenElement ||
	            document.mozFullScreenElement ||
	            document.msFullscreenElement ||
	            null;
	    };
	    FullscreenOverlayContainer = __decorate$25([
	        _angular_core.Injectable(), 
	        __metadata$25('design:paramtypes', [])
	    ], FullscreenOverlayContainer);
	    return FullscreenOverlayContainer;
	}(OverlayContainer));
	
	var __extends$6 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$26 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$26 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/* Adjusts configuration of our gesture library, Hammer. */
	var GestureConfig = (function (_super) {
	    __extends$6(GestureConfig, _super);
	    function GestureConfig() {
	        _super.call(this);
	        this._hammer = typeof window !== 'undefined' ? window.Hammer : null;
	        /* List of new event names to add to the gesture support list */
	        this.events = this._hammer ? [
	            'longpress',
	            'slide',
	            'slidestart',
	            'slideend',
	            'slideright',
	            'slideleft'
	        ] : [];
	        if (!this._hammer && _angular_core.isDevMode()) {
	            console.warn('Could not find HammerJS. Certain Angular Material ' +
	                'components may not work correctly.');
	        }
	    }
	    /**
	     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
	     *
	     * Our gesture names come from the Material Design gestures spec:
	     * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics
	     *
	     * More information on default recognizers can be found in Hammer docs:
	     * http://hammerjs.github.io/recognizer-pan/
	     * http://hammerjs.github.io/recognizer-press/
	     *
	     * @param element Element to which to assign the new HammerJS gestures.
	     * @returns Newly-created HammerJS instance.
	     */
	    GestureConfig.prototype.buildHammer = function (element) {
	        var mc = new this._hammer(element);
	        // Default Hammer Recognizers.
	        var pan = new this._hammer.Pan();
	        var swipe = new this._hammer.Swipe();
	        var press = new this._hammer.Press();
	        // Notice that a HammerJS recognizer can only depend on one other recognizer once.
	        // Otherwise the previous `recognizeWith` will be dropped.
	        // TODO: Confirm threshold numbers with Material Design UX Team
	        var slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
	        var longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
	        // Overwrite the default `pan` event to use the swipe event.
	        pan.recognizeWith(swipe);
	        // Add customized gestures to Hammer manager
	        mc.add([swipe, press, pan, slide, longpress]);
	        return mc;
	    };
	    /** Creates a new recognizer, without affecting the default recognizers of HammerJS */
	    GestureConfig.prototype._createRecognizer = function (base, options) {
	        var inheritances = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            inheritances[_i - 2] = arguments[_i];
	        }
	        var recognizer = new base.constructor(options);
	        inheritances.push(base);
	        inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });
	        return recognizer;
	    };
	    GestureConfig = __decorate$26([
	        _angular_core.Injectable(), 
	        __metadata$26('design:paramtypes', [])
	    ], GestureConfig);
	    return GestureConfig;
	}(_angular_platformBrowser.HammerGestureConfig));
	
	/**
	 * Class to be used to power selecting one or more options from a list.
	 * @docs-private
	 */
	var SelectionModel = (function () {
	    function SelectionModel(_isMulti, initiallySelectedValues) {
	        var _this = this;
	        if (_isMulti === void 0) { _isMulti = false; }
	        this._isMulti = _isMulti;
	        /** Currently-selected values. */
	        this._selection = new Set();
	        /** Keeps track of the deselected options that haven't been emitted by the change event. */
	        this._deselectedToEmit = [];
	        /** Keeps track of the selected option that haven't been emitted by the change event. */
	        this._selectedToEmit = [];
	        /** Event emitted when the value has changed. */
	        this.onChange = new rxjs_Subject.Subject();
	        if (initiallySelectedValues) {
	            if (_isMulti) {
	                initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });
	            }
	            else {
	                this._markSelected(initiallySelectedValues[0]);
	            }
	            // Clear the array in order to avoid firing the change event for preselected values.
	            this._selectedToEmit.length = 0;
	        }
	    }
	    Object.defineProperty(SelectionModel.prototype, "selected", {
	        /** Selected value(s). */
	        get: function () {
	            if (!this._selected) {
	                this._selected = Array.from(this._selection.values());
	            }
	            return this._selected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Selects a value or an array of values.
	     */
	    SelectionModel.prototype.select = function (value) {
	        this._markSelected(value);
	        this._emitChangeEvent();
	    };
	    /**
	     * Deselects a value or an array of values.
	     */
	    SelectionModel.prototype.deselect = function (value) {
	        this._unmarkSelected(value);
	        this._emitChangeEvent();
	    };
	    /**
	     * Clears all of the selected values.
	     */
	    SelectionModel.prototype.clear = function () {
	        this._unmarkAll();
	        this._emitChangeEvent();
	    };
	    /**
	     * Determines whether a value is selected.
	     */
	    SelectionModel.prototype.isSelected = function (value) {
	        return this._selection.has(value);
	    };
	    /**
	     * Determines whether the model has a value.
	     */
	    SelectionModel.prototype.isEmpty = function () {
	        return this._selection.size === 0;
	    };
	    /** Emits a change event and clears the records of selected and deselected values. */
	    SelectionModel.prototype._emitChangeEvent = function () {
	        if (this._selectedToEmit.length || this._deselectedToEmit.length) {
	            var eventData = new SelectionChange(this._selectedToEmit, this._deselectedToEmit);
	            this.onChange.next(eventData);
	            this._deselectedToEmit = [];
	            this._selectedToEmit = [];
	            this._selected = null;
	        }
	    };
	    /** Selects a value. */
	    SelectionModel.prototype._markSelected = function (value) {
	        if (!this.isSelected(value)) {
	            if (!this._isMulti) {
	                this._unmarkAll();
	            }
	            this._selection.add(value);
	            this._selectedToEmit.push(value);
	        }
	    };
	    /** Deselects a value. */
	    SelectionModel.prototype._unmarkSelected = function (value) {
	        if (this.isSelected(value)) {
	            this._selection.delete(value);
	            this._deselectedToEmit.push(value);
	        }
	    };
	    /** Clears out the selected values. */
	    SelectionModel.prototype._unmarkAll = function () {
	        var _this = this;
	        if (!this.isEmpty()) {
	            this._selection.forEach(function (value) { return _this._unmarkSelected(value); });
	        }
	    };
	    return SelectionModel;
	}());
	/**
	 * Describes an event emitted when the value of a MdSelectionModel has changed.
	 * @docs-private
	 */
	var SelectionChange = (function () {
	    function SelectionChange(added, removed) {
	        this.added = added;
	        this.removed = removed;
	    }
	    return SelectionChange;
	}());
	
	/**
	 * Screenreaders will often fire fake mousedown events when a focusable element
	 * is activated using the keyboard. We can typically distinguish between these faked
	 * mousedown events and real mousedown events using the "buttons" property. While
	 * real mousedowns will indicate the mouse button that was pressed (e.g. "1" for
	 * the left mouse button), faked mousedowns will usually set the property value to 0.
	 */
	function isFakeMousedownFromScreenReader(event) {
	    return event.buttons === 0;
	}
	
	var __decorate$27 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$27 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Class to coordinate unique selection based on name.
	 * Intended to be consumed as an Angular service.
	 * This service is needed because native radio change events are only fired on the item currently
	 * being selected, and we still need to uncheck the previous selection.
	 *
	 * This service does not *store* any IDs and names because they may change at any time, so it is
	 * less error-prone if they are simply passed through when the events occur.
	 */
	var UniqueSelectionDispatcher = (function () {
	    function UniqueSelectionDispatcher() {
	        this._listeners = [];
	    }
	    /**
	     * Notify other items that selection for the given name has been set.
	     * @param id ID of the item.
	     * @param name Name of the item.
	     */
	    UniqueSelectionDispatcher.prototype.notify = function (id, name) {
	        for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {
	            var listener = _a[_i];
	            listener(id, name);
	        }
	    };
	    /** Listen for future changes to item selection. */
	    UniqueSelectionDispatcher.prototype.listen = function (listener) {
	        this._listeners.push(listener);
	    };
	    UniqueSelectionDispatcher = __decorate$27([
	        _angular_core.Injectable(), 
	        __metadata$27('design:paramtypes', [])
	    ], UniqueSelectionDispatcher);
	    return UniqueSelectionDispatcher;
	}());
	function UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {
	    return parentDispatcher || new UniqueSelectionDispatcher();
	}
	var UNIQUE_SELECTION_DISPATCHER_PROVIDER = {
	    // If there is already a dispatcher available, use that. Otherwise, provide a new one.
	    provide: UniqueSelectionDispatcher,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), UniqueSelectionDispatcher]],
	    useFactory: UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY
	};
	
	var __decorate$29 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$29 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found
	// that a value of around 650ms seems appropriate.
	var TOUCH_BUFFER_MS = 650;
	/** Monitors mouse and keyboard events to determine the cause of focus events. */
	var FocusOriginMonitor = (function () {
	    function FocusOriginMonitor() {
	        // Note: we listen to events in the capture phase so we can detect them even if the user stops
	        // propagation.
	        var _this = this;
	        /** The focus origin that the next focus event is a result of. */
	        this._origin = null;
	        /** Whether the window has just been focused. */
	        this._windowFocused = false;
	        // On keydown record the origin and clear any touch event that may be in progress.
	        document.addEventListener('keydown', function () {
	            _this._lastTouchTarget = null;
	            _this._setOriginForCurrentEventQueue('keyboard');
	        }, true);
	        // On mousedown record the origin only if there is not touch target, since a mousedown can
	        // happen as a result of a touch event.
	        document.addEventListener('mousedown', function () {
	            if (!_this._lastTouchTarget) {
	                _this._setOriginForCurrentEventQueue('mouse');
	            }
	        }, true);
	        // When the touchstart event fires the focus event is not yet in the event queue. This means we
	        // can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to see if
	        // a focus happens.
	        document.addEventListener('touchstart', function (event) {
	            if (_this._touchTimeout != null) {
	                clearTimeout(_this._touchTimeout);
	            }
	            _this._lastTouchTarget = event.target;
	            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);
	        }, true);
	        // Make a note of when the window regains focus, so we can restore the origin info for the
	        // focused element.
	        window.addEventListener('focus', function () {
	            _this._windowFocused = true;
	            setTimeout(function () { return _this._windowFocused = false; }, 0);
	        });
	    }
	    /** Register an element to receive focus classes. */
	    FocusOriginMonitor.prototype.registerElementForFocusClasses = function (element, renderer) {
	        var _this = this;
	        var subject = new rxjs_Subject.Subject();
	        renderer.listen(element, 'focus', function (event) { return _this._onFocus(event, element, renderer, subject); });
	        renderer.listen(element, 'blur', function () { return _this._onBlur(element, renderer, subject); });
	        return subject.asObservable();
	    };
	    /** Focuses the element via the specified focus origin. */
	    FocusOriginMonitor.prototype.focusVia = function (element, renderer, origin) {
	        this._setOriginForCurrentEventQueue(origin);
	        renderer.invokeElementMethod(element, 'focus');
	    };
	    /** Sets the origin and schedules an async function to clear it at the end of the event queue. */
	    FocusOriginMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {
	        var _this = this;
	        this._origin = origin;
	        setTimeout(function () { return _this._origin = null; }, 0);
	    };
	    /** Checks whether the given focus event was caused by a touchstart event. */
	    FocusOriginMonitor.prototype._wasCausedByTouch = function (event) {
	        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.
	        // Consider the following dom structure:
	        //
	        // <div #parent tabindex="0" cdkFocusClasses>
	        //   <div #child (click)="#parent.focus()"></div>
	        // </div>
	        //
	        // If the user touches the #child element and the #parent is programmatically focused as a
	        // result, this code will still consider it to have been caused by the touch event and will
	        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a
	        // relatively small edge-case that can be worked around by using
	        // focusVia(parentEl, renderer,  'program') to focus the parent element.
	        //
	        // If we decide that we absolutely must handle this case correctly, we can do so by listening
	        // for the first focus event after the touchstart, and then the first blur event after that
	        // focus event. When that blur event fires we know that whatever follows is not a result of the
	        // touchstart.
	        var focusTarget = event.target;
	        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&
	            (focusTarget == this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));
	    };
	    /** Handles focus events on a registered element. */
	    FocusOriginMonitor.prototype._onFocus = function (event, element, renderer, subject) {
	        // If we couldn't detect a cause for the focus event, it's due to one of two reasons:
	        // 1) The window has just regained focus, in which case we want to restore the focused state of
	        //    the element from before the window blurred.
	        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.
	        // 3) The element was programmatically focused, in which case we should mark the origin as
	        //    'program'.
	        if (!this._origin) {
	            if (this._windowFocused && this._lastFocusOrigin) {
	                this._origin = this._lastFocusOrigin;
	            }
	            else if (this._wasCausedByTouch(event)) {
	                this._origin = 'touch';
	            }
	            else {
	                this._origin = 'program';
	            }
	        }
	        renderer.setElementClass(element, 'cdk-focused', true);
	        renderer.setElementClass(element, 'cdk-touch-focused', this._origin == 'touch');
	        renderer.setElementClass(element, 'cdk-keyboard-focused', this._origin == 'keyboard');
	        renderer.setElementClass(element, 'cdk-mouse-focused', this._origin == 'mouse');
	        renderer.setElementClass(element, 'cdk-program-focused', this._origin == 'program');
	        subject.next(this._origin);
	        this._lastFocusOrigin = this._origin;
	        this._origin = null;
	    };
	    /** Handles blur events on a registered element. */
	    FocusOriginMonitor.prototype._onBlur = function (element, renderer, subject) {
	        renderer.setElementClass(element, 'cdk-focused', false);
	        renderer.setElementClass(element, 'cdk-touch-focused', false);
	        renderer.setElementClass(element, 'cdk-keyboard-focused', false);
	        renderer.setElementClass(element, 'cdk-mouse-focused', false);
	        renderer.setElementClass(element, 'cdk-program-focused', false);
	        subject.next(null);
	    };
	    FocusOriginMonitor = __decorate$29([
	        _angular_core.Injectable(), 
	        __metadata$29('design:paramtypes', [])
	    ], FocusOriginMonitor);
	    return FocusOriginMonitor;
	}());
	/**
	 * Directive that determines how a particular element was focused (via keyboard, mouse, or
	 * programmatically) and adds corresponding classes to the element.
	 */
	var CdkFocusClasses = (function () {
	    function CdkFocusClasses(elementRef, focusOriginMonitor, renderer) {
	        this.changes =
	            focusOriginMonitor.registerElementForFocusClasses(elementRef.nativeElement, renderer);
	    }
	    CdkFocusClasses = __decorate$29([
	        _angular_core.Directive({
	            selector: '[cdkFocusClasses]',
	        }), 
	        __metadata$29('design:paramtypes', [_angular_core.ElementRef, FocusOriginMonitor, _angular_core.Renderer])
	    ], CdkFocusClasses);
	    return CdkFocusClasses;
	}());
	function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher) {
	    return parentDispatcher || new FocusOriginMonitor();
	}
	var FOCUS_ORIGIN_MONITOR_PROVIDER = {
	    // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.
	    provide: FocusOriginMonitor,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), FocusOriginMonitor]],
	    useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY
	};
	
	/**
	 * Applies a CSS transform to an element, including browser-prefixed properties.
	 * @param element
	 * @param transformValue
	 */
	function applyCssTransform(element, transformValue) {
	    // It's important to trim the result, because the browser will ignore the set operation
	    // if the string contains only whitespace.
	    var value = transformValue.trim();
	    element.style.transform = value;
	    element.style.webkitTransform = value;
	}
	
	var __decorate$28 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$28 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var StyleModule = (function () {
	    function StyleModule() {
	    }
	    StyleModule = __decorate$28([
	        _angular_core.NgModule({
	            declarations: [CdkFocusClasses],
	            exports: [CdkFocusClasses],
	            providers: [FOCUS_ORIGIN_MONITOR_PROVIDER],
	        }), 
	        __metadata$28('design:paramtypes', [])
	    ], StyleModule);
	    return StyleModule;
	}());
	
	/** @docs-private */
	var AnimationCurves = (function () {
	    function AnimationCurves() {
	    }
	    AnimationCurves.STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';
	    AnimationCurves.DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';
	    AnimationCurves.ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';
	    AnimationCurves.SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';
	    return AnimationCurves;
	}());
	/** @docs-private */
	var AnimationDurations = (function () {
	    function AnimationDurations() {
	    }
	    AnimationDurations.COMPLEX = '375ms';
	    AnimationDurations.ENTERING = '225ms';
	    AnimationDurations.EXITING = '195ms';
	    return AnimationDurations;
	}());
	
	/** Coerces a data-bound value (typically a string) to a number. */
	function coerceNumberProperty(value, fallbackValue) {
	    if (fallbackValue === void 0) { fallbackValue = 0; }
	    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
	    // and other non-number values as NaN, where Number just uses 0) but it considers the string
	    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
	    return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);
	}
	
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdCoreModule = (function () {
	    function MdCoreModule() {
	    }
	    /** @deprecated */
	    MdCoreModule.forRoot = function () {
	        return {
	            ngModule: MdCoreModule,
	            providers: [],
	        };
	    };
	    MdCoreModule = __decorate([
	        _angular_core.NgModule({
	            imports: [
	                MdLineModule,
	                RtlModule,
	                MdRippleModule,
	                ObserveContentModule,
	                PortalModule,
	                OverlayModule,
	                A11yModule,
	                MdOptionModule,
	                MdSelectionModule,
	            ],
	            exports: [
	                MdLineModule,
	                RtlModule,
	                MdRippleModule,
	                ObserveContentModule,
	                PortalModule,
	                OverlayModule,
	                A11yModule,
	                MdOptionModule,
	                MdSelectionModule,
	            ],
	        }), 
	        __metadata('design:paramtypes', [])
	    ], MdCoreModule);
	    return MdCoreModule;
	}());
	
	var __decorate$31 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$31 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$4 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Provider Expression that allows md-button-toggle-group to register as a ControlValueAccessor.
	 * This allows it to support [(ngModel)].
	 * @docs-private
	 */
	var MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdButtonToggleGroup; }),
	    multi: true
	};
	var _uniqueIdCounter$1 = 0;
	/** Change event object emitted by MdButtonToggle. */
	var MdButtonToggleChange = (function () {
	    function MdButtonToggleChange() {
	    }
	    return MdButtonToggleChange;
	}());
	/** Exclusive selection button toggle group that behaves like a radio-button group. */
	var MdButtonToggleGroup = (function () {
	    function MdButtonToggleGroup() {
	        /** The value for the button toggle group. Should match currently selected button toggle. */
	        this._value = null;
	        /** The HTML name attribute applied to toggles in this group. */
	        this._name = "md-button-toggle-group-" + _uniqueIdCounter$1++;
	        /** Disables all toggles in the group. */
	        this._disabled = null;
	        /** Whether the button toggle group should be vertical. */
	        this._vertical = false;
	        /** The currently selected button toggle, should match the value. */
	        this._selected = null;
	        /** Whether the button toggle group is initialized or not. */
	        this._isInitialized = false;
	        /**
	         * The method to be called in order to update ngModel.
	         * Now `ngModel` binding is not supported in multiple selection mode.
	         */
	        this._controlValueAccessorChangeFn = function (value) { };
	        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
	        this.onTouched = function () { };
	        /** Event emitted when the group's value changes. */
	        this._change = new _angular_core.EventEmitter();
	        /** Child button toggle buttons. */
	        this._buttonToggles = null;
	    }
	    Object.defineProperty(MdButtonToggleGroup.prototype, "change", {
	        get: function () {
	            return this._change.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdButtonToggleGroup.prototype.ngAfterViewInit = function () {
	        this._isInitialized = true;
	    };
	    Object.defineProperty(MdButtonToggleGroup.prototype, "name", {
	        /** `name` attribute for the underlying `input` element. */
	        get: function () {
	            return this._name;
	        },
	        set: function (value) {
	            this._name = value;
	            this._updateButtonToggleNames();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "disabled", {
	        /** Whether the toggle group is disabled. */
	        get: function () {
	            return this._disabled;
	        },
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "vertical", {
	        /** Whether the toggle group is vertical. */
	        get: function () {
	            return this._vertical;
	        },
	        set: function (value) {
	            this._vertical = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "value", {
	        /** Value of the toggle group. */
	        get: function () {
	            return this._value;
	        },
	        set: function (newValue) {
	            if (this._value != newValue) {
	                this._value = newValue;
	                this._updateSelectedButtonToggleFromValue();
	                // Only emit a change event if the view is completely initialized.
	                // We don't want to emit a change event for the initial values.
	                if (this._isInitialized) {
	                    this._emitChangeEvent();
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "selected", {
	        /** Whether the toggle group is selected. */
	        get: function () {
	            return this._selected;
	        },
	        set: function (selected) {
	            this._selected = selected;
	            this.value = selected ? selected.value : null;
	            if (selected && !selected.checked) {
	                selected.checked = true;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdButtonToggleGroup.prototype._updateButtonToggleNames = function () {
	        var _this = this;
	        if (this._buttonToggles) {
	            this._buttonToggles.forEach(function (toggle) {
	                toggle.name = _this._name;
	            });
	        }
	    };
	    // TODO: Refactor into shared code with radio.
	    MdButtonToggleGroup.prototype._updateSelectedButtonToggleFromValue = function () {
	        var _this = this;
	        var isAlreadySelected = this._selected != null && this._selected.value == this._value;
	        if (this._buttonToggles != null && !isAlreadySelected) {
	            var matchingButtonToggle = this._buttonToggles.filter(function (buttonToggle) { return buttonToggle.value == _this._value; })[0];
	            if (matchingButtonToggle) {
	                this.selected = matchingButtonToggle;
	            }
	            else if (this.value == null) {
	                this.selected = null;
	                this._buttonToggles.forEach(function (buttonToggle) {
	                    buttonToggle.checked = false;
	                });
	            }
	        }
	    };
	    /** Dispatch change event with current selection and group value. */
	    MdButtonToggleGroup.prototype._emitChangeEvent = function () {
	        var event = new MdButtonToggleChange();
	        event.source = this._selected;
	        event.value = this._value;
	        this._controlValueAccessorChangeFn(event.value);
	        this._change.emit(event);
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value Value to be set to the model.
	     */
	    MdButtonToggleGroup.prototype.writeValue = function (value) {
	        this.value = value;
	    };
	    /**
	     * Registers a callback that will be triggered when the value has changed.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn On change callback function.
	     */
	    MdButtonToggleGroup.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback that will be triggered when the control has been touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn On touch callback function.
	     */
	    MdButtonToggleGroup.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Toggles the disabled state of the component. Implemented as part of ControlValueAccessor.
	     * @param isDisabled Whether the component should be disabled.
	     */
	    MdButtonToggleGroup.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    __decorate$31([
	        _angular_core.Output(), 
	        __metadata$31('design:type', rxjs_Observable.Observable)
	    ], MdButtonToggleGroup.prototype, "change", null);
	    __decorate$31([
	        _angular_core.ContentChildren(_angular_core.forwardRef(function () { return MdButtonToggle; })), 
	        __metadata$31('design:type', _angular_core.QueryList)
	    ], MdButtonToggleGroup.prototype, "_buttonToggles", void 0);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', String)
	    ], MdButtonToggleGroup.prototype, "name", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroup.prototype, "disabled", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroup.prototype, "vertical", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Object)
	    ], MdButtonToggleGroup.prototype, "value", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Object)
	    ], MdButtonToggleGroup.prototype, "selected", null);
	    MdButtonToggleGroup = __decorate$31([
	        _angular_core.Directive({
	            selector: 'md-button-toggle-group:not([multiple]), mat-button-toggle-group:not([multiple])',
	            providers: [MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],
	            host: {
	                '[class.mat-button-toggle-group]': 'true',
	                'role': 'radiogroup',
	                '[class.mat-button-toggle-vertical]': 'vertical'
	            },
	            exportAs: 'mdButtonToggleGroup',
	        }), 
	        __metadata$31('design:paramtypes', [])
	    ], MdButtonToggleGroup);
	    return MdButtonToggleGroup;
	}());
	/** Multiple selection button-toggle group. `ngModel` is not supported in this mode. */
	var MdButtonToggleGroupMultiple = (function () {
	    function MdButtonToggleGroupMultiple() {
	        /** Disables all toggles in the group. */
	        this._disabled = null;
	        /** Whether the button toggle group should be vertical. */
	        this._vertical = false;
	    }
	    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, "disabled", {
	        /** Whether the toggle group is disabled. */
	        get: function () {
	            return this._disabled;
	        },
	        set: function (value) {
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, "vertical", {
	        /** Whether the toggle group is vertical. */
	        get: function () {
	            return this._vertical;
	        },
	        set: function (value) {
	            this._vertical = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroupMultiple.prototype, "disabled", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroupMultiple.prototype, "vertical", null);
	    MdButtonToggleGroupMultiple = __decorate$31([
	        _angular_core.Directive({
	            selector: 'md-button-toggle-group[multiple], mat-button-toggle-group[multiple]',
	            exportAs: 'mdButtonToggleGroup',
	            host: {
	                '[class.mat-button-toggle-group]': 'true',
	                '[class.mat-button-toggle-vertical]': 'vertical'
	            }
	        }), 
	        __metadata$31('design:paramtypes', [])
	    ], MdButtonToggleGroupMultiple);
	    return MdButtonToggleGroupMultiple;
	}());
	/** Single button inside of a toggle group. */
	var MdButtonToggle = (function () {
	    function MdButtonToggle(toggleGroup, toggleGroupMultiple, buttonToggleDispatcher, _renderer) {
	        var _this = this;
	        this.buttonToggleDispatcher = buttonToggleDispatcher;
	        this._renderer = _renderer;
	        /** Whether or not this button toggle is checked. */
	        this._checked = false;
	        /** Whether or not this button toggle is disabled. */
	        this._disabled = null;
	        /** Value assigned to this button toggle. */
	        this._value = null;
	        /** Whether or not the button toggle is a single selection. */
	        this._isSingleSelector = null;
	        /** Event emitted when the group value changes. */
	        this._change = new _angular_core.EventEmitter();
	        this.buttonToggleGroup = toggleGroup;
	        this.buttonToggleGroupMultiple = toggleGroupMultiple;
	        if (this.buttonToggleGroup) {
	            buttonToggleDispatcher.listen(function (id, name) {
	                if (id != _this.id && name == _this.name) {
	                    _this.checked = false;
	                }
	            });
	            this._type = 'radio';
	            this.name = this.buttonToggleGroup.name;
	            this._isSingleSelector = true;
	        }
	        else {
	            // Even if there is no group at all, treat the button toggle as a checkbox so it can be
	            // toggled on or off.
	            this._type = 'checkbox';
	            this._isSingleSelector = false;
	        }
	    }
	    Object.defineProperty(MdButtonToggle.prototype, "change", {
	        get: function () {
	            return this._change.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdButtonToggle.prototype.ngOnInit = function () {
	        if (this.id == null) {
	            this.id = "md-button-toggle-" + _uniqueIdCounter$1++;
	        }
	        if (this.buttonToggleGroup && this._value == this.buttonToggleGroup.value) {
	            this._checked = true;
	        }
	    };
	    Object.defineProperty(MdButtonToggle.prototype, "inputId", {
	        /** Unique ID for the underlying `input` element. */
	        get: function () {
	            return this.id + "-input";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggle.prototype, "checked", {
	        /** Whether the button is checked. */
	        get: function () {
	            return this._checked;
	        },
	        set: function (newCheckedState) {
	            if (this._isSingleSelector) {
	                if (newCheckedState) {
	                    // Notify all button toggles with the same name (in the same group) to un-check.
	                    this.buttonToggleDispatcher.notify(this.id, this.name);
	                }
	            }
	            this._checked = newCheckedState;
	            if (newCheckedState && this._isSingleSelector && this.buttonToggleGroup.value != this.value) {
	                this.buttonToggleGroup.selected = this;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggle.prototype, "value", {
	        /** MdButtonToggleGroup reads this to assign its own value. */
	        get: function () {
	            return this._value;
	        },
	        set: function (value) {
	            if (this._value != value) {
	                if (this.buttonToggleGroup != null && this.checked) {
	                    this.buttonToggleGroup.value = value;
	                }
	                this._value = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Dispatch change event with current value. */
	    MdButtonToggle.prototype._emitChangeEvent = function () {
	        var event = new MdButtonToggleChange();
	        event.source = this;
	        event.value = this._value;
	        this._change.emit(event);
	    };
	    Object.defineProperty(MdButtonToggle.prototype, "disabled", {
	        /** Whether the button is disabled. */
	        get: function () {
	            return this._disabled || (this.buttonToggleGroup != null && this.buttonToggleGroup.disabled) ||
	                (this.buttonToggleGroupMultiple != null && this.buttonToggleGroupMultiple.disabled);
	        },
	        set: function (value) {
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Toggle the state of the current button toggle. */
	    MdButtonToggle.prototype._toggle = function () {
	        this.checked = !this.checked;
	    };
	    /** Checks the button toggle due to an interaction with the underlying native input. */
	    MdButtonToggle.prototype._onInputChange = function (event) {
	        event.stopPropagation();
	        if (this._isSingleSelector) {
	            // Propagate the change one-way via the group, which will in turn mark this
	            // button toggle as checked.
	            this.checked = true;
	            this.buttonToggleGroup.selected = this;
	            this.buttonToggleGroup.onTouched();
	        }
	        else {
	            this._toggle();
	        }
	        // Emit a change event when the native input does.
	        this._emitChangeEvent();
	    };
	    MdButtonToggle.prototype._onInputClick = function (event) {
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `slide-toggle` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    /** Focuses the button. */
	    MdButtonToggle.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	    };
	    __decorate$31([
	        _angular_core.HostBinding(),
	        _angular_core.Input(), 
	        __metadata$31('design:type', String)
	    ], MdButtonToggle.prototype, "id", void 0);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', String)
	    ], MdButtonToggle.prototype, "name", void 0);
	    __decorate$31([
	        _angular_core.Output(), 
	        __metadata$31('design:type', rxjs_Observable.Observable)
	    ], MdButtonToggle.prototype, "change", null);
	    __decorate$31([
	        _angular_core.ViewChild('input'), 
	        __metadata$31('design:type', _angular_core.ElementRef)
	    ], MdButtonToggle.prototype, "_inputElement", void 0);
	    __decorate$31([
	        _angular_core.HostBinding('class.mat-button-toggle-checked'),
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggle.prototype, "checked", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Object)
	    ], MdButtonToggle.prototype, "value", null);
	    __decorate$31([
	        _angular_core.HostBinding('class.mat-button-toggle-disabled'),
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggle.prototype, "disabled", null);
	    MdButtonToggle = __decorate$31([
	        _angular_core.Component({selector: 'md-button-toggle, mat-button-toggle',
	            template: "<label [attr.for]=\"inputId\" class=\"mat-button-toggle-label\"><input #input class=\"mat-button-toggle-input cdk-visually-hidden\" [type]=\"_type\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [name]=\"name\" (change)=\"_onInputChange($event)\" (click)=\"_onInputClick($event)\"><div class=\"mat-button-toggle-label-content\"><ng-content></ng-content></div></label>",
	            styles: [".mat-button-toggle-group{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);position:relative;display:inline-flex;flex-direction:row;border-radius:2px;cursor:pointer;white-space:nowrap}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle-disabled .mat-button-toggle-label-content{cursor:default}.mat-button-toggle{white-space:nowrap;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-button-toggle-label-content{display:inline-block;line-height:36px;padding:0 16px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mat-button-toggle-label-content>*{vertical-align:middle}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                '[class.mat-button-toggle]': 'true'
	            }
	        }),
	        __param$4(0, _angular_core.Optional()),
	        __param$4(1, _angular_core.Optional()), 
	        __metadata$31('design:paramtypes', [MdButtonToggleGroup, MdButtonToggleGroupMultiple, UniqueSelectionDispatcher, _angular_core.Renderer])
	    ], MdButtonToggle);
	    return MdButtonToggle;
	}());
	var MdButtonToggleModule = (function () {
	    function MdButtonToggleModule() {
	    }
	    /** @deprecated */
	    MdButtonToggleModule.forRoot = function () {
	        return {
	            ngModule: MdButtonToggleModule,
	            providers: []
	        };
	    };
	    MdButtonToggleModule = __decorate$31([
	        _angular_core.NgModule({
	            imports: [_angular_forms.FormsModule, CompatibilityModule],
	            exports: [
	                MdButtonToggleGroup,
	                MdButtonToggleGroupMultiple,
	                MdButtonToggle,
	                CompatibilityModule,
	            ],
	            declarations: [MdButtonToggleGroup, MdButtonToggleGroupMultiple, MdButtonToggle],
	            providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER]
	        }), 
	        __metadata$31('design:paramtypes', [])
	    ], MdButtonToggleModule);
	    return MdButtonToggleModule;
	}());
	
	var __extends$7 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$32 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$32 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(jelbourn): Make the `isMouseDown` stuff done with one global listener.
	// TODO(kara): Convert attribute selectors to classes when attr maps become available
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdButtonCssMatStyler = (function () {
	    function MdButtonCssMatStyler() {
	    }
	    MdButtonCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-button], button[mat-button], a[md-button], a[mat-button]',
	            host: {
	                '[class.mat-button]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdButtonCssMatStyler);
	    return MdButtonCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdRaisedButtonCssMatStyler = (function () {
	    function MdRaisedButtonCssMatStyler() {
	    }
	    MdRaisedButtonCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-raised-button], button[mat-raised-button], ' +
	                'a[md-raised-button], a[mat-raised-button]',
	            host: {
	                '[class.mat-raised-button]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdRaisedButtonCssMatStyler);
	    return MdRaisedButtonCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdIconButtonCssMatStyler = (function () {
	    function MdIconButtonCssMatStyler() {
	    }
	    MdIconButtonCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-icon-button], button[mat-icon-button], a[md-icon-button], a[mat-icon-button]',
	            host: {
	                '[class.mat-icon-button]': 'true',
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdIconButtonCssMatStyler);
	    return MdIconButtonCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdFabCssMatStyler = (function () {
	    function MdFabCssMatStyler() {
	    }
	    MdFabCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-fab], button[mat-fab], a[md-fab], a[mat-fab]',
	            host: {
	                '[class.mat-fab]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdFabCssMatStyler);
	    return MdFabCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdMiniFabCssMatStyler = (function () {
	    function MdMiniFabCssMatStyler() {
	    }
	    MdMiniFabCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-mini-fab], button[mat-mini-fab], a[md-mini-fab], a[mat-mini-fab]',
	            host: {
	                '[class.mat-mini-fab]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdMiniFabCssMatStyler);
	    return MdMiniFabCssMatStyler;
	}());
	/**
	 * Material design button.
	 */
	var MdButton = (function () {
	    function MdButton(_elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** Whether the button has focus from the keyboard (not the mouse). Used for class binding. */
	        this._isKeyboardFocused = false;
	        /** Whether a mousedown has occurred on this element in the last 100ms. */
	        this._isMouseDown = false;
	        /** Whether the ripple effect on click should be disabled. */
	        this._disableRipple = false;
	        this._disabled = null;
	    }
	    Object.defineProperty(MdButton.prototype, "disableRipple", {
	        /** Whether the ripple effect for this button is disabled. */
	        get: function () { return this._disableRipple; },
	        set: function (v) { this._disableRipple = coerceBooleanProperty(v); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButton.prototype, "disabled", {
	        /** Whether the button is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value) ? true : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButton.prototype, "color", {
	        /** The color of the button. Can be `primary`, `accent`, or `warn`. */
	        get: function () { return this._color; },
	        set: function (value) { this._updateColor(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdButton.prototype._setMousedown = function () {
	        var _this = this;
	        // We only *show* the focus style when focus has come to the button via the keyboard.
	        // The Material Design spec is silent on this topic, and without doing this, the
	        // button continues to look :active after clicking.
	        // @see http://marcysutton.com/button-focus-hell/
	        this._isMouseDown = true;
	        setTimeout(function () { _this._isMouseDown = false; }, 100);
	    };
	    MdButton.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdButton.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._getHostElement(), "mat-" + color, isAdd);
	        }
	    };
	    MdButton.prototype._setKeyboardFocus = function () {
	        this._isKeyboardFocused = !this._isMouseDown;
	    };
	    MdButton.prototype._removeKeyboardFocus = function () {
	        this._isKeyboardFocused = false;
	    };
	    /** Focuses the button. */
	    MdButton.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._getHostElement(), 'focus');
	    };
	    MdButton.prototype._getHostElement = function () {
	        return this._elementRef.nativeElement;
	    };
	    MdButton.prototype._isRoundButton = function () {
	        var el = this._getHostElement();
	        return el.hasAttribute('md-icon-button') ||
	            el.hasAttribute('md-fab') ||
	            el.hasAttribute('md-mini-fab');
	    };
	    MdButton.prototype._isRippleDisabled = function () {
	        return this.disableRipple || this.disabled;
	    };
	    __decorate$32([
	        _angular_core.Input(), 
	        __metadata$32('design:type', Object)
	    ], MdButton.prototype, "disableRipple", null);
	    __decorate$32([
	        _angular_core.Input(), 
	        __metadata$32('design:type', Object)
	    ], MdButton.prototype, "disabled", null);
	    __decorate$32([
	        _angular_core.Input(), 
	        __metadata$32('design:type', String)
	    ], MdButton.prototype, "color", null);
	    MdButton = __decorate$32([
	        _angular_core.Component({selector: 'button[md-button], button[md-raised-button], button[md-icon-button],' +
	                'button[md-fab], button[md-mini-fab],' +
	                'button[mat-button], button[mat-raised-button], button[mat-icon-button],' +
	                'button[mat-fab], button[mat-mini-fab]',
	            host: {
	                '[disabled]': 'disabled',
	                '[class.mat-button-focus]': '_isKeyboardFocused',
	                '(mousedown)': '_setMousedown()',
	                '(focus)': '_setKeyboardFocus()',
	                '(blur)': '_removeKeyboardFocus()',
	            },
	            template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"_isRoundButton()\" [mdRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\" (touchstart)=\"$event.preventDefault()\"></div>",
	            styles: [".mat-button-focus.mat-button .mat-button-focus-overlay,.mat-button-focus.mat-fab .mat-button-focus-overlay,.mat-button-focus.mat-icon-button .mat-button-focus-overlay,.mat-button-focus.mat-mini-fab .mat-button-focus-overlay,.mat-button-focus.mat-raised-button .mat-button-focus-overlay,.mat-button:hover .mat-button-focus-overlay,.mat-icon-button:hover .mat-button-focus-overlay{opacity:1}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button[disabled]:hover .mat-button-focus-overlay,.mat-button[disabled]:hover.mat-accent,.mat-button[disabled]:hover.mat-primary,.mat-button[disabled]:hover.mat-warn,.mat-icon-button[disabled]:hover .mat-button-focus-overlay,.mat-icon-button[disabled]:hover.mat-accent,.mat-icon-button[disabled]:hover.mat-primary,.mat-icon-button[disabled]:hover.mat-warn{background-color:transparent}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-icon-button,.mat-mini-fab{min-width:0;width:40px;height:40px;border-radius:50%}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;flex-shrink:0;line-height:40px}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;pointer-events:none;opacity:0}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$32('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdButton);
	    return MdButton;
	}());
	/**
	 * Raised Material design button.
	 */
	var MdAnchor = (function (_super) {
	    __extends$7(MdAnchor, _super);
	    function MdAnchor(elementRef, renderer) {
	        _super.call(this, elementRef, renderer);
	    }
	    Object.defineProperty(MdAnchor.prototype, "tabIndex", {
	        /** @docs-private */
	        get: function () {
	            return this.disabled ? -1 : 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdAnchor.prototype, "_isAriaDisabled", {
	        get: function () {
	            return this.disabled ? 'true' : 'false';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdAnchor.prototype._haltDisabledEvents = function (event) {
	        // A disabled button shouldn't apply any actions
	        if (this.disabled) {
	            event.preventDefault();
	            event.stopImmediatePropagation();
	        }
	    };
	    __decorate$32([
	        _angular_core.HostBinding('tabIndex'), 
	        __metadata$32('design:type', Number)
	    ], MdAnchor.prototype, "tabIndex", null);
	    MdAnchor = __decorate$32([
	        _angular_core.Component({selector: "a[md-button], a[md-raised-button], a[md-icon-button], a[md-fab], a[md-mini-fab],\n             a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab], a[mat-mini-fab]",
	            host: {
	                '[attr.disabled]': 'disabled',
	                '[attr.aria-disabled]': '_isAriaDisabled',
	                '[class.mat-button-focus]': '_isKeyboardFocused',
	                '(mousedown)': '_setMousedown()',
	                '(focus)': '_setKeyboardFocus()',
	                '(blur)': '_removeKeyboardFocus()',
	                '(click)': '_haltDisabledEvents($event)',
	            },
	            template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"_isRoundButton()\" [mdRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\" (touchstart)=\"$event.preventDefault()\"></div>",
	            styles: [".mat-button-focus.mat-button .mat-button-focus-overlay,.mat-button-focus.mat-fab .mat-button-focus-overlay,.mat-button-focus.mat-icon-button .mat-button-focus-overlay,.mat-button-focus.mat-mini-fab .mat-button-focus-overlay,.mat-button-focus.mat-raised-button .mat-button-focus-overlay,.mat-button:hover .mat-button-focus-overlay,.mat-icon-button:hover .mat-button-focus-overlay{opacity:1}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button[disabled]:hover .mat-button-focus-overlay,.mat-button[disabled]:hover.mat-accent,.mat-button[disabled]:hover.mat-primary,.mat-button[disabled]:hover.mat-warn,.mat-icon-button[disabled]:hover .mat-button-focus-overlay,.mat-icon-button[disabled]:hover.mat-accent,.mat-icon-button[disabled]:hover.mat-primary,.mat-icon-button[disabled]:hover.mat-warn{background-color:transparent}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-icon-button,.mat-mini-fab{min-width:0;width:40px;height:40px;border-radius:50%}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;flex-shrink:0;line-height:40px}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;pointer-events:none;opacity:0}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$32('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdAnchor);
	    return MdAnchor;
	}(MdButton));
	var MdButtonModule = (function () {
	    function MdButtonModule() {
	    }
	    /** @deprecated */
	    MdButtonModule.forRoot = function () {
	        return {
	            ngModule: MdButtonModule,
	            providers: []
	        };
	    };
	    MdButtonModule = __decorate$32([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [
	                MdButton, MdAnchor,
	                CompatibilityModule,
	                MdButtonCssMatStyler,
	                MdRaisedButtonCssMatStyler,
	                MdIconButtonCssMatStyler,
	                MdFabCssMatStyler,
	                MdMiniFabCssMatStyler
	            ],
	            declarations: [
	                MdButton,
	                MdAnchor,
	                MdButtonCssMatStyler,
	                MdRaisedButtonCssMatStyler,
	                MdIconButtonCssMatStyler,
	                MdFabCssMatStyler,
	                MdMiniFabCssMatStyler
	            ],
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdButtonModule);
	    return MdButtonModule;
	}());
	
	var __decorate$33 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$33 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Monotonically increasing integer used to auto-generate unique ids for checkbox components. */
	var nextId = 0;
	/**
	 * Provider Expression that allows md-checkbox to register as a ControlValueAccessor.
	 * This allows it to support [(ngModel)].
	 * @docs-private
	 */
	var MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdCheckbox; }),
	    multi: true
	};
	/**
	 * Represents the different states that require custom transitions between them.
	 * @docs-private
	 */
	
	(function (TransitionCheckState) {
	    /** The initial state of the component before any user interaction. */
	    TransitionCheckState[TransitionCheckState["Init"] = 0] = "Init";
	    /** The state representing the component when it's becoming checked. */
	    TransitionCheckState[TransitionCheckState["Checked"] = 1] = "Checked";
	    /** The state representing the component when it's becoming unchecked. */
	    TransitionCheckState[TransitionCheckState["Unchecked"] = 2] = "Unchecked";
	    /** The state representing the component when it's becoming indeterminate. */
	    TransitionCheckState[TransitionCheckState["Indeterminate"] = 3] = "Indeterminate";
	})(exports.TransitionCheckState || (exports.TransitionCheckState = {}));
	/** Change event object emitted by MdCheckbox. */
	var MdCheckboxChange = (function () {
	    function MdCheckboxChange() {
	    }
	    return MdCheckboxChange;
	}());
	/**
	 * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,
	 * and exposes a similar API. A MdCheckbox can be either checked, unchecked, indeterminate, or
	 * disabled. Note that all additional accessibility attributes are taken care of by the component,
	 * so there is no need to provide them yourself. However, if you want to omit a label and still
	 * have the checkbox be accessible, you may supply an [aria-label] input.
	 * See: https://www.google.com/design/spec/components/selection-controls.html
	 */
	var MdCheckbox = (function () {
	    function MdCheckbox(_renderer, _elementRef, _changeDetectorRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._changeDetectorRef = _changeDetectorRef;
	        /**
	         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
	         * take precedence so this may be omitted.
	         */
	        this.ariaLabel = '';
	        /**
	         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
	         */
	        this.ariaLabelledby = null;
	        /** A unique id for the checkbox. If one is not supplied, it is auto-generated. */
	        this.id = "md-checkbox-" + ++nextId;
	        /** Whether the label should appear after or before the checkbox. Defaults to 'after' */
	        this.labelPosition = 'after';
	        this._disabled = false;
	        /** Tabindex value that is passed to the underlying input element. */
	        this.tabIndex = 0;
	        /** Name value will be applied to the input element if present */
	        this.name = null;
	        /** Event emitted when the checkbox's `checked` value changes. */
	        this.change = new _angular_core.EventEmitter();
	        /** Event emitted when the checkbox's `indeterminate` value changes. */
	        this.indeterminateChange = new _angular_core.EventEmitter();
	        /**
	         * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
	         * @docs-private
	         */
	        this.onTouched = function () { };
	        this._currentAnimationClass = '';
	        this._currentCheckState = exports.TransitionCheckState.Init;
	        this._checked = false;
	        this._indeterminate = false;
	        this._controlValueAccessorChangeFn = function (value) { };
	        this._hasFocus = false;
	        this.color = 'accent';
	    }
	    Object.defineProperty(MdCheckbox.prototype, "disableRipple", {
	        /** Whether the ripple effect for this checkbox is disabled. */
	        get: function () { return this._disableRipple; },
	        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "inputId", {
	        /** ID of the native input element inside `<md-checkbox>` */
	        get: function () {
	            return "input-" + this.id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "required", {
	        /** Whether the checkbox is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "align", {
	        /**
	         * Whether or not the checkbox should appear before or after the label.
	         * @deprecated
	         */
	        get: function () {
	            // align refers to the checkbox relative to the label, while labelPosition refers to the
	            // label relative to the checkbox. As such, they are inverted.
	            return this.labelPosition == 'after' ? 'start' : 'end';
	        },
	        set: function (v) {
	            this.labelPosition = (v == 'start') ? 'after' : 'before';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "disabled", {
	        /** Whether the checkbox is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "checked", {
	        /**
	         * Whether the checkbox is checked. Note that setting `checked` will immediately set
	         * `indeterminate` to false.
	         */
	        get: function () {
	            return this._checked;
	        },
	        set: function (checked) {
	            if (checked != this.checked) {
	                if (this._indeterminate) {
	                    this._indeterminate = false;
	                    this.indeterminateChange.emit(this._indeterminate);
	                }
	                this._checked = checked;
	                this._transitionCheckState(this._checked ? exports.TransitionCheckState.Checked : exports.TransitionCheckState.Unchecked);
	                this._changeDetectorRef.markForCheck();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "indeterminate", {
	        /**
	         * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
	         * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
	         * checkable items. Note that whenever `checked` is set, indeterminate is immediately set to
	         * false. This differs from the web platform in that indeterminate state on native
	         * checkboxes is only remove when the user manually checks the checkbox (rather than setting the
	         * `checked` property programmatically). However, we feel that this behavior is more accommodating
	         * to the way consumers would envision using this component.
	         */
	        get: function () {
	            return this._indeterminate;
	        },
	        set: function (indeterminate) {
	            var changed = indeterminate != this._indeterminate;
	            this._indeterminate = indeterminate;
	            if (this._indeterminate) {
	                this._transitionCheckState(exports.TransitionCheckState.Indeterminate);
	            }
	            else {
	                this._transitionCheckState(this.checked ? exports.TransitionCheckState.Checked : exports.TransitionCheckState.Unchecked);
	            }
	            if (changed) {
	                this.indeterminateChange.emit(this._indeterminate);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "color", {
	        /** The color of the button. Can be `primary`, `accent`, or `warn`. */
	        get: function () { return this._color; },
	        set: function (value) { this._updateColor(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdCheckbox.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdCheckbox.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    MdCheckbox.prototype._isRippleDisabled = function () {
	        return this.disableRipple || this.disabled;
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value Value to be set to the model.
	     */
	    MdCheckbox.prototype.writeValue = function (value) {
	        this.checked = !!value;
	    };
	    /**
	     * Registers a callback to be triggered when the value has changed.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Function to be called on change.
	     */
	    MdCheckbox.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback to be triggered when the control has been touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be triggered when the checkbox is touched.
	     */
	    MdCheckbox.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Sets the checkbox's disabled state. Implemented as a part of ControlValueAccessor.
	     * @param isDisabled Whether the checkbox should be disabled.
	     */
	    MdCheckbox.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    MdCheckbox.prototype._transitionCheckState = function (newState) {
	        var oldState = this._currentCheckState;
	        var renderer = this._renderer;
	        var elementRef = this._elementRef;
	        if (oldState === newState) {
	            return;
	        }
	        if (this._currentAnimationClass.length > 0) {
	            renderer.setElementClass(elementRef.nativeElement, this._currentAnimationClass, false);
	        }
	        this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
	        this._currentCheckState = newState;
	        if (this._currentAnimationClass.length > 0) {
	            renderer.setElementClass(elementRef.nativeElement, this._currentAnimationClass, true);
	        }
	    };
	    MdCheckbox.prototype._emitChangeEvent = function () {
	        var event = new MdCheckboxChange();
	        event.source = this;
	        event.checked = this.checked;
	        this._controlValueAccessorChangeFn(this.checked);
	        this.change.emit(event);
	    };
	    /** Informs the component when the input has focus so that we can style accordingly */
	    MdCheckbox.prototype._onInputFocus = function () {
	        this._hasFocus = true;
	    };
	    /** Informs the component when we lose focus in order to style accordingly */
	    MdCheckbox.prototype._onInputBlur = function () {
	        this._hasFocus = false;
	        this.onTouched();
	    };
	    /** Toggles the `checked` state of the checkbox. */
	    MdCheckbox.prototype.toggle = function () {
	        this.checked = !this.checked;
	    };
	    /**
	     * Event handler for checkbox input element.
	     * Toggles checked state if element is not disabled.
	     * @param event
	     */
	    MdCheckbox.prototype._onInteractionEvent = function (event) {
	        // We always have to stop propagation on the change event.
	        // Otherwise the change event, from the input element, will bubble up and
	        // emit its event object to the `change` output.
	        event.stopPropagation();
	        if (!this.disabled) {
	            this.toggle();
	            // Emit our custom change event if the native input emitted one.
	            // It is important to only emit it, if the native input triggered one, because
	            // we don't want to trigger a change event, when the `checked` variable changes for example.
	            this._emitChangeEvent();
	        }
	    };
	    /** Focuses the checkbox. */
	    MdCheckbox.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	        this._onInputFocus();
	    };
	    MdCheckbox.prototype._onInputClick = function (event) {
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `checkbox` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    MdCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {
	        var animSuffix;
	        switch (oldState) {
	            case exports.TransitionCheckState.Init:
	                // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or
	                // [checked] bound to it.
	                if (newState === exports.TransitionCheckState.Checked) {
	                    animSuffix = 'unchecked-checked';
	                }
	                else {
	                    return '';
	                }
	                break;
	            case exports.TransitionCheckState.Unchecked:
	                animSuffix = newState === exports.TransitionCheckState.Checked ?
	                    'unchecked-checked' : 'unchecked-indeterminate';
	                break;
	            case exports.TransitionCheckState.Checked:
	                animSuffix = newState === exports.TransitionCheckState.Unchecked ?
	                    'checked-unchecked' : 'checked-indeterminate';
	                break;
	            case exports.TransitionCheckState.Indeterminate:
	                animSuffix = newState === exports.TransitionCheckState.Checked ?
	                    'indeterminate-checked' : 'indeterminate-unchecked';
	        }
	        return "mat-checkbox-anim-" + animSuffix;
	    };
	    MdCheckbox.prototype._getHostElement = function () {
	        return this._elementRef.nativeElement;
	    };
	    __decorate$33([
	        _angular_core.Input('aria-label'), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "ariaLabel", void 0);
	    __decorate$33([
	        _angular_core.Input('aria-labelledby'), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "ariaLabelledby", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "id", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Boolean)
	    ], MdCheckbox.prototype, "disableRipple", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Boolean)
	    ], MdCheckbox.prototype, "required", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "align", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "labelPosition", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Boolean)
	    ], MdCheckbox.prototype, "disabled", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Number)
	    ], MdCheckbox.prototype, "tabIndex", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "name", void 0);
	    __decorate$33([
	        _angular_core.Output(), 
	        __metadata$33('design:type', _angular_core.EventEmitter)
	    ], MdCheckbox.prototype, "change", void 0);
	    __decorate$33([
	        _angular_core.Output(), 
	        __metadata$33('design:type', _angular_core.EventEmitter)
	    ], MdCheckbox.prototype, "indeterminateChange", void 0);
	    __decorate$33([
	        _angular_core.ViewChild('input'), 
	        __metadata$33('design:type', _angular_core.ElementRef)
	    ], MdCheckbox.prototype, "_inputElement", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "checked", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "indeterminate", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "color", null);
	    MdCheckbox = __decorate$33([
	        _angular_core.Component({selector: 'md-checkbox, mat-checkbox',
	            template: "<label class=\"mat-checkbox-layout\"><div class=\"mat-checkbox-inner-container\"><input #input class=\"mat-checkbox-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [checked]=\"checked\" [disabled]=\"disabled\" [name]=\"name\" [tabIndex]=\"tabIndex\" [indeterminate]=\"indeterminate\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (focus)=\"_onInputFocus()\" (blur)=\"_onInputBlur()\" (change)=\"_onInteractionEvent($event)\" (click)=\"_onInputClick($event)\"><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-checkbox-ripple\" [mdRippleTrigger]=\"_getHostElement()\" [mdRippleCentered]=\"true\" [mdRippleSpeedFactor]=\"0.3\"></div><div class=\"mat-checkbox-frame\"></div><div class=\"mat-checkbox-background\"><svg version=\"1.1\" class=\"mat-checkbox-checkmark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" xml:space=\"preserve\"><path class=\"mat-checkbox-checkmark-path\" fill=\"none\" stroke=\"white\" d=\"M4.1,12.7 9,17.6 20.3,6.3\"/></svg><div class=\"mat-checkbox-mixedmark\"></div></div></div><span class=\"mat-checkbox-label\"><ng-content></ng-content></span></label>",
	            styles: [".mat-checkbox-frame,.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-checkmark,.mat-checkbox-frame{bottom:0;left:0;position:absolute;right:0;top:0}.mat-checkbox-checkmark,.mat-checkbox-mixedmark{width:calc(100% - 4px)}.mat-checkbox-background,.mat-checkbox-frame{border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{cursor:pointer;font-family:Roboto,\"Helvetica Neue\",sans-serif;transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-checkbox-layout{cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex}.mat-checkbox-inner-container{display:inline-block;height:20px;line-height:0;margin:auto 8px auto auto;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:20px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-checkbox-frame{transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-checkbox-checkmark{width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.67px}.mat-checkbox-checked .mat-checkbox-checkmark-path,.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-mixedmark{height:2px;opacity:0;transform:scaleX(0) rotate(0)}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none}"],
	            host: {
	                '[class.mat-checkbox]': 'true',
	                '[class.mat-checkbox-indeterminate]': 'indeterminate',
	                '[class.mat-checkbox-checked]': 'checked',
	                '[class.mat-checkbox-disabled]': 'disabled',
	                '[class.mat-checkbox-label-before]': 'labelPosition == "before"',
	                '[class.mat-checkbox-focused]': '_hasFocus',
	            },
	            providers: [MD_CHECKBOX_CONTROL_VALUE_ACCESSOR],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush
	        }), 
	        __metadata$33('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef, _angular_core.ChangeDetectorRef])
	    ], MdCheckbox);
	    return MdCheckbox;
	}());
	var MdCheckboxModule = (function () {
	    function MdCheckboxModule() {
	    }
	    /** @deprecated */
	    MdCheckboxModule.forRoot = function () {
	        return {
	            ngModule: MdCheckboxModule,
	            providers: []
	        };
	    };
	    MdCheckboxModule = __decorate$33([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [MdCheckbox, CompatibilityModule],
	            declarations: [MdCheckbox],
	        }), 
	        __metadata$33('design:paramtypes', [])
	    ], MdCheckboxModule);
	    return MdCheckboxModule;
	}());
	
	var __decorate$34 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$34 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$5 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Provider Expression that allows md-radio-group to register as a ControlValueAccessor. This
	 * allows it to support [(ngModel)] and ngControl.
	 * @docs-private
	 */
	var MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdRadioGroup; }),
	    multi: true
	};
	var _uniqueIdCounter$2 = 0;
	/** Change event object emitted by MdRadio and MdRadioGroup. */
	var MdRadioChange = (function () {
	    function MdRadioChange() {
	    }
	    return MdRadioChange;
	}());
	/**
	 * A group of radio buttons. May contain one or more `<md-radio-button>` elements.
	 */
	var MdRadioGroup = (function () {
	    function MdRadioGroup() {
	        /**
	         * Selected value for group. Should equal the value of the selected radio button if there *is*
	         * a corresponding radio button with a matching value. If there is *not* such a corresponding
	         * radio button, this value persists to be applied in case a new radio button is added with a
	         * matching value.
	         */
	        this._value = null;
	        /** The HTML name attribute applied to radio buttons in this group. */
	        this._name = "md-radio-group-" + _uniqueIdCounter$2++;
	        /** Disables all individual radio buttons assigned to this group. */
	        this._disabled = false;
	        /** The currently selected radio button. Should match value. */
	        this._selected = null;
	        /** Whether the `value` has been set to its initial value. */
	        this._isInitialized = false;
	        /** The method to be called in order to update ngModel */
	        this._controlValueAccessorChangeFn = function (value) { };
	        /**
	         * onTouch function registered via registerOnTouch (ControlValueAccessor).
	         * @docs-private
	         */
	        this.onTouched = function () { };
	        /**
	         * Event emitted when the group value changes.
	         * Change events are only emitted when the value changes due to user interaction with
	         * a radio button (the same behavior as `<input type-"radio">`).
	         */
	        this.change = new _angular_core.EventEmitter();
	        /** Child radio buttons. */
	        this._radios = null;
	        /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */
	        this.labelPosition = 'after';
	    }
	    Object.defineProperty(MdRadioGroup.prototype, "name", {
	        /** Name of the radio button group. All radio buttons inside this group will use this name. */
	        get: function () { return this._name; },
	        set: function (value) {
	            this._name = value;
	            this._updateRadioButtonNames();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioGroup.prototype, "align", {
	        /**
	         * Alignment of the radio-buttons relative to their labels. Can be 'before' or 'after'.
	         * @deprecated
	         */
	        get: function () {
	            // align refers to the checkbox relative to the label, while labelPosition refers to the
	            // label relative to the checkbox. As such, they are inverted.
	            return this.labelPosition == 'after' ? 'start' : 'end';
	        },
	        set: function (v) {
	            this.labelPosition = (v == 'start') ? 'after' : 'before';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioGroup.prototype, "disabled", {
	        /** Whether the radio button is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) {
	            // The presence of *any* disabled value makes the component disabled, *except* for false.
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioGroup.prototype, "value", {
	        /** Value of the radio button. */
	        get: function () { return this._value; },
	        set: function (newValue) {
	            if (this._value != newValue) {
	                // Set this before proceeding to ensure no circular loop occurs with selection.
	                this._value = newValue;
	                this._updateSelectedRadioFromValue();
	                this._checkSelectedRadioButton();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdRadioGroup.prototype._checkSelectedRadioButton = function () {
	        if (this.selected && !this._selected.checked) {
	            this._selected.checked = true;
	        }
	    };
	    Object.defineProperty(MdRadioGroup.prototype, "selected", {
	        /** Whether the radio button is selected. */
	        get: function () { return this._selected; },
	        set: function (selected) {
	            this._selected = selected;
	            this.value = selected ? selected.value : null;
	            this._checkSelectedRadioButton();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Initialize properties once content children are available.
	     * This allows us to propagate relevant attributes to associated buttons.
	     */
	    MdRadioGroup.prototype.ngAfterContentInit = function () {
	        // Mark this component as initialized in AfterContentInit because the initial value can
	        // possibly be set by NgModel on MdRadioGroup, and it is possible that the OnInit of the
	        // NgModel occurs *after* the OnInit of the MdRadioGroup.
	        this._isInitialized = true;
	    };
	    /**
	     * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
	     * radio buttons upon their blur.
	     */
	    MdRadioGroup.prototype._touch = function () {
	        if (this.onTouched) {
	            this.onTouched();
	        }
	    };
	    MdRadioGroup.prototype._updateRadioButtonNames = function () {
	        var _this = this;
	        if (this._radios) {
	            this._radios.forEach(function (radio) {
	                radio.name = _this.name;
	            });
	        }
	    };
	    /** Updates the `selected` radio button from the internal _value state. */
	    MdRadioGroup.prototype._updateSelectedRadioFromValue = function () {
	        var _this = this;
	        // If the value already matches the selected radio, do nothing.
	        var isAlreadySelected = this._selected != null && this._selected.value == this._value;
	        if (this._radios != null && !isAlreadySelected) {
	            this._selected = null;
	            this._radios.forEach(function (radio) {
	                radio.checked = _this.value == radio.value;
	                if (radio.checked) {
	                    _this._selected = radio;
	                }
	            });
	        }
	    };
	    /** Dispatch change event with current selection and group value. */
	    MdRadioGroup.prototype._emitChangeEvent = function () {
	        if (this._isInitialized) {
	            var event_1 = new MdRadioChange();
	            event_1.source = this._selected;
	            event_1.value = this._value;
	            this.change.emit(event_1);
	        }
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value
	     */
	    MdRadioGroup.prototype.writeValue = function (value) {
	        this.value = value;
	    };
	    /**
	     * Registers a callback to be triggered when the model value changes.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdRadioGroup.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback to be triggered when the control is touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdRadioGroup.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
	     * @param isDisabled Whether the control should be disabled.
	     */
	    MdRadioGroup.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    __decorate$34([
	        _angular_core.Output(), 
	        __metadata$34('design:type', _angular_core.EventEmitter)
	    ], MdRadioGroup.prototype, "change", void 0);
	    __decorate$34([
	        _angular_core.ContentChildren(_angular_core.forwardRef(function () { return MdRadioButton; })), 
	        __metadata$34('design:type', _angular_core.QueryList)
	    ], MdRadioGroup.prototype, "_radios", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', String)
	    ], MdRadioGroup.prototype, "name", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "align", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "labelPosition", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioGroup.prototype, "disabled", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "value", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "selected", null);
	    MdRadioGroup = __decorate$34([
	        _angular_core.Directive({
	            selector: 'md-radio-group, mat-radio-group',
	            providers: [MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],
	            host: {
	                'role': 'radiogroup',
	                '[class.mat-radio-group]': 'true',
	            },
	        }), 
	        __metadata$34('design:paramtypes', [])
	    ], MdRadioGroup);
	    return MdRadioGroup;
	}());
	/**
	 * A radio-button. May be inside of
	 */
	var MdRadioButton = (function () {
	    function MdRadioButton(radioGroup, _elementRef, _renderer, radioDispatcher) {
	        // Assertions. Ideally these should be stripped out by the compiler.
	        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.
	        var _this = this;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this.radioDispatcher = radioDispatcher;
	        /** Whether this radio is checked. */
	        this._checked = false;
	        /** The unique ID for the radio button. */
	        this.id = "md-radio-" + _uniqueIdCounter$2++;
	        /** Value assigned to this radio.*/
	        this._value = null;
	        /**
	         * Event emitted when the checked state of this radio button changes.
	         * Change events are only emitted when the value changes due to user interaction with
	         * the radio button (the same behavior as `<input type-"radio">`).
	         */
	        this.change = new _angular_core.EventEmitter();
	        this.radioGroup = radioGroup;
	        radioDispatcher.listen(function (id, name) {
	            if (id != _this.id && name == _this.name) {
	                _this.checked = false;
	            }
	        });
	    }
	    Object.defineProperty(MdRadioButton.prototype, "disableRipple", {
	        /** Whether the ripple effect for this radio button is disabled. */
	        get: function () { return this._disableRipple; },
	        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "inputId", {
	        /** ID of the native input element inside `<md-radio-button>` */
	        get: function () {
	            return this.id + "-input";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "checked", {
	        /** Whether this radio button is checked. */
	        get: function () {
	            return this._checked;
	        },
	        set: function (newCheckedState) {
	            if (this._checked != newCheckedState) {
	                this._checked = newCheckedState;
	                if (newCheckedState && this.radioGroup && this.radioGroup.value != this.value) {
	                    this.radioGroup.selected = this;
	                }
	                else if (!newCheckedState && this.radioGroup && this.radioGroup.value == this.value) {
	                    // When unchecking the selected radio button, update the selected radio
	                    // property on the group.
	                    this.radioGroup.selected = null;
	                }
	                if (newCheckedState) {
	                    // Notify all radio buttons with the same name to un-check.
	                    this.radioDispatcher.notify(this.id, this.name);
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "value", {
	        /** The value of this radio button. */
	        get: function () {
	            return this._value;
	        },
	        set: function (value) {
	            if (this._value != value) {
	                this._value = value;
	                if (this.radioGroup != null) {
	                    if (!this.checked) {
	                        // Update checked when the value changed to match the radio group's value
	                        this.checked = this.radioGroup.value == value;
	                    }
	                    if (this.checked) {
	                        this.radioGroup.selected = this;
	                    }
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "align", {
	        /**
	         * Whether or not the radio-button should appear before or after the label.
	         * @deprecated
	         */
	        get: function () {
	            // align refers to the checkbox relative to the label, while labelPosition refers to the
	            // label relative to the checkbox. As such, they are inverted.
	            return this.labelPosition == 'after' ? 'start' : 'end';
	        },
	        set: function (v) {
	            this.labelPosition = (v == 'start') ? 'after' : 'before';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "labelPosition", {
	        /** Whether the label should appear after or before the radio button. Defaults to 'after' */
	        get: function () {
	            return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';
	        },
	        set: function (value) {
	            this._labelPosition = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "disabled", {
	        /** Whether the radio button is disabled. */
	        get: function () {
	            return this._disabled || (this.radioGroup != null && this.radioGroup.disabled);
	        },
	        set: function (value) {
	            // The presence of *any* disabled value makes the component disabled, *except* for false.
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdRadioButton.prototype.ngOnInit = function () {
	        if (this.radioGroup) {
	            // If the radio is inside a radio group, determine if it should be checked
	            this.checked = this.radioGroup.value === this._value;
	            // Copy name from parent radio group
	            this.name = this.radioGroup.name;
	        }
	    };
	    /** Dispatch change event with current value. */
	    MdRadioButton.prototype._emitChangeEvent = function () {
	        var event = new MdRadioChange();
	        event.source = this;
	        event.value = this._value;
	        this.change.emit(event);
	    };
	    MdRadioButton.prototype._isRippleDisabled = function () {
	        return this.disableRipple || this.disabled;
	    };
	    /**
	     * We use a hidden native input field to handle changes to focus state via keyboard navigation,
	     * with visual rendering done separately. The native element is kept in sync with the overall
	     * state of the component.
	     */
	    MdRadioButton.prototype._onInputFocus = function () {
	        this._isFocused = true;
	    };
	    /** Focuses the radio button. */
	    MdRadioButton.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	        this._onInputFocus();
	    };
	    MdRadioButton.prototype._onInputBlur = function () {
	        this._isFocused = false;
	        if (this.radioGroup) {
	            this.radioGroup._touch();
	        }
	    };
	    MdRadioButton.prototype._onInputClick = function (event) {
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `radio-button` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    /**
	     * Triggered when the radio button received a click or the input recognized any change.
	     * Clicking on a label element, will trigger a change event on the associated input.
	     */
	    MdRadioButton.prototype._onInputChange = function (event) {
	        // We always have to stop propagation on the change event.
	        // Otherwise the change event, from the input element, will bubble up and
	        // emit its event object to the `change` output.
	        event.stopPropagation();
	        var groupValueChanged = this.radioGroup && this.value != this.radioGroup.value;
	        this.checked = true;
	        this._emitChangeEvent();
	        if (this.radioGroup) {
	            this.radioGroup._controlValueAccessorChangeFn(this.value);
	            this.radioGroup._touch();
	            if (groupValueChanged) {
	                this.radioGroup._emitChangeEvent();
	            }
	        }
	    };
	    __decorate$34([
	        _angular_core.HostBinding('class.mat-radio-focused'), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "_isFocused", void 0);
	    __decorate$34([
	        _angular_core.HostBinding('id'),
	        _angular_core.Input(), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "id", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "name", void 0);
	    __decorate$34([
	        _angular_core.Input('aria-label'), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "ariaLabel", void 0);
	    __decorate$34([
	        _angular_core.Input('aria-labelledby'), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "ariaLabelledby", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "disableRipple", null);
	    __decorate$34([
	        _angular_core.Output(), 
	        __metadata$34('design:type', _angular_core.EventEmitter)
	    ], MdRadioButton.prototype, "change", void 0);
	    __decorate$34([
	        _angular_core.ViewChild('input'), 
	        __metadata$34('design:type', _angular_core.ElementRef)
	    ], MdRadioButton.prototype, "_inputElement", void 0);
	    __decorate$34([
	        _angular_core.HostBinding('class.mat-radio-checked'),
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "checked", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioButton.prototype, "value", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioButton.prototype, "align", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioButton.prototype, "labelPosition", null);
	    __decorate$34([
	        _angular_core.HostBinding('class.mat-radio-disabled'),
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "disabled", null);
	    MdRadioButton = __decorate$34([
	        _angular_core.Component({selector: 'md-radio-button, mat-radio-button',
	            template: "<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label><div class=\"mat-radio-container\"><div class=\"mat-radio-outer-circle\"></div><div class=\"mat-radio-inner-circle\"></div><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-radio-ripple\" [mdRippleTrigger]=\"label\" [mdRippleCentered]=\"true\" [mdRippleSpeedFactor]=\"0.3\"></div></div><input #input class=\"mat-radio-input cdk-visually-hidden\" type=\"radio\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [name]=\"name\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (change)=\"_onInputChange($event)\" (focus)=\"_onInputFocus()\" (blur)=\"_onInputBlur()\" (click)=\"_onInputClick($event)\"><div class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\"><ng-content></ng-content></div></label>",
	            styles: [".mat-radio-button{display:inline-block;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-radio-label{cursor:pointer;display:inline-flex;align-items:baseline;white-space:nowrap}.mat-radio-container{box-sizing:border-box;display:inline-block;height:20px;position:relative;width:20px;top:2px}.mat-radio-inner-circle,.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;top:0;width:20px;position:absolute;border-radius:50%}.mat-radio-outer-circle{transition:border-color ease 280ms;border-width:2px;border-style:solid}.mat-radio-inner-circle{transition:transform ease 280ms,background-color ease 280ms;transform:scale(0)}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}.mat-radio-label-content{display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                '[class.mat-radio-button]': 'true',
	            }
	        }),
	        __param$5(0, _angular_core.Optional()), 
	        __metadata$34('design:paramtypes', [MdRadioGroup, _angular_core.ElementRef, _angular_core.Renderer, UniqueSelectionDispatcher])
	    ], MdRadioButton);
	    return MdRadioButton;
	}());
	var MdRadioModule = (function () {
	    function MdRadioModule() {
	    }
	    /** @deprecated */
	    MdRadioModule.forRoot = function () {
	        return {
	            ngModule: MdRadioModule,
	            providers: [],
	        };
	    };
	    MdRadioModule = __decorate$34([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [MdRadioGroup, MdRadioButton, CompatibilityModule],
	            providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER, VIEWPORT_RULER_PROVIDER],
	            declarations: [MdRadioGroup, MdRadioButton],
	        }), 
	        __metadata$34('design:paramtypes', [])
	    ], MdRadioModule);
	    return MdRadioModule;
	}());
	
	/**
	 * This class manages keyboard events for selectable lists. If you pass it a query list
	 * of items, it will set the active item correctly when arrow events occur.
	 */
	var ListKeyManager = (function () {
	    function ListKeyManager(_items) {
	        this._items = _items;
	        this._tabOut = new rxjs_Subject.Subject();
	        this._wrap = false;
	    }
	    /**
	     * Turns on wrapping mode, which ensures that the active item will wrap to
	     * the other end of list when there are no more items in the given direction.
	     *
	     * @returns The ListKeyManager that the method was called on.
	     */
	    ListKeyManager.prototype.withWrap = function () {
	        this._wrap = true;
	        return this;
	    };
	    /**
	     * Sets the active item to the item at the index specified.
	     *
	     * @param index The index of the item to be set as active.
	     */
	    ListKeyManager.prototype.setActiveItem = function (index) {
	        this._activeItemIndex = index;
	        this._activeItem = this._items.toArray()[index];
	    };
	    /**
	     * Sets the active item depending on the key event passed in.
	     * @param event Keyboard event to be used for determining which element should be active.
	     */
	    ListKeyManager.prototype.onKeydown = function (event) {
	        switch (event.keyCode) {
	            case DOWN_ARROW:
	                this.setNextItemActive();
	                break;
	            case UP_ARROW:
	                this.setPreviousItemActive();
	                break;
	            case HOME:
	                this.setFirstItemActive();
	                break;
	            case END:
	                this.setLastItemActive();
	                break;
	            case TAB:
	                // Note that we shouldn't prevent the default action on tab.
	                this._tabOut.next(null);
	                return;
	            default:
	                return;
	        }
	        event.preventDefault();
	    };
	    Object.defineProperty(ListKeyManager.prototype, "activeItemIndex", {
	        /** Returns the index of the currently active item. */
	        get: function () {
	            return this._activeItemIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ListKeyManager.prototype, "activeItem", {
	        /** Returns the currently active item. */
	        get: function () {
	            return this._activeItem;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Sets the active item to the first enabled item in the list. */
	    ListKeyManager.prototype.setFirstItemActive = function () {
	        this._setActiveItemByIndex(0, 1);
	    };
	    /** Sets the active item to the last enabled item in the list. */
	    ListKeyManager.prototype.setLastItemActive = function () {
	        this._setActiveItemByIndex(this._items.length - 1, -1);
	    };
	    /** Sets the active item to the next enabled item in the list. */
	    ListKeyManager.prototype.setNextItemActive = function () {
	        this._activeItemIndex === null ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
	    };
	    /** Sets the active item to a previous enabled item in the list. */
	    ListKeyManager.prototype.setPreviousItemActive = function () {
	        this._activeItemIndex === null && this._wrap ? this.setLastItemActive()
	            : this._setActiveItemByDelta(-1);
	    };
	    /**
	     * Allows setting of the activeItemIndex without any other effects.
	     * @param index The new activeItemIndex.
	     */
	    ListKeyManager.prototype.updateActiveItemIndex = function (index) {
	        this._activeItemIndex = index;
	    };
	    Object.defineProperty(ListKeyManager.prototype, "tabOut", {
	        /**
	         * Observable that emits any time the TAB key is pressed, so components can react
	         * when focus is shifted off of the list.
	         */
	        get: function () {
	            return this._tabOut.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * This method sets the active item, given a list of items and the delta between the
	     * currently active item and the new active item. It will calculate differently
	     * depending on whether wrap mode is turned on.
	     */
	    ListKeyManager.prototype._setActiveItemByDelta = function (delta, items) {
	        if (items === void 0) { items = this._items.toArray(); }
	        this._wrap ? this._setActiveInWrapMode(delta, items)
	            : this._setActiveInDefaultMode(delta, items);
	    };
	    /**
	     * Sets the active item properly given "wrap" mode. In other words, it will continue to move
	     * down the list until it finds an item that is not disabled, and it will wrap if it
	     * encounters either end of the list.
	     */
	    ListKeyManager.prototype._setActiveInWrapMode = function (delta, items) {
	        // when active item would leave menu, wrap to beginning or end
	        this._activeItemIndex =
	            (this._activeItemIndex + delta + items.length) % items.length;
	        // skip all disabled menu items recursively until an enabled one is reached
	        if (items[this._activeItemIndex].disabled) {
	            this._setActiveInWrapMode(delta, items);
	        }
	        else {
	            this.setActiveItem(this._activeItemIndex);
	        }
	    };
	    /**
	     * Sets the active item properly given the default mode. In other words, it will
	     * continue to move down the list until it finds an item that is not disabled. If
	     * it encounters either end of the list, it will stop and not wrap.
	     */
	    ListKeyManager.prototype._setActiveInDefaultMode = function (delta, items) {
	        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);
	    };
	    /**
	     * Sets the active item to the first enabled item starting at the index specified. If the
	     * item is disabled, it will move in the fallbackDelta direction until it either
	     * finds an enabled item or encounters the end of the list.
	     */
	    ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta, items) {
	        if (items === void 0) { items = this._items.toArray(); }
	        if (!items[index]) {
	            return;
	        }
	        while (items[index].disabled) {
	            index += fallbackDelta;
	            if (!items[index]) {
	                return;
	            }
	        }
	        this.setActiveItem(index);
	    };
	    return ListKeyManager;
	}());
	
	var __extends$8 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var FocusKeyManager = (function (_super) {
	    __extends$8(FocusKeyManager, _super);
	    function FocusKeyManager(items) {
	        _super.call(this, items);
	    }
	    /**
	     * This method sets the active item to the item at the specified index.
	     * It also adds focuses the newly active item.
	     */
	    FocusKeyManager.prototype.setActiveItem = function (index) {
	        _super.prototype.setActiveItem.call(this, index);
	        this.activeItem.focus();
	    };
	    return FocusKeyManager;
	}(ListKeyManager));
	
	/**
	 * The following are all the animations for the md-select component, with each
	 * const containing the metadata for one animation.
	 *
	 * The values below match the implementation of the AngularJS Material md-select animation.
	 */
	/**
	 * This animation shrinks the placeholder text to 75% of its normal size and translates
	 * it to either the top left corner (ltr) or top right corner (rtl) of the trigger,
	 * depending on the text direction of the application.
	 */
	var transformPlaceholder = _angular_core.trigger('transformPlaceholder', [
	    _angular_core.state('floating-ltr', _angular_core.style({
	        top: '-22px',
	        left: '-2px',
	        transform: "scale(0.75)"
	    })),
	    _angular_core.state('floating-rtl', _angular_core.style({
	        top: '-22px',
	        left: '2px',
	        transform: "scale(0.75)"
	    })),
	    _angular_core.transition('* => *', _angular_core.animate("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))
	]);
	/**
	 * This animation transforms the select's overlay panel on and off the page.
	 *
	 * When the panel is attached to the DOM, it expands its width 32px, scales it up to
	 * 100% on the Y axis, fades in its border, and translates slightly up and to the
	 * side to ensure the option text correctly overlaps the trigger text.
	 *
	 * When the panel is removed from the DOM, it simply fades out linearly.
	 */
	var transformPanel = _angular_core.trigger('transformPanel', [
	    _angular_core.state('showing', _angular_core.style({
	        opacity: 1,
	        minWidth: 'calc(100% + 32px)',
	        transform: "translate3d(0,0,0) scaleY(1)"
	    })),
	    _angular_core.transition('void => *', [
	        _angular_core.style({
	            opacity: 0,
	            minWidth: '100%',
	            transform: "translate3d(0, 0, 0) scaleY(0)"
	        }),
	        _angular_core.animate("150ms cubic-bezier(0.25, 0.8, 0.25, 1)")
	    ]),
	    _angular_core.transition('* => void', [
	        _angular_core.animate('250ms 100ms linear', _angular_core.style({ opacity: 0 }))
	    ])
	]);
	/**
	 * This animation fades in the background color and text content of the
	 * select's options. It is time delayed to occur 100ms after the overlay
	 * panel has transformed in.
	 */
	var fadeInContent = _angular_core.trigger('fadeInContent', [
	    _angular_core.state('showing', _angular_core.style({ opacity: 1 })),
	    _angular_core.transition('void => showing', [
	        _angular_core.style({ opacity: 0 }),
	        _angular_core.animate("150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
	    ])
	]);
	
	var __decorate$36 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$36 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$6 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * The following style constants are necessary to save here in order
	 * to properly calculate the alignment of the selected option over
	 * the trigger element.
	 */
	/** The fixed height of every option element. */
	var SELECT_OPTION_HEIGHT = 48;
	/** The max height of the select's overlay panel */
	var SELECT_PANEL_MAX_HEIGHT = 256;
	/** The max number of options visible at once in the select panel. */
	var SELECT_MAX_OPTIONS_DISPLAYED = 5;
	/** The fixed height of the select's trigger element. */
	var SELECT_TRIGGER_HEIGHT = 30;
	/**
	 * Must adjust for the difference in height between the option and the trigger,
	 * so the text will align on the y axis.
	 * (SELECT_OPTION_HEIGHT (48) - SELECT_TRIGGER_HEIGHT (30)) / 2 = 9
	 */
	var SELECT_OPTION_HEIGHT_ADJUSTMENT = 9;
	/** The panel's padding on the x-axis */
	var SELECT_PANEL_PADDING_X = 16;
	/**
	 * The panel's padding on the y-axis. This padding indicates there are more
	 * options available if you scroll.
	 */
	var SELECT_PANEL_PADDING_Y = 16;
	/**
	 * The select panel will only "fit" inside the viewport if it is positioned at
	 * this value or more away from the viewport boundary.
	 */
	var SELECT_PANEL_VIEWPORT_PADDING = 8;
	/** Change event object that is emitted when the select value has changed. */
	var MdSelectChange = (function () {
	    function MdSelectChange(source, value) {
	        this.source = source;
	        this.value = value;
	    }
	    return MdSelectChange;
	}());
	var MdSelect = (function () {
	    function MdSelect(_element, _renderer, _viewportRuler, _changeDetectorRef, _dir, _control) {
	        this._element = _element;
	        this._renderer = _renderer;
	        this._viewportRuler = _viewportRuler;
	        this._changeDetectorRef = _changeDetectorRef;
	        this._dir = _dir;
	        this._control = _control;
	        /** Whether or not the overlay panel is open. */
	        this._panelOpen = false;
	        /** Subscriptions to option events. */
	        this._subscriptions = [];
	        /** Whether filling out the select is required in the form.  */
	        this._required = false;
	        /** Whether the select is disabled.  */
	        this._disabled = false;
	        /** The scroll position of the overlay panel, calculated to center the selected option. */
	        this._scrollTop = 0;
	        /** The animation state of the placeholder. */
	        this._placeholderState = '';
	        /** View -> model callback called when value changes */
	        this._onChange = function (value) { };
	        /** View -> model callback called when select has been touched */
	        this._onTouched = function () { };
	        /** The IDs of child options to be passed to the aria-owns attribute. */
	        this._optionIds = '';
	        /** The value of the select panel's transform-origin property. */
	        this._transformOrigin = 'top';
	        /** Whether the panel's animation is done. */
	        this._panelDoneAnimating = false;
	        /**
	         * The x-offset of the overlay panel in relation to the trigger's top start corner.
	         * This must be adjusted to align the selected option text over the trigger text when
	         * the panel opens. Will change based on LTR or RTL text direction.
	         */
	        this._offsetX = 0;
	        /**
	         * The y-offset of the overlay panel in relation to the trigger's top start corner.
	         * This must be adjusted to align the selected option text over the trigger text.
	         * when the panel opens. Will change based on the y-position of the selected option.
	         */
	        this._offsetY = 0;
	        /**
	         * This position config ensures that the top "start" corner of the overlay
	         * is aligned with with the top "start" of the origin by default (overlapping
	         * the trigger completely). If the panel cannot fit below the trigger, it
	         * will fall back to a position above the trigger.
	         */
	        this._positions = [
	            {
	                originX: 'start',
	                originY: 'top',
	                overlayX: 'start',
	                overlayY: 'top',
	            },
	            {
	                originX: 'start',
	                originY: 'bottom',
	                overlayX: 'start',
	                overlayY: 'bottom',
	            },
	        ];
	        /** Event emitted when the select has been opened. */
	        this.onOpen = new _angular_core.EventEmitter();
	        /** Event emitted when the select has been closed. */
	        this.onClose = new _angular_core.EventEmitter();
	        /** Event emitted when the selected value has been changed by the user. */
	        this.change = new _angular_core.EventEmitter();
	        if (this._control) {
	            this._control.valueAccessor = this;
	        }
	    }
	    Object.defineProperty(MdSelect.prototype, "placeholder", {
	        /** Placeholder to be shown if no value has been selected. */
	        get: function () { return this._placeholder; },
	        set: function (value) {
	            var _this = this;
	            this._placeholder = value;
	            // Must wait to record the trigger width to ensure placeholder width is included.
	            Promise.resolve(null).then(function () { return _this._triggerWidth = _this._getWidth(); });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSelect.prototype, "disabled", {
	        /** Whether the component is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSelect.prototype, "required", {
	        /** Whether the component is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdSelect.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._initKeyManager();
	        this._changeSubscription = this.options.changes.startWith(null).subscribe(function () {
	            _this._resetOptions();
	            if (_this._control) {
	                // Defer setting the value in order to avoid the "Expression
	                // has changed after it was checked" errors from Angular.
	                Promise.resolve(null).then(function () { return _this._setSelectionByValue(_this._control.value); });
	            }
	        });
	    };
	    MdSelect.prototype.ngOnDestroy = function () {
	        this._dropSubscriptions();
	        if (this._changeSubscription) {
	            this._changeSubscription.unsubscribe();
	        }
	        if (this._tabSubscription) {
	            this._tabSubscription.unsubscribe();
	        }
	    };
	    /** Toggles the overlay panel open or closed. */
	    MdSelect.prototype.toggle = function () {
	        this.panelOpen ? this.close() : this.open();
	    };
	    /** Opens the overlay panel. */
	    MdSelect.prototype.open = function () {
	        if (this.disabled || !this.options.length) {
	            return;
	        }
	        this._calculateOverlayPosition();
	        this._placeholderState = this._isRtl() ? 'floating-rtl' : 'floating-ltr';
	        this._panelOpen = true;
	    };
	    /** Closes the overlay panel and focuses the host element. */
	    MdSelect.prototype.close = function () {
	        this._panelOpen = false;
	        if (!this._selected) {
	            this._placeholderState = '';
	        }
	        this._focusHost();
	    };
	    /**
	     * Sets the select's value. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param value New value to be written to the model.
	     */
	    MdSelect.prototype.writeValue = function (value) {
	        if (this.options) {
	            this._setSelectionByValue(value);
	            this._changeDetectorRef.markForCheck();
	        }
	    };
	    /**
	     * Saves a callback function to be invoked when the select's value
	     * changes from user input. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the value changes.
	     */
	    MdSelect.prototype.registerOnChange = function (fn) {
	        this._onChange = fn;
	    };
	    /**
	     * Saves a callback function to be invoked when the select is blurred
	     * by the user. Part of the ControlValueAccessor interface required
	     * to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the component has been touched.
	     */
	    MdSelect.prototype.registerOnTouched = function (fn) {
	        this._onTouched = fn;
	    };
	    /**
	     * Disables the select. Part of the ControlValueAccessor interface required
	     * to integrate with Angular's core forms API.
	     *
	     * @param isDisabled Sets whether the component is disabled.
	     */
	    MdSelect.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    Object.defineProperty(MdSelect.prototype, "panelOpen", {
	        /** Whether or not the overlay panel is open. */
	        get: function () {
	            return this._panelOpen;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSelect.prototype, "selected", {
	        /** The currently selected option. */
	        get: function () {
	            return this._selected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdSelect.prototype._isRtl = function () {
	        return this._dir ? this._dir.value === 'rtl' : false;
	    };
	    /** The width of the trigger element. This is necessary to match
	     * the overlay width to the trigger width.
	     */
	    MdSelect.prototype._getWidth = function () {
	        return this._getTriggerRect().width;
	    };
	    /** Ensures the panel opens if activated by the keyboard. */
	    MdSelect.prototype._handleKeydown = function (event) {
	        if (event.keyCode === ENTER || event.keyCode === SPACE) {
	            this.open();
	        }
	    };
	    /**
	     * When the panel element is finished transforming in (though not fading in), it
	     * emits an event and focuses an option if the panel is open.
	     */
	    MdSelect.prototype._onPanelDone = function () {
	        if (this.panelOpen) {
	            this._focusCorrectOption();
	            this.onOpen.emit();
	        }
	        else {
	            this.onClose.emit();
	        }
	    };
	    /**
	     * When the panel content is done fading in, the _panelDoneAnimating property is
	     * set so the proper class can be added to the panel.
	     */
	    MdSelect.prototype._onFadeInDone = function () {
	        this._panelDoneAnimating = this.panelOpen;
	    };
	    /**
	     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
	     * "blur" to the panel when it opens, causing a false positive.
	     */
	    MdSelect.prototype._onBlur = function () {
	        if (!this.panelOpen) {
	            this._onTouched();
	        }
	    };
	    /** Returns the correct tabindex for the select depending on disabled state. */
	    MdSelect.prototype._getTabIndex = function () {
	        return this.disabled ? '-1' : '0';
	    };
	    /**
	     * Sets the scroll position of the scroll container. This must be called after
	     * the overlay pane is attached or the scroll container element will not yet be
	     * present in the DOM.
	     */
	    MdSelect.prototype._setScrollTop = function () {
	        var scrollContainer = this.overlayDir.overlayRef.overlayElement.querySelector('.mat-select-panel');
	        scrollContainer.scrollTop = this._scrollTop;
	    };
	    /**
	     * Sets the selected option based on a value. If no option can be
	     * found with the designated value, the select trigger is cleared.
	     */
	    MdSelect.prototype._setSelectionByValue = function (value) {
	        var options = this.options.toArray();
	        for (var i = 0; i < this.options.length; i++) {
	            if (options[i].value === value) {
	                options[i].select();
	                return;
	            }
	        }
	        // Clear selection if no item was selected.
	        this._clearSelection();
	    };
	    /** Clears the select trigger and deselects every option in the list. */
	    MdSelect.prototype._clearSelection = function () {
	        this._selected = null;
	        this._updateOptions();
	    };
	    MdSelect.prototype._getTriggerRect = function () {
	        return this.trigger.nativeElement.getBoundingClientRect();
	    };
	    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
	    MdSelect.prototype._initKeyManager = function () {
	        var _this = this;
	        this._keyManager = new FocusKeyManager(this.options);
	        this._tabSubscription = this._keyManager.tabOut.subscribe(function () {
	            _this.close();
	        });
	    };
	    /** Drops current option subscriptions and IDs and resets from scratch. */
	    MdSelect.prototype._resetOptions = function () {
	        this._dropSubscriptions();
	        this._listenToOptions();
	        this._setOptionIds();
	    };
	    /** Listens to selection events on each option. */
	    MdSelect.prototype._listenToOptions = function () {
	        var _this = this;
	        this.options.forEach(function (option) {
	            var sub = option.onSelect.subscribe(function (event) {
	                if (event.isUserInput && _this._selected !== option) {
	                    _this._emitChangeEvent(option);
	                }
	                _this._onSelect(option);
	            });
	            _this._subscriptions.push(sub);
	        });
	    };
	    /** Unsubscribes from all option subscriptions. */
	    MdSelect.prototype._dropSubscriptions = function () {
	        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
	        this._subscriptions = [];
	    };
	    /** Emits an event when the user selects an option. */
	    MdSelect.prototype._emitChangeEvent = function (option) {
	        this._onChange(option.value);
	        this.change.emit(new MdSelectChange(this, option.value));
	    };
	    /** Records option IDs to pass to the aria-owns property. */
	    MdSelect.prototype._setOptionIds = function () {
	        this._optionIds = this.options.map(function (option) { return option.id; }).join(' ');
	    };
	    /** When a new option is selected, deselects the others and closes the panel. */
	    MdSelect.prototype._onSelect = function (option) {
	        this._selected = option;
	        this._updateOptions();
	        this._setValueWidth();
	        this._placeholderState = '';
	        if (this.panelOpen) {
	            this.close();
	        }
	    };
	    /** Deselect each option that doesn't match the current selection. */
	    MdSelect.prototype._updateOptions = function () {
	        var _this = this;
	        this.options.forEach(function (option) {
	            if (option !== _this.selected) {
	                option.deselect();
	            }
	        });
	    };
	    /**
	     * Must set the width of the selected option's value programmatically
	     * because it is absolutely positioned and otherwise will not clip
	     * overflow. The selection arrow is 9px wide, add 4px of padding = 13
	     */
	    MdSelect.prototype._setValueWidth = function () {
	        this._selectedValueWidth = this._triggerWidth - 13;
	    };
	    /** Focuses the selected item. If no option is selected, it will focus
	     * the first item instead.
	     */
	    MdSelect.prototype._focusCorrectOption = function () {
	        if (this.selected) {
	            this._keyManager.setActiveItem(this._getOptionIndex(this.selected));
	        }
	        else {
	            this._keyManager.setFirstItemActive();
	        }
	    };
	    /** Focuses the host element when the panel closes. */
	    MdSelect.prototype._focusHost = function () {
	        this._renderer.invokeElementMethod(this._element.nativeElement, 'focus');
	    };
	    /** Gets the index of the provided option in the option list. */
	    MdSelect.prototype._getOptionIndex = function (option) {
	        return this.options.reduce(function (result, current, index) {
	            return result === undefined ? (option === current ? index : undefined) : result;
	        }, undefined);
	    };
	    /** Calculates the scroll position and x- and y-offsets of the overlay panel. */
	    MdSelect.prototype._calculateOverlayPosition = function () {
	        this._offsetX = this._isRtl() ? SELECT_PANEL_PADDING_X : -SELECT_PANEL_PADDING_X;
	        var panelHeight = Math.min(this.options.length * SELECT_OPTION_HEIGHT, SELECT_PANEL_MAX_HEIGHT);
	        var scrollContainerHeight = this.options.length * SELECT_OPTION_HEIGHT;
	        // The farthest the panel can be scrolled before it hits the bottom
	        var maxScroll = scrollContainerHeight - panelHeight;
	        if (this.selected) {
	            var selectedIndex = this._getOptionIndex(this.selected);
	            // We must maintain a scroll buffer so the selected option will be scrolled to the
	            // center of the overlay panel rather than the top.
	            var scrollBuffer = panelHeight / 2;
	            this._scrollTop = this._calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll);
	            this._offsetY = this._calculateOverlayOffset(selectedIndex, scrollBuffer, maxScroll);
	        }
	        else {
	            // If no option is selected, the panel centers on the first option. In this case,
	            // we must only adjust for the height difference between the option element
	            // and the trigger element, then multiply it by -1 to ensure the panel moves
	            // in the correct direction up the page.
	            this._offsetY = (SELECT_OPTION_HEIGHT - SELECT_TRIGGER_HEIGHT) / 2 * -1;
	        }
	        this._checkOverlayWithinViewport(maxScroll);
	    };
	    /**
	     * Calculates the scroll position of the select's overlay panel.
	     *
	     * Attempts to center the selected option in the panel. If the option is
	     * too high or too low in the panel to be scrolled to the center, it clamps the
	     * scroll position to the min or max scroll positions respectively.
	     */
	    MdSelect.prototype._calculateOverlayScroll = function (selectedIndex, scrollBuffer, maxScroll) {
	        var optionOffsetFromScrollTop = SELECT_OPTION_HEIGHT * selectedIndex;
	        var halfOptionHeight = SELECT_OPTION_HEIGHT / 2;
	        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the
	        // scroll container, then subtracts the scroll buffer to scroll the option down to
	        // the center of the overlay panel. Half the option height must be re-added to the
	        // scrollTop so the option is centered based on its middle, not its top edge.
	        var optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;
	        return clampValue(0, optimalScrollPosition, maxScroll);
	    };
	    /**
	     * Calculates the y-offset of the select's overlay panel in relation to the
	     * top start corner of the trigger. It has to be adjusted in order for the
	     * selected option to be aligned over the trigger when the panel opens.
	     */
	    MdSelect.prototype._calculateOverlayOffset = function (selectedIndex, scrollBuffer, maxScroll) {
	        var optionOffsetFromPanelTop;
	        if (this._scrollTop === 0) {
	            optionOffsetFromPanelTop = selectedIndex * SELECT_OPTION_HEIGHT;
	        }
	        else if (this._scrollTop === maxScroll) {
	            var firstDisplayedIndex = this.options.length - SELECT_MAX_OPTIONS_DISPLAYED;
	            var selectedDisplayIndex = selectedIndex - firstDisplayedIndex;
	            // Because the panel height is longer than the height of the options alone,
	            // there is always extra padding at the top or bottom of the panel. When
	            // scrolled to the very bottom, this padding is at the top of the panel and
	            // must be added to the offset.
	            optionOffsetFromPanelTop =
	                selectedDisplayIndex * SELECT_OPTION_HEIGHT + SELECT_PANEL_PADDING_Y;
	        }
	        else {
	            // If the option was scrolled to the middle of the panel using a scroll buffer,
	            // its offset will be the scroll buffer minus the half height that was added to
	            // center it.
	            optionOffsetFromPanelTop = scrollBuffer - SELECT_OPTION_HEIGHT / 2;
	        }
	        // The final offset is the option's offset from the top, adjusted for the height
	        // difference, multiplied by -1 to ensure that the overlay moves in the correct
	        // direction up the page.
	        return optionOffsetFromPanelTop * -1 - SELECT_OPTION_HEIGHT_ADJUSTMENT;
	    };
	    /**
	     * Checks that the attempted overlay position will fit within the viewport.
	     * If it will not fit, tries to adjust the scroll position and the associated
	     * y-offset so the panel can open fully on-screen. If it still won't fit,
	     * sets the offset back to 0 to allow the fallback position to take over.
	     */
	    MdSelect.prototype._checkOverlayWithinViewport = function (maxScroll) {
	        var viewportRect = this._viewportRuler.getViewportRect();
	        var triggerRect = this._getTriggerRect();
	        var topSpaceAvailable = triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;
	        var bottomSpaceAvailable = viewportRect.height - triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;
	        var panelHeightTop = Math.abs(this._offsetY);
	        var totalPanelHeight = Math.min(this.options.length * SELECT_OPTION_HEIGHT, SELECT_PANEL_MAX_HEIGHT);
	        var panelHeightBottom = totalPanelHeight - panelHeightTop - triggerRect.height;
	        if (panelHeightBottom > bottomSpaceAvailable) {
	            this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);
	        }
	        else if (panelHeightTop > topSpaceAvailable) {
	            this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);
	        }
	        else {
	            this._transformOrigin = this._getOriginBasedOnOption();
	        }
	    };
	    /** Adjusts the overlay panel up to fit in the viewport. */
	    MdSelect.prototype._adjustPanelUp = function (panelHeightBottom, bottomSpaceAvailable) {
	        var distanceBelowViewport = panelHeightBottom - bottomSpaceAvailable;
	        // Scrolls the panel up by the distance it was extending past the boundary, then
	        // adjusts the offset by that amount to move the panel up into the viewport.
	        this._scrollTop -= distanceBelowViewport;
	        this._offsetY -= distanceBelowViewport;
	        this._transformOrigin = this._getOriginBasedOnOption();
	        // If the panel is scrolled to the very top, it won't be able to fit the panel
	        // by scrolling, so set the offset to 0 to allow the fallback position to take
	        // effect.
	        if (this._scrollTop <= 0) {
	            this._scrollTop = 0;
	            this._offsetY = 0;
	            this._transformOrigin = "50% bottom 0px";
	        }
	    };
	    /** Adjusts the overlay panel down to fit in the viewport. */
	    MdSelect.prototype._adjustPanelDown = function (panelHeightTop, topSpaceAvailable, maxScroll) {
	        var distanceAboveViewport = panelHeightTop - topSpaceAvailable;
	        // Scrolls the panel down by the distance it was extending past the boundary, then
	        // adjusts the offset by that amount to move the panel down into the viewport.
	        this._scrollTop += distanceAboveViewport;
	        this._offsetY += distanceAboveViewport;
	        this._transformOrigin = this._getOriginBasedOnOption();
	        // If the panel is scrolled to the very bottom, it won't be able to fit the
	        // panel by scrolling, so set the offset to 0 to allow the fallback position
	        // to take effect.
	        if (this._scrollTop >= maxScroll) {
	            this._scrollTop = maxScroll;
	            this._offsetY = 0;
	            this._transformOrigin = "50% top 0px";
	            return;
	        }
	    };
	    /** Sets the transform origin point based on the selected option. */
	    MdSelect.prototype._getOriginBasedOnOption = function () {
	        var originY = Math.abs(this._offsetY) - SELECT_OPTION_HEIGHT_ADJUSTMENT + SELECT_OPTION_HEIGHT / 2;
	        return "50% " + originY + "px 0px";
	    };
	    __decorate$36([
	        _angular_core.ViewChild('trigger'), 
	        __metadata$36('design:type', _angular_core.ElementRef)
	    ], MdSelect.prototype, "trigger", void 0);
	    __decorate$36([
	        _angular_core.ViewChild(ConnectedOverlayDirective), 
	        __metadata$36('design:type', ConnectedOverlayDirective)
	    ], MdSelect.prototype, "overlayDir", void 0);
	    __decorate$36([
	        _angular_core.ContentChildren(MdOption), 
	        __metadata$36('design:type', _angular_core.QueryList)
	    ], MdSelect.prototype, "options", void 0);
	    __decorate$36([
	        _angular_core.Input(), 
	        __metadata$36('design:type', Object)
	    ], MdSelect.prototype, "placeholder", null);
	    __decorate$36([
	        _angular_core.Input(), 
	        __metadata$36('design:type', Object)
	    ], MdSelect.prototype, "disabled", null);
	    __decorate$36([
	        _angular_core.Input(), 
	        __metadata$36('design:type', Object)
	    ], MdSelect.prototype, "required", null);
	    __decorate$36([
	        _angular_core.Output(), 
	        __metadata$36('design:type', _angular_core.EventEmitter)
	    ], MdSelect.prototype, "onOpen", void 0);
	    __decorate$36([
	        _angular_core.Output(), 
	        __metadata$36('design:type', _angular_core.EventEmitter)
	    ], MdSelect.prototype, "onClose", void 0);
	    __decorate$36([
	        _angular_core.Output(), 
	        __metadata$36('design:type', _angular_core.EventEmitter)
	    ], MdSelect.prototype, "change", void 0);
	    MdSelect = __decorate$36([
	        _angular_core.Component({selector: 'md-select, mat-select',
	            template: "<div class=\"mat-select-trigger\" cdk-overlay-origin (click)=\"toggle()\" #origin=\"cdkOverlayOrigin\" #trigger><span class=\"mat-select-placeholder\" [class.mat-floating-placeholder]=\"this.selected\" [@transformPlaceholder]=\"_placeholderState\" [style.width.px]=\"_selectedValueWidth\">{{ placeholder }} </span><span class=\"mat-select-value\" *ngIf=\"selected\"><span class=\"mat-select-value-text\">{{ selected?.viewValue }}</span> </span><span class=\"mat-select-arrow\"></span> <span class=\"mat-select-underline\"></span></div><template cdk-connected-overlay [origin]=\"origin\" [open]=\"panelOpen\" hasBackdrop (backdropClick)=\"close()\" backdropClass=\"cdk-overlay-transparent-backdrop\" [positions]=\"_positions\" [minWidth]=\"_triggerWidth\" [offsetY]=\"_offsetY\" [offsetX]=\"_offsetX\" (attach)=\"_setScrollTop()\"><div class=\"mat-select-panel\" [@transformPanel]=\"'showing'\" (@transformPanel.done)=\"_onPanelDone()\" (keydown)=\"_keyManager.onKeydown($event)\" [style.transformOrigin]=\"_transformOrigin\" [class.mat-select-panel-done-animating]=\"_panelDoneAnimating\"><div class=\"mat-select-content\" [@fadeInContent]=\"'showing'\" (@fadeInContent.done)=\"_onFadeInDone()\"><ng-content></ng-content></div></div></template>",
	            styles: [".mat-select{display:inline-block;outline:0;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-select-trigger{display:flex;align-items:center;height:30px;min-width:112px;cursor:pointer;position:relative;box-sizing:border-box;font-size:16px}[aria-disabled=true] .mat-select-trigger{cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mat-select-underline{position:absolute;bottom:0;left:0;right:0;height:1px}[aria-disabled=true] .mat-select-underline{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-color:transparent;background-position:0 bottom}.mat-select-placeholder{position:relative;padding:0 2px;transform-origin:left top;flex-grow:1}.mat-select-placeholder.mat-floating-placeholder{top:-22px;left:-2px;text-align:left;transform:scale(.75)}[dir=rtl] .mat-select-placeholder{transform-origin:right top}[dir=rtl] .mat-select-placeholder.mat-floating-placeholder{left:2px;text-align:right}[aria-required=true] .mat-select-placeholder::after{content:'*'}.mat-select-value{position:absolute;max-width:calc(100% - 18px);flex-grow:1;top:0;left:0;bottom:0;display:flex;align-items:center}[dir=rtl] .mat-select-value{left:auto;right:0}.mat-select-value-text{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;line-height:30px}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px}@media screen and (-ms-high-contrast:active){.mat-select-panel{outline:solid 1px}}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                'role': 'listbox',
	                '[attr.tabindex]': '_getTabIndex()',
	                '[attr.aria-label]': 'placeholder',
	                '[attr.aria-required]': 'required.toString()',
	                '[attr.aria-disabled]': 'disabled.toString()',
	                '[attr.aria-invalid]': '_control?.invalid || "false"',
	                '[attr.aria-owns]': '_optionIds',
	                '[class.mat-select-disabled]': 'disabled',
	                '[class.mat-select]': 'true',
	                '(keydown)': '_handleKeydown($event)',
	                '(blur)': '_onBlur()'
	            },
	            animations: [
	                transformPlaceholder,
	                transformPanel,
	                fadeInContent
	            ],
	            exportAs: 'mdSelect',
	        }),
	        __param$6(4, _angular_core.Optional()),
	        __param$6(5, _angular_core.Self()),
	        __param$6(5, _angular_core.Optional()), 
	        __metadata$36('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer, ViewportRuler, _angular_core.ChangeDetectorRef, Dir, _angular_forms.NgControl])
	    ], MdSelect);
	    return MdSelect;
	}());
	/** Clamps a value n between min and max values. */
	function clampValue(min, n, max) {
	    return Math.min(Math.max(min, n), max);
	}
	
	var __decorate$35 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$35 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdSelectModule = (function () {
	    function MdSelectModule() {
	    }
	    /** @deprecated */
	    MdSelectModule.forRoot = function () {
	        return {
	            ngModule: MdSelectModule,
	            providers: []
	        };
	    };
	    MdSelectModule = __decorate$35([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, OverlayModule, MdOptionModule, CompatibilityModule],
	            exports: [MdSelect, MdOptionModule, CompatibilityModule],
	            declarations: [MdSelect],
	        }), 
	        __metadata$35('design:paramtypes', [])
	    ], MdSelectModule);
	    return MdSelectModule;
	}());
	
	var __decorate$37 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$37 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MD_SLIDE_TOGGLE_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdSlideToggle; }),
	    multi: true
	};
	// A simple change event emitted by the MdSlideToggle component.
	var MdSlideToggleChange = (function () {
	    function MdSlideToggleChange() {
	    }
	    return MdSlideToggleChange;
	}());
	// Increasing integer for generating unique ids for slide-toggle components.
	var nextId$1 = 0;
	/**
	 * Two-state control, which can be also called `switch`.
	 */
	var MdSlideToggle = (function () {
	    function MdSlideToggle(_elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	        // A unique id for the slide-toggle. By default the id is auto-generated.
	        this._uniqueId = "md-slide-toggle-" + ++nextId$1;
	        this._checked = false;
	        this._isMousedown = false;
	        this._slideRenderer = null;
	        this._disabled = false;
	        this._required = false;
	        // Needs to be public to support AOT compilation (as host binding).
	        this._hasFocus = false;
	        /** Name value will be applied to the input element if present */
	        this.name = null;
	        /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */
	        this.id = this._uniqueId;
	        /** Used to specify the tabIndex value for the underlying input element. */
	        this.tabIndex = 0;
	        /** Whether the label should appear after or before the slide-toggle. Defaults to 'after' */
	        this.labelPosition = 'after';
	        /** Used to set the aria-label attribute on the underlying input element. */
	        this.ariaLabel = null;
	        /** Used to set the aria-labelledby attribute on the underlying input element. */
	        this.ariaLabelledby = null;
	        this._change = new _angular_core.EventEmitter();
	        /** An event will be dispatched each time the slide-toggle changes its value. */
	        this.change = this._change.asObservable();
	    }
	    Object.defineProperty(MdSlideToggle.prototype, "disabled", {
	        /** Whether the slide-toggle is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlideToggle.prototype, "required", {
	        /** Whether the slide-toggle is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlideToggle.prototype, "inputId", {
	        /** Returns the unique id for the visual hidden input. */
	        get: function () { return (this.id || this._uniqueId) + "-input"; },
	        enumerable: true,
	        configurable: true
	    });
	    MdSlideToggle.prototype.ngAfterContentInit = function () {
	        this._slideRenderer = new SlideToggleRenderer(this._elementRef);
	    };
	    /**
	     * The onChangeEvent method will be also called on click.
	     * This is because everything for the slide-toggle is wrapped inside of a label,
	     * which triggers a onChange event on click.
	     */
	    MdSlideToggle.prototype._onChangeEvent = function (event) {
	        // We always have to stop propagation on the change event.
	        // Otherwise the change event, from the input element, will bubble up and
	        // emit its event object to the component's `change` output.
	        event.stopPropagation();
	        // Once a drag is currently in progress, we do not want to toggle the slide-toggle on a click.
	        if (!this.disabled && !this._slideRenderer.isDragging()) {
	            this.toggle();
	            // Emit our custom change event if the native input emitted one.
	            // It is important to only emit it, if the native input triggered one, because
	            // we don't want to trigger a change event, when the `checked` variable changes for example.
	            this._emitChangeEvent();
	        }
	    };
	    MdSlideToggle.prototype._onInputClick = function (event) {
	        this.onTouched();
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `slide-toggle` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    MdSlideToggle.prototype._setMousedown = function () {
	        var _this = this;
	        // We only *show* the focus style when focus has come to the button via the keyboard.
	        // The Material Design spec is silent on this topic, and without doing this, the
	        // button continues to look :active after clicking.
	        // @see http://marcysutton.com/button-focus-hell/
	        this._isMousedown = true;
	        setTimeout(function () { return _this._isMousedown = false; }, 100);
	    };
	    MdSlideToggle.prototype._onInputFocus = function () {
	        // Only show the focus / ripple indicator when the focus was not triggered by a mouse
	        // interaction on the component.
	        if (!this._isMousedown) {
	            this._hasFocus = true;
	        }
	    };
	    MdSlideToggle.prototype._onInputBlur = function () {
	        this._hasFocus = false;
	        this.onTouched();
	    };
	    /** Implemented as part of ControlValueAccessor. */
	    MdSlideToggle.prototype.writeValue = function (value) {
	        this.checked = value;
	    };
	    /** Implemented as part of ControlValueAccessor. */
	    MdSlideToggle.prototype.registerOnChange = function (fn) {
	        this.onChange = fn;
	    };
	    /** Implemented as part of ControlValueAccessor. */
	    MdSlideToggle.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /** Implemented as a part of ControlValueAccessor. */
	    MdSlideToggle.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    /** Focuses the slide-toggle. */
	    MdSlideToggle.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	        this._onInputFocus();
	    };
	    Object.defineProperty(MdSlideToggle.prototype, "checked", {
	        /** Whether the slide-toggle is checked. */
	        get: function () { return !!this._checked; },
	        set: function (value) {
	            if (this.checked !== !!value) {
	                this._checked = value;
	                this.onChange(this._checked);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlideToggle.prototype, "color", {
	        /** The color of the slide-toggle. Can be primary, accent, or warn. */
	        get: function () { return this._color; },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Toggles the checked state of the slide-toggle. */
	    MdSlideToggle.prototype.toggle = function () {
	        this.checked = !this.checked;
	    };
	    MdSlideToggle.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdSlideToggle.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    /** Emits the change event to the `change` output EventEmitter */
	    MdSlideToggle.prototype._emitChangeEvent = function () {
	        var event = new MdSlideToggleChange();
	        event.source = this;
	        event.checked = this.checked;
	        this._change.emit(event);
	    };
	    MdSlideToggle.prototype._onDragStart = function () {
	        if (!this.disabled) {
	            this._slideRenderer.startThumbDrag(this.checked);
	        }
	    };
	    MdSlideToggle.prototype._onDrag = function (event) {
	        if (this._slideRenderer.isDragging()) {
	            this._slideRenderer.updateThumbPosition(event.deltaX);
	        }
	    };
	    MdSlideToggle.prototype._onDragEnd = function () {
	        var _this = this;
	        if (!this._slideRenderer.isDragging()) {
	            return;
	        }
	        // Notice that we have to stop outside of the current event handler,
	        // because otherwise the click event will be fired and will reset the new checked variable.
	        setTimeout(function () {
	            _this.checked = _this._slideRenderer.stopThumbDrag();
	            _this._emitChangeEvent();
	        }, 0);
	    };
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "name", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "id", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Number)
	    ], MdSlideToggle.prototype, "tabIndex", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Object)
	    ], MdSlideToggle.prototype, "labelPosition", void 0);
	    __decorate$37([
	        _angular_core.Input('aria-label'), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "ariaLabel", void 0);
	    __decorate$37([
	        _angular_core.Input('aria-labelledby'), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "ariaLabelledby", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Boolean)
	    ], MdSlideToggle.prototype, "disabled", null);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Boolean)
	    ], MdSlideToggle.prototype, "required", null);
	    __decorate$37([
	        _angular_core.Output(), 
	        __metadata$37('design:type', rxjs_Observable.Observable)
	    ], MdSlideToggle.prototype, "change", void 0);
	    __decorate$37([
	        _angular_core.ViewChild('input'), 
	        __metadata$37('design:type', _angular_core.ElementRef)
	    ], MdSlideToggle.prototype, "_inputElement", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Object)
	    ], MdSlideToggle.prototype, "checked", null);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "color", null);
	    MdSlideToggle = __decorate$37([
	        _angular_core.Component({selector: 'md-slide-toggle, mat-slide-toggle',
	            host: {
	                '[class.mat-slide-toggle]': 'true',
	                '[class.mat-checked]': 'checked',
	                '[class.mat-disabled]': 'disabled',
	                // This mat-slide-toggle prefix will change, once the temporary ripple is removed.
	                '[class.mat-slide-toggle-focused]': '_hasFocus',
	                '[class.mat-slide-toggle-label-before]': 'labelPosition == "before"',
	                '(mousedown)': '_setMousedown()'
	            },
	            template: "<label class=\"mat-slide-toggle-label\"><div class=\"mat-slide-toggle-container\"><div class=\"mat-slide-toggle-bar\"></div><div class=\"mat-slide-toggle-thumb-container\" (slidestart)=\"_onDragStart()\" (slide)=\"_onDrag($event)\" (slideend)=\"_onDragEnd()\"><div class=\"mat-slide-toggle-thumb\"><div class=\"mat-ink-ripple\"></div></div></div><input #input class=\"mat-slide-toggle-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [tabIndex]=\"tabIndex\" [checked]=\"checked\" [disabled]=\"disabled\" [attr.name]=\"name\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (blur)=\"_onInputBlur()\" (focus)=\"_onInputFocus()\" (change)=\"_onChangeEvent($event)\" (click)=\"_onInputClick($event)\"></div><span class=\"mat-slide-toggle-content\"><ng-content></ng-content></span></label>",
	            styles: [".mat-slide-toggle{display:flex;height:24px;margin:16px 0;line-height:24px;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(100%,0,0)}.mat-slide-toggle .mat-ink-ripple{border-radius:50%;opacity:0;height:48px;left:50%;overflow:hidden;pointer-events:none;position:absolute;top:50%;transform:translate(-50%,-50%);transition:opacity ease 280ms,background-color ease 280ms;width:48px}.mat-slide-toggle.mat-slide-toggle-focused .mat-ink-ripple{opacity:1}.mat-slide-toggle.mat-slide-toggle-disabled .mat-ink-ripple{background-color:#000}.mat-slide-toggle.mat-disabled .mat-slide-toggle-container,.mat-slide-toggle.mat-disabled .mat-slide-toggle-label{cursor:default}.mat-slide-toggle-content{font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500}.mat-slide-toggle-label{display:flex;flex:1;cursor:pointer}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-container{order:2}.mat-slide-toggle-container{cursor:-webkit-grab;cursor:grab;width:36px;height:24px;position:relative}.mat-slide-toggle-container,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-container{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-container,[dir=rtl] .mat-slide-toggle-container{margin-left:8px;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;top:2px;left:0;z-index:1;width:16px;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform}.mat-slide-toggle-thumb-container.mat-dragging{transition-duration:0s}.mat-slide-toggle-thumb{position:absolute;margin:0;left:0;top:0;height:20px;width:20px;border-radius:50%;box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:1px solid #000}.mat-slide-toggle-bar{background:#fff}}.mat-slide-toggle-bar{position:absolute;left:1px;top:5px;width:34px;height:14px;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}"],
	            providers: [MD_SLIDE_TOGGLE_VALUE_ACCESSOR],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush
	        }), 
	        __metadata$37('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdSlideToggle);
	    return MdSlideToggle;
	}());
	/**
	 * Renderer for the Slide Toggle component, which separates DOM modification in its own class
	 */
	var SlideToggleRenderer = (function () {
	    function SlideToggleRenderer(_elementRef) {
	        this._elementRef = _elementRef;
	        this._thumbEl = _elementRef.nativeElement.querySelector('.mat-slide-toggle-thumb-container');
	        this._thumbBarEl = _elementRef.nativeElement.querySelector('.mat-slide-toggle-bar');
	    }
	    /** Whether the slide-toggle is currently dragging. */
	    SlideToggleRenderer.prototype.isDragging = function () {
	        return !!this._thumbBarWidth;
	    };
	    /** Initializes the drag of the slide-toggle. */
	    SlideToggleRenderer.prototype.startThumbDrag = function (checked) {
	        if (!this.isDragging()) {
	            this._thumbBarWidth = this._thumbBarEl.clientWidth - this._thumbEl.clientWidth;
	            this._checked = checked;
	            this._thumbEl.classList.add('mat-dragging');
	        }
	    };
	    /** Stops the current drag and returns the new checked value. */
	    SlideToggleRenderer.prototype.stopThumbDrag = function () {
	        if (this.isDragging()) {
	            this._thumbBarWidth = null;
	            this._thumbEl.classList.remove('mat-dragging');
	            applyCssTransform(this._thumbEl, '');
	            return this._percentage > 50;
	        }
	    };
	    /** Updates the thumb containers position from the specified distance. */
	    SlideToggleRenderer.prototype.updateThumbPosition = function (distance) {
	        this._percentage = this._getThumbPercentage(distance);
	        applyCssTransform(this._thumbEl, "translate3d(" + this._percentage + "%, 0, 0)");
	    };
	    /** Retrieves the percentage of thumb from the moved distance. */
	    SlideToggleRenderer.prototype._getThumbPercentage = function (distance) {
	        var percentage = (distance / this._thumbBarWidth) * 100;
	        // When the toggle was initially checked, then we have to start the drag at the end.
	        if (this._checked) {
	            percentage += 100;
	        }
	        return Math.max(0, Math.min(percentage, 100));
	    };
	    return SlideToggleRenderer;
	}());
	var MdSlideToggleModule = (function () {
	    function MdSlideToggleModule() {
	    }
	    /** @deprecated */
	    MdSlideToggleModule.forRoot = function () {
	        return {
	            ngModule: MdSlideToggleModule,
	            providers: []
	        };
	    };
	    MdSlideToggleModule = __decorate$37([
	        _angular_core.NgModule({
	            imports: [_angular_forms.FormsModule, CompatibilityModule],
	            exports: [MdSlideToggle, CompatibilityModule],
	            declarations: [MdSlideToggle],
	            providers: [{ provide: _angular_platformBrowser.HAMMER_GESTURE_CONFIG, useClass: GestureConfig }],
	        }), 
	        __metadata$37('design:paramtypes', [])
	    ], MdSlideToggleModule);
	    return MdSlideToggleModule;
	}());
	
	var __decorate$38 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$38 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$7 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Visually, a 30px separation between tick marks looks best. This is very subjective but it is
	 * the default separation we chose.
	 */
	var MIN_AUTO_TICK_SEPARATION = 30;
	/** The thumb gap size for a disabled slider. */
	var DISABLED_THUMB_GAP = 7;
	/** The thumb gap size for a non-active slider at its minimum value. */
	var MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
	/** The thumb gap size for an active slider at its minimum value. */
	var MIN_VALUE_ACTIVE_THUMB_GAP = 10;
	/**
	 * Provider Expression that allows md-slider to register as a ControlValueAccessor.
	 * This allows it to support [(ngModel)] and [formControl].
	 */
	var MD_SLIDER_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdSlider; }),
	    multi: true
	};
	/** A simple change event emitted by the MdSlider component. */
	var MdSliderChange = (function () {
	    function MdSliderChange() {
	    }
	    return MdSliderChange;
	}());
	/**
	 * Allows users to select from a range of values by moving the slider thumb. It is similar in
	 * behavior to the native `<input type="range">` element.
	 */
	var MdSlider = (function () {
	    function MdSlider(_dir, elementRef) {
	        this._dir = _dir;
	        /** A renderer to handle updating the slider's thumb and fill track. */
	        this._renderer = null;
	        /** The dimensions of the slider. */
	        this._sliderDimensions = null;
	        this._disabled = false;
	        this._thumbLabel = false;
	        this._controlValueAccessorChangeFn = function () { };
	        /** The last values for which a change or input event was emitted. */
	        this._lastChangeValue = null;
	        this._lastInputValue = null;
	        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
	        this.onTouched = function () { };
	        /**
	         * Whether or not the thumb is sliding.
	         * Used to determine if there should be a transition for the thumb and fill track.
	         */
	        this._isSliding = false;
	        /**
	         * Whether or not the slider is active (clicked or sliding).
	         * Used to shrink and grow the thumb as according to the Material Design spec.
	         */
	        this._isActive = false;
	        this._step = 1;
	        this._tickInterval = 0;
	        this._tickIntervalPercent = 0;
	        this._percent = 0;
	        this._value = null;
	        this._min = 0;
	        this._max = 100;
	        this._invert = false;
	        this._vertical = false;
	        /** Event emitted when the slider value has changed. */
	        this.change = new _angular_core.EventEmitter();
	        /** Event emitted when the slider thumb moves. */
	        this.input = new _angular_core.EventEmitter();
	        this._renderer = new SliderRenderer(elementRef);
	    }
	    Object.defineProperty(MdSlider.prototype, "disabled", {
	        /** Whether or not the slider is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "thumbLabel", {
	        /** Whether or not to show the thumb label. */
	        get: function () { return this._thumbLabel; },
	        set: function (value) { this._thumbLabel = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_thumbLabelDeprecated", {
	        /** @deprecated */
	        get: function () { return this._thumbLabel; },
	        set: function (value) { this._thumbLabel = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "step", {
	        /** The values at which the thumb will snap. */
	        get: function () { return this._step; },
	        set: function (v) {
	            this._step = coerceNumberProperty(v, this._step);
	            if (this._step % 1 !== 0) {
	                this._roundLabelTo = this._step.toString().split('.').pop().length;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "tickInterval", {
	        /**
	         * How often to show ticks. Relative to the step so that a tick always appears on a step.
	         * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
	         */
	        get: function () { return this._tickInterval; },
	        set: function (v) {
	            this._tickInterval = (v == 'auto') ? v : coerceNumberProperty(v, this._tickInterval);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_tickIntervalDeprecated", {
	        /** @deprecated */
	        get: function () { return this.tickInterval; },
	        set: function (v) { this.tickInterval = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "tickIntervalPercent", {
	        /** The size of a tick interval as a percentage of the size of the track. */
	        get: function () { return this._tickIntervalPercent; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "percent", {
	        /** The percentage of the slider that coincides with the value. */
	        get: function () { return this._clamp(this._percent); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "value", {
	        /** Value of the slider. */
	        get: function () {
	            // If the value needs to be read and it is still uninitialized, initialize it to the min.
	            if (this._value === null) {
	                this.value = this._min;
	            }
	            return this._value;
	        },
	        set: function (v) {
	            this._value = coerceNumberProperty(v, this._value);
	            this._percent = this._calculatePercentage(this._value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "min", {
	        /** The minimum value that the slider can have. */
	        get: function () {
	            return this._min;
	        },
	        set: function (v) {
	            this._min = coerceNumberProperty(v, this._min);
	            // If the value wasn't explicitly set by the user, set it to the min.
	            if (this._value === null) {
	                this.value = this._min;
	            }
	            this._percent = this._calculatePercentage(this.value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "max", {
	        /** The maximum value that the slider can have. */
	        get: function () {
	            return this._max;
	        },
	        set: function (v) {
	            this._max = coerceNumberProperty(v, this._max);
	            this._percent = this._calculatePercentage(this.value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "invert", {
	        /** Whether the slider is inverted. */
	        get: function () { return this._invert; },
	        set: function (value) { this._invert = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "vertical", {
	        /** Whether the slider is vertical. */
	        get: function () { return this._vertical; },
	        set: function (value) { this._vertical = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "displayValue", {
	        /** The value to be used for display purposes. */
	        get: function () {
	            // Note that this could be improved further by rounding something like 0.999 to 1 or
	            // 0.899 to 0.9, however it is very performance sensitive, because it gets called on
	            // every change detection cycle.
	            if (this._roundLabelTo && this.value % 1 !== 0) {
	                return this.value.toFixed(this._roundLabelTo);
	            }
	            return this.value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "invertAxis", {
	        /**
	         * Whether the axis of the slider is inverted.
	         * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
	         */
	        get: function () {
	            // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to
	            // top. However from a y-axis standpoint this is inverted.
	            return this.vertical ? !this.invert : this.invert;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "invertMouseCoords", {
	        /**
	         * Whether mouse events should be converted to a slider position by calculating their distance
	         * from the right or bottom edge of the slider as opposed to the top or left.
	         */
	        get: function () {
	            return (this.direction == 'rtl' && !this.vertical) ? !this.invertAxis : this.invertAxis;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_isMinValue", {
	        /** Whether the slider is at its minimum value. */
	        get: function () {
	            return this.percent === 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_thumbGap", {
	        /**
	         * The amount of space to leave between the slider thumb and the track fill & track background
	         * elements.
	         */
	        get: function () {
	            if (this.disabled) {
	                return DISABLED_THUMB_GAP;
	            }
	            if (this._isMinValue && !this.thumbLabel) {
	                return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
	            }
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "trackBackgroundStyles", {
	        /** CSS styles for the track background element. */
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            var sign = this.invertMouseCoords ? '-' : '';
	            return {
	                'transform': "translate" + axis + "(" + sign + this._thumbGap + "px) scale" + axis + "(" + (1 - this.percent) + ")"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "trackFillStyles", {
	        /** CSS styles for the track fill element. */
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            var sign = this.invertMouseCoords ? '' : '-';
	            return {
	                'transform': "translate" + axis + "(" + sign + this._thumbGap + "px) scale" + axis + "(" + this.percent + ")"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "ticksContainerStyles", {
	        /** CSS styles for the ticks container element. */
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            // For a horizontal slider in RTL languages we push the ticks container off the left edge
	            // instead of the right edge to avoid causing a horizontal scrollbar to appear.
	            var sign = !this.vertical && this.direction == 'rtl' ? '' : '-';
	            var offset = this.tickIntervalPercent / 2 * 100;
	            return {
	                'transform': "translate" + axis + "(" + sign + offset + "%)"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "ticksStyles", {
	        /** CSS styles for the ticks element. */
	        get: function () {
	            var tickSize = this.tickIntervalPercent * 100;
	            var backgroundSize = this.vertical ? "2px " + tickSize + "%" : tickSize + "% 2px";
	            var axis = this.vertical ? 'Y' : 'X';
	            // Depending on the direction we pushed the ticks container, push the ticks the opposite
	            // direction to re-center them but clip off the end edge. In RTL languages we need to flip the
	            // ticks 180 degrees so we're really cutting off the end edge abd not the start.
	            var sign = !this.vertical && this.direction == 'rtl' ? '-' : '';
	            var rotate = !this.vertical && this.direction == 'rtl' ? ' rotate(180deg)' : '';
	            var styles = {
	                'backgroundSize': backgroundSize,
	                // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
	                'transform': "translateZ(0) translate" + axis + "(" + sign + tickSize / 2 + "%)" + rotate
	            };
	            if (this._isMinValue && this._thumbGap) {
	                var side = this.vertical ?
	                    (this.invertAxis ? 'Bottom' : 'Top') :
	                    (this.invertAxis ? 'Right' : 'Left');
	                styles[("padding" + side)] = this._thumbGap + "px";
	            }
	            return styles;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "thumbContainerStyles", {
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            // For a horizontal slider in RTL languages we push the thumb container off the left edge
	            // instead of the right edge to avoid causing a horizontal scrollbar to appear.
	            var invertOffset = (this.direction == 'rtl' && !this.vertical) ? !this.invertAxis : this.invertAxis;
	            var offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
	            return {
	                'transform': "translate" + axis + "(-" + offset + "%)"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "direction", {
	        /** The language direction for this slider element. */
	        get: function () {
	            return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdSlider.prototype._onMouseenter = function () {
	        if (this.disabled) {
	            return;
	        }
	        // We save the dimensions of the slider here so we can use them to update the spacing of the
	        // ticks and determine where on the slider click and slide events happen.
	        this._sliderDimensions = this._renderer.getSliderDimensions();
	        this._updateTickIntervalPercent();
	    };
	    MdSlider.prototype._onClick = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        this._isActive = true;
	        this._isSliding = false;
	        this._renderer.addFocus();
	        this._updateValueFromPosition({ x: event.clientX, y: event.clientY });
	        /* Emits a change and input event if the value changed. */
	        this._emitInputEvent();
	        this._emitValueIfChanged();
	    };
	    MdSlider.prototype._onSlide = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        // Prevent the slide from selecting anything else.
	        event.preventDefault();
	        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
	        // Native range elements always emit `input` events when the value changed while sliding.
	        this._emitInputEvent();
	    };
	    MdSlider.prototype._onSlideStart = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        // Simulate mouseenter in case this is a mobile device.
	        this._onMouseenter();
	        event.preventDefault();
	        this._isSliding = true;
	        this._isActive = true;
	        this._renderer.addFocus();
	        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
	    };
	    MdSlider.prototype._onSlideEnd = function () {
	        this._isSliding = false;
	        this._emitValueIfChanged();
	    };
	    MdSlider.prototype._onBlur = function () {
	        this._isActive = false;
	        this.onTouched();
	    };
	    MdSlider.prototype._onKeydown = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        switch (event.keyCode) {
	            case PAGE_UP:
	                this._increment(10);
	                break;
	            case PAGE_DOWN:
	                this._increment(-10);
	                break;
	            case END:
	                this.value = this.max;
	                break;
	            case HOME:
	                this.value = this.min;
	                break;
	            case LEFT_ARROW:
	                // NOTE: For a sighted user it would make more sense that when they press an arrow key on an
	                // inverted slider the thumb moves in that direction. However for a blind user, nothing
	                // about the slider indicates that it is inverted. They will expect left to be decrement,
	                // regardless of how it appears on the screen. For speakers ofRTL languages, they probably
	                // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for
	                // RTL. For inverted sliders we prefer a good a11y experience to having it "look right" for
	                // sighted users, therefore we do not swap the meaning.
	                this._increment(this.direction == 'rtl' ? 1 : -1);
	                break;
	            case UP_ARROW:
	                this._increment(1);
	                break;
	            case RIGHT_ARROW:
	                // See comment on LEFT_ARROW about the conditions under which we flip the meaning.
	                this._increment(this.direction == 'rtl' ? -1 : 1);
	                break;
	            case DOWN_ARROW:
	                this._increment(-1);
	                break;
	            default:
	                // Return if the key is not one that we explicitly handle to avoid calling preventDefault on
	                // it.
	                return;
	        }
	        this._isSliding = true;
	        event.preventDefault();
	    };
	    MdSlider.prototype._onKeyup = function () {
	        this._isSliding = false;
	    };
	    /** Increments the slider by the given number of steps (negative number decrements). */
	    MdSlider.prototype._increment = function (numSteps) {
	        this.value = this._clamp(this.value + this.step * numSteps, this.min, this.max);
	        this._emitInputEvent();
	        this._emitValueIfChanged();
	    };
	    /** Calculate the new value from the new physical location. The value will always be snapped. */
	    MdSlider.prototype._updateValueFromPosition = function (pos) {
	        if (!this._sliderDimensions) {
	            return;
	        }
	        var offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
	        var size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
	        var posComponent = this.vertical ? pos.y : pos.x;
	        // The exact value is calculated from the event and used to find the closest snap value.
	        var percent = this._clamp((posComponent - offset) / size);
	        if (this.invertMouseCoords) {
	            percent = 1 - percent;
	        }
	        var exactValue = this._calculateValue(percent);
	        // This calculation finds the closest step by finding the closest whole number divisible by the
	        // step relative to the min.
	        var closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
	        // The value needs to snap to the min and max.
	        this.value = this._clamp(closestValue, this.min, this.max);
	    };
	    /** Emits a change event if the current value is different from the last emitted value. */
	    MdSlider.prototype._emitValueIfChanged = function () {
	        if (this.value != this._lastChangeValue) {
	            var event_1 = this._createChangeEvent();
	            this._lastChangeValue = this.value;
	            this._controlValueAccessorChangeFn(this.value);
	            this.change.emit(event_1);
	        }
	    };
	    /** Emits an input event when the current value is different from the last emitted value. */
	    MdSlider.prototype._emitInputEvent = function () {
	        if (this.value != this._lastInputValue) {
	            var event_2 = this._createChangeEvent();
	            this._lastInputValue = this.value;
	            this.input.emit(event_2);
	        }
	    };
	    /** Updates the amount of space between ticks as a percentage of the width of the slider. */
	    MdSlider.prototype._updateTickIntervalPercent = function () {
	        if (!this.tickInterval) {
	            return;
	        }
	        if (this.tickInterval == 'auto') {
	            var trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
	            var pixelsPerStep = trackSize * this.step / (this.max - this.min);
	            var stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
	            var pixelsPerTick = stepsPerTick * this.step;
	            this._tickIntervalPercent = pixelsPerTick / trackSize;
	        }
	        else {
	            this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
	        }
	    };
	    /** Creates a slider change object from the specified value. */
	    MdSlider.prototype._createChangeEvent = function (value) {
	        if (value === void 0) { value = this.value; }
	        var event = new MdSliderChange();
	        event.source = this;
	        event.value = value;
	        return event;
	    };
	    /** Calculates the percentage of the slider that a value is. */
	    MdSlider.prototype._calculatePercentage = function (value) {
	        return (value - this.min) / (this.max - this.min);
	    };
	    /** Calculates the value a percentage of the slider corresponds to. */
	    MdSlider.prototype._calculateValue = function (percentage) {
	        return this.min + percentage * (this.max - this.min);
	    };
	    /** Return a number between two numbers. */
	    MdSlider.prototype._clamp = function (value, min, max) {
	        if (min === void 0) { min = 0; }
	        if (max === void 0) { max = 1; }
	        return Math.max(min, Math.min(value, max));
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value
	     */
	    MdSlider.prototype.writeValue = function (value) {
	        this.value = value;
	    };
	    /**
	     * Registers a callback to eb triggered when the value has changed.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdSlider.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback to be triggered when the component is touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdSlider.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Sets whether the component should be disabled.
	     * Implemented as part of ControlValueAccessor.
	     * @param isDisabled
	     */
	    MdSlider.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Boolean)
	    ], MdSlider.prototype, "disabled", null);
	    __decorate$38([
	        _angular_core.Input('thumbLabel'), 
	        __metadata$38('design:type', Boolean)
	    ], MdSlider.prototype, "thumbLabel", null);
	    __decorate$38([
	        _angular_core.Input('thumb-label'), 
	        __metadata$38('design:type', Boolean)
	    ], MdSlider.prototype, "_thumbLabelDeprecated", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "step", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "tickInterval", null);
	    __decorate$38([
	        _angular_core.Input('tick-interval'), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "_tickIntervalDeprecated", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "value", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "min", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "max", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "invert", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "vertical", null);
	    __decorate$38([
	        _angular_core.Output(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "change", void 0);
	    __decorate$38([
	        _angular_core.Output(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "input", void 0);
	    MdSlider = __decorate$38([
	        _angular_core.Component({selector: 'md-slider, mat-slider',
	            providers: [MD_SLIDER_VALUE_ACCESSOR],
	            host: {
	                '[class.mat-slider]': 'true',
	                '(blur)': '_onBlur()',
	                '(click)': '_onClick($event)',
	                '(keydown)': '_onKeydown($event)',
	                '(keyup)': '_onKeyup()',
	                '(mouseenter)': '_onMouseenter()',
	                '(slide)': '_onSlide($event)',
	                '(slideend)': '_onSlideEnd()',
	                '(slidestart)': '_onSlideStart($event)',
	                'role': 'slider',
	                'tabindex': '0',
	                '[attr.aria-disabled]': 'disabled',
	                '[attr.aria-valuemax]': 'max',
	                '[attr.aria-valuemin]': 'min',
	                '[attr.aria-valuenow]': 'value',
	                '[class.mat-slider-active]': '_isActive',
	                '[class.mat-slider-disabled]': 'disabled',
	                '[class.mat-slider-has-ticks]': 'tickInterval',
	                '[class.mat-slider-horizontal]': '!vertical',
	                '[class.mat-slider-axis-inverted]': 'invertAxis',
	                '[class.mat-slider-sliding]': '_isSliding',
	                '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
	                '[class.mat-slider-vertical]': 'vertical',
	                '[class.mat-slider-min-value]': '_isMinValue',
	                '[class.mat-slider-hide-last-tick]': '_isMinValue && _thumbGap && invertAxis',
	            },
	            template: "<div class=\"mat-slider-wrapper\"><div class=\"mat-slider-track-wrapper\"><div class=\"mat-slider-track-background\" [ngStyle]=\"trackBackgroundStyles\"></div><div class=\"mat-slider-track-fill\" [ngStyle]=\"trackFillStyles\"></div></div><div class=\"mat-slider-ticks-container\" [ngStyle]=\"ticksContainerStyles\"><div class=\"mat-slider-ticks\" [ngStyle]=\"ticksStyles\"></div></div><div class=\"mat-slider-thumb-container\" [ngStyle]=\"thumbContainerStyles\"><div class=\"mat-slider-thumb\"></div><div class=\"mat-slider-thumb-label\"><span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span></div></div></div>",
	            styles: [".mat-slider-track-background,.mat-slider-track-fill{transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0}.mat-slider-track-background{position:absolute;transform-origin:100% 100%}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-disabled .mat-slider-ticks{opacity:0}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label-text{z-index:1;font-size:12px;font-weight:700;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:'';position:absolute;border:0 solid rgba(0,0,0,.6);opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-active .mat-slider-thumb-label-text,.mat-slider-has-ticks.mat-slider-active .mat-slider-ticks,.mat-slider-has-ticks.mat-slider-active:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider-active .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-active.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider-active .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.mat-slider-horizontal .mat-slider-ticks{background:repeating-linear-gradient(to right,rgba(0,0,0,.6),rgba(0,0,0,.6) 2px,transparent 0,transparent);background:-moz-repeating-linear-gradient(.0001deg,rgba(0,0,0,.6),rgba(0,0,0,.6) 2px,transparent 0,transparent);background-clip:content-box;height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.mat-slider-active .mat-slider-thumb-label{transform:rotate(45deg)}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.mat-slider-vertical .mat-slider-ticks{background:repeating-linear-gradient(to bottom,rgba(0,0,0,.6),rgba(0,0,0,.6) 2px,transparent 0,transparent);background-clip:content-box;width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.mat-slider-active .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background,[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }),
	        __param$7(0, _angular_core.Optional()), 
	        __metadata$38('design:paramtypes', [Dir, _angular_core.ElementRef])
	    ], MdSlider);
	    return MdSlider;
	}());
	/**
	 * Renderer class in order to keep all dom manipulation in one place and outside of the main class.
	 * @docs-private
	 */
	var SliderRenderer = (function () {
	    function SliderRenderer(elementRef) {
	        this._sliderElement = elementRef.nativeElement;
	    }
	    /**
	     * Get the bounding client rect of the slider track element.
	     * The track is used rather than the native element to ignore the extra space that the thumb can
	     * take up.
	     */
	    SliderRenderer.prototype.getSliderDimensions = function () {
	        var wrapperElement = this._sliderElement.querySelector('.mat-slider-wrapper');
	        return wrapperElement.getBoundingClientRect();
	    };
	    /**
	     * Focuses the native element.
	     * Currently only used to allow a blur event to fire but will be used with keyboard input later.
	     */
	    SliderRenderer.prototype.addFocus = function () {
	        this._sliderElement.focus();
	    };
	    return SliderRenderer;
	}());
	var MdSliderModule = (function () {
	    function MdSliderModule() {
	    }
	    /** @deprecated */
	    MdSliderModule.forRoot = function () {
	        return {
	            ngModule: MdSliderModule,
	            providers: []
	        };
	    };
	    MdSliderModule = __decorate$38([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, _angular_forms.FormsModule, CompatibilityModule],
	            exports: [MdSlider, CompatibilityModule],
	            declarations: [MdSlider],
	            providers: [{ provide: _angular_platformBrowser.HAMMER_GESTURE_CONFIG, useClass: GestureConfig }]
	        }), 
	        __metadata$38('design:paramtypes', [])
	    ], MdSliderModule);
	    return MdSliderModule;
	}());
	
	var __extends$9 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$39 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$39 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$8 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** Exception thrown when two MdSidenav are matching the same side. */
	var MdDuplicatedSidenavError = (function (_super) {
	    __extends$9(MdDuplicatedSidenavError, _super);
	    function MdDuplicatedSidenavError(align) {
	        _super.call(this, "A sidenav was already declared for 'align=\"" + align + "\"'");
	    }
	    return MdDuplicatedSidenavError;
	}(MdError));
	/** Sidenav toggle promise result. */
	var MdSidenavToggleResult = (function () {
	    function MdSidenavToggleResult(type, animationFinished) {
	        this.type = type;
	        this.animationFinished = animationFinished;
	    }
	    return MdSidenavToggleResult;
	}());
	/**
	 * <md-sidenav> component.
	 *
	 * This component corresponds to the drawer of the sidenav.
	 *
	 * Please refer to README.md for examples on how to use it.
	 */
	var MdSidenav = (function () {
	    /**
	     * @param _elementRef The DOM element reference. Used for transition and width calculation.
	     *     If not available we do not hook on transitions.
	     */
	    function MdSidenav(_elementRef, _renderer) {
	        var _this = this;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** Alignment of the sidenav (direction neutral); whether 'start' or 'end'. */
	        this._align = 'start';
	        this._valid = true;
	        /** Mode of the sidenav; whether 'over' or 'side'. */
	        this.mode = 'over';
	        this._disableClose = false;
	        /** Whether the sidenav is opened. */
	        this._opened = false;
	        /** Event emitted when the sidenav is being opened. Use this to synchronize animations. */
	        this.onOpenStart = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav is fully opened. */
	        this.onOpen = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav is being closed. Use this to synchronize animations. */
	        this.onCloseStart = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav is fully closed. */
	        this.onClose = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav alignment changes. */
	        this.onAlignChanged = new _angular_core.EventEmitter();
	        /** The current toggle animation promise. `null` if no animation is in progress. */
	        this._toggleAnimationPromise = null;
	        /**
	         * The current toggle animation promise resolution function.
	         * `null` if no animation is in progress.
	         */
	        this._resolveToggleAnimationPromise = null;
	        this._elementFocusedBeforeSidenavWasOpened = null;
	        this.onOpen.subscribe(function () {
	            _this._elementFocusedBeforeSidenavWasOpened = document.activeElement;
	            if (!_this.isFocusTrapDisabled) {
	                _this._focusTrap.focusFirstTabbableElementWhenReady();
	            }
	        });
	        this.onClose.subscribe(function () {
	            if (_this._elementFocusedBeforeSidenavWasOpened instanceof HTMLElement) {
	                _this._renderer.invokeElementMethod(_this._elementFocusedBeforeSidenavWasOpened, 'focus');
	            }
	            else {
	                _this._renderer.invokeElementMethod(_this._elementRef.nativeElement, 'blur');
	            }
	            _this._elementFocusedBeforeSidenavWasOpened = null;
	        });
	    }
	    Object.defineProperty(MdSidenav.prototype, "valid", {
	        /** Whether this md-sidenav is part of a valid md-sidenav-container configuration. */
	        get: function () { return this._valid; },
	        set: function (value) {
	            value = coerceBooleanProperty(value);
	            // When the drawers are not in a valid configuration we close them all until they are in a valid
	            // configuration again.
	            if (!value) {
	                this.close();
	            }
	            this._valid = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "align", {
	        /** Direction which the sidenav is aligned in. */
	        get: function () { return this._align; },
	        set: function (value) {
	            // Make sure we have a valid value.
	            value = (value == 'end') ? 'end' : 'start';
	            if (value != this._align) {
	                this._align = value;
	                this.onAlignChanged.emit();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "disableClose", {
	        /** Whether the sidenav can be closed with the escape key or not. */
	        get: function () { return this._disableClose; },
	        set: function (value) { this._disableClose = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "isFocusTrapDisabled", {
	        get: function () {
	            // The focus trap is only enabled when the sidenav is open in any mode other than side.
	            return !this.opened || this.mode == 'side';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdSidenav.prototype.ngAfterContentInit = function () {
	        // This can happen when the sidenav is set to opened in the template and the transition
	        // isn't ended.
	        if (this._toggleAnimationPromise) {
	            this._resolveToggleAnimationPromise(true);
	            this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;
	        }
	    };
	    Object.defineProperty(MdSidenav.prototype, "opened", {
	        /**
	         * Whether the sidenav is opened. We overload this because we trigger an event when it
	         * starts or end.
	         */
	        get: function () { return this._opened; },
	        set: function (v) {
	            this.toggle(coerceBooleanProperty(v));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Open this sidenav, and return a Promise that will resolve when it's fully opened (or get
	     * rejected if it didn't). */
	    MdSidenav.prototype.open = function () {
	        return this.toggle(true);
	    };
	    /**
	     * Close this sidenav, and return a Promise that will resolve when it's fully closed (or get
	     * rejected if it didn't).
	     */
	    MdSidenav.prototype.close = function () {
	        return this.toggle(false);
	    };
	    /**
	     * Toggle this sidenav. This is equivalent to calling open() when it's already opened, or
	     * close() when it's closed.
	     * @param isOpen Whether the sidenav should be open.
	     * @returns Resolves with the result of whether the sidenav was opened or closed.
	     */
	    MdSidenav.prototype.toggle = function (isOpen) {
	        var _this = this;
	        if (isOpen === void 0) { isOpen = !this.opened; }
	        if (!this.valid) {
	            return Promise.resolve(new MdSidenavToggleResult(isOpen ? 'open' : 'close', true));
	        }
	        // Shortcut it if we're already opened.
	        if (isOpen === this.opened) {
	            return this._toggleAnimationPromise ||
	                Promise.resolve(new MdSidenavToggleResult(isOpen ? 'open' : 'close', true));
	        }
	        this._opened = isOpen;
	        if (isOpen) {
	            this.onOpenStart.emit();
	        }
	        else {
	            this.onCloseStart.emit();
	        }
	        if (this._toggleAnimationPromise) {
	            this._resolveToggleAnimationPromise(false);
	        }
	        this._toggleAnimationPromise = new Promise(function (resolve) {
	            _this._resolveToggleAnimationPromise = function (animationFinished) {
	                return resolve(new MdSidenavToggleResult(isOpen ? 'open' : 'close', animationFinished));
	            };
	        });
	        return this._toggleAnimationPromise;
	    };
	    /**
	     * Handles the keyboard events.
	     * @docs-private
	     */
	    MdSidenav.prototype.handleKeydown = function (event) {
	        if (event.keyCode === ESCAPE && !this.disableClose) {
	            this.close();
	            event.stopPropagation();
	        }
	    };
	    /**
	     * When transition has finished, set the internal state for classes and emit the proper event.
	     * The event passed is actually of type TransitionEvent, but that type is not available in
	     * Android so we use any.
	     */
	    MdSidenav.prototype._onTransitionEnd = function (transitionEvent) {
	        if (transitionEvent.target == this._elementRef.nativeElement
	            && transitionEvent.propertyName.endsWith('transform')) {
	            if (this._opened) {
	                this.onOpen.emit();
	            }
	            else {
	                this.onClose.emit();
	            }
	            if (this._toggleAnimationPromise) {
	                this._resolveToggleAnimationPromise(true);
	                this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;
	            }
	        }
	    };
	    Object.defineProperty(MdSidenav.prototype, "_isClosing", {
	        get: function () {
	            return !this._opened && !!this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isOpening", {
	        get: function () {
	            return this._opened && !!this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isClosed", {
	        get: function () {
	            return !this._opened && !this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isOpened", {
	        get: function () {
	            return this._opened && !this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isEnd", {
	        get: function () {
	            return this.align == 'end';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_modeSide", {
	        get: function () {
	            return this.mode == 'side';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_modeOver", {
	        get: function () {
	            return this.mode == 'over';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_modePush", {
	        get: function () {
	            return this.mode == 'push';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_width", {
	        get: function () {
	            if (this._elementRef.nativeElement) {
	                return this._elementRef.nativeElement.offsetWidth;
	            }
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$39([
	        _angular_core.ViewChild(FocusTrap), 
	        __metadata$39('design:type', FocusTrap)
	    ], MdSidenav.prototype, "_focusTrap", void 0);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "align", null);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "mode", void 0);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Boolean)
	    ], MdSidenav.prototype, "disableClose", null);
	    __decorate$39([
	        _angular_core.Output('open-start'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onOpenStart", void 0);
	    __decorate$39([
	        _angular_core.Output('open'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onOpen", void 0);
	    __decorate$39([
	        _angular_core.Output('close-start'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onCloseStart", void 0);
	    __decorate$39([
	        _angular_core.Output('close'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onClose", void 0);
	    __decorate$39([
	        _angular_core.Output('align-changed'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onAlignChanged", void 0);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Boolean)
	    ], MdSidenav.prototype, "opened", null);
	    MdSidenav = __decorate$39([
	        _angular_core.Component({selector: 'md-sidenav, mat-sidenav',
	            // TODO(mmalerba): move template to separate file.
	            template: "<cdk-focus-trap class=\"mat-sidenav-focus-trap\" [disabled]=\"isFocusTrapDisabled\"><ng-content></ng-content></cdk-focus-trap>",
	            host: {
	                '[class.mat-sidenav]': 'true',
	                '(transitionend)': '_onTransitionEnd($event)',
	                '(keydown)': 'handleKeydown($event)',
	                // must prevent the browser from aligning text based on value
	                '[attr.align]': 'null',
	                '[class.mat-sidenav-closed]': '_isClosed',
	                '[class.mat-sidenav-closing]': '_isClosing',
	                '[class.mat-sidenav-end]': '_isEnd',
	                '[class.mat-sidenav-opened]': '_isOpened',
	                '[class.mat-sidenav-opening]': '_isOpening',
	                '[class.mat-sidenav-over]': '_modeOver',
	                '[class.mat-sidenav-push]': '_modePush',
	                '[class.mat-sidenav-side]': '_modeSide',
	                '[class.mat-sidenav-invalid]': '!valid',
	                'tabIndex': '-1'
	            },
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$39('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdSidenav);
	    return MdSidenav;
	}());
	/**
	 * <md-sidenav-container> component.
	 *
	 * This is the parent component to one or two <md-sidenav>s that validates the state internally
	 * and coordinates the backdrop and content styling.
	 */
	var MdSidenavContainer = (function () {
	    function MdSidenavContainer(_dir, _element, _renderer, _ngZone) {
	        var _this = this;
	        this._dir = _dir;
	        this._element = _element;
	        this._renderer = _renderer;
	        this._ngZone = _ngZone;
	        /** Event emitted when the sidenav backdrop is clicked. */
	        this.backdropClick = new _angular_core.EventEmitter();
	        /** Whether to enable open/close trantions. */
	        this._enableTransitions = false;
	        // If a `Dir` directive exists up the tree, listen direction changes and update the left/right
	        // properties to point to the proper start/end.
	        if (_dir != null) {
	            _dir.dirChange.subscribe(function () { return _this._validateDrawers(); });
	        }
	    }
	    Object.defineProperty(MdSidenavContainer.prototype, "start", {
	        /** The sidenav child with the `start` alignment. */
	        get: function () { return this._start; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenavContainer.prototype, "end", {
	        /** The sidenav child with the `end` alignment. */
	        get: function () { return this._end; },
	        enumerable: true,
	        configurable: true
	    });
	    MdSidenavContainer.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        // On changes, assert on consistency.
	        this._sidenavs.changes.subscribe(function () { return _this._validateDrawers(); });
	        this._sidenavs.forEach(function (sidenav) {
	            _this._watchSidenavToggle(sidenav);
	            _this._watchSidenavAlign(sidenav);
	        });
	        this._validateDrawers();
	        // Give the view a chance to render the initial state, then enable transitions.
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () { return _this._enableTransitions = true; });
	    };
	    /**
	     * Subscribes to sidenav events in order to set a class on the main container element when the
	     * sidenav is open and the backdrop is visible. This ensures any overflow on the container element
	     * is properly hidden.
	     */
	    MdSidenavContainer.prototype._watchSidenavToggle = function (sidenav) {
	        var _this = this;
	        if (!sidenav || sidenav.mode === 'side') {
	            return;
	        }
	        sidenav.onOpen.subscribe(function () { return _this._setContainerClass(sidenav, true); });
	        sidenav.onClose.subscribe(function () { return _this._setContainerClass(sidenav, false); });
	    };
	    /**
	     * Subscribes to sidenav onAlignChanged event in order to re-validate drawers when the align
	     * changes.
	     */
	    MdSidenavContainer.prototype._watchSidenavAlign = function (sidenav) {
	        var _this = this;
	        if (!sidenav) {
	            return;
	        }
	        sidenav.onAlignChanged.subscribe(function () { return _this._validateDrawers(); });
	    };
	    /** Toggles the 'mat-sidenav-opened' class on the main 'md-sidenav-container' element. */
	    MdSidenavContainer.prototype._setContainerClass = function (sidenav, bool) {
	        this._renderer.setElementClass(this._element.nativeElement, 'mat-sidenav-opened', bool);
	    };
	    /** Sets the valid state of the drawers. */
	    MdSidenavContainer.prototype._setDrawersValid = function (valid) {
	        this._sidenavs.forEach(function (sidenav) {
	            sidenav.valid = valid;
	        });
	        if (!valid) {
	            this._start = this._end = this._left = this._right = null;
	        }
	    };
	    /** Validate the state of the sidenav children components. */
	    MdSidenavContainer.prototype._validateDrawers = function () {
	        this._start = this._end = null;
	        // Ensure that we have at most one start and one end sidenav.
	        // NOTE: We must call toArray on _sidenavs even though it's iterable
	        // (see https://github.com/Microsoft/TypeScript/issues/3164).
	        for (var _i = 0, _a = this._sidenavs.toArray(); _i < _a.length; _i++) {
	            var sidenav = _a[_i];
	            if (sidenav.align == 'end') {
	                if (this._end != null) {
	                    this._setDrawersValid(false);
	                    return;
	                }
	                this._end = sidenav;
	            }
	            else {
	                if (this._start != null) {
	                    this._setDrawersValid(false);
	                    return;
	                }
	                this._start = sidenav;
	            }
	        }
	        this._right = this._left = null;
	        // Detect if we're LTR or RTL.
	        if (this._dir == null || this._dir.value == 'ltr') {
	            this._left = this._start;
	            this._right = this._end;
	        }
	        else {
	            this._left = this._end;
	            this._right = this._start;
	        }
	        this._setDrawersValid(true);
	    };
	    MdSidenavContainer.prototype._onBackdropClicked = function () {
	        this.backdropClick.emit();
	        this._closeModalSidenav();
	    };
	    MdSidenavContainer.prototype._closeModalSidenav = function () {
	        // Close all open sidenav's where closing is not disabled and the mode is not `side`.
	        [this._start, this._end]
	            .filter(function (sidenav) { return sidenav && !sidenav.disableClose && sidenav.mode !== 'side'; })
	            .forEach(function (sidenav) { return sidenav.close(); });
	    };
	    MdSidenavContainer.prototype._isShowingBackdrop = function () {
	        return (this._isSidenavOpen(this._start) && this._start.mode != 'side')
	            || (this._isSidenavOpen(this._end) && this._end.mode != 'side');
	    };
	    MdSidenavContainer.prototype._isSidenavOpen = function (side) {
	        return side != null && side.opened;
	    };
	    /**
	     * Return the width of the sidenav, if it's in the proper mode and opened.
	     * This may relayout the view, so do not call this often.
	     * @param sidenav
	     * @param mode
	     */
	    MdSidenavContainer.prototype._getSidenavEffectiveWidth = function (sidenav, mode) {
	        return (this._isSidenavOpen(sidenav) && sidenav.mode == mode) ? sidenav._width : 0;
	    };
	    MdSidenavContainer.prototype._getMarginLeft = function () {
	        return this._getSidenavEffectiveWidth(this._left, 'side');
	    };
	    MdSidenavContainer.prototype._getMarginRight = function () {
	        return this._getSidenavEffectiveWidth(this._right, 'side');
	    };
	    MdSidenavContainer.prototype._getPositionLeft = function () {
	        return this._getSidenavEffectiveWidth(this._left, 'push');
	    };
	    MdSidenavContainer.prototype._getPositionRight = function () {
	        return this._getSidenavEffectiveWidth(this._right, 'push');
	    };
	    /**
	     * Returns the horizontal offset for the content area.  There should never be a value for both
	     * left and right, so by subtracting the right value from the left value, we should always get
	     * the appropriate offset.
	     */
	    MdSidenavContainer.prototype._getPositionOffset = function () {
	        return this._getPositionLeft() - this._getPositionRight();
	    };
	    /**
	     * This is using [ngStyle] rather than separate [style...] properties because [style.transform]
	     * doesn't seem to work right now.
	     */
	    MdSidenavContainer.prototype._getStyles = function () {
	        return {
	            marginLeft: this._getMarginLeft() + "px",
	            marginRight: this._getMarginRight() + "px",
	            transform: "translate3d(" + this._getPositionOffset() + "px, 0, 0)"
	        };
	    };
	    __decorate$39([
	        _angular_core.ContentChildren(MdSidenav), 
	        __metadata$39('design:type', _angular_core.QueryList)
	    ], MdSidenavContainer.prototype, "_sidenavs", void 0);
	    __decorate$39([
	        _angular_core.Output(), 
	        __metadata$39('design:type', Object)
	    ], MdSidenavContainer.prototype, "backdropClick", void 0);
	    MdSidenavContainer = __decorate$39([
	        _angular_core.Component({selector: 'md-sidenav-container, mat-sidenav-container',
	            // Do not use ChangeDetectionStrategy.OnPush. It does not work for this component because
	            // technically it is a sibling of MdSidenav (on the content tree) and isn't updated when MdSidenav
	            // changes its state.
	            template: "<div class=\"mat-sidenav-backdrop\" (click)=\"_onBackdropClicked()\" [class.mat-sidenav-shown]=\"_isShowingBackdrop()\"></div><ng-content select=\"md-sidenav, mat-sidenav\"></ng-content><div class=\"mat-sidenav-content\" [ngStyle]=\"_getStyles()\" cdk-scrollable><ng-content></ng-content></div>",
	            styles: [".mat-sidenav-container{position:relative;transform:translate3d(0,0,0);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-sidenav-backdrop,.mat-sidenav-container[fullscreen]{position:absolute;top:0;bottom:0;right:0;left:0}.mat-sidenav-container[fullscreen].mat-sidenav-opened{overflow:hidden}.mat-sidenav-backdrop{display:block;z-index:2;visibility:hidden}.mat-sidenav-backdrop.mat-sidenav-shown{visibility:visible}.mat-sidenav.mat-sidenav-closed,.mat-sidenav.mat-sidenav-end.mat-sidenav-closed,[dir=rtl] .mat-sidenav.mat-sidenav-closed,[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-closed{visibility:hidden}@media screen and (-ms-high-contrast:active){.mat-sidenav-backdrop{opacity:.5}}.mat-sidenav-content{position:relative;transform:translate3d(0,0,0);display:block;height:100%;overflow:auto}.mat-sidenav{display:block;position:absolute;top:0;bottom:0;z-index:3;min-width:5%;outline:0;transform:translate3d(-100%,0,0)}.mat-sidenav.mat-sidenav-opened,.mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-side{z-index:1}.mat-sidenav.mat-sidenav-end{right:0;transform:translate3d(100%,0,0)}.mat-sidenav.mat-sidenav-end.mat-sidenav-opened,.mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav{transform:translate3d(100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end{left:0;right:auto;transform:translate3d(-100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-opened:not(.mat-sidenav-side),.mat-sidenav.mat-sidenav-opening:not(.mat-sidenav-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.mat-sidenav-focus-trap{height:100%}.mat-sidenav-focus-trap>.cdk-focus-trap-content{box-sizing:border-box;height:100%;overflow-y:auto;transform:translateZ(0)}.mat-sidenav-invalid{display:none}",
	".mat-sidenav-transition .mat-sidenav{transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-sidenav-transition .mat-sidenav-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-sidenav-transition .mat-sidenav-backdrop.mat-sidenav-shown{transition:background-color .4s cubic-bezier(.25,.8,.25,1)}"],
	            host: {
	                '[class.mat-sidenav-container]': 'true',
	                '[class.mat-sidenav-transition]': '_enableTransitions',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }),
	        __param$8(0, _angular_core.Optional()), 
	        __metadata$39('design:paramtypes', [Dir, _angular_core.ElementRef, _angular_core.Renderer, _angular_core.NgZone])
	    ], MdSidenavContainer);
	    return MdSidenavContainer;
	}());
	var MdSidenavModule = (function () {
	    function MdSidenavModule() {
	    }
	    /** @deprecated */
	    MdSidenavModule.forRoot = function () {
	        return {
	            ngModule: MdSidenavModule,
	            providers: []
	        };
	    };
	    MdSidenavModule = __decorate$39([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, CompatibilityModule, A11yModule, OverlayModule],
	            exports: [MdSidenavContainer, MdSidenav, CompatibilityModule],
	            declarations: [MdSidenavContainer, MdSidenav],
	        }), 
	        __metadata$39('design:paramtypes', [])
	    ], MdSidenavModule);
	    return MdSidenavModule;
	}());
	
	var __decorate$40 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$40 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdListDivider = (function () {
	    function MdListDivider() {
	    }
	    MdListDivider = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-divider, mat-divider'
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListDivider);
	    return MdListDivider;
	}());
	var MdList = (function () {
	    function MdList() {
	    }
	    MdList = __decorate$40([
	        _angular_core.Component({selector: 'md-list, mat-list, md-nav-list, mat-nav-list',
	            host: {
	                'role': 'list' },
	            template: '<ng-content></ng-content>',
	            styles: [".mat-list,.mat-nav-list{padding-top:8px;display:block}.mat-list .mat-subheader,.mat-nav-list .mat-subheader{display:block;box-sizing:border-box;height:48px;padding:16px;margin:0;font-size:14px;font-weight:500}.mat-list .mat-subheader:first-child,.mat-nav-list .mat-subheader:first-child{margin-top:-8px}.mat-list .mat-list-item,.mat-nav-list .mat-list-item{display:block}.mat-list .mat-list-item .mat-list-item-content,.mat-nav-list .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;font-family:Roboto,\"Helvetica Neue\",sans-serif;box-sizing:border-box;font-size:16px;height:48px;padding:0 16px}.mat-list .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:56px}.mat-list .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-2-line .mat-list-item-content{height:72px}.mat-list .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-3-line .mat-list-item-content{height:88px}.mat-list .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list .mat-list-item .mat-list-text,.mat-nav-list .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list .mat-list-item .mat-list-text>*,.mat-nav-list .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list .mat-list-item .mat-list-text:empty,.mat-nav-list .mat-list-item .mat-list-text:empty{display:none}.mat-list .mat-list-item .mat-list-text:first-child,.mat-nav-list .mat-list-item .mat-list-text:first-child{padding:0}.mat-list .mat-list-item .mat-list-avatar,.mat-nav-list .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list .mat-list-item .mat-list-icon,.mat-nav-list .mat-list-item .mat-list-icon{width:24px;height:24px;border-radius:50%;padding:4px}.mat-list .mat-list-item .mat-line,.mat-nav-list .mat-list-item .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list .mat-list-item .mat-line:nth-child(n+2),.mat-nav-list .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list[dense],.mat-nav-list[dense]{padding-top:4px;display:block}.mat-list[dense] .mat-subheader,.mat-nav-list[dense] .mat-subheader{display:block;box-sizing:border-box;height:40px;padding:16px;margin:0;font-size:13px;font-weight:500}.mat-list[dense] .mat-subheader:first-child,.mat-nav-list[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list[dense] .mat-list-item,.mat-nav-list[dense] .mat-list-item{display:block}.mat-list[dense] .mat-list-item .mat-list-item-content,.mat-nav-list[dense] .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;font-family:Roboto,\"Helvetica Neue\",sans-serif;box-sizing:border-box;font-size:13px;height:40px;padding:0 16px}.mat-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:48px}.mat-list[dense] .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-2-line .mat-list-item-content{height:60px}.mat-list[dense] .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-3-line .mat-list-item-content{height:76px}.mat-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list[dense] .mat-list-item .mat-list-text,.mat-nav-list[dense] .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list[dense] .mat-list-item .mat-list-text>*,.mat-nav-list[dense] .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list[dense] .mat-list-item .mat-list-text:empty,.mat-nav-list[dense] .mat-list-item .mat-list-text:empty{display:none}.mat-list[dense] .mat-list-item .mat-list-text:first-child,.mat-nav-list[dense] .mat-list-item .mat-list-text:first-child{padding:0}.mat-list[dense] .mat-list-item .mat-list-avatar,.mat-nav-list[dense] .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list[dense] .mat-list-item .mat-list-icon,.mat-nav-list[dense] .mat-list-item .mat-list-icon{width:24px;height:24px;border-radius:50%;padding:4px}.mat-list[dense] .mat-list-item .mat-line,.mat-nav-list[dense] .mat-list-item .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-nav-list[dense] .mat-list-item .mat-line:nth-child(n+2){font-size:13px}.mat-divider{display:block;border-top-style:solid;border-top-width:1px;margin:0}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item-content{cursor:pointer}.mat-nav-list .mat-list-item-content.mat-list-item-focus,.mat-nav-list .mat-list-item-content:hover{outline:0}"],
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdList);
	    return MdList;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdListCssMatStyler = (function () {
	    function MdListCssMatStyler() {
	    }
	    MdListCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-list, mat-list',
	            host: {
	                '[class.mat-list]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListCssMatStyler);
	    return MdListCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdNavListCssMatStyler = (function () {
	    function MdNavListCssMatStyler() {
	    }
	    MdNavListCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-nav-list, mat-nav-list',
	            host: {
	                '[class.mat-nav-list]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdNavListCssMatStyler);
	    return MdNavListCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdDividerCssMatStyler = (function () {
	    function MdDividerCssMatStyler() {
	    }
	    MdDividerCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-divider, mat-divider',
	            host: {
	                '[class.mat-divider]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdDividerCssMatStyler);
	    return MdDividerCssMatStyler;
	}());
	/* Need directive for a ContentChild query in list-item */
	var MdListAvatarCssMatStyler = (function () {
	    function MdListAvatarCssMatStyler() {
	    }
	    MdListAvatarCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: '[md-list-avatar], [mat-list-avatar]',
	            host: {
	                '[class.mat-list-avatar]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListAvatarCssMatStyler);
	    return MdListAvatarCssMatStyler;
	}());
	/* Need directive to add mat- CSS styling */
	var MdListIconCssMatStyler = (function () {
	    function MdListIconCssMatStyler() {
	    }
	    MdListIconCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: '[md-list-icon], [mat-list-icon]',
	            host: {
	                '[class.mat-list-icon]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListIconCssMatStyler);
	    return MdListIconCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdListSubheaderCssMatStyler = (function () {
	    function MdListSubheaderCssMatStyler() {
	    }
	    MdListSubheaderCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: '[md-subheader], [mat-subheader]',
	            host: {
	                '[class.mat-subheader]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListSubheaderCssMatStyler);
	    return MdListSubheaderCssMatStyler;
	}());
	var MdListItem = (function () {
	    function MdListItem(_renderer, _element) {
	        this._renderer = _renderer;
	        this._element = _element;
	        this._hasFocus = false;
	    }
	    Object.defineProperty(MdListItem.prototype, "_hasAvatar", {
	        set: function (avatar) {
	            this._renderer.setElementClass(this._element.nativeElement, 'mat-list-item-avatar', avatar != null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdListItem.prototype.ngAfterContentInit = function () {
	        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);
	    };
	    MdListItem.prototype._handleFocus = function () {
	        this._hasFocus = true;
	    };
	    MdListItem.prototype._handleBlur = function () {
	        this._hasFocus = false;
	    };
	    __decorate$40([
	        _angular_core.ContentChildren(MdLine), 
	        __metadata$40('design:type', _angular_core.QueryList)
	    ], MdListItem.prototype, "_lines", void 0);
	    __decorate$40([
	        _angular_core.ContentChild(MdListAvatarCssMatStyler), 
	        __metadata$40('design:type', MdListAvatarCssMatStyler), 
	        __metadata$40('design:paramtypes', [MdListAvatarCssMatStyler])
	    ], MdListItem.prototype, "_hasAvatar", null);
	    MdListItem = __decorate$40([
	        _angular_core.Component({selector: 'md-list-item, mat-list-item, a[md-list-item], a[mat-list-item]',
	            host: {
	                'role': 'listitem',
	                '(focus)': '_handleFocus()',
	                '(blur)': '_handleBlur()',
	                '[class.mat-list-item]': 'true',
	            },
	            template: "<div class=\"mat-list-item-content\" [class.mat-list-item-focus]=\"_hasFocus\"><ng-content select=\"[md-list-avatar],[md-list-icon], [mat-list-avatar], [mat-list-icon]\"></ng-content><div class=\"mat-list-text\"><ng-content select=\"[md-line], [mat-line]\"></ng-content></div><ng-content></ng-content></div>",
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$40('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdListItem);
	    return MdListItem;
	}());
	var MdListModule = (function () {
	    function MdListModule() {
	    }
	    /** @deprecated */
	    MdListModule.forRoot = function () {
	        return {
	            ngModule: MdListModule,
	            providers: []
	        };
	    };
	    MdListModule = __decorate$40([
	        _angular_core.NgModule({
	            imports: [MdLineModule, CompatibilityModule],
	            exports: [
	                MdList,
	                MdListItem,
	                MdListDivider,
	                MdListAvatarCssMatStyler,
	                MdLineModule,
	                CompatibilityModule,
	                MdListIconCssMatStyler,
	                MdListCssMatStyler,
	                MdNavListCssMatStyler,
	                MdDividerCssMatStyler,
	                MdListSubheaderCssMatStyler
	            ],
	            declarations: [
	                MdList,
	                MdListItem,
	                MdListDivider,
	                MdListAvatarCssMatStyler,
	                MdListIconCssMatStyler,
	                MdListCssMatStyler,
	                MdNavListCssMatStyler,
	                MdDividerCssMatStyler,
	                MdListSubheaderCssMatStyler
	            ],
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListModule);
	    return MdListModule;
	}());
	
	/**
	 * Converts values into strings. Falsy values become empty strings.
	 * @docs-private
	 */
	function coerceToString(value) {
	    return "" + (value || '');
	}
	/**
	 * Converts a value that might be a string into a number.
	 * @docs-private
	 */
	function coerceToNumber(value) {
	    return typeof value === 'string' ? parseInt(value, 10) : value;
	}
	
	var __decorate$42 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$42 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdGridTile = (function () {
	    function MdGridTile(_renderer, _element) {
	        this._renderer = _renderer;
	        this._element = _element;
	        this._rowspan = 1;
	        this._colspan = 1;
	    }
	    Object.defineProperty(MdGridTile.prototype, "rowspan", {
	        /** Amount of rows that the grid tile takes up. */
	        get: function () { return this._rowspan; },
	        set: function (value) { this._rowspan = coerceToNumber(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdGridTile.prototype, "colspan", {
	        /** Amount of columns that the grid tile takes up. */
	        get: function () { return this._colspan; },
	        set: function (value) { this._colspan = coerceToNumber(value); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the style of the grid-tile element.  Needs to be set manually to avoid
	     * "Changed after checked" errors that would occur with HostBinding.
	     */
	    MdGridTile.prototype._setStyle = function (property, value) {
	        this._renderer.setElementStyle(this._element.nativeElement, property, value);
	    };
	    __decorate$42([
	        _angular_core.Input(), 
	        __metadata$42('design:type', Object)
	    ], MdGridTile.prototype, "rowspan", null);
	    __decorate$42([
	        _angular_core.Input(), 
	        __metadata$42('design:type', Object)
	    ], MdGridTile.prototype, "colspan", null);
	    MdGridTile = __decorate$42([
	        _angular_core.Component({selector: 'md-grid-tile, mat-grid-tile',
	            host: {
	                'role': 'listitem',
	                '[class.mat-grid-tile]': 'true',
	            },
	            template: "<figure class=\"mat-figure\"><ng-content></ng-content></figure>",
	            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;font-size:16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer .mat-line,.mat-grid-tile .mat-grid-tile-header .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile .mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile .mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}.mat-grid-tile .mat-grid-list-text>*,.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-avatar:empty,.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$42('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdGridTile);
	    return MdGridTile;
	}());
	var MdGridTileText = (function () {
	    function MdGridTileText(_renderer, _element) {
	        this._renderer = _renderer;
	        this._element = _element;
	    }
	    MdGridTileText.prototype.ngAfterContentInit = function () {
	        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);
	    };
	    __decorate$42([
	        _angular_core.ContentChildren(MdLine), 
	        __metadata$42('design:type', _angular_core.QueryList)
	    ], MdGridTileText.prototype, "_lines", void 0);
	    MdGridTileText = __decorate$42([
	        _angular_core.Component({selector: 'md-grid-tile-header, mat-grid-tile-header, md-grid-tile-footer, mat-grid-tile-footer',
	            template: "<ng-content select=\"[md-grid-avatar], [mat-grid-avatar]\"></ng-content><div class=\"mat-grid-list-text\"><ng-content select=\"[md-line], [mat-line]\"></ng-content></div><ng-content></ng-content>"
	        }), 
	        __metadata$42('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdGridTileText);
	    return MdGridTileText;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdGridAvatarCssMatStyler = (function () {
	    function MdGridAvatarCssMatStyler() {
	    }
	    MdGridAvatarCssMatStyler = __decorate$42([
	        _angular_core.Directive({
	            selector: '[md-grid-avatar], [mat-grid-avatar]',
	            host: {
	                '[class.mat-grid-avatar]': 'true'
	            }
	        }), 
	        __metadata$42('design:paramtypes', [])
	    ], MdGridAvatarCssMatStyler);
	    return MdGridAvatarCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdGridTileHeaderCssMatStyler = (function () {
	    function MdGridTileHeaderCssMatStyler() {
	    }
	    MdGridTileHeaderCssMatStyler = __decorate$42([
	        _angular_core.Directive({
	            selector: 'md-grid-tile-header, mat-grid-tile-header',
	            host: {
	                '[class.mat-grid-tile-header]': 'true'
	            }
	        }), 
	        __metadata$42('design:paramtypes', [])
	    ], MdGridTileHeaderCssMatStyler);
	    return MdGridTileHeaderCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdGridTileFooterCssMatStyler = (function () {
	    function MdGridTileFooterCssMatStyler() {
	    }
	    MdGridTileFooterCssMatStyler = __decorate$42([
	        _angular_core.Directive({
	            selector: 'md-grid-tile-footer, mat-grid-tile-footer',
	            host: {
	                '[class.mat-grid-tile-footer]': 'true'
	            }
	        }), 
	        __metadata$42('design:paramtypes', [])
	    ], MdGridTileFooterCssMatStyler);
	    return MdGridTileFooterCssMatStyler;
	}());
	
	var __extends$10 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when cols property is missing from grid-list
	 * @docs-private
	 */
	var MdGridListColsError = (function (_super) {
	    __extends$10(MdGridListColsError, _super);
	    function MdGridListColsError() {
	        _super.call(this, "md-grid-list: must pass in number of columns. Example: <md-grid-list cols=\"3\">");
	    }
	    return MdGridListColsError;
	}(MdError));
	/**
	 * Exception thrown when a tile's colspan is longer than the number of cols in list
	 * @docs-private
	 */
	var MdGridTileTooWideError = (function (_super) {
	    __extends$10(MdGridTileTooWideError, _super);
	    function MdGridTileTooWideError(cols, listLength) {
	        _super.call(this, "md-grid-list: tile with colspan " + cols + " is wider than grid with cols=\"" + listLength + "\".");
	    }
	    return MdGridTileTooWideError;
	}(MdError));
	/**
	 * Exception thrown when an invalid ratio is passed in as a rowHeight
	 * @docs-private
	 */
	var MdGridListBadRatioError = (function (_super) {
	    __extends$10(MdGridListBadRatioError, _super);
	    function MdGridListBadRatioError(value) {
	        _super.call(this, "md-grid-list: invalid ratio given for row-height: \"" + value + "\"");
	    }
	    return MdGridListBadRatioError;
	}(MdError));
	
	/**
	 * Class for determining, from a list of tiles, the (row, col) position of each of those tiles
	 * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)
	 * because the tiles can have a rowspan.
	 *
	 * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid
	 * large enough to accommodate it so that the tiles still render in the same order in which they
	 * are given.
	 *
	 * The basis of the algorithm is the use of an array to track the already placed tiles. Each
	 * element of the array corresponds to a column, and the value indicates how many cells in that
	 * column are already occupied; zero indicates an empty cell. Moving "down" to the next row
	 * decrements each value in the tracking array (indicating that the column is one cell closer to
	 * being free).
	 *
	 * @docs-private
	 */
	var TileCoordinator = (function () {
	    function TileCoordinator(numColumns, tiles) {
	        var _this = this;
	        /** Index at which the search for the next gap will start. */
	        this.columnIndex = 0;
	        /** The current row index. */
	        this.rowIndex = 0;
	        this.tracker = new Array(numColumns);
	        this.tracker.fill(0, 0, this.tracker.length);
	        this.positions = tiles.map(function (tile) { return _this._trackTile(tile); });
	    }
	    Object.defineProperty(TileCoordinator.prototype, "rowCount", {
	        /** Gets the total number of rows occupied by tiles */
	        get: function () { return this.rowIndex + 1; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TileCoordinator.prototype, "rowspan", {
	        /** Gets the total span of rows occupied by tiles.
	         * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2. */
	        get: function () {
	            var lastRowMax = Math.max.apply(Math, this.tracker);
	            // if any of the tiles has a rowspan that pushes it beyond the total row count,
	            // add the difference to the rowcount
	            return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Calculates the row and col position of a tile. */
	    TileCoordinator.prototype._trackTile = function (tile) {
	        // Find a gap large enough for this tile.
	        var gapStartIndex = this._findMatchingGap(tile.colspan);
	        // Place tile in the resulting gap.
	        this._markTilePosition(gapStartIndex, tile);
	        // The next time we look for a gap, the search will start at columnIndex, which should be
	        // immediately after the tile that has just been placed.
	        this.columnIndex = gapStartIndex + tile.colspan;
	        return new TilePosition(this.rowIndex, gapStartIndex);
	    };
	    /** Finds the next available space large enough to fit the tile. */
	    TileCoordinator.prototype._findMatchingGap = function (tileCols) {
	        if (tileCols > this.tracker.length) {
	            throw new MdGridTileTooWideError(tileCols, this.tracker.length);
	        }
	        // Start index is inclusive, end index is exclusive.
	        var gapStartIndex = -1;
	        var gapEndIndex = -1;
	        // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.
	        do {
	            // If we've reached the end of the row, go to the next row.
	            if (this.columnIndex + tileCols > this.tracker.length) {
	                this._nextRow();
	                continue;
	            }
	            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
	            // If there are no more empty spaces in this row at all, move on to the next row.
	            if (gapStartIndex == -1) {
	                this._nextRow();
	                continue;
	            }
	            gapEndIndex = this._findGapEndIndex(gapStartIndex);
	            // If a gap large enough isn't found, we want to start looking immediately after the current
	            // gap on the next iteration.
	            this.columnIndex = gapStartIndex + 1;
	        } while (gapEndIndex - gapStartIndex < tileCols);
	        return gapStartIndex;
	    };
	    /** Move "down" to the next row. */
	    TileCoordinator.prototype._nextRow = function () {
	        this.columnIndex = 0;
	        this.rowIndex++;
	        // Decrement all spaces by one to reflect moving down one row.
	        for (var i = 0; i < this.tracker.length; i++) {
	            this.tracker[i] = Math.max(0, this.tracker[i] - 1);
	        }
	    };
	    /**
	     * Finds the end index (exclusive) of a gap given the index from which to start looking.
	     * The gap ends when a non-zero value is found.
	     */
	    TileCoordinator.prototype._findGapEndIndex = function (gapStartIndex) {
	        for (var i = gapStartIndex + 1; i < this.tracker.length; i++) {
	            if (this.tracker[i] != 0) {
	                return i;
	            }
	        }
	        // The gap ends with the end of the row.
	        return this.tracker.length;
	    };
	    /** Update the tile tracker to account for the given tile in the given space. */
	    TileCoordinator.prototype._markTilePosition = function (start, tile) {
	        for (var i = 0; i < tile.colspan; i++) {
	            this.tracker[start + i] = tile.rowspan;
	        }
	    };
	    return TileCoordinator;
	}());
	/**
	 * Simple data structure for tile position (row, col).
	 * @docs-private
	 */
	var TilePosition = (function () {
	    function TilePosition(row, col) {
	        this.row = row;
	        this.col = col;
	    }
	    return TilePosition;
	}());
	
	var __extends$11 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Sets the style properties for an individual tile, given the position calculated by the
	 * Tile Coordinator.
	 * @docs-private
	 */
	var TileStyler = (function () {
	    function TileStyler() {
	        this._rows = 0;
	        this._rowspan = 0;
	    }
	    /**
	     * Adds grid-list layout info once it is available. Cannot be processed in the constructor
	     * because these properties haven't been calculated by that point.
	     *
	     * @param gutterSize Size of the grid's gutter.
	     * @param tracker Instance of the TileCoordinator.
	     * @param cols Amount of columns in the grid.
	     * @param direction Layout direction of the grid.
	     */
	    TileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
	        this._gutterSize = normalizeUnits(gutterSize);
	        this._rows = tracker.rowCount;
	        this._rowspan = tracker.rowspan;
	        this._cols = cols;
	        this._direction = direction;
	    };
	    /**
	     * Computes the amount of space a single 1x1 tile would take up (width or height).
	     * Used as a basis for other calculations.
	     * @param sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
	     * @param gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
	     * @return The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
	     */
	    TileStyler.prototype.getBaseTileSize = function (sizePercent, gutterFraction) {
	        // Take the base size percent (as would be if evenly dividing the size between cells),
	        // and then subtracting the size of one gutter. However, since there are no gutters on the
	        // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter
	        // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the
	        // edge evenly among the cells).
	        return "(" + sizePercent + "% - ( " + this._gutterSize + " * " + gutterFraction + " ))";
	    };
	    /**
	     * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
	     * @param offset Number of tiles that have already been rendered in the row/column.
	     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
	     * @return Position of the tile as a CSS calc() expression.
	     */
	    TileStyler.prototype.getTilePosition = function (baseSize, offset) {
	        // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
	        // row/column (offset).
	        return calc("(" + baseSize + " + " + this._gutterSize + ") * " + offset);
	    };
	    /**
	     * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
	     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
	     * @param span The tile's rowspan or colspan.
	     * @return Size of the tile as a CSS calc() expression.
	     */
	    TileStyler.prototype.getTileSize = function (baseSize, span) {
	        return "(" + baseSize + " * " + span + ") + (" + (span - 1) + " * " + this._gutterSize + ")";
	    };
	    /**
	     * Sets the style properties to be applied to a tile for the given row and column index.
	     * @param tile Tile to which to apply the styling.
	     * @param rowIndex Index of the tile's row.
	     * @param colIndex Index of the tile's column.
	     */
	    TileStyler.prototype.setStyle = function (tile, rowIndex, colIndex) {
	        // Percent of the available horizontal space that one column takes up.
	        var percentWidthPerTile = 100 / this._cols;
	        // Fraction of the vertical gutter size that each column takes up.
	        // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.
	        var gutterWidthFractionPerTile = (this._cols - 1) / this._cols;
	        this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);
	        this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);
	    };
	    /** Sets the horizontal placement of the tile in the list. */
	    TileStyler.prototype.setColStyles = function (tile, colIndex, percentWidth, gutterWidth) {
	        // Base horizontal size of a column.
	        var baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);
	        // The width and horizontal position of each tile is always calculated the same way, but the
	        // height and vertical position depends on the rowMode.
	        var side = this._direction === 'ltr' ? 'left' : 'right';
	        tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));
	        tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));
	    };
	    /**
	     * Calculates the total size taken up by gutters across one axis of a list.
	     */
	    TileStyler.prototype.getGutterSpan = function () {
	        return this._gutterSize + " * (" + this._rowspan + " - 1)";
	    };
	    /**
	     * Calculates the total size taken up by tiles across one axis of a list.
	     * @param tileHeight Height of the tile.
	     */
	    TileStyler.prototype.getTileSpan = function (tileHeight) {
	        return this._rowspan + " * " + this.getTileSize(tileHeight, 1);
	    };
	    /**
	     * Sets the vertical placement of the tile in the list.
	     * This method will be implemented by each type of TileStyler.
	     * @docs-private
	     */
	    TileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) { };
	    /**
	     * Calculates the computed height and returns the correct style property to set.
	     * This method will be implemented by each type of TileStyler.
	     * @docs-private
	     */
	    TileStyler.prototype.getComputedHeight = function () { return null; };
	    return TileStyler;
	}());
	/**
	 * This type of styler is instantiated when the user passes in a fixed row height.
	 * Example <md-grid-list cols="3" rowHeight="100px">
	 * @docs-private
	 */
	var FixedTileStyler = (function (_super) {
	    __extends$11(FixedTileStyler, _super);
	    function FixedTileStyler(fixedRowHeight) {
	        _super.call(this);
	        this.fixedRowHeight = fixedRowHeight;
	    }
	    FixedTileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
	        _super.prototype.init.call(this, gutterSize, tracker, cols, direction);
	        this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);
	    };
	    FixedTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
	        tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));
	        tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));
	    };
	    FixedTileStyler.prototype.getComputedHeight = function () {
	        return [
	            'height', calc(this.getTileSpan(this.fixedRowHeight) + " + " + this.getGutterSpan())
	        ];
	    };
	    return FixedTileStyler;
	}(TileStyler));
	/**
	 * This type of styler is instantiated when the user passes in a width:height ratio
	 * for the row height.  Example <md-grid-list cols="3" rowHeight="3:1">
	 * @docs-private
	 */
	var RatioTileStyler = (function (_super) {
	    __extends$11(RatioTileStyler, _super);
	    function RatioTileStyler(value) {
	        _super.call(this);
	        this._parseRatio(value);
	    }
	    RatioTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
	        var percentHeightPerTile = percentWidth / this.rowHeightRatio;
	        this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);
	        // Use paddingTop and marginTop to maintain the given aspect ratio, as
	        // a percentage-based value for these properties is applied versus the *width* of the
	        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
	        tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));
	        tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));
	    };
	    RatioTileStyler.prototype.getComputedHeight = function () {
	        return [
	            'paddingBottom', calc(this.getTileSpan(this.baseTileHeight) + " + " + this.getGutterSpan())
	        ];
	    };
	    RatioTileStyler.prototype._parseRatio = function (value) {
	        var ratioParts = value.split(':');
	        if (ratioParts.length !== 2) {
	            throw new MdGridListBadRatioError(value);
	        }
	        this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);
	    };
	    return RatioTileStyler;
	}(TileStyler));
	/**
	 * This type of styler is instantiated when the user selects a "fit" row height mode.
	 * In other words, the row height will reflect the total height of the container divided
	 * by the number of rows.  Example <md-grid-list cols="3" rowHeight="fit">
	 *
	 * @docs-private
	 */
	var FitTileStyler = (function (_super) {
	    __extends$11(FitTileStyler, _super);
	    function FitTileStyler() {
	        _super.apply(this, arguments);
	    }
	    FitTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
	        // Percent of the available vertical space that one row takes up.
	        var percentHeightPerTile = 100 / this._rowspan;
	        // Fraction of the horizontal gutter size that each column takes up.
	        var gutterHeightPerTile = (this._rows - 1) / this._rows;
	        // Base vertical size of a column.
	        var baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);
	        tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));
	        tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));
	    };
	    return FitTileStyler;
	}(TileStyler));
	/** Wraps a CSS string in a calc function */
	function calc(exp) { return "calc(" + exp + ")"; }
	/** Appends pixels to a CSS string if no units are given. */
	function normalizeUnits(value) {
	    return (value.match(/px|em|rem/)) ? value : value + 'px';
	}
	
	var __decorate$41 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$41 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$9 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	// TODO(kara): Conditional (responsive) column count / row size.
	// TODO(kara): Re-layout on window resize / media change (debounced).
	// TODO(kara): gridTileHeader and gridTileFooter.
	var MD_FIT_MODE = 'fit';
	var MdGridList = (function () {
	    function MdGridList(_renderer, _element, _dir) {
	        this._renderer = _renderer;
	        this._element = _element;
	        this._dir = _dir;
	        /** The amount of space between tiles. This will be something like '5px' or '2em'. */
	        this._gutter = '1px';
	    }
	    Object.defineProperty(MdGridList.prototype, "cols", {
	        /** Amount of columns in the grid list. */
	        get: function () { return this._cols; },
	        set: function (value) { this._cols = coerceToNumber(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdGridList.prototype, "gutterSize", {
	        /** Size of the grid list's gutter in pixels. */
	        get: function () { return this._gutter; },
	        set: function (value) { this._gutter = coerceToString(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdGridList.prototype, "rowHeight", {
	        /** Set internal representation of row height from the user-provided value. */
	        set: function (value) {
	            this._rowHeight = coerceToString(value);
	            this._setTileStyler();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdGridList.prototype.ngOnInit = function () {
	        this._checkCols();
	        this._checkRowHeight();
	    };
	    /**
	     * The layout calculation is fairly cheap if nothing changes, so there's little cost
	     * to run it frequently.
	     */
	    MdGridList.prototype.ngAfterContentChecked = function () {
	        this._layoutTiles();
	    };
	    /** Throw a friendly error if cols property is missing */
	    MdGridList.prototype._checkCols = function () {
	        if (!this.cols) {
	            throw new MdGridListColsError();
	        }
	    };
	    /** Default to equal width:height if rowHeight property is missing */
	    MdGridList.prototype._checkRowHeight = function () {
	        if (!this._rowHeight) {
	            this._tileStyler = new RatioTileStyler('1:1');
	        }
	    };
	    /** Creates correct Tile Styler subtype based on rowHeight passed in by user */
	    MdGridList.prototype._setTileStyler = function () {
	        if (this._rowHeight === MD_FIT_MODE) {
	            this._tileStyler = new FitTileStyler();
	        }
	        else if (this._rowHeight && this._rowHeight.indexOf(':') > -1) {
	            this._tileStyler = new RatioTileStyler(this._rowHeight);
	        }
	        else {
	            this._tileStyler = new FixedTileStyler(this._rowHeight);
	        }
	    };
	    /** Computes and applies the size and position for all children grid tiles. */
	    MdGridList.prototype._layoutTiles = function () {
	        var _this = this;
	        var tracker = new TileCoordinator(this.cols, this._tiles);
	        var direction = this._dir ? this._dir.value : 'ltr';
	        this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);
	        this._tiles.forEach(function (tile, index) {
	            var pos = tracker.positions[index];
	            _this._tileStyler.setStyle(tile, pos.row, pos.col);
	        });
	        this._setListStyle(this._tileStyler.getComputedHeight());
	    };
	    /** Sets style on the main grid-list element, given the style name and value. */
	    MdGridList.prototype._setListStyle = function (style$$1) {
	        if (style$$1) {
	            this._renderer.setElementStyle(this._element.nativeElement, style$$1[0], style$$1[1]);
	        }
	    };
	    __decorate$41([
	        _angular_core.ContentChildren(MdGridTile), 
	        __metadata$41('design:type', _angular_core.QueryList)
	    ], MdGridList.prototype, "_tiles", void 0);
	    __decorate$41([
	        _angular_core.Input(), 
	        __metadata$41('design:type', Object)
	    ], MdGridList.prototype, "cols", null);
	    __decorate$41([
	        _angular_core.Input(), 
	        __metadata$41('design:type', Object)
	    ], MdGridList.prototype, "gutterSize", null);
	    __decorate$41([
	        _angular_core.Input(), 
	        __metadata$41('design:type', Object), 
	        __metadata$41('design:paramtypes', [Object])
	    ], MdGridList.prototype, "rowHeight", null);
	    MdGridList = __decorate$41([
	        _angular_core.Component({selector: 'md-grid-list, mat-grid-list',
	            template: "<div><ng-content></ng-content></div>",
	            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;font-size:16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer .mat-line,.mat-grid-tile .mat-grid-tile-header .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile .mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile .mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}.mat-grid-tile .mat-grid-list-text>*,.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-avatar:empty,.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}"],
	            host: {
	                'role': 'list',
	                '[class.mat-grid-list]': 'true',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }),
	        __param$9(2, _angular_core.Optional()), 
	        __metadata$41('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef, Dir])
	    ], MdGridList);
	    return MdGridList;
	}());
	var MdGridListModule = (function () {
	    function MdGridListModule() {
	    }
	    /** @deprecated */
	    MdGridListModule.forRoot = function () {
	        return {
	            ngModule: MdGridListModule,
	            providers: []
	        };
	    };
	    MdGridListModule = __decorate$41([
	        _angular_core.NgModule({
	            imports: [MdLineModule, CompatibilityModule],
	            exports: [
	                MdGridList,
	                MdGridTile,
	                MdGridTileText,
	                MdLineModule,
	                CompatibilityModule,
	                MdGridTileHeaderCssMatStyler,
	                MdGridTileFooterCssMatStyler,
	                MdGridAvatarCssMatStyler
	            ],
	            declarations: [
	                MdGridList,
	                MdGridTile,
	                MdGridTileText,
	                MdGridTileHeaderCssMatStyler,
	                MdGridTileFooterCssMatStyler,
	                MdGridAvatarCssMatStyler],
	        }), 
	        __metadata$41('design:paramtypes', [])
	    ], MdGridListModule);
	    return MdGridListModule;
	}());
	
	var __decorate$43 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$43 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Content of a card, needed as it's used as a selector in the API.
	 */
	var MdCardContent = (function () {
	    function MdCardContent() {
	    }
	    MdCardContent = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-content, mat-card-content',
	            host: {
	                '[class.mat-card-content]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardContent);
	    return MdCardContent;
	}());
	/**
	 * Title of a card, needed as it's used as a selector in the API.
	 */
	var MdCardTitle = (function () {
	    function MdCardTitle() {
	    }
	    MdCardTitle = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-title, mat-card-title',
	            host: {
	                '[class.mat-card-title]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardTitle);
	    return MdCardTitle;
	}());
	/**
	 * Sub-title of a card, needed as it's used as a selector in the API.
	 */
	var MdCardSubtitle = (function () {
	    function MdCardSubtitle() {
	    }
	    MdCardSubtitle = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-subtitle, mat-card-subtitle',
	            host: {
	                '[class.mat-card-subtitle]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardSubtitle);
	    return MdCardSubtitle;
	}());
	/**
	 * Action section of a card, needed as it's used as a selector in the API.
	 */
	var MdCardActions = (function () {
	    function MdCardActions() {
	    }
	    MdCardActions = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-actions, mat-card-actions',
	            host: {
	                '[class.mat-card-actions]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardActions);
	    return MdCardActions;
	}());
	/**
	 * Footer of a card, needed as it's used as a selector in the API.
	 */
	var MdCardFooter = (function () {
	    function MdCardFooter() {
	    }
	    MdCardFooter = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-footer, mat-card-footer',
	            host: {
	                '[class.mat-card-footer]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardFooter);
	    return MdCardFooter;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardSmImage = (function () {
	    function MdCardSmImage() {
	    }
	    MdCardSmImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-sm-image], [mat-card-sm-image]',
	            host: {
	                '[class.mat-card-sm-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardSmImage);
	    return MdCardSmImage;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardMdImage = (function () {
	    function MdCardMdImage() {
	    }
	    MdCardMdImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-md-image], [mat-card-md-image]',
	            host: {
	                '[class.mat-card-md-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardMdImage);
	    return MdCardMdImage;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardLgImage = (function () {
	    function MdCardLgImage() {
	    }
	    MdCardLgImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-lg-image], [mat-card-lg-image]',
	            host: {
	                'class.mat-card-lg-image': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardLgImage);
	    return MdCardLgImage;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardImage = (function () {
	    function MdCardImage() {
	    }
	    MdCardImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-image], [mat-card-image]',
	            host: {
	                '[class.mat-card-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardImage);
	    return MdCardImage;
	}());
	/**
	 * Large image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardXlImage = (function () {
	    function MdCardXlImage() {
	    }
	    MdCardXlImage = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-xl-image, mat-card-xl-image',
	            host: {
	                '[class.mat-card-xl-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardXlImage);
	    return MdCardXlImage;
	}());
	/**
	 * Avatar image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardAvatar = (function () {
	    function MdCardAvatar() {
	    }
	    MdCardAvatar = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-avatar, mat-card-avatar',
	            host: {
	                '[class.mat-card-avatar]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardAvatar);
	    return MdCardAvatar;
	}());
	/**
	 * A basic content container component that adds the styles of a Material design card.
	 *
	 * While this component can be used alone, it also provides a number
	 * of preset styles for common card sections, including:
	 * - md-card-title
	 * - md-card-subtitle
	 * - md-card-content
	 * - md-card-actions
	 * - md-card-footer
	 */
	var MdCard = (function () {
	    function MdCard() {
	    }
	    MdCard = __decorate$43([
	        _angular_core.Component({selector: 'md-card, mat-card',
	            template: "<ng-content></ng-content>",
	            styles: [".mat-card{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);will-change:box-shadow;display:block;position:relative;padding:24px;border-radius:2px;font-family:Roboto,\"Helvetica Neue\",sans-serif}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-flat{box-shadow:none}.mat-card-actions,.mat-card-content,.mat-card-subtitle,.mat-card-title{display:block;margin-bottom:16px}.mat-card-title{font-size:24px;font-weight:400}.mat-card-content,.mat-card-header .mat-card-title,.mat-card-subtitle{font-size:14px}.mat-card-actions{margin-left:-16px;margin-right:-16px;padding:8px 0}.mat-card-actions[align=end]{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 48px);margin:0 -24px 16px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-footer{position:absolute;width:100%;min-height:5px;bottom:0;left:0}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 4px}.mat-card-header{display:flex;flex-direction:row;height:40px;margin:-8px 0 16px}.mat-card-header-text{height:40px;margin:0 8px}.mat-card-avatar{height:40px;width:40px;border-radius:50%}.mat-card-lg-image,.mat-card-md-image,.mat-card-sm-image{margin:-8px 0}.mat-card-title-group{display:flex;justify-content:space-between;margin:0 -8px}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}@media (max-width:600px){.mat-card{padding:24px 16px}.mat-card-actions{margin-left:-8px;margin-right:-8px}.mat-card-image{width:calc(100% + 32px);margin:16px -16px}.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}.mat-card-header{margin:-8px 0 0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child,.mat-card>:last-child{margin-bottom:0}.mat-card-image:first-child{margin-top:-24px}.mat-card>.mat-card-actions:last-child{margin-bottom:-16px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child),.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            host: {
	                '[class.mat-card]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCard);
	    return MdCard;
	}());
	/**
	 * Component intended to be used within the `<md-card>` component. It adds styles for a
	 * preset header section (i.e. a title, subtitle, and avatar layout).
	 */
	var MdCardHeader = (function () {
	    function MdCardHeader() {
	    }
	    MdCardHeader = __decorate$43([
	        _angular_core.Component({selector: 'md-card-header, mat-card-header',
	            template: "<ng-content select=\"[md-card-avatar], [mat-card-avatar]\"></ng-content><div class=\"mat-card-header-text\"><ng-content select=\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle\"></ng-content></div><ng-content></ng-content>",
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            host: {
	                '[class.mat-card-header]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardHeader);
	    return MdCardHeader;
	}());
	/**
	 * Component intended to be used within the <md-card> component. It adds styles for a preset
	 * layout that groups an image with a title section.
	 */
	var MdCardTitleGroup = (function () {
	    function MdCardTitleGroup() {
	    }
	    MdCardTitleGroup = __decorate$43([
	        _angular_core.Component({selector: 'md-card-title-group, mat-card-title-group',
	            template: "<div><ng-content select=\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle\"></ng-content></div><ng-content select=\"img\"></ng-content><ng-content></ng-content>",
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            host: {
	                '[class.mat-card-title-group]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardTitleGroup);
	    return MdCardTitleGroup;
	}());
	var MdCardModule = (function () {
	    function MdCardModule() {
	    }
	    /** @deprecated */
	    MdCardModule.forRoot = function () {
	        return {
	            ngModule: MdCardModule,
	            providers: []
	        };
	    };
	    MdCardModule = __decorate$43([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [
	                MdCard,
	                MdCardHeader,
	                MdCardTitleGroup,
	                MdCardContent,
	                MdCardTitle,
	                MdCardSubtitle,
	                MdCardActions,
	                MdCardFooter,
	                MdCardSmImage,
	                MdCardMdImage,
	                MdCardLgImage,
	                MdCardImage,
	                MdCardXlImage,
	                MdCardAvatar,
	                CompatibilityModule,
	            ],
	            declarations: [
	                MdCard, MdCardHeader, MdCardTitleGroup, MdCardContent, MdCardTitle, MdCardSubtitle,
	                MdCardActions, MdCardFooter, MdCardSmImage, MdCardMdImage, MdCardLgImage, MdCardImage,
	                MdCardXlImage, MdCardAvatar,
	            ],
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardModule);
	    return MdCardModule;
	}());
	
	var __decorate$45 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$45 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Material design styled Chip component. Used inside the MdChipList component.
	 */
	var MdChip = (function () {
	    function MdChip(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        /** Whether or not the chip is disabled. Disabled chips cannot be focused. */
	        this._disabled = null;
	        /** Whether or not the chip is selected. */
	        this._selected = false;
	        /** The palette color of selected chips. */
	        this._color = 'primary';
	        /** Emitted when the chip is focused. */
	        this.onFocus = new _angular_core.EventEmitter();
	        /** Emitted when the chip is selected. */
	        this.select = new _angular_core.EventEmitter();
	        /** Emitted when the chip is deselected. */
	        this.deselect = new _angular_core.EventEmitter();
	        /** Emitted when the chip is destroyed. */
	        this.destroy = new _angular_core.EventEmitter();
	    }
	    MdChip.prototype.ngOnInit = function () {
	        this._addDefaultCSSClass();
	        this._updateColor(this._color);
	    };
	    MdChip.prototype.ngOnDestroy = function () {
	        this.destroy.emit({ chip: this });
	    };
	    Object.defineProperty(MdChip.prototype, "disabled", {
	        /** Whether or not the chip is disabled. */
	        get: function () {
	            return this._disabled;
	        },
	        /** Sets the disabled state of the chip. */
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdChip.prototype, "_isAriaDisabled", {
	        /** A String representation of the current disabled state. */
	        get: function () {
	            return String(coerceBooleanProperty(this.disabled));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdChip.prototype, "selected", {
	        /** Whether or not this chip is selected. */
	        get: function () {
	            return this._selected;
	        },
	        set: function (value) {
	            this._selected = coerceBooleanProperty(value);
	            if (this._selected) {
	                this.select.emit({ chip: this });
	            }
	            else {
	                this.deselect.emit({ chip: this });
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Toggles the current selected state of this chip.
	     * @return Whether the chip is selected.
	     */
	    MdChip.prototype.toggleSelected = function () {
	        this.selected = !this.selected;
	        return this.selected;
	    };
	    Object.defineProperty(MdChip.prototype, "color", {
	        /** The color of the chip. Can be `primary`, `accent`, or `warn`. */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Allows for programmatic focusing of the chip. */
	    MdChip.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._elementRef.nativeElement, 'focus');
	        this.onFocus.emit({ chip: this });
	    };
	    /** Ensures events fire properly upon click. */
	    MdChip.prototype._handleClick = function (event) {
	        // Check disabled
	        if (this.disabled) {
	            event.preventDefault();
	            event.stopPropagation();
	        }
	        else {
	            this.focus();
	        }
	    };
	    /** Initializes the appropriate CSS classes based on the chip type (basic or standard). */
	    MdChip.prototype._addDefaultCSSClass = function () {
	        var el = this._elementRef.nativeElement;
	        // Always add the `mat-chip` class
	        el.classList.add('mat-chip');
	        // If we are a basic chip, also add the `mat-basic-chip` class for :not() targeting
	        if (el.nodeName.toLowerCase() == 'mat-basic-chip' || el.hasAttribute('mat-basic-chip') ||
	            el.nodeName.toLowerCase() == 'md-basic-chip' || el.hasAttribute('md-basic-chip')) {
	            el.classList.add('mat-basic-chip');
	        }
	    };
	    /** Updates the private _color variable and the native element. */
	    MdChip.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    /** Sets the mat-color on the native element. */
	    MdChip.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    __decorate$45([
	        _angular_core.Output(), 
	        __metadata$45('design:type', Object)
	    ], MdChip.prototype, "select", void 0);
	    __decorate$45([
	        _angular_core.Output(), 
	        __metadata$45('design:type', Object)
	    ], MdChip.prototype, "deselect", void 0);
	    __decorate$45([
	        _angular_core.Output(), 
	        __metadata$45('design:type', Object)
	    ], MdChip.prototype, "destroy", void 0);
	    __decorate$45([
	        _angular_core.Input(), 
	        __metadata$45('design:type', Boolean)
	    ], MdChip.prototype, "disabled", null);
	    __decorate$45([
	        _angular_core.Input(), 
	        __metadata$45('design:type', Boolean)
	    ], MdChip.prototype, "selected", null);
	    __decorate$45([
	        _angular_core.Input(), 
	        __metadata$45('design:type', String)
	    ], MdChip.prototype, "color", null);
	    MdChip = __decorate$45([
	        _angular_core.Component({
	            selector: "md-basic-chip, [md-basic-chip], md-chip, [md-chip],\n             mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]",
	            template: "<ng-content></ng-content>",
	            host: {
	                '[class.mat-chip]': 'true',
	                'tabindex': '-1',
	                'role': 'option',
	                '[class.mat-chip-selected]': 'selected',
	                '[attr.disabled]': 'disabled',
	                '[attr.aria-disabled]': '_isAriaDisabled',
	                '(click)': '_handleClick($event)'
	            }
	        }), 
	        __metadata$45('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdChip);
	    return MdChip;
	}());
	
	var __decorate$44 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$44 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * A material design chips component (named ChipList for it's similarity to the List component).
	 *
	 * Example:
	 *
	 *     <md-chip-list>
	 *       <md-chip>Chip 1<md-chip>
	 *       <md-chip>Chip 2<md-chip>
	 *     </md-chip-list>
	 */
	var MdChipList = (function () {
	    function MdChipList(_elementRef) {
	        this._elementRef = _elementRef;
	        /** Track which chips we're listening to for focus/destruction. */
	        this._subscribed = new WeakMap();
	        /** Whether or not the chip is selectable. */
	        this._selectable = true;
	    }
	    MdChipList.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._keyManager = new FocusKeyManager(this.chips).withWrap();
	        // Go ahead and subscribe all of the initial chips
	        this._subscribeChips(this.chips);
	        // When the list changes, re-subscribe
	        this.chips.changes.subscribe(function (chips) {
	            _this._subscribeChips(chips);
	        });
	    };
	    Object.defineProperty(MdChipList.prototype, "selectable", {
	        /**
	         * Whether or not this chip is selectable. When a chip is not selectable,
	         * it's selected state is always ignored.
	         */
	        get: function () {
	            return this._selectable;
	        },
	        set: function (value) {
	            this._selectable = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Programmatically focus the chip list. This in turn focuses the first
	     * non-disabled chip in this chip list.
	     */
	    MdChipList.prototype.focus = function () {
	        // TODO: ARIA says this should focus the first `selected` chip.
	        this._keyManager.setFirstItemActive();
	    };
	    /** Passes relevant key presses to our key manager. */
	    MdChipList.prototype._keydown = function (event) {
	        var target = event.target;
	        // If they are on a chip, check for space/left/right, otherwise pass to our key manager
	        if (target && target.classList.contains('mat-chip')) {
	            switch (event.keyCode) {
	                case SPACE:
	                    // If we are selectable, toggle the focused chip
	                    if (this.selectable) {
	                        this._toggleSelectOnFocusedChip();
	                    }
	                    // Always prevent space from scrolling the page since the list has focus
	                    event.preventDefault();
	                    break;
	                case LEFT_ARROW:
	                    this._keyManager.setPreviousItemActive();
	                    event.preventDefault();
	                    break;
	                case RIGHT_ARROW:
	                    this._keyManager.setNextItemActive();
	                    event.preventDefault();
	                    break;
	                default:
	                    this._keyManager.onKeydown(event);
	            }
	        }
	    };
	    /** Toggles the selected state of the currently focused chip. */
	    MdChipList.prototype._toggleSelectOnFocusedChip = function () {
	        // Allow disabling of chip selection
	        if (!this.selectable) {
	            return;
	        }
	        var focusedIndex = this._keyManager.activeItemIndex;
	        if (this._isValidIndex(focusedIndex)) {
	            var focusedChip = this.chips.toArray()[focusedIndex];
	            if (focusedChip) {
	                focusedChip.toggleSelected();
	            }
	        }
	    };
	    /**
	     * Iterate through the list of chips and add them to our list of
	     * subscribed chips.
	     *
	     * @param chips The list of chips to be subscribed.
	     */
	    MdChipList.prototype._subscribeChips = function (chips) {
	        var _this = this;
	        chips.forEach(function (chip) { return _this._addChip(chip); });
	    };
	    /**
	     * Add a specific chip to our subscribed list. If the chip has
	     * already been subscribed, this ensures it is only subscribed
	     * once.
	     *
	     * @param chip The chip to be subscribed (or checked for existing
	     * subscription).
	     */
	    MdChipList.prototype._addChip = function (chip) {
	        var _this = this;
	        // If we've already been subscribed to a parent, do nothing
	        if (this._subscribed.has(chip)) {
	            return;
	        }
	        // Watch for focus events outside of the keyboard navigation
	        chip.onFocus.subscribe(function () {
	            var chipIndex = _this.chips.toArray().indexOf(chip);
	            if (_this._isValidIndex(chipIndex)) {
	                _this._keyManager.updateActiveItemIndex(chipIndex);
	            }
	        });
	        // On destroy, remove the item from our list, and check focus
	        chip.destroy.subscribe(function () {
	            var chipIndex = _this.chips.toArray().indexOf(chip);
	            if (_this._isValidIndex(chipIndex)) {
	                // Check whether the chip is the last item
	                if (chipIndex < _this.chips.length - 1) {
	                    _this._keyManager.setActiveItem(chipIndex);
	                }
	                else if (chipIndex - 1 >= 0) {
	                    _this._keyManager.setActiveItem(chipIndex - 1);
	                }
	            }
	            _this._subscribed.delete(chip);
	            chip.destroy.unsubscribe();
	        });
	        this._subscribed.set(chip, true);
	    };
	    /**
	     * Utility to ensure all indexes are valid.
	     *
	     * @param index The index to be checked.
	     * @returns True if the index is valid for our list of chips.
	     */
	    MdChipList.prototype._isValidIndex = function (index) {
	        return index >= 0 && index < this.chips.length;
	    };
	    __decorate$44([
	        _angular_core.Input(), 
	        __metadata$44('design:type', Boolean)
	    ], MdChipList.prototype, "selectable", null);
	    MdChipList = __decorate$44([
	        _angular_core.Component({selector: 'md-chip-list, mat-chip-list',
	            template: "<div class=\"md-chip-list-wrapper\"><ng-content></ng-content></div>",
	            host: {
	                // Properties
	                'tabindex': '0',
	                'role': 'listbox',
	                '[class.mat-chip-list]': 'true',
	                // Events
	                '(focus)': 'focus()',
	                '(keydown)': '_keydown($event)'
	            },
	            queries: {
	                chips: new _angular_core.ContentChildren(MdChip)
	            },
	            styles: [".mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:flex-start}.mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){margin:0 3px}.mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):first-child{margin-left:0;margin-right:3px}.mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child,[dir=rtl] .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):first-child{margin-left:3px;margin-right:0}[dir=rtl] .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child{margin-left:0;margin-right:3px}.mat-chip:not(.mat-basic-chip){display:inline-block;padding:8px 12px;border-radius:24px;font-size:13px;line-height:16px}.mat-chip-list-stacked .mat-chip-list-wrapper{display:block}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){display:block;margin:0 0 8px}[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){margin:0 0 8px}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child,[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child{margin-bottom:0}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush
	        }), 
	        __metadata$44('design:paramtypes', [_angular_core.ElementRef])
	    ], MdChipList);
	    return MdChipList;
	}());
	var MdChipsModule = (function () {
	    function MdChipsModule() {
	    }
	    /** @deprecated */
	    MdChipsModule.forRoot = function () {
	        return {
	            ngModule: MdChipsModule,
	            providers: []
	        };
	    };
	    MdChipsModule = __decorate$44([
	        _angular_core.NgModule({
	            imports: [],
	            exports: [MdChipList, MdChip],
	            declarations: [MdChipList, MdChip]
	        }), 
	        __metadata$44('design:paramtypes', [])
	    ], MdChipsModule);
	    return MdChipsModule;
	}());
	
	var __extends$13 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$47 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$47 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Exception thrown when attempting to load an icon with a name that cannot be found.
	 * @docs-private
	 */
	var MdIconNameNotFoundError = (function (_super) {
	    __extends$13(MdIconNameNotFoundError, _super);
	    function MdIconNameNotFoundError(iconName) {
	        _super.call(this, "Unable to find icon with the name \"" + iconName + "\"");
	    }
	    return MdIconNameNotFoundError;
	}(MdError));
	/**
	 * Exception thrown when attempting to load SVG content that does not contain the expected
	 * <svg> tag.
	 * @docs-private
	 */
	var MdIconSvgTagNotFoundError = (function (_super) {
	    __extends$13(MdIconSvgTagNotFoundError, _super);
	    function MdIconSvgTagNotFoundError() {
	        _super.call(this, '<svg> tag not found');
	    }
	    return MdIconSvgTagNotFoundError;
	}(MdError));
	/**
	 * Configuration for an icon, including the URL and possibly the cached SVG element.
	 * @docs-private
	 */
	var SvgIconConfig = (function () {
	    function SvgIconConfig(url) {
	        this.url = url;
	        this.svgElement = null;
	    }
	    return SvgIconConfig;
	}());
	/** Returns the cache key to use for an icon namespace and name. */
	var iconKey = function (namespace, name) { return namespace + ':' + name; };
	/**
	 * Service to register and display icons used by the <md-icon> component.
	 * - Registers icon URLs by namespace and name.
	 * - Registers icon set URLs by namespace.
	 * - Registers aliases for CSS classes, for use with icon fonts.
	 * - Loads icons from URLs and extracts individual icons from icon sets.
	 */
	var MdIconRegistry = (function () {
	    function MdIconRegistry(_http, _sanitizer) {
	        this._http = _http;
	        this._sanitizer = _sanitizer;
	        /**
	         * URLs and cached SVG elements for individual icons. Keys are of the format "[namespace]:[icon]".
	         */
	        this._svgIconConfigs = new Map();
	        /**
	         * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.
	         * Multiple icon sets can be registered under the same namespace.
	         */
	        this._iconSetConfigs = new Map();
	        /** Cache for icons loaded by direct URLs. */
	        this._cachedIconsByUrl = new Map();
	        /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */
	        this._inProgressUrlFetches = new Map();
	        /** Map from font identifiers to their CSS class names. Used for icon fonts. */
	        this._fontCssClassesByAlias = new Map();
	        /**
	         * The CSS class to apply when an <md-icon> component has no icon name, url, or font specified.
	         * The default 'material-icons' value assumes that the material icon font has been loaded as
	         * described at http://google.github.io/material-design-icons/#icon-font-for-the-web
	         */
	        this._defaultFontSetClass = 'material-icons';
	    }
	    /**
	     * Registers an icon by URL in the default namespace.
	     * @param iconName Name under which the icon should be registered.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIcon = function (iconName, url) {
	        return this.addSvgIconInNamespace('', iconName, url);
	    };
	    /**
	     * Registers an icon by URL in the specified namespace.
	     * @param namespace Namespace in which the icon should be registered.
	     * @param iconName Name under which the icon should be registered.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIconInNamespace = function (namespace, iconName, url) {
	        var key = iconKey(namespace, iconName);
	        this._svgIconConfigs.set(key, new SvgIconConfig(url));
	        return this;
	    };
	    /**
	     * Registers an icon set by URL in the default namespace.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIconSet = function (url) {
	        return this.addSvgIconSetInNamespace('', url);
	    };
	    /**
	     * Registers an icon set by URL in the specified namespace.
	     * @param namespace Namespace in which to register the icon set.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIconSetInNamespace = function (namespace, url) {
	        var config = new SvgIconConfig(url);
	        if (this._iconSetConfigs.has(namespace)) {
	            this._iconSetConfigs.get(namespace).push(config);
	        }
	        else {
	            this._iconSetConfigs.set(namespace, [config]);
	        }
	        return this;
	    };
	    /**
	     * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdIcon
	     * component with the alias as the fontSet input will cause the class name to be applied
	     * to the <md-icon> element.
	     *
	     * @param alias Alias for the font.
	     * @param className Class name override to be used instead of the alias.
	     */
	    MdIconRegistry.prototype.registerFontClassAlias = function (alias, className) {
	        if (className === void 0) { className = alias; }
	        this._fontCssClassesByAlias.set(alias, className);
	        return this;
	    };
	    /**
	     * Returns the CSS class name associated with the alias by a previous call to
	     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
	     */
	    MdIconRegistry.prototype.classNameForFontAlias = function (alias) {
	        return this._fontCssClassesByAlias.get(alias) || alias;
	    };
	    /**
	     * Sets the CSS class name to be used for icon fonts when an <md-icon> component does not
	     * have a fontSet input value, and is not loading an icon by name or URL.
	     *
	     * @param className
	     */
	    MdIconRegistry.prototype.setDefaultFontSetClass = function (className) {
	        this._defaultFontSetClass = className;
	        return this;
	    };
	    /**
	     * Returns the CSS class name to be used for icon fonts when an <md-icon> component does not
	     * have a fontSet input value, and is not loading an icon by name or URL.
	     */
	    MdIconRegistry.prototype.getDefaultFontSetClass = function () {
	        return this._defaultFontSetClass;
	    };
	    /**
	     * Returns an Observable that produces the icon (as an <svg> DOM element) from the given URL.
	     * The response from the URL may be cached so this will not always cause an HTTP request, but
	     * the produced element will always be a new copy of the originally fetched icon. (That is,
	     * it will not contain any modifications made to elements previously returned).
	     *
	     * @param safeUrl URL from which to fetch the SVG icon.
	     */
	    MdIconRegistry.prototype.getSvgIconFromUrl = function (safeUrl) {
	        var _this = this;
	        var url = this._sanitizer.sanitize(_angular_core.SecurityContext.RESOURCE_URL, safeUrl);
	        if (this._cachedIconsByUrl.has(url)) {
	            return rxjs_Observable.Observable.of(cloneSvg(this._cachedIconsByUrl.get(url)));
	        }
	        return this._loadSvgIconFromConfig(new SvgIconConfig(url))
	            .do(function (svg) { return _this._cachedIconsByUrl.set(url, svg); })
	            .map(function (svg) { return cloneSvg(svg); });
	    };
	    /**
	     * Returns an Observable that produces the icon (as an <svg> DOM element) with the given name
	     * and namespace. The icon must have been previously registered with addIcon or addIconSet;
	     * if not, the Observable will throw an MdIconNameNotFoundError.
	     *
	     * @param name Name of the icon to be retrieved.
	     * @param namespace Namespace in which to look for the icon.
	     */
	    MdIconRegistry.prototype.getNamedSvgIcon = function (name, namespace) {
	        if (namespace === void 0) { namespace = ''; }
	        // Return (copy of) cached icon if possible.
	        var key = iconKey(namespace, name);
	        if (this._svgIconConfigs.has(key)) {
	            return this._getSvgFromConfig(this._svgIconConfigs.get(key));
	        }
	        // See if we have any icon sets registered for the namespace.
	        var iconSetConfigs = this._iconSetConfigs.get(namespace);
	        if (iconSetConfigs) {
	            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);
	        }
	        return rxjs_Observable.Observable.throw(new MdIconNameNotFoundError(key));
	    };
	    /**
	     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
	     */
	    MdIconRegistry.prototype._getSvgFromConfig = function (config) {
	        if (config.svgElement) {
	            // We already have the SVG element for this icon, return a copy.
	            return rxjs_Observable.Observable.of(cloneSvg(config.svgElement));
	        }
	        else {
	            // Fetch the icon from the config's URL, cache it, and return a copy.
	            return this._loadSvgIconFromConfig(config)
	                .do(function (svg) { return config.svgElement = svg; })
	                .map(function (svg) { return cloneSvg(svg); });
	        }
	    };
	    /**
	     * Attempts to find an icon with the specified name in any of the SVG icon sets.
	     * First searches the available cached icons for a nested element with a matching name, and
	     * if found copies the element to a new <svg> element. If not found, fetches all icon sets
	     * that have not been cached, and searches again after all fetches are completed.
	     * The returned Observable produces the SVG element if possible, and throws
	     * MdIconNameNotFoundError if no icon with the specified name can be found.
	     */
	    MdIconRegistry.prototype._getSvgFromIconSetConfigs = function (name, iconSetConfigs) {
	        var _this = this;
	        // For all the icon set SVG elements we've fetched, see if any contain an icon with the
	        // requested name.
	        var namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
	        if (namedIcon) {
	            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every
	            // time anyway, there's probably not much advantage compared to just always extracting
	            // it from the icon set.
	            return rxjs_Observable.Observable.of(namedIcon);
	        }
	        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't
	        // fetched, fetch them now and look for iconName in the results.
	        var iconSetFetchRequests = iconSetConfigs
	            .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })
	            .map(function (iconSetConfig) {
	            return _this._loadSvgIconSetFromConfig(iconSetConfig)
	                .catch(function (err, caught) {
	                var url = _this._sanitizer.sanitize(_angular_core.SecurityContext.RESOURCE_URL, iconSetConfig.url);
	                // Swallow errors fetching individual URLs so the combined Observable won't
	                // necessarily fail.
	                console.log("Loading icon set URL: " + url + " failed: " + err);
	                return rxjs_Observable.Observable.of(null);
	            })
	                .do(function (svg) {
	                // Cache SVG element.
	                if (svg) {
	                    iconSetConfig.svgElement = svg;
	                }
	            });
	        });
	        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a
	        // cached SVG element (unless the request failed), and we can check again for the icon.
	        return rxjs_Observable.Observable.forkJoin(iconSetFetchRequests)
	            .map(function (ignoredResults) {
	            var foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);
	            if (!foundIcon) {
	                throw new MdIconNameNotFoundError(name);
	            }
	            return foundIcon;
	        });
	    };
	    /**
	     * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
	     * tag matches the specified name. If found, copies the nested element to a new SVG element and
	     * returns it. Returns null if no matching element is found.
	     */
	    MdIconRegistry.prototype._extractIconWithNameFromAnySet = function (iconName, iconSetConfigs) {
	        // Iterate backwards, so icon sets added later have precedence.
	        for (var i = iconSetConfigs.length - 1; i >= 0; i--) {
	            var config = iconSetConfigs[i];
	            if (config.svgElement) {
	                var foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName);
	                if (foundIcon) {
	                    return foundIcon;
	                }
	            }
	        }
	        return null;
	    };
	    /**
	     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
	     * from it.
	     */
	    MdIconRegistry.prototype._loadSvgIconFromConfig = function (config) {
	        var _this = this;
	        return this._fetchUrl(config.url)
	            .map(function (svgText) { return _this._createSvgElementForSingleIcon(svgText); });
	    };
	    /**
	     * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
	     * from it.
	     */
	    MdIconRegistry.prototype._loadSvgIconSetFromConfig = function (config) {
	        var _this = this;
	        // TODO: Document that icons should only be loaded from trusted sources.
	        return this._fetchUrl(config.url)
	            .map(function (svgText) { return _this._svgElementFromString(svgText); });
	    };
	    /**
	     * Creates a DOM element from the given SVG string, and adds default attributes.
	     */
	    MdIconRegistry.prototype._createSvgElementForSingleIcon = function (responseText) {
	        var svg = this._svgElementFromString(responseText);
	        this._setSvgAttributes(svg);
	        return svg;
	    };
	    /**
	     * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
	     * tag matches the specified name. If found, copies the nested element to a new SVG element and
	     * returns it. Returns null if no matching element is found.
	     */
	    MdIconRegistry.prototype._extractSvgIconFromSet = function (iconSet, iconName) {
	        var iconNode = iconSet.querySelector('#' + iconName);
	        if (!iconNode) {
	            return null;
	        }
	        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as
	        // the content of a new <svg> node.
	        if (iconNode.tagName.toLowerCase() == 'svg') {
	            return this._setSvgAttributes(iconNode.cloneNode(true));
	        }
	        // createElement('SVG') doesn't work as expected; the DOM ends up with
	        // the correct nodes, but the SVG content doesn't render. Instead we
	        // have to create an empty SVG node using innerHTML and append its content.
	        // Elements created using DOMParser.parseFromString have the same problem.
	        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display
	        var svg = this._svgElementFromString('<svg></svg>');
	        // Clone the node so we don't remove it from the parent icon set element.
	        svg.appendChild(iconNode.cloneNode(true));
	        return this._setSvgAttributes(svg);
	    };
	    /**
	     * Creates a DOM element from the given SVG string.
	     */
	    MdIconRegistry.prototype._svgElementFromString = function (str) {
	        // TODO: Is there a better way than innerHTML? Renderer doesn't appear to have a method for
	        // creating an element from an HTML string.
	        var div = document.createElement('DIV');
	        div.innerHTML = str;
	        var svg = div.querySelector('svg');
	        if (!svg) {
	            throw new MdIconSvgTagNotFoundError();
	        }
	        return svg;
	    };
	    /**
	     * Sets the default attributes for an SVG element to be used as an icon.
	     */
	    MdIconRegistry.prototype._setSvgAttributes = function (svg) {
	        if (!svg.getAttribute('xmlns')) {
	            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
	        }
	        svg.setAttribute('fit', '');
	        svg.setAttribute('height', '100%');
	        svg.setAttribute('width', '100%');
	        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
	        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
	        return svg;
	    };
	    /**
	     * Returns an Observable which produces the string contents of the given URL. Results may be
	     * cached, so future calls with the same URL may not cause another HTTP request.
	     */
	    MdIconRegistry.prototype._fetchUrl = function (safeUrl) {
	        var _this = this;
	        var url = this._sanitizer.sanitize(_angular_core.SecurityContext.RESOURCE_URL, safeUrl);
	        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
	        // already a request in progress for that URL. It's necessary to call share() on the
	        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
	        if (this._inProgressUrlFetches.has(url)) {
	            return this._inProgressUrlFetches.get(url);
	        }
	        // TODO(jelbourn): for some reason, the `finally` operator "loses" the generic type on the
	        // Observable. Figure out why and fix it.
	        var req = this._http.get(url)
	            .map(function (response) { return response.text(); })
	            .finally(function () {
	            _this._inProgressUrlFetches.delete(url);
	        })
	            .share();
	        this._inProgressUrlFetches.set(url, req);
	        return req;
	    };
	    MdIconRegistry = __decorate$47([
	        _angular_core.Injectable(), 
	        __metadata$47('design:paramtypes', [_angular_http.Http, _angular_platformBrowser.DomSanitizer])
	    ], MdIconRegistry);
	    return MdIconRegistry;
	}());
	/** Clones an SVGElement while preserving type information. */
	function cloneSvg(svg) {
	    return svg.cloneNode(true);
	}
	
	var __extends$12 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$46 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$46 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Exception thrown when an invalid icon name is passed to an md-icon component. */
	var MdIconInvalidNameError = (function (_super) {
	    __extends$12(MdIconInvalidNameError, _super);
	    function MdIconInvalidNameError(iconName) {
	        _super.call(this, "Invalid icon name: \"" + iconName + "\"");
	    }
	    return MdIconInvalidNameError;
	}(MdError));
	/**
	 * Component to display an icon. It can be used in the following ways:
	 * - Specify the svgSrc input to load an SVG icon from a URL. The SVG content is directly inlined
	 *   as a child of the <md-icon> component, so that CSS styles can easily be applied to it.
	 *   The URL is loaded via an XMLHttpRequest, so it must be on the same domain as the page or its
	 *   server must be configured to allow cross-domain requests.
	 *   Example:
	 *     <md-icon svgSrc="assets/arrow.svg"></md-icon>
	 *
	 * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the
	 *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of
	 *   MdIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format
	 *   "[namespace]:[name]", if not the value will be the name of an icon in the default namespace.
	 *   Examples:
	 *     <md-icon svgIcon="left-arrow"></md-icon>
	 *     <md-icon svgIcon="animals:cat"></md-icon>
	 *
	 * - Use a font ligature as an icon by putting the ligature text in the content of the <md-icon>
	 *   component. By default the Material icons font is used as described at
	 *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an
	 *   alternate font by setting the fontSet input to either the CSS class to apply to use the
	 *   desired font, or to an alias previously registered with MdIconRegistry.registerFontClassAlias.
	 *   Examples:
	 *     <md-icon>home</md-icon>
	 *     <md-icon fontSet="myfont">sun</md-icon>
	 *
	 * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the
	 *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a
	 *   CSS class which causes the glyph to be displayed via a :before selector, as in
	 *   https://fortawesome.github.io/Font-Awesome/examples/
	 *   Example:
	 *     <md-icon fontSet="fa" fontIcon="alarm"></md-icon>
	 */
	var MdIcon = (function () {
	    function MdIcon(_elementRef, _renderer, _mdIconRegistry) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._mdIconRegistry = _mdIconRegistry;
	        /** Screenreader label for the icon. */
	        this.hostAriaLabel = '';
	    }
	    Object.defineProperty(MdIcon.prototype, "color", {
	        /** Color of the icon. */
	        get: function () { return this._color; },
	        set: function (value) { this._updateColor(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdIcon.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdIcon.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    /**
	     * Splits an svgIcon binding value into its icon set and icon name components.
	     * Returns a 2-element array of [(icon set), (icon name)].
	     * The separator for the two fields is ':'. If there is no separator, an empty
	     * string is returned for the icon set and the entire value is returned for
	     * the icon name. If the argument is falsy, returns an array of two empty strings.
	     * Throws a MdIconInvalidNameError if the name contains two or more ':' separators.
	     * Examples:
	     *   'social:cake' -> ['social', 'cake']
	     *   'penguin' -> ['', 'penguin']
	     *   null -> ['', '']
	     *   'a:b:c' -> (throws MdIconInvalidNameError)
	     */
	    MdIcon.prototype._splitIconName = function (iconName) {
	        if (!iconName) {
	            return ['', ''];
	        }
	        var parts = iconName.split(':');
	        switch (parts.length) {
	            case 1:
	                // Use default namespace.
	                return ['', parts[0]];
	            case 2:
	                return parts;
	            default:
	                throw new MdIconInvalidNameError(iconName);
	        }
	    };
	    MdIcon.prototype.ngOnChanges = function (changes) {
	        var _this = this;
	        var changedInputs = Object.keys(changes);
	        // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.
	        if (changedInputs.indexOf('svgIcon') != -1 || changedInputs.indexOf('svgSrc') != -1) {
	            if (this.svgIcon) {
	                var _a = this._splitIconName(this.svgIcon), namespace = _a[0], iconName = _a[1];
	                this._mdIconRegistry.getNamedSvgIcon(iconName, namespace).first().subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) { return console.log("Error retrieving icon: " + err); });
	            }
	        }
	        if (this._usingFontIcon()) {
	            this._updateFontIconClasses();
	        }
	        this._updateAriaLabel();
	    };
	    MdIcon.prototype.ngOnInit = function () {
	        // Update font classes because ngOnChanges won't be called if none of the inputs are present,
	        // e.g. <md-icon>arrow</md-icon>. In this case we need to add a CSS class for the default font.
	        if (this._usingFontIcon()) {
	            this._updateFontIconClasses();
	        }
	    };
	    MdIcon.prototype.ngAfterViewChecked = function () {
	        // Update aria label here because it may depend on the projected text content.
	        // (e.g. <md-icon>home</md-icon> should use 'home').
	        this._updateAriaLabel();
	    };
	    MdIcon.prototype._updateAriaLabel = function () {
	        var ariaLabel = this._getAriaLabel();
	        if (ariaLabel && ariaLabel !== this._previousAriaLabel) {
	            this._previousAriaLabel = ariaLabel;
	            this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-label', ariaLabel);
	        }
	    };
	    MdIcon.prototype._getAriaLabel = function () {
	        // If the parent provided an aria-label attribute value, use it as-is. Otherwise look for a
	        // reasonable value from the alt attribute, font icon name, SVG icon name, or (for ligatures)
	        // the text content of the directive.
	        var label = this.hostAriaLabel ||
	            this.alt ||
	            this.fontIcon ||
	            this._splitIconName(this.svgIcon)[1];
	        if (label) {
	            return label;
	        }
	        // The "content" of an SVG icon is not a useful label.
	        if (this._usingFontIcon()) {
	            var text = this._elementRef.nativeElement.textContent;
	            if (text) {
	                return text;
	            }
	        }
	        // TODO: Warn here in dev mode.
	        return null;
	    };
	    MdIcon.prototype._usingFontIcon = function () {
	        return !this.svgIcon;
	    };
	    MdIcon.prototype._setSvgElement = function (svg) {
	        var layoutElement = this._elementRef.nativeElement;
	        // Remove existing child nodes and add the new SVG element.
	        // We would use renderer.detachView(Array.from(layoutElement.childNodes)) here,
	        // but it fails in IE11: https://github.com/angular/angular/issues/6327
	        layoutElement.innerHTML = '';
	        this._renderer.projectNodes(layoutElement, [svg]);
	    };
	    MdIcon.prototype._updateFontIconClasses = function () {
	        if (!this._usingFontIcon()) {
	            return;
	        }
	        var elem = this._elementRef.nativeElement;
	        var fontSetClass = this.fontSet ?
	            this._mdIconRegistry.classNameForFontAlias(this.fontSet) :
	            this._mdIconRegistry.getDefaultFontSetClass();
	        if (fontSetClass != this._previousFontSetClass) {
	            if (this._previousFontSetClass) {
	                this._renderer.setElementClass(elem, this._previousFontSetClass, false);
	            }
	            if (fontSetClass) {
	                this._renderer.setElementClass(elem, fontSetClass, true);
	            }
	            this._previousFontSetClass = fontSetClass;
	        }
	        if (this.fontIcon != this._previousFontIconClass) {
	            if (this._previousFontIconClass) {
	                this._renderer.setElementClass(elem, this._previousFontIconClass, false);
	            }
	            if (this.fontIcon) {
	                this._renderer.setElementClass(elem, this.fontIcon, true);
	            }
	            this._previousFontIconClass = this.fontIcon;
	        }
	    };
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "svgIcon", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "fontSet", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "fontIcon", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "alt", void 0);
	    __decorate$46([
	        _angular_core.Input('aria-label'), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "hostAriaLabel", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "color", null);
	    MdIcon = __decorate$46([
	        _angular_core.Component({template: '<ng-content></ng-content>',
	            selector: 'md-icon, mat-icon',
	            styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}"],
	            host: {
	                'role': 'img',
	                '[class.mat-icon]': 'true',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$46('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer, MdIconRegistry])
	    ], MdIcon);
	    return MdIcon;
	}());
	function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, http, sanitizer) {
	    return parentRegistry || new MdIconRegistry(http, sanitizer);
	}
	
	var ICON_REGISTRY_PROVIDER = {
	    // If there is already an MdIconRegistry available, use that. Otherwise, provide a new one.
	    provide: MdIconRegistry,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), MdIconRegistry], _angular_http.Http, _angular_platformBrowser.DomSanitizer],
	    useFactory: ICON_REGISTRY_PROVIDER_FACTORY,
	};
	var MdIconModule = (function () {
	    function MdIconModule() {
	    }
	    /** @deprecated */
	    MdIconModule.forRoot = function () {
	        return {
	            ngModule: MdIconModule,
	            providers: [],
	        };
	    };
	    MdIconModule = __decorate$46([
	        _angular_core.NgModule({
	            imports: [_angular_http.HttpModule, CompatibilityModule],
	            exports: [MdIcon, CompatibilityModule],
	            declarations: [MdIcon],
	            providers: [ICON_REGISTRY_PROVIDER],
	        }), 
	        __metadata$46('design:paramtypes', [])
	    ], MdIconModule);
	    return MdIconModule;
	}());
	
	var __extends$14 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$48 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$48 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(josephperrott): Benchpress tests.
	/** A single degree in radians. */
	var DEGREE_IN_RADIANS = Math.PI / 180;
	/** Duration of the indeterminate animation. */
	var DURATION_INDETERMINATE = 667;
	/** Duration of the indeterminate animation. */
	var DURATION_DETERMINATE = 225;
	/** Start animation value of the indeterminate animation */
	var startIndeterminate = 3;
	/** End animation value of the indeterminate animation */
	var endIndeterminate = 80;
	/* Maximum angle for the arc. The angle can't be exactly 360, because the arc becomes hidden. */
	var MAX_ANGLE = 359.99 / 100;
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdProgressSpinnerCssMatStyler = (function () {
	    function MdProgressSpinnerCssMatStyler() {
	    }
	    MdProgressSpinnerCssMatStyler = __decorate$48([
	        _angular_core.Directive({
	            selector: 'md-progress-spinner, mat-progress-spinner',
	            host: {
	                '[class.mat-progress-spinner]': 'true'
	            }
	        }), 
	        __metadata$48('design:paramtypes', [])
	    ], MdProgressSpinnerCssMatStyler);
	    return MdProgressSpinnerCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdProgressCircleCssMatStyler = (function () {
	    function MdProgressCircleCssMatStyler() {
	    }
	    MdProgressCircleCssMatStyler = __decorate$48([
	        _angular_core.Directive({
	            selector: 'md-progress-circle, mat-progress-circle',
	            host: {
	                '[class.mat-progress-circle]': 'true'
	            }
	        }), 
	        __metadata$48('design:paramtypes', [])
	    ], MdProgressCircleCssMatStyler);
	    return MdProgressCircleCssMatStyler;
	}());
	/**
	 * <md-progress-spinner> component.
	 */
	var MdProgressSpinner = (function () {
	    function MdProgressSpinner(_ngZone, _elementRef, _renderer) {
	        this._ngZone = _ngZone;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** The id of the last requested animation. */
	        this._lastAnimationId = 0;
	        this._mode = 'determinate';
	        this._color = 'primary';
	    }
	    Object.defineProperty(MdProgressSpinner.prototype, "_ariaValueMin", {
	        /**
	         * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this
	         * because voiceover does not report the progress indicator as indeterminate if the aria min
	         * and/or max value are number values.
	         */
	        get: function () {
	            return this.mode == 'determinate' ? 0 : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "_ariaValueMax", {
	        get: function () {
	            return this.mode == 'determinate' ? 100 : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "interdeterminateInterval", {
	        /** @docs-private */
	        get: function () {
	            return this._interdeterminateInterval;
	        },
	        /** @docs-private */
	        set: function (interval) {
	            clearInterval(this._interdeterminateInterval);
	            this._interdeterminateInterval = interval;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clean up any animations that were running.
	     */
	    MdProgressSpinner.prototype.ngOnDestroy = function () {
	        this._cleanupIndeterminateAnimation();
	    };
	    Object.defineProperty(MdProgressSpinner.prototype, "color", {
	        /** The color of the progress-spinner. Can be primary, accent, or warn. */
	        get: function () { return this._color; },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "value", {
	        /** Value of the progress circle. It is bound to the host as the attribute aria-valuenow. */
	        get: function () {
	            if (this.mode == 'determinate') {
	                return this._value;
	            }
	        },
	        set: function (v) {
	            if (v != null && this.mode == 'determinate') {
	                var newValue = clamp(v);
	                this._animateCircle((this.value || 0), newValue, linearEase, DURATION_DETERMINATE, 0);
	                this._value = newValue;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "mode", {
	        /**
	         * Mode of the progress circle
	         *
	         * Input must be one of the values from ProgressMode, defaults to 'determinate'.
	         * mode is bound to the host as the attribute host.
	         */
	        get: function () {
	            return this._mode;
	        },
	        set: function (m) {
	            if (m == 'indeterminate') {
	                this._startIndeterminateAnimation();
	            }
	            else {
	                this._cleanupIndeterminateAnimation();
	            }
	            this._mode = m;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Animates the circle from one percentage value to another.
	     *
	     * @param animateFrom The percentage of the circle filled starting the animation.
	     * @param animateTo The percentage of the circle filled ending the animation.
	     * @param ease The easing function to manage the pace of change in the animation.
	     * @param duration The length of time to show the animation, in milliseconds.
	     * @param rotation The starting angle of the circle fill, with 0 represented at the top center
	     *    of the circle.
	     */
	    MdProgressSpinner.prototype._animateCircle = function (animateFrom, animateTo, ease, duration, rotation) {
	        var _this = this;
	        var id = ++this._lastAnimationId;
	        var startTime = Date.now();
	        var changeInValue = animateTo - animateFrom;
	        // No need to animate it if the values are the same
	        if (animateTo === animateFrom) {
	            this._renderArc(animateTo, rotation);
	        }
	        else {
	            var animation_1 = function () {
	                var elapsedTime = Math.max(0, Math.min(Date.now() - startTime, duration));
	                _this._renderArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);
	                // Prevent overlapping animations by checking if a new animation has been called for and
	                // if the animation has lasted longer than the animation duration.
	                if (id === _this._lastAnimationId && elapsedTime < duration) {
	                    requestAnimationFrame(animation_1);
	                }
	            };
	            // Run the animation outside of Angular's zone, in order to avoid
	            // hitting ZoneJS and change detection on each frame.
	            this._ngZone.runOutsideAngular(animation_1);
	        }
	    };
	    /**
	     * Starts the indeterminate animation interval, if it is not already running.
	     */
	    MdProgressSpinner.prototype._startIndeterminateAnimation = function () {
	        var _this = this;
	        var rotationStartPoint = 0;
	        var start = startIndeterminate;
	        var end = endIndeterminate;
	        var duration = DURATION_INDETERMINATE;
	        var animate$$1 = function () {
	            _this._animateCircle(start, end, materialEase, duration, rotationStartPoint);
	            // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.
	            rotationStartPoint = (rotationStartPoint + end) % 100;
	            var temp = start;
	            start = -end;
	            end = -temp;
	        };
	        if (!this.interdeterminateInterval) {
	            this._ngZone.runOutsideAngular(function () {
	                _this.interdeterminateInterval = setInterval(animate$$1, duration + 50, 0, false);
	                animate$$1();
	            });
	        }
	    };
	    /**
	     * Removes interval, ending the animation.
	     */
	    MdProgressSpinner.prototype._cleanupIndeterminateAnimation = function () {
	        this.interdeterminateInterval = null;
	    };
	    /**
	     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper
	     * DOM attribute on the `<path>`.
	     */
	    MdProgressSpinner.prototype._renderArc = function (currentValue, rotation) {
	        // Caches the path reference so it doesn't have to be looked up every time.
	        var path = this._path = this._path || this._elementRef.nativeElement.querySelector('path');
	        // Ensure that the path was found. This may not be the case if the
	        // animation function fires too early.
	        if (path) {
	            path.setAttribute('d', getSvgArc(currentValue, rotation));
	        }
	    };
	    /**
	     * Updates the color of the progress-spinner by adding the new palette class to the element
	     * and removing the old one.
	     */
	    MdProgressSpinner.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    /** Sets the given palette class on the component element. */
	    MdProgressSpinner.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    __decorate$48([
	        _angular_core.Input(), 
	        __metadata$48('design:type', String)
	    ], MdProgressSpinner.prototype, "color", null);
	    __decorate$48([
	        _angular_core.Input(),
	        _angular_core.HostBinding('attr.aria-valuenow'), 
	        __metadata$48('design:type', Object)
	    ], MdProgressSpinner.prototype, "value", null);
	    __decorate$48([
	        _angular_core.HostBinding('attr.mode'),
	        _angular_core.Input(), 
	        __metadata$48('design:type', Object)
	    ], MdProgressSpinner.prototype, "mode", null);
	    MdProgressSpinner = __decorate$48([
	        _angular_core.Component({selector: 'md-progress-spinner, mat-progress-spinner, md-progress-circle, mat-progress-circle',
	            host: {
	                'role': 'progressbar',
	                '[attr.aria-valuemin]': '_ariaValueMin',
	                '[attr.aria-valuemax]': '_ariaValueMax'
	            },
	            template: "<svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid meet\"><path></path></svg>",
	            styles: [":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;stroke-width:10px}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}"],
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$48('design:paramtypes', [_angular_core.NgZone, _angular_core.ElementRef, _angular_core.Renderer])
	    ], MdProgressSpinner);
	    return MdProgressSpinner;
	}());
	/**
	 * <md-spinner> component.
	 *
	 * This is a component definition to be used as a convenience reference to create an
	 * indeterminate <md-progress-spinner> instance.
	 */
	var MdSpinner = (function (_super) {
	    __extends$14(MdSpinner, _super);
	    function MdSpinner(elementRef, ngZone, renderer) {
	        _super.call(this, ngZone, elementRef, renderer);
	        this.mode = 'indeterminate';
	    }
	    MdSpinner.prototype.ngOnDestroy = function () {
	        // The `ngOnDestroy` from `MdProgressSpinner` should be called explicitly, because
	        // in certain cases Angular won't call it (e.g. when using AoT and in unit tests).
	        _super.prototype.ngOnDestroy.call(this);
	    };
	    MdSpinner = __decorate$48([
	        _angular_core.Component({selector: 'md-spinner, mat-spinner',
	            host: {
	                'role': 'progressbar',
	                'mode': 'indeterminate',
	                '[class.mat-spinner]': 'true',
	            },
	            template: "<svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid meet\"><path></path></svg>",
	            styles: [":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;stroke-width:10px}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}"],
	        }), 
	        __metadata$48('design:paramtypes', [_angular_core.ElementRef, _angular_core.NgZone, _angular_core.Renderer])
	    ], MdSpinner);
	    return MdSpinner;
	}(MdProgressSpinner));
	/**
	 * Module functions.
	 */
	/** Clamps a value to be between 0 and 100. */
	function clamp(v) {
	    return Math.max(0, Math.min(100, v));
	}
	/**
	 * Converts Polar coordinates to Cartesian.
	 */
	function polarToCartesian(radius, pathRadius, angleInDegrees) {
	    var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
	    return (radius + (pathRadius * Math.cos(angleInRadians))) +
	        ',' + (radius + (pathRadius * Math.sin(angleInRadians)));
	}
	/**
	 * Easing function for linear animation.
	 */
	function linearEase(currentTime, startValue, changeInValue, duration) {
	    return changeInValue * currentTime / duration + startValue;
	}
	/**
	 * Easing function to match material design indeterminate animation.
	 */
	function materialEase(currentTime, startValue, changeInValue, duration) {
	    var time = currentTime / duration;
	    var timeCubed = Math.pow(time, 3);
	    var timeQuad = Math.pow(time, 4);
	    var timeQuint = Math.pow(time, 5);
	    return startValue + changeInValue * ((6 * timeQuint) + (-15 * timeQuad) + (10 * timeCubed));
	}
	/**
	 * Determines the path value to define the arc.  Converting percentage values to to polar
	 * coordinates on the circle, and then to cartesian coordinates in the viewport.
	 *
	 * @param currentValue The current percentage value of the progress circle, the percentage of the
	 *    circle to fill.
	 * @param rotation The starting point of the circle with 0 being the 0 degree point.
	 * @return A string for an SVG path representing a circle filled from the starting point to the
	 *    percentage value provided.
	 */
	function getSvgArc(currentValue, rotation) {
	    var startPoint = rotation || 0;
	    var radius = 50;
	    var pathRadius = 40;
	    var startAngle = startPoint * MAX_ANGLE;
	    var endAngle = currentValue * MAX_ANGLE;
	    var start = polarToCartesian(radius, pathRadius, startAngle);
	    var end = polarToCartesian(radius, pathRadius, endAngle + startAngle);
	    var arcSweep = endAngle < 0 ? 0 : 1;
	    var largeArcFlag;
	    if (endAngle < 0) {
	        largeArcFlag = endAngle >= -180 ? 0 : 1;
	    }
	    else {
	        largeArcFlag = endAngle <= 180 ? 0 : 1;
	    }
	    return "M" + start + "A" + pathRadius + "," + pathRadius + " 0 " + largeArcFlag + "," + arcSweep + " " + end;
	}
	var MdProgressSpinnerModule = (function () {
	    function MdProgressSpinnerModule() {
	    }
	    /** @deprecated */
	    MdProgressSpinnerModule.forRoot = function () {
	        return {
	            ngModule: MdProgressSpinnerModule,
	            providers: []
	        };
	    };
	    MdProgressSpinnerModule = __decorate$48([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [
	                MdProgressSpinner,
	                MdSpinner,
	                CompatibilityModule,
	                MdProgressSpinnerCssMatStyler,
	                MdProgressCircleCssMatStyler
	            ],
	            declarations: [
	                MdProgressSpinner,
	                MdSpinner,
	                MdProgressSpinnerCssMatStyler,
	                MdProgressCircleCssMatStyler
	            ],
	        }), 
	        __metadata$48('design:paramtypes', [])
	    ], MdProgressSpinnerModule);
	    return MdProgressSpinnerModule;
	}());
	
	/** @deprecated */
	
	var __decorate$49 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$49 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(josephperrott): Benchpress tests.
	// TODO(josephperrott): Add ARIA attributes for progressbar "for".
	/**
	 * <md-progress-bar> component.
	 */
	var MdProgressBar = (function () {
	    function MdProgressBar() {
	        /** Color of the progress bar. */
	        this.color = 'primary';
	        this._value = 0;
	        this._bufferValue = 0;
	        /**
	         * Mode of the progress bar.
	         *
	         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
	         * 'determinate'.
	         * Mirrored to mode attribute.
	         */
	        this.mode = 'determinate';
	    }
	    Object.defineProperty(MdProgressBar.prototype, "value", {
	        /** Value of the progressbar. Defaults to zero. Mirrored to aria-valuenow. */
	        get: function () { return this._value; },
	        set: function (v) { this._value = clamp$1(v || 0); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressBar.prototype, "bufferValue", {
	        /** Buffer value of the progress bar. Defaults to zero. */
	        get: function () { return this._bufferValue; },
	        set: function (v) { this._bufferValue = clamp$1(v || 0); },
	        enumerable: true,
	        configurable: true
	    });
	    /** Gets the current transform value for the progress bar's primary indicator. */
	    MdProgressBar.prototype._primaryTransform = function () {
	        var scale = this.value / 100;
	        return { transform: "scaleX(" + scale + ")" };
	    };
	    /**
	     * Gets the current transform value for the progress bar's buffer indicator.  Only used if the
	     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.
	     */
	    MdProgressBar.prototype._bufferTransform = function () {
	        if (this.mode == 'buffer') {
	            var scale = this.bufferValue / 100;
	            return { transform: "scaleX(" + scale + ")" };
	        }
	    };
	    __decorate$49([
	        _angular_core.Input(), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "color", void 0);
	    __decorate$49([
	        _angular_core.Input(),
	        _angular_core.HostBinding('attr.aria-valuenow'), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "value", null);
	    __decorate$49([
	        _angular_core.Input(), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "bufferValue", null);
	    __decorate$49([
	        _angular_core.Input(),
	        _angular_core.HostBinding('attr.mode'), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "mode", void 0);
	    MdProgressBar = __decorate$49([
	        _angular_core.Component({selector: 'md-progress-bar, mat-progress-bar',
	            host: {
	                'role': 'progressbar',
	                'aria-valuemin': '0',
	                'aria-valuemax': '100',
	                '[class.mat-primary]': 'color == "primary"',
	                '[class.mat-accent]': 'color == "accent"',
	                '[class.mat-warn]': 'color == "warn"',
	                '[class.mat-progress-bar]': 'true',
	            },
	            template: "<div class=\"mat-progress-bar-background mat-progress-bar-element\"></div><div class=\"mat-progress-bar-buffer mat-progress-bar-element\" [ngStyle]=\"_bufferTransform()\"></div><div class=\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\" [ngStyle]=\"_primaryTransform()\"></div><div class=\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\"></div>",
	            styles: [":host{display:block;height:5px;overflow:hidden;position:relative;transform:translateZ(0);transition:opacity 250ms linear;width:100%}:host .mat-progress-bar-element,:host .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}:host .mat-progress-bar-background{background-repeat:repeat-x;background-size:10px 4px;display:none}:host .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}:host .mat-progress-bar-secondary{display:none}:host .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}:host .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}:host[mode=query]{transform:rotateZ(180deg)}:host[mode=query] .mat-progress-bar-fill,:host[mode=indeterminate] .mat-progress-bar-fill{transition:none}:host[mode=query] .mat-progress-bar-primary,:host[mode=indeterminate] .mat-progress-bar-primary{animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}:host[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after,:host[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after{animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}:host[mode=query] .mat-progress-bar-secondary,:host[mode=indeterminate] .mat-progress-bar-secondary{animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}:host[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after,:host[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}:host[mode=buffer] .mat-progress-bar-background{animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}:host-context([dir=rtl]){transform:rotateY(180deg)}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-10px)}}"],
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$49('design:paramtypes', [])
	    ], MdProgressBar);
	    return MdProgressBar;
	}());
	/** Clamps a value to be between two numbers, by default 0 and 100. */
	function clamp$1(v, min, max) {
	    if (min === void 0) { min = 0; }
	    if (max === void 0) { max = 100; }
	    return Math.max(min, Math.min(max, v));
	}
	var MdProgressBarModule = (function () {
	    function MdProgressBarModule() {
	    }
	    /** @deprecated */
	    MdProgressBarModule.forRoot = function () {
	        return {
	            ngModule: MdProgressBarModule,
	            providers: []
	        };
	    };
	    MdProgressBarModule = __decorate$49([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, CompatibilityModule],
	            exports: [MdProgressBar, CompatibilityModule],
	            declarations: [MdProgressBar],
	        }), 
	        __metadata$49('design:paramtypes', [])
	    ], MdProgressBarModule);
	    return MdProgressBarModule;
	}());
	
	var __extends$15 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/** @docs-private */
	var MdInputContainerPlaceholderConflictError = (function (_super) {
	    __extends$15(MdInputContainerPlaceholderConflictError, _super);
	    function MdInputContainerPlaceholderConflictError() {
	        _super.call(this, 'Placeholder attribute and child element were both specified.');
	    }
	    return MdInputContainerPlaceholderConflictError;
	}(MdError));
	/** @docs-private */
	var MdInputContainerUnsupportedTypeError = (function (_super) {
	    __extends$15(MdInputContainerUnsupportedTypeError, _super);
	    function MdInputContainerUnsupportedTypeError(type) {
	        _super.call(this, "Input type \"" + type + "\" isn't supported by md-input-container.");
	    }
	    return MdInputContainerUnsupportedTypeError;
	}(MdError));
	/** @docs-private */
	var MdInputContainerDuplicatedHintError = (function (_super) {
	    __extends$15(MdInputContainerDuplicatedHintError, _super);
	    function MdInputContainerDuplicatedHintError(align) {
	        _super.call(this, "A hint was already declared for 'align=\"" + align + "\"'.");
	    }
	    return MdInputContainerDuplicatedHintError;
	}(MdError));
	/** @docs-private */
	var MdInputContainerMissingMdInputError = (function (_super) {
	    __extends$15(MdInputContainerMissingMdInputError, _super);
	    function MdInputContainerMissingMdInputError() {
	        _super.call(this, 'md-input-container must contain an mdInput directive. Did you forget to add mdInput ' +
	            'to the native input or textarea element?');
	    }
	    return MdInputContainerMissingMdInputError;
	}(MdError));
	
	var __decorate$51 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$51 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$10 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	// Invalid input type. Using one of these will throw an MdInputContainerUnsupportedTypeError.
	var MD_INPUT_INVALID_TYPES = [
	    'button',
	    'checkbox',
	    'color',
	    'file',
	    'hidden',
	    'image',
	    'radio',
	    'range',
	    'reset',
	    'submit'
	];
	var nextUniqueId$1 = 0;
	/**
	 * The placeholder directive. The content can declare this to implement more
	 * complex placeholders.
	 */
	var MdPlaceholder = (function () {
	    function MdPlaceholder() {
	    }
	    MdPlaceholder = __decorate$51([
	        _angular_core.Directive({
	            selector: 'md-placeholder, mat-placeholder'
	        }), 
	        __metadata$51('design:paramtypes', [])
	    ], MdPlaceholder);
	    return MdPlaceholder;
	}());
	/** The hint directive, used to tag content as hint labels (going under the input). */
	var MdHint = (function () {
	    function MdHint() {
	        // Whether to align the hint label at the start or end of the line.
	        this.align = 'start';
	        // Unique ID for the hint. Used for the aria-describedby on the input.
	        this.id = "md-input-hint-" + nextUniqueId$1++;
	    }
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdHint.prototype, "align", void 0);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', String)
	    ], MdHint.prototype, "id", void 0);
	    MdHint = __decorate$51([
	        _angular_core.Directive({
	            selector: 'md-hint, mat-hint',
	            host: {
	                '[class.mat-hint]': 'true',
	                '[class.mat-right]': 'align == "end"',
	                '[attr.id]': 'id',
	            }
	        }), 
	        __metadata$51('design:paramtypes', [])
	    ], MdHint);
	    return MdHint;
	}());
	/** The input directive, used to mark the input that `MdInputContainer` is wrapping. */
	var MdInputDirective = (function () {
	    function MdInputDirective(_elementRef, _renderer, _ngControl) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._ngControl = _ngControl;
	        /** Variables used as cache for getters and setters. */
	        this._type = 'text';
	        this._placeholder = '';
	        this._disabled = false;
	        this._required = false;
	        /** Whether the element is focused or not. */
	        this.focused = false;
	        /**
	         * Emits an event when the placeholder changes so that the `md-input-container` can re-validate.
	         */
	        this._placeholderChange = new _angular_core.EventEmitter();
	        this._neverEmptyInputTypes = [
	            'date',
	            'datetime',
	            'datetime-local',
	            'month',
	            'time',
	            'week'
	        ].filter(function (t) { return getSupportedInputTypes().has(t); });
	        // Force setter to be called in case id was not specified.
	        this.id = this.id;
	    }
	    Object.defineProperty(MdInputDirective.prototype, "disabled", {
	        /** Whether the element is disabled. */
	        get: function () {
	            return this._ngControl ? this._ngControl.disabled : this._disabled;
	        },
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "id", {
	        /** Unique id of the element. */
	        get: function () { return this._id; },
	        set: function (value) { this._id = value || this._uid; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(MdInputDirective.prototype, "placeholder", {
	        /** Placeholder attribute of the element. */
	        get: function () { return this._placeholder; },
	        set: function (value) {
	            if (this._placeholder !== value) {
	                this._placeholder = value;
	                this._placeholderChange.emit(this._placeholder);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "required", {
	        /** Whether the element is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "type", {
	        /** Input type of the element. */
	        get: function () { return this._type; },
	        set: function (value) {
	            this._type = value || 'text';
	            this._validateType();
	            // When using Angular inputs, developers are no longer able to set the properties on the native
	            // input element. To ensure that bindings for `type` work, we need to sync the setter
	            // with the native property. Textarea elements don't support the type property or attribute.
	            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
	                this._renderer.setElementProperty(this._elementRef.nativeElement, 'type', this._type);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "value", {
	        /** The input element's value. */
	        get: function () { return this._elementRef.nativeElement.value; },
	        set: function (value) { this._elementRef.nativeElement.value = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "empty", {
	        get: function () {
	            return !this._isNeverEmpty() &&
	                (this.value == null || this.value === '') &&
	                // Check if the input contains bad input. If so, we know that it only appears empty because
	                // the value failed to parse. From the user's perspective it is not empty.
	                // TODO(mmalerba): Add e2e test for bad input case.
	                !this._isBadInput();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "_uid", {
	        get: function () { return this._cachedUid = this._cachedUid || "md-input-" + nextUniqueId$1++; },
	        enumerable: true,
	        configurable: true
	    });
	    /** Focuses the input element. */
	    MdInputDirective.prototype.focus = function () { this._renderer.invokeElementMethod(this._elementRef.nativeElement, 'focus'); };
	    MdInputDirective.prototype._onFocus = function () { this.focused = true; };
	    MdInputDirective.prototype._onBlur = function () { this.focused = false; };
	    MdInputDirective.prototype._onInput = function () {
	        // This is a noop function and is used to let Angular know whenever the value changes.
	        // Angular will run a new change detection each time the `input` event has been dispatched.
	        // It's necessary that Angular recognizes the value change, because when floatingLabel
	        // is set to false and Angular forms aren't used, the placeholder won't recognize the
	        // value changes and will not disappear.
	        // Listening to the input event wouldn't be necessary when the input is using the
	        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
	    };
	    /** Make sure the input is a supported type. */
	    MdInputDirective.prototype._validateType = function () {
	        if (MD_INPUT_INVALID_TYPES.indexOf(this._type) !== -1) {
	            throw new MdInputContainerUnsupportedTypeError(this._type);
	        }
	    };
	    MdInputDirective.prototype._isNeverEmpty = function () { return this._neverEmptyInputTypes.indexOf(this._type) !== -1; };
	    MdInputDirective.prototype._isBadInput = function () {
	        return this._elementRef.nativeElement.validity.badInput;
	    };
	    /** Determines if the component host is a textarea. If not recognizable it returns false. */
	    MdInputDirective.prototype._isTextarea = function () {
	        var nativeElement = this._elementRef.nativeElement;
	        return nativeElement ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
	    };
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "disabled", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "id", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "placeholder", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "required", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "type", null);
	    __decorate$51([
	        _angular_core.Output(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "_placeholderChange", void 0);
	    MdInputDirective = __decorate$51([
	        _angular_core.Directive({
	            selector: "input[mdInput], textarea[mdInput], input[matInput], textarea[matInput]",
	            host: {
	                '[class.mat-input-element]': 'true',
	                // Native input properties that are overwritten by Angular inputs need to be synced with
	                // the native input element. Otherwise property bindings for those don't work.
	                '[id]': 'id',
	                '[placeholder]': 'placeholder',
	                '[disabled]': 'disabled',
	                '[required]': 'required',
	                '[attr.aria-describedby]': 'ariaDescribedby',
	                '(blur)': '_onBlur()',
	                '(focus)': '_onFocus()',
	                '(input)': '_onInput()',
	            }
	        }),
	        __param$10(2, _angular_core.Optional()), 
	        __metadata$51('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer, _angular_forms.NgControl])
	    ], MdInputDirective);
	    return MdInputDirective;
	}());
	/**
	 * Component that represents a text input. It encapsulates the <input> HTMLElement and
	 * improve on its behaviour, along with styling it according to the Material Design.
	 */
	var MdInputContainer = (function () {
	    function MdInputContainer() {
	        /** Alignment of the input container's content. */
	        this.align = 'start';
	        /** Color of the input divider, based on the theme. */
	        this.dividerColor = 'primary';
	        this._hintLabel = '';
	        // Unique id for the hint label.
	        this._hintLabelId = "md-input-hint-" + nextUniqueId$1++;
	        this._floatPlaceholder = 'auto';
	    }
	    Object.defineProperty(MdInputContainer.prototype, "_shouldAlwaysFloat", {
	        /** Whether the floating label should always float or not. */
	        get: function () { return this._floatPlaceholder === 'always'; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(MdInputContainer.prototype, "_canPlaceholderFloat", {
	        /** Whether the placeholder can float or not. */
	        get: function () { return this._floatPlaceholder !== 'never'; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputContainer.prototype, "hintLabel", {
	        /** Text for the input hint. */
	        get: function () { return this._hintLabel; },
	        set: function (value) {
	            this._hintLabel = value;
	            this._processHints();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputContainer.prototype, "floatPlaceholder", {
	        /** Whether the placeholder should always float, never float or float as the user types. */
	        get: function () { return this._floatPlaceholder; },
	        set: function (value) {
	            this._floatPlaceholder = value || 'auto';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdInputContainer.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        if (!this._mdInputChild) {
	            throw new MdInputContainerMissingMdInputError();
	        }
	        this._processHints();
	        this._validatePlaceholders();
	        // Re-validate when things change.
	        this._hintChildren.changes.subscribe(function () { return _this._processHints(); });
	        this._mdInputChild._placeholderChange.subscribe(function () { return _this._validatePlaceholders(); });
	    };
	    /** Determines whether a class from the NgControl should be forwarded to the host element. */
	    MdInputContainer.prototype._shouldForward = function (prop) {
	        var control = this._mdInputChild ? this._mdInputChild._ngControl : null;
	        return control && control[prop];
	    };
	    /** Whether the input has a placeholder. */
	    MdInputContainer.prototype._hasPlaceholder = function () { return !!(this._mdInputChild.placeholder || this._placeholderChild); };
	    /** Focuses the underlying input. */
	    MdInputContainer.prototype._focusInput = function () { this._mdInputChild.focus(); };
	    /**
	     * Ensure that there is only one placeholder (either `input` attribute or child element with the
	     * `md-placeholder` attribute.
	     */
	    MdInputContainer.prototype._validatePlaceholders = function () {
	        if (this._mdInputChild.placeholder && this._placeholderChild) {
	            throw new MdInputContainerPlaceholderConflictError();
	        }
	    };
	    /**
	     * Does any extra processing that is required when handling the hints.
	     */
	    MdInputContainer.prototype._processHints = function () {
	        this._validateHints();
	        this._syncAriaDescribedby();
	    };
	    /**
	     * Ensure that there is a maximum of one of each `<md-hint>` alignment specified, with the
	     * attribute being considered as `align="start"`.
	     */
	    MdInputContainer.prototype._validateHints = function () {
	        var _this = this;
	        if (this._hintChildren) {
	            var startHint_1 = null;
	            var endHint_1 = null;
	            this._hintChildren.forEach(function (hint) {
	                if (hint.align == 'start') {
	                    if (startHint_1 || _this.hintLabel) {
	                        throw new MdInputContainerDuplicatedHintError('start');
	                    }
	                    startHint_1 = hint;
	                }
	                else if (hint.align == 'end') {
	                    if (endHint_1) {
	                        throw new MdInputContainerDuplicatedHintError('end');
	                    }
	                    endHint_1 = hint;
	                }
	            });
	        }
	    };
	    /**
	     * Sets the child input's `aria-describedby` to a space-separated list of the ids
	     * of the currently-specified hints, as well as a generated id for the hint label.
	     */
	    MdInputContainer.prototype._syncAriaDescribedby = function () {
	        var ids = [];
	        var startHint = this._hintChildren ?
	            this._hintChildren.find(function (hint) { return hint.align === 'start'; }) : null;
	        var endHint = this._hintChildren ?
	            this._hintChildren.find(function (hint) { return hint.align === 'end'; }) : null;
	        if (startHint) {
	            ids.push(startHint.id);
	        }
	        else if (this._hintLabel) {
	            ids.push(this._hintLabelId);
	        }
	        if (endHint) {
	            ids.push(endHint.id);
	        }
	        this._mdInputChild.ariaDescribedby = ids.join(' ');
	    };
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "align", void 0);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "dividerColor", void 0);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "hintLabel", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "floatPlaceholder", null);
	    __decorate$51([
	        _angular_core.ContentChild(MdInputDirective), 
	        __metadata$51('design:type', MdInputDirective)
	    ], MdInputContainer.prototype, "_mdInputChild", void 0);
	    __decorate$51([
	        _angular_core.ContentChild(MdPlaceholder), 
	        __metadata$51('design:type', MdPlaceholder)
	    ], MdInputContainer.prototype, "_placeholderChild", void 0);
	    __decorate$51([
	        _angular_core.ContentChildren(MdHint), 
	        __metadata$51('design:type', _angular_core.QueryList)
	    ], MdInputContainer.prototype, "_hintChildren", void 0);
	    MdInputContainer = __decorate$51([
	        _angular_core.Component({selector: 'md-input-container, mat-input-container',
	            template: "<div class=\"mat-input-wrapper\"><div class=\"mat-input-table\"><div class=\"mat-input-prefix\"><ng-content select=\"[mdPrefix], [matPrefix], [md-prefix]\"></ng-content></div><div class=\"mat-input-infix\" [class.mat-end]=\"align == 'end'\"><ng-content selector=\"input, textarea\"></ng-content><span class=\"mat-input-placeholder-wrapper\"><label class=\"mat-input-placeholder\" [attr.for]=\"_mdInputChild.id\" [class.mat-empty]=\"_mdInputChild.empty && !_shouldAlwaysFloat\" [class.mat-focused]=\"_mdInputChild.focused\" [class.mat-float]=\"_canPlaceholderFloat\" [class.mat-accent]=\"dividerColor == 'accent'\" [class.mat-warn]=\"dividerColor == 'warn'\" *ngIf=\"_hasPlaceholder()\"><ng-content select=\"md-placeholder, mat-placeholder\"></ng-content>{{_mdInputChild.placeholder}} <span class=\"mat-placeholder-required\" *ngIf=\"_mdInputChild.required\">*</span></label></span></div><div class=\"mat-input-suffix\"><ng-content select=\"[mdSuffix], [matSuffix], [md-suffix]\"></ng-content></div></div><div class=\"mat-input-underline\" [class.mat-disabled]=\"_mdInputChild.disabled\"><span class=\"mat-input-ripple\" [class.mat-focused]=\"_mdInputChild.focused\" [class.mat-accent]=\"dividerColor == 'accent'\" [class.mat-warn]=\"dividerColor == 'warn'\"></span></div><div *ngIf=\"hintLabel != ''\" [attr.id]=\"_hintLabelId\" class=\"mat-hint\">{{hintLabel}}</div><ng-content select=\"md-hint, mat-hint\"></ng-content></div>",
	            styles: [".mat-input-container{display:inline-block;position:relative;font-family:Roboto,\"Helvetica Neue\",sans-serif;line-height:normal;text-align:left}.mat-end .mat-input-element,[dir=rtl] .mat-input-container{text-align:right}.mat-input-wrapper{margin:1em 0;padding-bottom:6px}.mat-input-table{display:inline-table;flex-flow:column;vertical-align:bottom;width:100%}.mat-input-table>*{display:table-cell}.mat-input-infix{position:relative}.mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;width:100%}.mat-input-placeholder,.mat-input-placeholder-wrapper{padding-top:1em;pointer-events:none;position:absolute}[dir=rtl] .mat-end .mat-input-element{text-align:left}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element:-webkit-autofill+.mat-input-placeholder.mat-float{display:block;transform:translateY(-1.35em) scale(.75);width:133.33333%}.mat-input-element::placeholder{color:transparent}.mat-input-element::-moz-placeholder{color:transparent}.mat-input-element::-webkit-input-placeholder{color:transparent}.mat-input-element:-ms-input-placeholder{color:transparent}.mat-input-placeholder{left:0;top:0;font-size:100%;z-index:1;width:100%;display:none;white-space:nowrap;text-overflow:ellipsis;overflow-x:hidden;transform:translateY(0);transform-origin:bottom left;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1)}.mat-input-placeholder.mat-empty{display:block;cursor:text}.mat-input-placeholder.mat-float.mat-focused,.mat-input-placeholder.mat-float:not(.mat-empty){display:block;transform:translateY(-1.35em) scale(.75);width:133.33333%}[dir=rtl] .mat-input-placeholder{transform-origin:bottom right;left:auto;right:0}.mat-input-placeholder-wrapper{left:0;top:-1em;width:100%;overflow:hidden}.mat-input-placeholder-wrapper::after{content:'';display:inline-table}.mat-input-underline{position:absolute;height:1px;width:100%;margin-top:4px;border-top-width:1px;border-top-style:solid}.mat-input-underline.mat-disabled{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;border-top:0;background-position:0}.mat-input-underline .mat-input-ripple{position:absolute;height:2px;z-index:1;top:-1px;width:100%;transform-origin:top;opacity:0;transform:scaleY(0);transition:transform .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-input-underline .mat-input-ripple.mat-focused{opacity:1;transform:scaleY(1)}.mat-hint{display:block;position:absolute;font-size:75%;bottom:0}.mat-hint.mat-right{right:0}[dir=rtl] .mat-hint{right:0;left:auto}[dir=rtl] .mat-hint.mat-right{right:auto;left:0}.mat-input-prefix,.mat-input-suffix{width:.1px;white-space:nowrap}"],
	            host: {
	                '[class.mat-input-container]': 'true',
	                // Remove align attribute to prevent it from interfering with layout.
	                '[attr.align]': 'null',
	                '[class.ng-untouched]': '_shouldForward("untouched")',
	                '[class.ng-touched]': '_shouldForward("touched")',
	                '[class.ng-pristine]': '_shouldForward("pristine")',
	                '[class.ng-dirty]': '_shouldForward("dirty")',
	                '[class.ng-valid]': '_shouldForward("valid")',
	                '[class.ng-invalid]': '_shouldForward("invalid")',
	                '[class.ng-pending]': '_shouldForward("pending")',
	                '(click)': '_focusInput()',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$51('design:paramtypes', [])
	    ], MdInputContainer);
	    return MdInputContainer;
	}());
	
	var __decorate$52 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$52 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive to automatically resize a textarea to fit its content.
	 */
	var MdTextareaAutosize = (function () {
	    function MdTextareaAutosize(_elementRef) {
	        this._elementRef = _elementRef;
	    }
	    Object.defineProperty(MdTextareaAutosize.prototype, "mdAutosizeMinRows", {
	        get: function () {
	            return this.minRows;
	        },
	        set: function (value) {
	            this.minRows = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTextareaAutosize.prototype, "mdAutosizeMaxRows", {
	        get: function () {
	            return this.maxRows;
	        },
	        set: function (value) {
	            this.maxRows = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTextareaAutosize.prototype, "_minHeight", {
	        /** The minimum height of the textarea as determined by minRows. */
	        get: function () {
	            return this.minRows ? this.minRows * this._cachedLineHeight + "px" : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTextareaAutosize.prototype, "_maxHeight", {
	        /** The maximum height of the textarea as determined by maxRows. */
	        get: function () {
	            return this.maxRows ? this.maxRows * this._cachedLineHeight + "px" : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdTextareaAutosize.prototype.ngOnInit = function () {
	        this._cacheTextareaLineHeight();
	        this.resizeToFitContent();
	    };
	    /**
	     * Cache the height of a single-row textarea.
	     *
	     * We need to know how large a single "row" of a textarea is in order to apply minRows and
	     * maxRows. For the initial version, we will assume that the height of a single line in the
	     * textarea does not ever change.
	     */
	    MdTextareaAutosize.prototype._cacheTextareaLineHeight = function () {
	        var textarea = this._elementRef.nativeElement;
	        // Use a clone element because we have to override some styles.
	        var textareaClone = textarea.cloneNode(false);
	        textareaClone.rows = 1;
	        // Use `position: absolute` so that this doesn't cause a browser layout and use
	        // `visibility: hidden` so that nothing is rendered. Clear any other styles that
	        // would affect the height.
	        textareaClone.style.position = 'absolute';
	        textareaClone.style.visibility = 'hidden';
	        textareaClone.style.border = 'none';
	        textareaClone.style.padding = '';
	        textareaClone.style.height = '';
	        textareaClone.style.minHeight = '';
	        textareaClone.style.maxHeight = '';
	        textarea.parentNode.appendChild(textareaClone);
	        this._cachedLineHeight = textareaClone.offsetHeight;
	        textarea.parentNode.removeChild(textareaClone);
	    };
	    /** Resize the textarea to fit its content. */
	    MdTextareaAutosize.prototype.resizeToFitContent = function () {
	        var textarea = this._elementRef.nativeElement;
	        // Reset the textarea height to auto in order to shrink back to its default size.
	        textarea.style.height = 'auto';
	        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
	        textarea.style.height = textarea.scrollHeight + "px";
	    };
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "minRows", void 0);
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "mdAutosizeMinRows", null);
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "maxRows", void 0);
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "mdAutosizeMaxRows", null);
	    MdTextareaAutosize = __decorate$52([
	        _angular_core.Directive({
	            selector: 'textarea[md-autosize], textarea[mdTextareaAutosize],' +
	                'textarea[mat-autosize], textarea[matTextareaAutosize]',
	            exportAs: 'mdTextareaAutosize',
	            host: {
	                '(input)': 'resizeToFitContent()',
	                '[style.min-height]': '_minHeight',
	                '[style.max-height]': '_maxHeight',
	            },
	        }), 
	        __metadata$52('design:paramtypes', [_angular_core.ElementRef])
	    ], MdTextareaAutosize);
	    return MdTextareaAutosize;
	}());
	
	var __decorate$50 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$50 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdInputModule = (function () {
	    function MdInputModule() {
	    }
	    /** @deprecated */
	    MdInputModule.forRoot = function () {
	        return {
	            ngModule: MdInputModule,
	            providers: [],
	        };
	    };
	    MdInputModule = __decorate$50([
	        _angular_core.NgModule({
	            declarations: [
	                MdPlaceholder,
	                MdInputContainer,
	                MdHint,
	                MdTextareaAutosize,
	                MdInputDirective
	            ],
	            imports: [
	                _angular_common.CommonModule,
	                _angular_forms.FormsModule,
	                PlatformModule,
	            ],
	            exports: [
	                MdPlaceholder,
	                MdInputContainer,
	                MdHint,
	                MdTextareaAutosize,
	                MdInputDirective
	            ],
	        }), 
	        __metadata$50('design:paramtypes', [])
	    ], MdInputModule);
	    return MdInputModule;
	}());
	
	/**
	 * Configuration used when opening a snack-bar.
	 */
	var MdSnackBarConfig = (function () {
	    function MdSnackBarConfig() {
	        /** The politeness level for the MdAriaLiveAnnouncer announcement. */
	        this.politeness = 'assertive';
	        /** Message to be announced by the MdAriaLiveAnnouncer */
	        this.announcementMessage = '';
	        /** The view container to place the overlay for the snack bar into. */
	        this.viewContainerRef = null;
	        /** The length of time in milliseconds to wait before automatically dismissing the snack bar. */
	        this.duration = 0;
	    }
	    return MdSnackBarConfig;
	}());
	
	// TODO(josephperrott): Implement onAction observable.
	/**
	 * Reference to a snack bar dispatched from the snack bar service.
	 */
	var MdSnackBarRef = (function () {
	    function MdSnackBarRef(instance, containerInstance, _overlayRef) {
	        var _this = this;
	        this._overlayRef = _overlayRef;
	        /** Subject for notifying the user that the snack bar has closed. */
	        this._afterClosed = new rxjs_Subject.Subject();
	        /** Subject for notifying the user that the snack bar action was called. */
	        this._onAction = new rxjs_Subject.Subject();
	        // Sets the readonly instance of the snack bar content component.
	        this._instance = instance;
	        this.containerInstance = containerInstance;
	        // Dismiss snackbar on action.
	        this.onAction().subscribe(function () { return _this.dismiss(); });
	        containerInstance._onExit().subscribe(function () { return _this._finishDismiss(); });
	    }
	    Object.defineProperty(MdSnackBarRef.prototype, "instance", {
	        /** The instance of the component making up the content of the snack bar. */
	        get: function () {
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Dismisses the snack bar. */
	    MdSnackBarRef.prototype.dismiss = function () {
	        if (!this._afterClosed.closed) {
	            this.containerInstance.exit();
	        }
	    };
	    /** Marks the snackbar action clicked. */
	    MdSnackBarRef.prototype._action = function () {
	        if (!this._onAction.closed) {
	            this._onAction.next();
	            this._onAction.complete();
	        }
	    };
	    /** Marks the snackbar as opened */
	    MdSnackBarRef.prototype._open = function () {
	        if (!this._afterOpened.closed) {
	            this._afterOpened.next();
	            this._afterOpened.complete();
	        }
	    };
	    /** Cleans up the DOM after closing. */
	    MdSnackBarRef.prototype._finishDismiss = function () {
	        this._overlayRef.dispose();
	        this._afterClosed.next();
	        this._afterClosed.complete();
	    };
	    /** Gets an observable that is notified when the snack bar is finished closing. */
	    MdSnackBarRef.prototype.afterDismissed = function () {
	        return this._afterClosed.asObservable();
	    };
	    /** Gets an observable that is notified when the snack bar has opened and appeared. */
	    MdSnackBarRef.prototype.afterOpened = function () {
	        return this.containerInstance._onEnter();
	    };
	    /** Gets an observable that is notified when the snack bar action is called. */
	    MdSnackBarRef.prototype.onAction = function () {
	        return this._onAction.asObservable();
	    };
	    return MdSnackBarRef;
	}());
	
	var __extends$17 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Error that is thrown when attempting to attach a snack bar that is already attached.
	 * @docs-private
	 */
	var MdSnackBarContentAlreadyAttached = (function (_super) {
	    __extends$17(MdSnackBarContentAlreadyAttached, _super);
	    function MdSnackBarContentAlreadyAttached() {
	        _super.call(this, 'Attempting to attach snack bar content after content is already attached');
	    }
	    return MdSnackBarContentAlreadyAttached;
	}(MdError));
	
	var __extends$16 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$55 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$55 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(jelbourn): we can't use constants from animation.ts here because you can't use
	// a text interpolation in anything that is analyzed statically with ngc (for AoT compile).
	var SHOW_ANIMATION = '225ms cubic-bezier(0.4,0.0,1,1)';
	var HIDE_ANIMATION = '195ms cubic-bezier(0.0,0.0,0.2,1)';
	/**
	 * Internal component that wraps user-provided snack bar content.
	 * @docs-private
	 */
	var MdSnackBarContainer = (function (_super) {
	    __extends$16(MdSnackBarContainer, _super);
	    function MdSnackBarContainer(_ngZone, _renderer, _elementRef) {
	        _super.call(this);
	        this._ngZone = _ngZone;
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        /** Subject for notifying that the snack bar has exited from view. */
	        this.onExit = new rxjs_Subject.Subject();
	        /** Subject for notifying that the snack bar has finished entering the view. */
	        this.onEnter = new rxjs_Subject.Subject();
	        /** The state of the snack bar animations. */
	        this.animationState = 'initial';
	    }
	    /** Attach a component portal as content to this snack bar container. */
	    MdSnackBarContainer.prototype.attachComponentPortal = function (portal) {
	        if (this._portalHost.hasAttached()) {
	            throw new MdSnackBarContentAlreadyAttached();
	        }
	        if (this.snackBarConfig.extraClasses) {
	            // Not the most efficient way of adding classes, but the renderer doesn't allow us
	            // to pass in an array or a space-separated list.
	            for (var _i = 0, _a = this.snackBarConfig.extraClasses; _i < _a.length; _i++) {
	                var cssClass = _a[_i];
	                this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, true);
	            }
	        }
	        return this._portalHost.attachComponentPortal(portal);
	    };
	    /** Attach a template portal as content to this snack bar container. */
	    MdSnackBarContainer.prototype.attachTemplatePortal = function (portal) {
	        throw Error('Not yet implemented');
	    };
	    /** Handle end of animations, updating the state of the snackbar. */
	    MdSnackBarContainer.prototype.onAnimationEnd = function (event) {
	        var _this = this;
	        if (event.toState === 'void' || event.toState === 'complete') {
	            this._completeExit();
	        }
	        if (event.toState === 'visible') {
	            this._ngZone.run(function () {
	                _this.onEnter.next();
	                _this.onEnter.complete();
	            });
	        }
	    };
	    /** Begin animation of snack bar entrance into view. */
	    MdSnackBarContainer.prototype.enter = function () {
	        this.animationState = 'visible';
	    };
	    /** Returns an observable resolving when the enter animation completes.  */
	    MdSnackBarContainer.prototype._onEnter = function () {
	        this.animationState = 'visible';
	        return this.onEnter.asObservable();
	    };
	    /** Begin animation of the snack bar exiting from view. */
	    MdSnackBarContainer.prototype.exit = function () {
	        this.animationState = 'complete';
	        return this._onExit();
	    };
	    /** Returns an observable that completes after the closing animation is done. */
	    MdSnackBarContainer.prototype._onExit = function () {
	        return this.onExit.asObservable();
	    };
	    /**
	     * Makes sure the exit callbacks have been invoked when the element is destroyed.
	     */
	    MdSnackBarContainer.prototype.ngOnDestroy = function () {
	        this._completeExit();
	    };
	    /**
	     * Waits for the zone to settle before removing the element. Helps prevent
	     * errors where we end up removing an element which is in the middle of an animation.
	     */
	    MdSnackBarContainer.prototype._completeExit = function () {
	        var _this = this;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this.onExit.next();
	            _this.onExit.complete();
	        });
	    };
	    __decorate$55([
	        _angular_core.ViewChild(PortalHostDirective), 
	        __metadata$55('design:type', PortalHostDirective)
	    ], MdSnackBarContainer.prototype, "_portalHost", void 0);
	    MdSnackBarContainer = __decorate$55([
	        _angular_core.Component({selector: 'snack-bar-container',
	            template: "<template cdkPortalHost></template>",
	            styles: [":host{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);background:#323232;border-radius:2px;box-sizing:content-box;display:block;height:20px;max-width:568px;min-width:288px;overflow:hidden;padding:14px 24px;transform:translateY(100%)}@media screen and (-ms-high-contrast:active){:host{border:1px solid}}"],
	            host: {
	                'role': 'alert',
	                '[@state]': 'animationState',
	                '(@state.done)': 'onAnimationEnd($event)'
	            },
	            animations: [
	                _angular_core.trigger('state', [
	                    _angular_core.state('initial', _angular_core.style({ transform: 'translateY(100%)' })),
	                    _angular_core.state('visible', _angular_core.style({ transform: 'translateY(0%)' })),
	                    _angular_core.state('complete', _angular_core.style({ transform: 'translateY(100%)' })),
	                    _angular_core.transition('visible => complete', _angular_core.animate(HIDE_ANIMATION)),
	                    _angular_core.transition('initial => visible, void => visible', _angular_core.animate(SHOW_ANIMATION)),
	                ])
	            ],
	        }), 
	        __metadata$55('design:paramtypes', [_angular_core.NgZone, _angular_core.Renderer, _angular_core.ElementRef])
	    ], MdSnackBarContainer);
	    return MdSnackBarContainer;
	}(BasePortalHost));
	
	var __decorate$56 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$56 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * A component used to open as the default snack bar, matching material spec.
	 * This should only be used internally by the snack bar service.
	 */
	var SimpleSnackBar = (function () {
	    function SimpleSnackBar() {
	    }
	    /** Dismisses the snack bar. */
	    SimpleSnackBar.prototype.dismiss = function () {
	        this.snackBarRef._action();
	    };
	    Object.defineProperty(SimpleSnackBar.prototype, "hasAction", {
	        /** If the action button should be shown. */
	        get: function () { return !!this.action; },
	        enumerable: true,
	        configurable: true
	    });
	    SimpleSnackBar = __decorate$56([
	        _angular_core.Component({selector: 'simple-snack-bar',
	            template: "<span class=\"mat-simple-snackbar-message\">{{message}}</span> <button class=\"mat-simple-snackbar-action\" *ngIf=\"hasAction\" (click)=\"dismiss()\">{{action}}</button>",
	            styles: [":host{display:flex;justify-content:space-between;color:#fff;line-height:20px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-simple-snackbar-message{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis}.mat-simple-snackbar-action{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;background:0 0;margin:-5px 0 0;padding:5px;text-transform:uppercase;color:inherit;line-height:inherit;flex-shrink:0;font-family:inherit;font-size:inherit;font-weight:600}"],
	            host: {
	                '[class.mat-simple-snackbar]': 'true',
	            }
	        }), 
	        __metadata$56('design:paramtypes', [])
	    ], SimpleSnackBar);
	    return SimpleSnackBar;
	}());
	
	/**
	 * Extends an object with the *enumerable* and *own* properties of one or more source objects,
	 * similar to Object.assign.
	 *
	 * @param dest The object which will have properties copied to it.
	 * @param sources The source objects from which properties will be copied.
	 */
	function extendObject(dest) {
	    var sources = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        sources[_i - 1] = arguments[_i];
	    }
	    if (dest == null) {
	        throw TypeError('Cannot convert undefined or null to object');
	    }
	    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
	        var source = sources_1[_a];
	        if (source != null) {
	            for (var key in source) {
	                if (source.hasOwnProperty(key)) {
	                    dest[key] = source[key];
	                }
	            }
	        }
	    }
	    return dest;
	}
	
	var __decorate$54 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$54 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$11 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Service to dispatch Material Design snack bar messages.
	 */
	var MdSnackBar = (function () {
	    function MdSnackBar(_overlay, _live, _parentSnackBar) {
	        this._overlay = _overlay;
	        this._live = _live;
	        this._parentSnackBar = _parentSnackBar;
	    }
	    Object.defineProperty(MdSnackBar.prototype, "_openedSnackBarRef", {
	        /** Reference to the currently opened snackbar at *any* level. */
	        get: function () {
	            return this._parentSnackBar ?
	                this._parentSnackBar._openedSnackBarRef : this._snackBarRefAtThisLevel;
	        },
	        set: function (value) {
	            if (this._parentSnackBar) {
	                this._parentSnackBar._openedSnackBarRef = value;
	            }
	            else {
	                this._snackBarRefAtThisLevel = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates and dispatches a snack bar with a custom component for the content, removing any
	     * currently opened snack bars.
	     *
	     * @param component Component to be instantiated.
	     * @param config Extra configuration for the snack bar.
	     */
	    MdSnackBar.prototype.openFromComponent = function (component, config) {
	        var _this = this;
	        config = _applyConfigDefaults(config);
	        var overlayRef = this._createOverlay();
	        var snackBarContainer = this._attachSnackBarContainer(overlayRef, config);
	        var snackBarRef = this._attachSnackbarContent(component, snackBarContainer, overlayRef);
	        // When the snackbar is dismissed, clear the reference to it.
	        snackBarRef.afterDismissed().subscribe(function () {
	            // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
	            if (_this._openedSnackBarRef == snackBarRef) {
	                _this._openedSnackBarRef = null;
	            }
	        });
	        // If a snack bar is already in view, dismiss it and enter the new snack bar after exit
	        // animation is complete.
	        if (this._openedSnackBarRef) {
	            this._openedSnackBarRef.afterDismissed().subscribe(function () {
	                snackBarRef.containerInstance.enter();
	            });
	            this._openedSnackBarRef.dismiss();
	        }
	        else {
	            snackBarRef.containerInstance.enter();
	        }
	        // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.
	        if (config.duration > 0) {
	            snackBarRef.afterOpened().subscribe(function () {
	                setTimeout(function () { return snackBarRef.dismiss(); }, config.duration);
	            });
	        }
	        this._live.announce(config.announcementMessage, config.politeness);
	        this._openedSnackBarRef = snackBarRef;
	        return this._openedSnackBarRef;
	    };
	    /**
	     * Opens a snackbar with a message and an optional action.
	     * @param message The message to show in the snackbar.
	     * @param action The label for the snackbar action.
	     * @param config Additional configuration options for the snackbar.
	     */
	    MdSnackBar.prototype.open = function (message, action, config) {
	        if (action === void 0) { action = ''; }
	        if (config === void 0) { config = {}; }
	        config.announcementMessage = message;
	        var simpleSnackBarRef = this.openFromComponent(SimpleSnackBar, config);
	        simpleSnackBarRef.instance.snackBarRef = simpleSnackBarRef;
	        simpleSnackBarRef.instance.message = message;
	        simpleSnackBarRef.instance.action = action;
	        return simpleSnackBarRef;
	    };
	    /**
	     * Attaches the snack bar container component to the overlay.
	     */
	    MdSnackBar.prototype._attachSnackBarContainer = function (overlayRef, config) {
	        var containerPortal = new ComponentPortal(MdSnackBarContainer, config.viewContainerRef);
	        var containerRef = overlayRef.attach(containerPortal);
	        containerRef.instance.snackBarConfig = config;
	        return containerRef.instance;
	    };
	    /**
	     * Places a new component as the content of the snack bar container.
	     */
	    MdSnackBar.prototype._attachSnackbarContent = function (component, container, overlayRef) {
	        var portal = new ComponentPortal(component);
	        var contentRef = container.attachComponentPortal(portal);
	        return new MdSnackBarRef(contentRef.instance, container, overlayRef);
	    };
	    /**
	     * Creates a new overlay and places it in the correct location.
	     */
	    MdSnackBar.prototype._createOverlay = function () {
	        var state$$1 = new OverlayState();
	        state$$1.positionStrategy = this._overlay.position().global()
	            .centerHorizontally()
	            .bottom('0');
	        return this._overlay.create(state$$1);
	    };
	    MdSnackBar = __decorate$54([
	        _angular_core.Injectable(),
	        __param$11(2, _angular_core.Optional()),
	        __param$11(2, _angular_core.SkipSelf()), 
	        __metadata$54('design:paramtypes', [Overlay, LiveAnnouncer, MdSnackBar])
	    ], MdSnackBar);
	    return MdSnackBar;
	}());
	/**
	 * Applies default options to the snackbar config.
	 * @param config The configuration to which the defaults will be applied.
	 * @returns The new configuration object with defaults applied.
	 */
	function _applyConfigDefaults(config) {
	    return extendObject(new MdSnackBarConfig(), config);
	}
	
	var __decorate$53 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$53 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdSnackBarModule = (function () {
	    function MdSnackBarModule() {
	    }
	    /** @deprecated */
	    MdSnackBarModule.forRoot = function () {
	        return {
	            ngModule: MdSnackBarModule,
	            providers: []
	        };
	    };
	    MdSnackBarModule = __decorate$53([
	        _angular_core.NgModule({
	            imports: [OverlayModule, PortalModule, _angular_common.CommonModule, CompatibilityModule],
	            exports: [MdSnackBarContainer, CompatibilityModule],
	            declarations: [MdSnackBarContainer, SimpleSnackBar],
	            entryComponents: [MdSnackBarContainer, SimpleSnackBar],
	            providers: [MdSnackBar, LIVE_ANNOUNCER_PROVIDER]
	        }), 
	        __metadata$53('design:paramtypes', [])
	    ], MdSnackBarModule);
	    return MdSnackBarModule;
	}());
	
	var __extends$18 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$58 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$58 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Used to flag tab labels for use with the portal directive */
	var MdTabLabel = (function (_super) {
	    __extends$18(MdTabLabel, _super);
	    function MdTabLabel(templateRef, viewContainerRef) {
	        _super.call(this, templateRef, viewContainerRef);
	    }
	    MdTabLabel = __decorate$58([
	        _angular_core.Directive({
	            selector: '[md-tab-label], [mat-tab-label]',
	        }), 
	        __metadata$58('design:paramtypes', [_angular_core.TemplateRef, _angular_core.ViewContainerRef])
	    ], MdTabLabel);
	    return MdTabLabel;
	}(TemplatePortalDirective));
	
	var __decorate$59 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$59 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Used in the `md-tab-group` view to display tab labels */
	var MdTabLabelWrapper = (function () {
	    function MdTabLabelWrapper(elementRef, _renderer) {
	        this.elementRef = elementRef;
	        this._renderer = _renderer;
	        /** Whether the tab label is disabled.  */
	        this._disabled = false;
	    }
	    Object.defineProperty(MdTabLabelWrapper.prototype, "disabled", {
	        /** Whether the element is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    /** Sets focus on the wrapper element */
	    MdTabLabelWrapper.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this.elementRef.nativeElement, 'focus');
	    };
	    MdTabLabelWrapper.prototype.getOffsetLeft = function () {
	        return this.elementRef.nativeElement.offsetLeft;
	    };
	    MdTabLabelWrapper.prototype.getOffsetWidth = function () {
	        return this.elementRef.nativeElement.offsetWidth;
	    };
	    __decorate$59([
	        _angular_core.Input(), 
	        __metadata$59('design:type', Object)
	    ], MdTabLabelWrapper.prototype, "disabled", null);
	    MdTabLabelWrapper = __decorate$59([
	        _angular_core.Directive({
	            selector: '[md-tab-label-wrapper], [mat-tab-label-wrapper]',
	            host: {
	                '[class.mat-tab-disabled]': 'disabled'
	            }
	        }), 
	        __metadata$59('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdTabLabelWrapper);
	    return MdTabLabelWrapper;
	}());
	
	var __decorate$61 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$61 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** The ink-bar is used to display and animate the line underneath the current active tab label. */
	var MdInkBar = (function () {
	    function MdInkBar(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	    }
	    /**
	     * Calculates the styles from the provided element in order to align the ink-bar to that element.
	     * Shows the ink bar if previously set as hidden.
	     * @param element
	     */
	    MdInkBar.prototype.alignToElement = function (element) {
	        this.show();
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'left', this._getLeftPosition(element));
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'width', this._getElementWidth(element));
	    };
	    /** Shows the ink bar. */
	    MdInkBar.prototype.show = function () {
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'visibility', 'visible');
	    };
	    /** Hides the ink bar. */
	    MdInkBar.prototype.hide = function () {
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'visibility', 'hidden');
	    };
	    /**
	     * Generates the pixel distance from the left based on the provided element in string format.
	     * @param element
	     */
	    MdInkBar.prototype._getLeftPosition = function (element) {
	        return element ? element.offsetLeft + 'px' : '0';
	    };
	    /**
	     * Generates the pixel width from the provided element in string format.
	     * @param element
	     */
	    MdInkBar.prototype._getElementWidth = function (element) {
	        return element ? element.offsetWidth + 'px' : '0';
	    };
	    MdInkBar = __decorate$61([
	        _angular_core.Directive({
	            selector: 'md-ink-bar, mat-ink-bar',
	            host: {
	                '[class.mat-ink-bar]': 'true',
	            },
	        }), 
	        __metadata$61('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdInkBar);
	    return MdInkBar;
	}());
	
	var __extends$19 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$60 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$60 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Navigation component matching the styles of the tab group header.
	 * Provides anchored navigation with animated ink bar.
	 */
	var MdTabNavBar = (function () {
	    function MdTabNavBar() {
	    }
	    /** Notifies the component that the active link has been changed. */
	    MdTabNavBar.prototype.updateActiveLink = function (element) {
	        this._activeLinkChanged = this._activeLinkElement != element;
	        this._activeLinkElement = element;
	    };
	    /** Checks if the active link has been changed and, if so, will update the ink bar. */
	    MdTabNavBar.prototype.ngAfterContentChecked = function () {
	        if (this._activeLinkChanged) {
	            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);
	            this._activeLinkChanged = false;
	        }
	    };
	    __decorate$60([
	        _angular_core.ViewChild(MdInkBar), 
	        __metadata$60('design:type', MdInkBar)
	    ], MdTabNavBar.prototype, "_inkBar", void 0);
	    MdTabNavBar = __decorate$60([
	        _angular_core.Component({selector: '[md-tab-nav-bar], [mat-tab-nav-bar]',
	            template: "<div class=\"mat-tab-links\"><ng-content></ng-content></div><md-ink-bar></md-ink-bar>",
	            styles: [".mat-tab-link,.mat-tab-nav-bar{position:relative;overflow:hidden}.mat-tab-nav-bar{flex-shrink:0}.mat-tab-links{display:flex;position:relative}.mat-tab-link{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;color:currentColor;opacity:.6;min-width:160px;text-align:center;text-decoration:none}.mat-tab-link:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}"],
	            host: {
	                '[class.mat-tab-nav-bar]': 'true',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$60('design:paramtypes', [])
	    ], MdTabNavBar);
	    return MdTabNavBar;
	}());
	/**
	 * Link inside of a `md-tab-nav-bar`.
	 */
	var MdTabLink = (function () {
	    function MdTabLink(_mdTabNavBar, _elementRef) {
	        this._mdTabNavBar = _mdTabNavBar;
	        this._elementRef = _elementRef;
	        this._isActive = false;
	    }
	    Object.defineProperty(MdTabLink.prototype, "active", {
	        /** Whether the link is active. */
	        get: function () { return this._isActive; },
	        set: function (value) {
	            this._isActive = value;
	            if (value) {
	                this._mdTabNavBar.updateActiveLink(this._elementRef);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$60([
	        _angular_core.Input(), 
	        __metadata$60('design:type', Boolean)
	    ], MdTabLink.prototype, "active", null);
	    MdTabLink = __decorate$60([
	        _angular_core.Directive({
	            selector: '[md-tab-link], [mat-tab-link]',
	            host: {
	                '[class.mat-tab-link]': 'true',
	            }
	        }), 
	        __metadata$60('design:paramtypes', [MdTabNavBar, _angular_core.ElementRef])
	    ], MdTabLink);
	    return MdTabLink;
	}());
	/**
	 * Simple directive that extends the ripple and matches the selector of the MdTabLink. This
	 * adds the ripple behavior to nav bar labels.
	 */
	var MdTabLinkRipple = (function (_super) {
	    __extends$19(MdTabLinkRipple, _super);
	    function MdTabLinkRipple(elementRef, ngZone, ruler) {
	        _super.call(this, elementRef, ngZone, ruler);
	    }
	    MdTabLinkRipple = __decorate$60([
	        _angular_core.Directive({
	            selector: '[md-tab-link], [mat-tab-link]',
	            host: {
	                '[class.mat-tab-link]': 'true',
	            },
	        }), 
	        __metadata$60('design:paramtypes', [_angular_core.ElementRef, _angular_core.NgZone, ViewportRuler])
	    ], MdTabLinkRipple);
	    return MdTabLinkRipple;
	}(MdRipple));
	
	var __decorate$62 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$62 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdTab = (function () {
	    function MdTab(_viewContainerRef) {
	        this._viewContainerRef = _viewContainerRef;
	        /** The plain text label for the tab, used when there is no template label. */
	        this.textLabel = '';
	        /** The portal that will be the hosted content of the tab */
	        this._contentPortal = null;
	        /**
	         * The relatively indexed position where 0 represents the center, negative is left, and positive
	         * represents the right.
	         */
	        this.position = null;
	        /**
	         * The initial relatively index origin of the tab if it was created and selected after there
	         * was already a selected tab. Provides context of what position the tab should originate from.
	         */
	        this.origin = null;
	        this._disabled = false;
	    }
	    Object.defineProperty(MdTab.prototype, "content", {
	        get: function () { return this._contentPortal; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTab.prototype, "disabled", {
	        get: function () { return this._disabled; },
	        /** Whether the tab is disabled */
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdTab.prototype.ngOnInit = function () {
	        this._contentPortal = new TemplatePortal(this._content, this._viewContainerRef);
	    };
	    __decorate$62([
	        _angular_core.ContentChild(MdTabLabel), 
	        __metadata$62('design:type', MdTabLabel)
	    ], MdTab.prototype, "templateLabel", void 0);
	    __decorate$62([
	        _angular_core.ViewChild(_angular_core.TemplateRef), 
	        __metadata$62('design:type', _angular_core.TemplateRef)
	    ], MdTab.prototype, "_content", void 0);
	    __decorate$62([
	        _angular_core.Input('label'), 
	        __metadata$62('design:type', String)
	    ], MdTab.prototype, "textLabel", void 0);
	    __decorate$62([
	        _angular_core.Input(), 
	        __metadata$62('design:type', Boolean), 
	        __metadata$62('design:paramtypes', [Boolean])
	    ], MdTab.prototype, "disabled", null);
	    MdTab = __decorate$62([
	        _angular_core.Component({selector: 'md-tab, mat-tab',
	            template: "<template><ng-content></ng-content></template>",
	        }), 
	        __metadata$62('design:paramtypes', [_angular_core.ViewContainerRef])
	    ], MdTab);
	    return MdTab;
	}());
	
	var __decorate$63 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$63 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$12 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Wrapper for the contents of a tab.
	 */
	var MdTabBody = (function () {
	    function MdTabBody(_dir, _elementRef, _changeDetectorRef) {
	        this._dir = _dir;
	        this._elementRef = _elementRef;
	        this._changeDetectorRef = _changeDetectorRef;
	        /** Event emitted when the tab begins to animate towards the center as the active tab. */
	        this.onCentering = new _angular_core.EventEmitter();
	        /** Event emitted when the tab completes its animation towards the center. */
	        this.onCentered = new _angular_core.EventEmitter(true);
	        /** Whether the element is allowed to be animated. */
	        this._canBeAnimated = false;
	    }
	    Object.defineProperty(MdTabBody.prototype, "position", {
	        set: function (position) {
	            if (position < 0) {
	                this._position = this._getLayoutDirection() == 'ltr' ? 'left' : 'right';
	            }
	            else if (position > 0) {
	                this._position = this._getLayoutDirection() == 'ltr' ? 'right' : 'left';
	            }
	            else {
	                this._position = 'center';
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabBody.prototype, "origin", {
	        /** The origin position from which this tab should appear when it is centered into view. */
	        set: function (origin) {
	            if (origin == null) {
	                return;
	            }
	            var dir = this._getLayoutDirection();
	            if ((dir == 'ltr' && origin <= 0) || (dir == 'rtl' && origin > 0)) {
	                this._origin = 'left';
	            }
	            else {
	                this._origin = 'right';
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * After initialized, check if the content is centered and has an origin. If so, set the
	     * special position states that transition the tab from the left or right before centering.
	     */
	    MdTabBody.prototype.ngOnInit = function () {
	        if (this._position == 'center' && this._origin) {
	            this._position = this._origin == 'left' ? 'left-origin-center' : 'right-origin-center';
	        }
	    };
	    /**
	     * After the view has been set, check if the tab content is set to the center and attach the
	     * content if it is not already attached.
	     */
	    MdTabBody.prototype.ngAfterViewChecked = function () {
	        if (this._isCenterPosition(this._position) && !this._portalHost.hasAttached()) {
	            this._portalHost.attach(this._content);
	        }
	    };
	    /**
	     * After the content has been checked, determines whether the element should be allowed to
	     * animate. This has to be limited, because under a specific set of circumstances (see #2151),
	     * the animations can be triggered too early, which either crashes Chrome by putting it into an
	     * infinite loop (with Angular < 2.3.0) or throws an error because the element doesn't have a
	     * computed style (with Angular > 2.3.0). This can alternatively be determined by checking the
	     * transform: canBeAnimated = getComputedStyle(element) !== '', however document.contains should
	     * be faster since it doesn't cause a reflow.
	     *
	     * TODO: This can safely be removed after we stop supporting Angular < 2.4.2. The fix landed via
	     * https://github.com/angular/angular/commit/21030e9a1cf30e8101399d8535ed72d847a23ba6
	     */
	    MdTabBody.prototype.ngAfterContentChecked = function () {
	        if (!this._canBeAnimated) {
	            this._canBeAnimated = document.body.contains(this._elementRef.nativeElement);
	            if (this._canBeAnimated) {
	                this._changeDetectorRef.markForCheck();
	            }
	        }
	    };
	    MdTabBody.prototype._onTranslateTabStarted = function (e) {
	        if (this._isCenterPosition(e.toState)) {
	            this.onCentering.emit(this._elementRef.nativeElement.clientHeight);
	        }
	    };
	    MdTabBody.prototype._onTranslateTabComplete = function (e) {
	        // If the end state is that the tab is not centered, then detach the content.
	        if (!this._isCenterPosition(e.toState) && !this._isCenterPosition(this._position)) {
	            this._portalHost.detach();
	        }
	        // If the transition to the center is complete, emit an event.
	        if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {
	            this.onCentered.emit();
	        }
	    };
	    /** The text direction of the containing app. */
	    MdTabBody.prototype._getLayoutDirection = function () {
	        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
	    };
	    /** Whether the provided position state is considered center, regardless of origin. */
	    MdTabBody.prototype._isCenterPosition = function (position) {
	        return position == 'center' ||
	            position == 'left-origin-center' ||
	            position == 'right-origin-center';
	    };
	    __decorate$63([
	        _angular_core.ViewChild(PortalHostDirective), 
	        __metadata$63('design:type', PortalHostDirective)
	    ], MdTabBody.prototype, "_portalHost", void 0);
	    __decorate$63([
	        _angular_core.Output(), 
	        __metadata$63('design:type', _angular_core.EventEmitter)
	    ], MdTabBody.prototype, "onCentering", void 0);
	    __decorate$63([
	        _angular_core.Output(), 
	        __metadata$63('design:type', _angular_core.EventEmitter)
	    ], MdTabBody.prototype, "onCentered", void 0);
	    __decorate$63([
	        _angular_core.Input('content'), 
	        __metadata$63('design:type', TemplatePortal)
	    ], MdTabBody.prototype, "_content", void 0);
	    __decorate$63([
	        _angular_core.Input('position'), 
	        __metadata$63('design:type', Number), 
	        __metadata$63('design:paramtypes', [Number])
	    ], MdTabBody.prototype, "position", null);
	    __decorate$63([
	        _angular_core.Input('origin'), 
	        __metadata$63('design:type', Number), 
	        __metadata$63('design:paramtypes', [Number])
	    ], MdTabBody.prototype, "origin", null);
	    MdTabBody = __decorate$63([
	        _angular_core.Component({selector: 'md-tab-body, mat-tab-body',
	            template: "<div class=\"mat-tab-body-content\" #content [@translateTab]=\"_canBeAnimated ? _position : null\" (@translateTab.start)=\"_onTranslateTabStarted($event)\" (@translateTab.done)=\"_onTranslateTabComplete($event)\"><template cdkPortalHost></template></div>",
	            host: {
	                '[class.mat-tab-body]': 'true',
	            },
	            animations: [
	                _angular_core.trigger('translateTab', [
	                    _angular_core.state('left', _angular_core.style({ transform: 'translate3d(-100%, 0, 0)' })),
	                    _angular_core.state('left-origin-center', _angular_core.style({ transform: 'translate3d(0, 0, 0)' })),
	                    _angular_core.state('right-origin-center', _angular_core.style({ transform: 'translate3d(0, 0, 0)' })),
	                    _angular_core.state('center', _angular_core.style({ transform: 'translate3d(0, 0, 0)' })),
	                    _angular_core.state('right', _angular_core.style({ transform: 'translate3d(100%, 0, 0)' })),
	                    _angular_core.transition('* => left, * => right, left => center, right => center', _angular_core.animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')),
	                    _angular_core.transition('void => left-origin-center', [
	                        _angular_core.style({ transform: 'translate3d(-100%, 0, 0)' }),
	                        _angular_core.animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')
	                    ]),
	                    _angular_core.transition('void => right-origin-center', [
	                        _angular_core.style({ transform: 'translate3d(100%, 0, 0)' }),
	                        _angular_core.animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')
	                    ])
	                ])
	            ]
	        }),
	        __param$12(0, _angular_core.Optional()), 
	        __metadata$63('design:paramtypes', [Dir, _angular_core.ElementRef, _angular_core.ChangeDetectorRef])
	    ], MdTabBody);
	    return MdTabBody;
	}());
	
	var __decorate$64 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$64 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$13 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * The distance in pixels that will be overshot when scrolling a tab label into view. This helps
	 * provide a small affordance to the label next to it.
	 */
	var EXAGGERATED_OVERSCROLL = 60;
	/**
	 * The header of the tab group which displays a list of all the tabs in the tab group. Includes
	 * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the
	 * width of the header container, then arrows will be displayed to allow the user to scroll
	 * left and right across the header.
	 */
	var MdTabHeader = (function () {
	    function MdTabHeader(_zone, _elementRef, _dir) {
	        this._zone = _zone;
	        this._elementRef = _elementRef;
	        this._dir = _dir;
	        /** The tab index that is focused. */
	        this._focusIndex = 0;
	        /** The distance in pixels that the tab labels should be translated to the left. */
	        this._scrollDistance = 0;
	        /** Whether the header should scroll to the selected index after the view has been checked. */
	        this._selectedIndexChanged = false;
	        /** Whether the controls for pagination should be displayed */
	        this._showPaginationControls = false;
	        /** Whether the tab list can be scrolled more towards the end of the tab label list. */
	        this._disableScrollAfter = true;
	        /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */
	        this._disableScrollBefore = true;
	        this._selectedIndex = 0;
	        /** Event emitted when the option is selected. */
	        this.selectFocusedIndex = new _angular_core.EventEmitter();
	        /** Event emitted when a label is focused. */
	        this.indexFocused = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(MdTabHeader.prototype, "selectedIndex", {
	        get: function () { return this._selectedIndex; },
	        /** The index of the active tab. */
	        set: function (value) {
	            this._selectedIndexChanged = this._selectedIndex != value;
	            this._selectedIndex = value;
	            this._focusIndex = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdTabHeader.prototype.ngAfterContentChecked = function () {
	        // If the number of tab labels have changed, check if scrolling should be enabled
	        if (this._tabLabelCount != this._labelWrappers.length) {
	            this._updatePagination();
	            this._tabLabelCount = this._labelWrappers.length;
	        }
	        // If the selected index has changed, scroll to the label and check if the scrolling controls
	        // should be disabled.
	        if (this._selectedIndexChanged) {
	            this._scrollToLabel(this._selectedIndex);
	            this._checkScrollingControls();
	            this._alignInkBarToSelectedTab();
	            this._selectedIndexChanged = false;
	        }
	        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),
	        // then translate the header to reflect this.
	        if (this._scrollDistanceChanged) {
	            this._updateTabScrollPosition();
	            this._scrollDistanceChanged = false;
	        }
	    };
	    MdTabHeader.prototype._handleKeydown = function (event) {
	        switch (event.keyCode) {
	            case RIGHT_ARROW:
	                this._focusNextTab();
	                break;
	            case LEFT_ARROW:
	                this._focusPreviousTab();
	                break;
	            case ENTER:
	                this.selectFocusedIndex.emit(this.focusIndex);
	                break;
	        }
	    };
	    /**
	     * Aligns the ink bar to the selected tab on load.
	     */
	    MdTabHeader.prototype.ngAfterContentInit = function () {
	        this._alignInkBarToSelectedTab();
	    };
	    /**
	     * Callback for when the MutationObserver detects that the content has changed.
	     */
	    MdTabHeader.prototype._onContentChanges = function () {
	        this._updatePagination();
	        this._alignInkBarToSelectedTab();
	    };
	    /**
	     * Updating the view whether pagination should be enabled or not
	     */
	    MdTabHeader.prototype._updatePagination = function () {
	        this._checkPaginationEnabled();
	        this._checkScrollingControls();
	        this._updateTabScrollPosition();
	    };
	    Object.defineProperty(MdTabHeader.prototype, "focusIndex", {
	        /** Tracks which element has focus; used for keyboard navigation */
	        get: function () { return this._focusIndex; },
	        /** When the focus index is set, we must manually send focus to the correct label */
	        set: function (value) {
	            if (!this._isValidIndex(value) || this._focusIndex == value) {
	                return;
	            }
	            this._focusIndex = value;
	            this.indexFocused.emit(value);
	            this._setTabFocus(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
	     * providing a valid index and return true.
	     */
	    MdTabHeader.prototype._isValidIndex = function (index) {
	        if (!this._labelWrappers) {
	            return true;
	        }
	        var tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;
	        return tab && !tab.disabled;
	    };
	    /**
	     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
	     * scrolling is enabled.
	     */
	    MdTabHeader.prototype._setTabFocus = function (tabIndex) {
	        if (this._showPaginationControls) {
	            this._scrollToLabel(tabIndex);
	        }
	        if (this._labelWrappers && this._labelWrappers.length) {
	            this._labelWrappers.toArray()[tabIndex].focus();
	            // Do not let the browser manage scrolling to focus the element, this will be handled
	            // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width
	            // should be the full width minus the offset width.
	            var containerEl = this._tabListContainer.nativeElement;
	            var dir = this._getLayoutDirection();
	            if (dir == 'ltr') {
	                containerEl.scrollLeft = 0;
	            }
	            else {
	                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;
	            }
	        }
	    };
	    /**
	     * Moves the focus towards the beginning or the end of the list depending on the offset provided.
	     * Valid offsets are 1 and -1.
	     */
	    MdTabHeader.prototype._moveFocus = function (offset) {
	        if (this._labelWrappers) {
	            var tabs = this._labelWrappers.toArray();
	            for (var i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {
	                if (this._isValidIndex(i)) {
	                    this.focusIndex = i;
	                    return;
	                }
	            }
	        }
	    };
	    /** Increment the focus index by 1 until a valid tab is found. */
	    MdTabHeader.prototype._focusNextTab = function () {
	        this._moveFocus(this._getLayoutDirection() == 'ltr' ? 1 : -1);
	    };
	    /** Decrement the focus index by 1 until a valid tab is found. */
	    MdTabHeader.prototype._focusPreviousTab = function () {
	        this._moveFocus(this._getLayoutDirection() == 'ltr' ? -1 : 1);
	    };
	    /** The layout direction of the containing app. */
	    MdTabHeader.prototype._getLayoutDirection = function () {
	        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
	    };
	    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */
	    MdTabHeader.prototype._updateTabScrollPosition = function () {
	        var translateX = this.scrollDistance + 'px';
	        if (this._getLayoutDirection() == 'ltr') {
	            translateX = '-' + translateX;
	        }
	        applyCssTransform(this._tabList.nativeElement, "translate3d(" + translateX + ", 0, 0)");
	    };
	    Object.defineProperty(MdTabHeader.prototype, "scrollDistance", {
	        get: function () { return this._scrollDistance; },
	        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */
	        set: function (v) {
	            this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));
	            // Mark that the scroll distance has changed so that after the view is checked, the CSS
	            // transformation can move the header.
	            this._scrollDistanceChanged = true;
	            this._checkScrollingControls();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
	     * the end of the list, respectively). The distance to scroll is computed to be a third of the
	     * length of the tab list view window.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._scrollHeader = function (scrollDir) {
	        var viewLength = this._tabListContainer.nativeElement.offsetWidth;
	        // Move the scroll distance one-third the length of the tab list's viewport.
	        this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;
	    };
	    /**
	     * Moves the tab list such that the desired tab label (marked by index) is moved into view.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._scrollToLabel = function (labelIndex) {
	        var selectedLabel = this._labelWrappers
	            ? this._labelWrappers.toArray()[labelIndex]
	            : null;
	        if (!selectedLabel) {
	            return;
	        }
	        // The view length is the visible width of the tab labels.
	        var viewLength = this._tabListContainer.nativeElement.offsetWidth;
	        var labelBeforePos, labelAfterPos;
	        if (this._getLayoutDirection() == 'ltr') {
	            labelBeforePos = selectedLabel.getOffsetLeft();
	            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();
	        }
	        else {
	            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();
	            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();
	        }
	        var beforeVisiblePos = this.scrollDistance;
	        var afterVisiblePos = this.scrollDistance + viewLength;
	        if (labelBeforePos < beforeVisiblePos) {
	            // Scroll header to move label to the before direction
	            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;
	        }
	        else if (labelAfterPos > afterVisiblePos) {
	            // Scroll header to move label to the after direction
	            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;
	        }
	    };
	    /**
	     * Evaluate whether the pagination controls should be displayed. If the scroll width of the
	     * tab list is wider than the size of the header container, then the pagination controls should
	     * be shown.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._checkPaginationEnabled = function () {
	        this._showPaginationControls =
	            this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
	        if (!this._showPaginationControls) {
	            this.scrollDistance = 0;
	        }
	    };
	    /**
	     * Evaluate whether the before and after controls should be enabled or disabled.
	     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
	     * before button. If the header is at the end of the list (scroll distance is equal to the
	     * maximum distance we can scroll), then disable the after button.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._checkScrollingControls = function () {
	        // Check if the pagination arrows should be activated.
	        this._disableScrollBefore = this.scrollDistance == 0;
	        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();
	    };
	    /**
	     * Determines what is the maximum length in pixels that can be set for the scroll distance. This
	     * is equal to the difference in width between the tab list container and tab header container.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._getMaxScrollDistance = function () {
	        var lengthOfTabList = this._tabList.nativeElement.scrollWidth;
	        var viewLength = this._tabListContainer.nativeElement.offsetWidth;
	        return lengthOfTabList - viewLength;
	    };
	    /** Tells the ink-bar to align itself to the current label wrapper */
	    MdTabHeader.prototype._alignInkBarToSelectedTab = function () {
	        var _this = this;
	        var selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length
	            ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement
	            : null;
	        this._zone.runOutsideAngular(function () {
	            requestAnimationFrame(function () {
	                _this._inkBar.alignToElement(selectedLabelWrapper);
	            });
	        });
	    };
	    __decorate$64([
	        _angular_core.ContentChildren(MdTabLabelWrapper), 
	        __metadata$64('design:type', _angular_core.QueryList)
	    ], MdTabHeader.prototype, "_labelWrappers", void 0);
	    __decorate$64([
	        _angular_core.ViewChild(MdInkBar), 
	        __metadata$64('design:type', MdInkBar)
	    ], MdTabHeader.prototype, "_inkBar", void 0);
	    __decorate$64([
	        _angular_core.ViewChild('tabListContainer'), 
	        __metadata$64('design:type', _angular_core.ElementRef)
	    ], MdTabHeader.prototype, "_tabListContainer", void 0);
	    __decorate$64([
	        _angular_core.ViewChild('tabList'), 
	        __metadata$64('design:type', _angular_core.ElementRef)
	    ], MdTabHeader.prototype, "_tabList", void 0);
	    __decorate$64([
	        _angular_core.Input(), 
	        __metadata$64('design:type', Number), 
	        __metadata$64('design:paramtypes', [Number])
	    ], MdTabHeader.prototype, "selectedIndex", null);
	    __decorate$64([
	        _angular_core.Output(), 
	        __metadata$64('design:type', Object)
	    ], MdTabHeader.prototype, "selectFocusedIndex", void 0);
	    __decorate$64([
	        _angular_core.Output(), 
	        __metadata$64('design:type', Object)
	    ], MdTabHeader.prototype, "indexFocused", void 0);
	    MdTabHeader = __decorate$64([
	        _angular_core.Component({selector: 'md-tab-header, mat-tab-header',
	            template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\" aria-hidden=\"true\" md-ripple [mdRippleDisabled]=\"_disableScrollBefore\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\" (click)=\"_scrollHeader('before')\"><div class=\"mat-tab-header-pagination-chevron\"></div></div><div class=\"mat-tab-label-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\"><div class=\"mat-tab-list\" #tabList role=\"tablist\" (cdkObserveContent)=\"_onContentChanges()\"><div class=\"mat-tab-labels\"><ng-content></ng-content></div><md-ink-bar></md-ink-bar></div></div><div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\" aria-hidden=\"true\" md-ripple [mdRippleDisabled]=\"_disableScrollAfter\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\" (click)=\"_scrollHeader('after')\"><div class=\"mat-tab-header-pagination-chevron\"></div></div>",
	            styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;color:currentColor;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination,.mat-tab-labels{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#ccc}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                'class': 'mat-tab-header',
	                '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
	                '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
	            }
	        }),
	        __param$13(2, _angular_core.Optional()), 
	        __metadata$64('design:paramtypes', [_angular_core.NgZone, _angular_core.ElementRef, Dir])
	    ], MdTabHeader);
	    return MdTabHeader;
	}());
	
	var __decorate$57 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$57 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Used to generate unique ID's for each tab component */
	var nextId$2 = 0;
	/** A simple change event emitted on focus or selection changes. */
	var MdTabChangeEvent = (function () {
	    function MdTabChangeEvent() {
	    }
	    return MdTabChangeEvent;
	}());
	/**
	 * Material design tab-group component.  Supports basic tab pairs (label + content) and includes
	 * animated ink-bar, keyboard navigation, and screen reader.
	 * See: https://www.google.com/design/spec/components/tabs.html
	 */
	var MdTabGroup = (function () {
	    function MdTabGroup(_renderer) {
	        this._renderer = _renderer;
	        /** Whether this component has been initialized. */
	        this._isInitialized = false;
	        /** The tab index that should be selected after the content has been checked. */
	        this._indexToSelect = 0;
	        /** Snapshot of the height of the tab body wrapper before another tab is activated. */
	        this._tabBodyWrapperHeight = null;
	        /** Whether the tab group should grow to the size of the active tab */
	        this._dynamicHeight = false;
	        this._selectedIndex = null;
	        /** Position of the tab header. */
	        this.headerPosition = 'above';
	        this._onFocusChange = new _angular_core.EventEmitter();
	        this._onSelectChange = new _angular_core.EventEmitter(true);
	        this._groupId = nextId$2++;
	    }
	    Object.defineProperty(MdTabGroup.prototype, "dynamicHeight", {
	        get: function () { return this._dynamicHeight; },
	        set: function (value) { this._dynamicHeight = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "_dynamicHeightDeprecated", {
	        /** @deprecated */
	        get: function () { return this._dynamicHeight; },
	        set: function (value) { this._dynamicHeight = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "selectedIndex", {
	        get: function () { return this._selectedIndex; },
	        /** The index of the active tab. */
	        set: function (value) { this._indexToSelect = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "selectedIndexChange", {
	        /** Output to enable support for two-way binding on `selectedIndex`. */
	        get: function () {
	            return this.selectChange.map(function (event) { return event.index; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "focusChange", {
	        /** Event emitted when focus has changed within a tab group. */
	        get: function () {
	            return this._onFocusChange.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "selectChange", {
	        /** Event emitted when the tab selection has changed. */
	        get: function () {
	            return this._onSelectChange.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * After the content is checked, this component knows what tabs have been defined
	     * and what the selected index should be. This is where we can know exactly what position
	     * each tab should be in according to the new selected index, and additionally we know how
	     * a new selected tab should transition in (from the left or right).
	     */
	    MdTabGroup.prototype.ngAfterContentChecked = function () {
	        var _this = this;
	        // Clamp the next selected index to the bounds of 0 and the tabs length. Note the `|| 0`, which
	        // ensures that values like NaN can't get through and which would otherwise throw the
	        // component into an infinite loop (since Math.max(NaN, 0) === NaN).
	        this._indexToSelect =
	            Math.min(this._tabs.length - 1, Math.max(this._indexToSelect || 0, 0));
	        // If there is a change in selected index, emit a change event. Should not trigger if
	        // the selected index has not yet been initialized.
	        if (this._selectedIndex != this._indexToSelect && this._selectedIndex != null) {
	            this._onSelectChange.emit(this._createChangeEvent(this._indexToSelect));
	        }
	        // Setup the position for each tab and optionally setup an origin on the next selected tab.
	        this._tabs.forEach(function (tab, index) {
	            tab.position = index - _this._indexToSelect;
	            // If there is already a selected tab, then set up an origin for the next selected tab
	            // if it doesn't have one already.
	            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {
	                tab.origin = _this._indexToSelect - _this._selectedIndex;
	            }
	        });
	        this._selectedIndex = this._indexToSelect;
	    };
	    /**
	     * Waits one frame for the view to update, then updates the ink bar
	     * Note: This must be run outside of the zone or it will create an infinite change detection loop.
	     */
	    MdTabGroup.prototype.ngAfterViewChecked = function () {
	        this._isInitialized = true;
	    };
	    MdTabGroup.prototype._focusChanged = function (index) {
	        this._onFocusChange.emit(this._createChangeEvent(index));
	    };
	    MdTabGroup.prototype._createChangeEvent = function (index) {
	        var event = new MdTabChangeEvent;
	        event.index = index;
	        if (this._tabs && this._tabs.length) {
	            event.tab = this._tabs.toArray()[index];
	        }
	        return event;
	    };
	    /** Returns a unique id for each tab label element */
	    MdTabGroup.prototype._getTabLabelId = function (i) {
	        return "md-tab-label-" + this._groupId + "-" + i;
	    };
	    /** Returns a unique id for each tab content element */
	    MdTabGroup.prototype._getTabContentId = function (i) {
	        return "md-tab-content-" + this._groupId + "-" + i;
	    };
	    /**
	     * Sets the height of the body wrapper to the height of the activating tab if dynamic
	     * height property is true.
	     */
	    MdTabGroup.prototype._setTabBodyWrapperHeight = function (tabHeight) {
	        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
	            return;
	        }
	        this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', this._tabBodyWrapperHeight + 'px');
	        // This conditional forces the browser to paint the height so that
	        // the animation to the new height can have an origin.
	        if (this._tabBodyWrapper.nativeElement.offsetHeight) {
	            this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', tabHeight + 'px');
	        }
	    };
	    /** Removes the height of the tab body wrapper. */
	    MdTabGroup.prototype._removeTabBodyWrapperHeight = function () {
	        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;
	        this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', '');
	    };
	    __decorate$57([
	        _angular_core.ContentChildren(MdTab), 
	        __metadata$57('design:type', _angular_core.QueryList)
	    ], MdTabGroup.prototype, "_tabs", void 0);
	    __decorate$57([
	        _angular_core.ViewChild('tabBodyWrapper'), 
	        __metadata$57('design:type', _angular_core.ElementRef)
	    ], MdTabGroup.prototype, "_tabBodyWrapper", void 0);
	    __decorate$57([
	        _angular_core.Input(), 
	        __metadata$57('design:type', Boolean)
	    ], MdTabGroup.prototype, "dynamicHeight", null);
	    __decorate$57([
	        _angular_core.Input('md-dynamic-height'), 
	        __metadata$57('design:type', Boolean)
	    ], MdTabGroup.prototype, "_dynamicHeightDeprecated", null);
	    __decorate$57([
	        _angular_core.Input(), 
	        __metadata$57('design:type', Number), 
	        __metadata$57('design:paramtypes', [Number])
	    ], MdTabGroup.prototype, "selectedIndex", null);
	    __decorate$57([
	        _angular_core.Input(), 
	        __metadata$57('design:type', String)
	    ], MdTabGroup.prototype, "headerPosition", void 0);
	    __decorate$57([
	        _angular_core.Output(), 
	        __metadata$57('design:type', rxjs_Observable.Observable)
	    ], MdTabGroup.prototype, "selectedIndexChange", null);
	    __decorate$57([
	        _angular_core.Output(), 
	        __metadata$57('design:type', rxjs_Observable.Observable)
	    ], MdTabGroup.prototype, "focusChange", null);
	    __decorate$57([
	        _angular_core.Output(), 
	        __metadata$57('design:type', rxjs_Observable.Observable)
	    ], MdTabGroup.prototype, "selectChange", null);
	    MdTabGroup = __decorate$57([
	        _angular_core.Component({selector: 'md-tab-group, mat-tab-group',
	            template: "<md-tab-header [selectedIndex]=\"selectedIndex\" #tabHeader (indexFocused)=\"_focusChanged($event)\" (selectFocusedIndex)=\"selectedIndex = $event\"><div class=\"mat-tab-label\" role=\"tab\" md-tab-label-wrapper md-ripple *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabLabelId(i)\" [tabIndex]=\"selectedIndex == i ? 0 : -1\" [attr.aria-controls]=\"_getTabContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [class.mat-tab-label-active]=\"selectedIndex == i\" [disabled]=\"tab.disabled\" (click)=\"tabHeader.focusIndex = selectedIndex = i\"><template [ngIf]=\"tab.templateLabel\"><template [cdkPortalHost]=\"tab.templateLabel\"></template></template><template [ngIf]=\"!tab.templateLabel\">{{tab.textLabel}}</template></div></md-tab-header><div class=\"mat-tab-body-wrapper\" #tabBodyWrapper><md-tab-body role=\"tabpanel\" *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabContentId(i)\" [attr.aria-labelledby]=\"_getTabLabelId(i)\" [class.mat-tab-body-active]=\"selectedIndex == i\" [content]=\"tab.content\" [position]=\"tab.position\" [origin]=\"tab.origin\" (onCentered)=\"_removeTabBodyWrapperHeight()\" (onCentering)=\"_setTabBodyWrapperHeight($event)\"></md-tab-body></div>",
	            styles: [":host{display:flex;flex-direction:column;font-family:Roboto,\"Helvetica Neue\",sans-serif}:host.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;color:currentColor;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-label{min-width:72px}}:host[mat-stretch-tabs] .mat-tab-label,:host[md-stretch-tabs] .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{position:absolute;top:0;left:0;right:0;bottom:0;display:block;overflow:hidden}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}:host.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}.mat-tab-disabled{cursor:default;pointer-events:none}"],
	            host: {
	                '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',
	                '[class.mat-tab-group-inverted-header]': 'headerPosition === "below"',
	            }
	        }), 
	        __metadata$57('design:paramtypes', [_angular_core.Renderer])
	    ], MdTabGroup);
	    return MdTabGroup;
	}());
	var MdTabsModule = (function () {
	    function MdTabsModule() {
	    }
	    /** @deprecated */
	    MdTabsModule.forRoot = function () {
	        return {
	            ngModule: MdTabsModule,
	            providers: []
	        };
	    };
	    MdTabsModule = __decorate$57([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, PortalModule, MdRippleModule, ObserveContentModule],
	            // Don't export all components because some are only to be used internally.
	            exports: [MdTabGroup, MdTabLabel, MdTab, MdTabNavBar, MdTabLink, MdTabLinkRipple],
	            declarations: [MdTabGroup, MdTabLabel, MdTab, MdInkBar, MdTabLabelWrapper,
	                MdTabNavBar, MdTabLink, MdTabBody, MdTabLinkRipple, MdTabHeader],
	            providers: [VIEWPORT_RULER_PROVIDER, SCROLL_DISPATCHER_PROVIDER],
	        }), 
	        __metadata$57('design:paramtypes', [])
	    ], MdTabsModule);
	    return MdTabsModule;
	}());
	
	var __decorate$65 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$65 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdToolbarRow = (function () {
	    function MdToolbarRow() {
	    }
	    MdToolbarRow = __decorate$65([
	        _angular_core.Directive({
	            selector: 'md-toolbar-row, mat-toolbar-row',
	            host: {
	                '[class.mat-toolbar-row]': 'true',
	            },
	        }), 
	        __metadata$65('design:paramtypes', [])
	    ], MdToolbarRow);
	    return MdToolbarRow;
	}());
	var MdToolbar = (function () {
	    function MdToolbar(elementRef, renderer) {
	        this.elementRef = elementRef;
	        this.renderer = renderer;
	    }
	    Object.defineProperty(MdToolbar.prototype, "color", {
	        /** The color of the toolbar. Can be primary, accent, or warn. */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdToolbar.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdToolbar.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this.renderer.setElementClass(this.elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    __decorate$65([
	        _angular_core.Input(), 
	        __metadata$65('design:type', String)
	    ], MdToolbar.prototype, "color", null);
	    MdToolbar = __decorate$65([
	        _angular_core.Component({selector: 'md-toolbar, mat-toolbar',
	            template: "<div class=\"mat-toolbar-layout\"><md-toolbar-row><ng-content></ng-content></md-toolbar-row><ng-content select=\"md-toolbar-row, mat-toolbar-row\"></ng-content></div>",
	            styles: [".mat-toolbar,.mat-toolbar .mat-toolbar-row{display:flex;box-sizing:border-box;width:100%}.mat-toolbar{font-size:20px;font-weight:500;font-family:Roboto,\"Helvetica Neue\",sans-serif;padding:0 16px;flex-direction:column;min-height:64px}.mat-toolbar .mat-toolbar-row{flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-row{height:64px}@media (max-width:600px) and (orientation:portrait){.mat-toolbar{min-height:56px}.mat-toolbar-row{height:56px}}@media (max-width:960px) and (orientation:landscape){.mat-toolbar{min-height:48px}.mat-toolbar-row{height:48px}}"],
	            host: {
	                '[class.mat-toolbar]': 'true',
	                'role': 'toolbar'
	            },
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$65('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdToolbar);
	    return MdToolbar;
	}());
	var MdToolbarModule = (function () {
	    function MdToolbarModule() {
	    }
	    /** @deprecated */
	    MdToolbarModule.forRoot = function () {
	        return {
	            ngModule: MdToolbarModule,
	            providers: []
	        };
	    };
	    MdToolbarModule = __decorate$65([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [MdToolbar, MdToolbarRow, CompatibilityModule],
	            declarations: [MdToolbar, MdToolbarRow],
	        }), 
	        __metadata$65('design:paramtypes', [])
	    ], MdToolbarModule);
	    return MdToolbarModule;
	}());
	
	var __extends$20 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when a tooltip has an invalid position.
	 * @docs-private
	 */
	var MdTooltipInvalidPositionError = (function (_super) {
	    __extends$20(MdTooltipInvalidPositionError, _super);
	    function MdTooltipInvalidPositionError(position) {
	        _super.call(this, "Tooltip position \"" + position + "\" is invalid.");
	    }
	    return MdTooltipInvalidPositionError;
	}(MdError));
	
	var __decorate$66 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$66 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$14 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** Time in ms to delay before changing the tooltip visibility to hidden */
	var TOUCHEND_HIDE_DELAY = 1500;
	/** Time in ms to throttle repositioning after scroll events. */
	var SCROLL_THROTTLE_MS = 20;
	/**
	 * Directive that attaches a material design tooltip to the host element. Animates the showing and
	 * hiding of a tooltip provided position (defaults to below the element).
	 *
	 * https://material.google.com/components/tooltips.html
	 */
	var MdTooltip = (function () {
	    function MdTooltip(_overlay, _scrollDispatcher, _elementRef, _viewContainerRef, _ngZone, _dir) {
	        this._overlay = _overlay;
	        this._scrollDispatcher = _scrollDispatcher;
	        this._elementRef = _elementRef;
	        this._viewContainerRef = _viewContainerRef;
	        this._ngZone = _ngZone;
	        this._dir = _dir;
	        this._position = 'below';
	        /** The default delay in ms before showing the tooltip after show is called */
	        this.showDelay = 0;
	        /** The default delay in ms before hiding the tooltip after hide is called */
	        this.hideDelay = 0;
	    }
	    Object.defineProperty(MdTooltip.prototype, "position", {
	        /** Allows the user to define the position of the tooltip relative to the parent element */
	        get: function () { return this._position; },
	        set: function (value) {
	            if (value !== this._position) {
	                this._position = value;
	                // TODO(andrewjs): When the overlay's position can be dynamically changed, do not destroy
	                // the tooltip.
	                if (this._tooltipInstance) {
	                    this._disposeTooltip();
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_positionDeprecated", {
	        /** @deprecated */
	        get: function () { return this._position; },
	        set: function (value) { this._position = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "message", {
	        /** The message to be displayed in the tooltip */
	        get: function () { return this._message; },
	        set: function (value) {
	            this._message = value;
	            if (this._tooltipInstance) {
	                this._setTooltipMessage(this._message);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_deprecatedMessage", {
	        /** @deprecated */
	        get: function () { return this.message; },
	        set: function (v) { this.message = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matMessage", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.message; },
	        set: function (v) { this.message = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matPosition", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.position; },
	        set: function (v) { this.position = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matHideDelay", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.hideDelay; },
	        set: function (v) { this.hideDelay = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matShowDelay", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.showDelay; },
	        set: function (v) { this.showDelay = v; },
	        enumerable: true,
	        configurable: true
	    });
	    MdTooltip.prototype.ngOnInit = function () {
	        var _this = this;
	        // When a scroll on the page occurs, update the position in case this tooltip needs
	        // to be repositioned.
	        this.scrollSubscription = this._scrollDispatcher.scrolled(SCROLL_THROTTLE_MS).subscribe(function () {
	            if (_this._overlayRef) {
	                _this._overlayRef.updatePosition();
	            }
	        });
	    };
	    /**
	     * Dispose the tooltip when destroyed.
	     */
	    MdTooltip.prototype.ngOnDestroy = function () {
	        if (this._tooltipInstance) {
	            this._disposeTooltip();
	        }
	        this.scrollSubscription.unsubscribe();
	    };
	    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
	    MdTooltip.prototype.show = function (delay) {
	        if (delay === void 0) { delay = this.showDelay; }
	        if (!this._message || !this._message.trim()) {
	            return;
	        }
	        if (!this._tooltipInstance) {
	            this._createTooltip();
	        }
	        this._setTooltipMessage(this._message);
	        this._tooltipInstance.show(this._position, delay);
	    };
	    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
	    MdTooltip.prototype.hide = function (delay) {
	        if (delay === void 0) { delay = this.hideDelay; }
	        if (this._tooltipInstance) {
	            this._tooltipInstance.hide(delay);
	        }
	    };
	    /** Shows/hides the tooltip */
	    MdTooltip.prototype.toggle = function () {
	        this._isTooltipVisible() ? this.hide() : this.show();
	    };
	    /** Returns true if the tooltip is currently visible to the user */
	    MdTooltip.prototype._isTooltipVisible = function () {
	        return this._tooltipInstance && this._tooltipInstance.isVisible();
	    };
	    /** Create the tooltip to display */
	    MdTooltip.prototype._createTooltip = function () {
	        var _this = this;
	        this._createOverlay();
	        var portal = new ComponentPortal(TooltipComponent, this._viewContainerRef);
	        this._tooltipInstance = this._overlayRef.attach(portal).instance;
	        // Dispose the overlay when finished the shown tooltip.
	        this._tooltipInstance.afterHidden().subscribe(function () {
	            // Check first if the tooltip has already been removed through this components destroy.
	            if (_this._tooltipInstance) {
	                _this._disposeTooltip();
	            }
	        });
	    };
	    /** Create the overlay config and position strategy */
	    MdTooltip.prototype._createOverlay = function () {
	        var _this = this;
	        var origin = this._getOrigin();
	        var position = this._getOverlayPosition();
	        // Create connected position strategy that listens for scroll events to reposition.
	        // After position changes occur and the overlay is clipped by a parent scrollable then
	        // close the tooltip.
	        var strategy = this._overlay.position().connectedTo(this._elementRef, origin, position);
	        strategy.withScrollableContainers(this._scrollDispatcher.getScrollContainers(this._elementRef));
	        strategy.onPositionChange.subscribe(function (change) {
	            if (change.scrollableViewProperties.isOverlayClipped &&
	                _this._tooltipInstance && _this._tooltipInstance.isVisible()) {
	                _this.hide(0);
	            }
	        });
	        var config = new OverlayState();
	        config.positionStrategy = strategy;
	        this._overlayRef = this._overlay.create(config);
	    };
	    /** Disposes the current tooltip and the overlay it is attached to */
	    MdTooltip.prototype._disposeTooltip = function () {
	        this._overlayRef.dispose();
	        this._overlayRef = null;
	        this._tooltipInstance = null;
	    };
	    /** Returns the origin position based on the user's position preference */
	    MdTooltip.prototype._getOrigin = function () {
	        if (this.position == 'above' || this.position == 'below') {
	            return { originX: 'center', originY: this.position == 'above' ? 'top' : 'bottom' };
	        }
	        var isDirectionLtr = !this._dir || this._dir.value == 'ltr';
	        if (this.position == 'left' ||
	            this.position == 'before' && isDirectionLtr ||
	            this.position == 'after' && !isDirectionLtr) {
	            return { originX: 'start', originY: 'center' };
	        }
	        if (this.position == 'right' ||
	            this.position == 'after' && isDirectionLtr ||
	            this.position == 'before' && !isDirectionLtr) {
	            return { originX: 'end', originY: 'center' };
	        }
	        throw new MdTooltipInvalidPositionError(this.position);
	    };
	    /** Returns the overlay position based on the user's preference */
	    MdTooltip.prototype._getOverlayPosition = function () {
	        if (this.position == 'above') {
	            return { overlayX: 'center', overlayY: 'bottom' };
	        }
	        if (this.position == 'below') {
	            return { overlayX: 'center', overlayY: 'top' };
	        }
	        var isLtr = !this._dir || this._dir.value == 'ltr';
	        if (this.position == 'left' ||
	            this.position == 'before' && isLtr ||
	            this.position == 'after' && !isLtr) {
	            return { overlayX: 'end', overlayY: 'center' };
	        }
	        if (this.position == 'right' ||
	            this.position == 'after' && isLtr ||
	            this.position == 'before' && !isLtr) {
	            return { overlayX: 'start', overlayY: 'center' };
	        }
	        throw new MdTooltipInvalidPositionError(this.position);
	    };
	    /** Updates the tooltip message and repositions the overlay according to the new message length */
	    MdTooltip.prototype._setTooltipMessage = function (message) {
	        var _this = this;
	        // Must wait for the message to be painted to the tooltip so that the overlay can properly
	        // calculate the correct positioning based on the size of the text.
	        this._tooltipInstance.message = message;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            if (_this._tooltipInstance) {
	                _this._overlayRef.updatePosition();
	            }
	        });
	    };
	    __decorate$66([
	        _angular_core.Input('mdTooltipPosition'), 
	        __metadata$66('design:type', String)
	    ], MdTooltip.prototype, "position", null);
	    __decorate$66([
	        _angular_core.Input('tooltip-position'), 
	        __metadata$66('design:type', String)
	    ], MdTooltip.prototype, "_positionDeprecated", null);
	    __decorate$66([
	        _angular_core.Input('mdTooltipShowDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "showDelay", void 0);
	    __decorate$66([
	        _angular_core.Input('mdTooltipHideDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "hideDelay", void 0);
	    __decorate$66([
	        _angular_core.Input('mdTooltip'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "message", null);
	    __decorate$66([
	        _angular_core.Input('md-tooltip'), 
	        __metadata$66('design:type', String)
	    ], MdTooltip.prototype, "_deprecatedMessage", null);
	    __decorate$66([
	        _angular_core.Input('matTooltip'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matMessage", null);
	    __decorate$66([
	        _angular_core.Input('matTooltipPosition'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matPosition", null);
	    __decorate$66([
	        _angular_core.Input('matTooltipHideDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matHideDelay", null);
	    __decorate$66([
	        _angular_core.Input('matTooltipShowDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matShowDelay", null);
	    MdTooltip = __decorate$66([
	        _angular_core.Directive({
	            selector: '[md-tooltip], [mdTooltip], [mat-tooltip], [matTooltip]',
	            host: {
	                '(longpress)': 'show()',
	                '(touchend)': 'hide(' + TOUCHEND_HIDE_DELAY + ')',
	                '(mouseenter)': 'show()',
	                '(mouseleave)': 'hide()',
	            },
	            exportAs: 'mdTooltip',
	        }),
	        __param$14(5, _angular_core.Optional()), 
	        __metadata$66('design:paramtypes', [Overlay, ScrollDispatcher, _angular_core.ElementRef, _angular_core.ViewContainerRef, _angular_core.NgZone, Dir])
	    ], MdTooltip);
	    return MdTooltip;
	}());
	/**
	 * Internal component that wraps the tooltip's content.
	 * @docs-private
	 */
	var TooltipComponent = (function () {
	    function TooltipComponent(_dir, _changeDetectorRef) {
	        this._dir = _dir;
	        this._changeDetectorRef = _changeDetectorRef;
	        /** Property watched by the animation framework to show or hide the tooltip */
	        this._visibility = 'initial';
	        /** Whether interactions on the page should close the tooltip */
	        this._closeOnInteraction = false;
	        /** The transform origin used in the animation for showing and hiding the tooltip */
	        this._transformOrigin = 'bottom';
	        /** Subject for notifying that the tooltip has been hidden from the view */
	        this._onHide = new rxjs_Subject.Subject();
	    }
	    /**
	     * Shows the tooltip with an animation originating from the provided origin
	     * @param position Position of the tooltip.
	     * @param delay Amount of milliseconds to the delay showing the tooltip.
	     */
	    TooltipComponent.prototype.show = function (position, delay) {
	        var _this = this;
	        // Cancel the delayed hide if it is scheduled
	        if (this._hideTimeoutId) {
	            clearTimeout(this._hideTimeoutId);
	        }
	        // Body interactions should cancel the tooltip if there is a delay in showing.
	        this._closeOnInteraction = true;
	        this._setTransformOrigin(position);
	        this._showTimeoutId = setTimeout(function () {
	            _this._visibility = 'visible';
	            // If this was set to true immediately, then a body click that triggers show() would
	            // trigger interaction and close the tooltip right after it was displayed.
	            _this._closeOnInteraction = false;
	            // Mark for check so if any parent component has set the
	            // ChangeDetectionStrategy to OnPush it will be checked anyways
	            _this._changeDetectorRef.markForCheck();
	            setTimeout(function () { _this._closeOnInteraction = true; }, 0);
	        }, delay);
	    };
	    /**
	     * Begins the animation to hide the tooltip after the provided delay in ms.
	     * @param delay Amount of milliseconds to delay showing the tooltip.
	     */
	    TooltipComponent.prototype.hide = function (delay) {
	        var _this = this;
	        // Cancel the delayed show if it is scheduled
	        if (this._showTimeoutId) {
	            clearTimeout(this._showTimeoutId);
	        }
	        this._hideTimeoutId = setTimeout(function () {
	            _this._visibility = 'hidden';
	            _this._closeOnInteraction = false;
	            // Mark for check so if any parent component has set the
	            // ChangeDetectionStrategy to OnPush it will be checked anyways
	            _this._changeDetectorRef.markForCheck();
	        }, delay);
	    };
	    /**
	     * Returns an observable that notifies when the tooltip has been hidden from view
	     */
	    TooltipComponent.prototype.afterHidden = function () {
	        return this._onHide.asObservable();
	    };
	    /**
	     * Whether the tooltip is being displayed
	     */
	    TooltipComponent.prototype.isVisible = function () {
	        return this._visibility === 'visible';
	    };
	    /** Sets the tooltip transform origin according to the tooltip position */
	    TooltipComponent.prototype._setTransformOrigin = function (value) {
	        var isLtr = !this._dir || this._dir.value == 'ltr';
	        switch (value) {
	            case 'before':
	                this._transformOrigin = isLtr ? 'right' : 'left';
	                break;
	            case 'after':
	                this._transformOrigin = isLtr ? 'left' : 'right';
	                break;
	            case 'left':
	                this._transformOrigin = 'right';
	                break;
	            case 'right':
	                this._transformOrigin = 'left';
	                break;
	            case 'above':
	                this._transformOrigin = 'bottom';
	                break;
	            case 'below':
	                this._transformOrigin = 'top';
	                break;
	            default: throw new MdTooltipInvalidPositionError(value);
	        }
	    };
	    TooltipComponent.prototype._afterVisibilityAnimation = function (e) {
	        if (e.toState === 'hidden' && !this.isVisible()) {
	            this._onHide.next();
	        }
	    };
	    /**
	     * Interactions on the HTML body should close the tooltip immediately as defined in the
	     * material design spec.
	     * https://material.google.com/components/tooltips.html#tooltips-interaction
	     */
	    TooltipComponent.prototype._handleBodyInteraction = function () {
	        if (this._closeOnInteraction) {
	            this.hide(0);
	        }
	    };
	    TooltipComponent = __decorate$66([
	        _angular_core.Component({selector: 'md-tooltip-component, mat-tooltip-component',
	            template: "<div class=\"mat-tooltip\" [style.transform-origin]=\"_transformOrigin\" [@state]=\"_visibility\" (@state.done)=\"_afterVisibilityAnimation($event)\">{{message}}</div>",
	            styles: [":host{pointer-events:none}.mat-tooltip{color:#fff;padding:6px 8px;border-radius:2px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:10px;margin:14px;max-width:250px}@media screen and (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}"],
	            animations: [
	                _angular_core.trigger('state', [
	                    _angular_core.state('void', _angular_core.style({ transform: 'scale(0)' })),
	                    _angular_core.state('initial', _angular_core.style({ transform: 'scale(0)' })),
	                    _angular_core.state('visible', _angular_core.style({ transform: 'scale(1)' })),
	                    _angular_core.state('hidden', _angular_core.style({ transform: 'scale(0)' })),
	                    _angular_core.transition('* => visible', _angular_core.animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),
	                    _angular_core.transition('* => hidden', _angular_core.animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),
	                ])
	            ],
	            host: {
	                '(body:click)': 'this._handleBodyInteraction()'
	            }
	        }),
	        __param$14(0, _angular_core.Optional()), 
	        __metadata$66('design:paramtypes', [Dir, _angular_core.ChangeDetectorRef])
	    ], TooltipComponent);
	    return TooltipComponent;
	}());
	var MdTooltipModule = (function () {
	    function MdTooltipModule() {
	    }
	    /** @deprecated */
	    MdTooltipModule.forRoot = function () {
	        return {
	            ngModule: MdTooltipModule,
	            providers: []
	        };
	    };
	    MdTooltipModule = __decorate$66([
	        _angular_core.NgModule({
	            imports: [OverlayModule, CompatibilityModule],
	            exports: [MdTooltip, TooltipComponent, CompatibilityModule],
	            declarations: [MdTooltip, TooltipComponent],
	            entryComponents: [TooltipComponent],
	        }), 
	        __metadata$66('design:paramtypes', [])
	    ], MdTooltipModule);
	    return MdTooltipModule;
	}());
	
	var __extends$21 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when menu trigger doesn't have a valid md-menu instance
	 * @docs-private
	 */
	var MdMenuMissingError = (function (_super) {
	    __extends$21(MdMenuMissingError, _super);
	    function MdMenuMissingError() {
	        _super.call(this, "md-menu-trigger: must pass in an md-menu instance.\n\n    Example:\n      <md-menu #menu=\"mdMenu\"></md-menu>\n      <button [mdMenuTriggerFor]=\"menu\"></button>\n    ");
	    }
	    return MdMenuMissingError;
	}(MdError));
	/**
	 * Exception thrown when menu's x-position value isn't valid.
	 * In other words, it doesn't match 'before' or 'after'.
	 * @docs-private
	 */
	var MdMenuInvalidPositionX = (function (_super) {
	    __extends$21(MdMenuInvalidPositionX, _super);
	    function MdMenuInvalidPositionX() {
	        _super.call(this, "x-position value must be either 'before' or after'.\n      Example: <md-menu x-position=\"before\" #menu=\"mdMenu\"></md-menu>\n    ");
	    }
	    return MdMenuInvalidPositionX;
	}(MdError));
	/**
	 * Exception thrown when menu's y-position value isn't valid.
	 * In other words, it doesn't match 'above' or 'below'.
	 * @docs-private
	 */
	var MdMenuInvalidPositionY = (function (_super) {
	    __extends$21(MdMenuInvalidPositionY, _super);
	    function MdMenuInvalidPositionY() {
	        _super.call(this, "y-position value must be either 'above' or below'.\n      Example: <md-menu y-position=\"above\" #menu=\"mdMenu\"></md-menu>\n    ");
	    }
	    return MdMenuInvalidPositionY;
	}(MdError));
	
	var __decorate$69 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$69 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * This directive is intended to be used inside an md-menu tag.
	 * It exists mostly to set the role attribute.
	 */
	var MdMenuItem = (function () {
	    function MdMenuItem(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	    }
	    MdMenuItem.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._elementRef.nativeElement, 'focus');
	    };
	    Object.defineProperty(MdMenuItem.prototype, "disabled", {
	        // this is necessary to support anchors
	        /** Whether the menu item is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) {
	            this._disabled = (value === false || value === undefined) ? null : true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuItem.prototype, "isAriaDisabled", {
	        /** Sets the aria-disabled property on the menu item. */
	        get: function () { return String(!!this.disabled); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuItem.prototype, "_tabindex", {
	        get: function () { return this.disabled ? '-1' : '0'; },
	        enumerable: true,
	        configurable: true
	    });
	    MdMenuItem.prototype._getHostElement = function () {
	        return this._elementRef.nativeElement;
	    };
	    MdMenuItem.prototype._checkDisabled = function (event) {
	        if (this.disabled) {
	            event.preventDefault();
	            event.stopPropagation();
	        }
	    };
	    __decorate$69([
	        _angular_core.HostBinding('attr.disabled'),
	        _angular_core.Input(), 
	        __metadata$69('design:type', Boolean)
	    ], MdMenuItem.prototype, "disabled", null);
	    __decorate$69([
	        _angular_core.HostBinding('attr.aria-disabled'), 
	        __metadata$69('design:type', String)
	    ], MdMenuItem.prototype, "isAriaDisabled", null);
	    MdMenuItem = __decorate$69([
	        _angular_core.Component({selector: '[md-menu-item], [mat-menu-item]',
	            host: {
	                'role': 'menuitem',
	                '[class.mat-menu-item]': 'true',
	                '(click)': '_checkDisabled($event)',
	                '[attr.tabindex]': '_tabindex'
	            },
	            template: "<ng-content></ng-content><div class=\"mat-menu-ripple\" *ngIf=\"!disabled\" md-ripple [mdRippleTrigger]=\"_getHostElement()\"></div>",
	            exportAs: 'mdMenuItem'
	        }), 
	        __metadata$69('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdMenuItem);
	    return MdMenuItem;
	}());
	
	/**
	 * Below are all the animations for the md-menu component.
	 * Animation duration and timing values are based on AngularJS Material.
	 */
	/**
	 * This animation controls the menu panel's entry and exit from the page.
	 *
	 * When the menu panel is added to the DOM, it scales in and fades in its border.
	 *
	 * When the menu panel is removed from the DOM, it simply fades out after a brief
	 * delay to display the ripple.
	 */
	// TODO(kara): switch to :enter and :leave once Mobile Safari is sorted out.
	var transformMenu = _angular_core.trigger('transformMenu', [
	    _angular_core.state('showing', _angular_core.style({
	        opacity: 1,
	        transform: "scale(1)"
	    })),
	    _angular_core.transition('void => *', [
	        _angular_core.style({
	            opacity: 0,
	            transform: "scale(0)"
	        }),
	        _angular_core.animate("200ms cubic-bezier(0.25, 0.8, 0.25, 1)")
	    ]),
	    _angular_core.transition('* => void', [
	        _angular_core.animate('50ms 100ms linear', _angular_core.style({ opacity: 0 }))
	    ])
	]);
	/**
	 * This animation fades in the background color and content of the menu panel
	 * after its containing element is scaled in.
	 */
	var fadeInItems = _angular_core.trigger('fadeInItems', [
	    _angular_core.state('showing', _angular_core.style({ opacity: 1 })),
	    _angular_core.transition('void => *', [
	        _angular_core.style({ opacity: 0 }),
	        _angular_core.animate("200ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
	    ])
	]);
	
	// TODO(kara): prevent-close functionality
	var __decorate$68 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$68 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$15 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var MdMenu = (function () {
	    function MdMenu(posX, posY) {
	        /** Config object to be passed into the menu's ngClass */
	        this._classList = {};
	        /** Position of the menu in the X axis. */
	        this.positionX = 'after';
	        /** Position of the menu in the Y axis. */
	        this.positionY = 'below';
	        this.overlapTrigger = true;
	        /** Event emitted when the menu is closed. */
	        this.close = new _angular_core.EventEmitter();
	        if (posX) {
	            this._setPositionX(posX);
	        }
	        if (posY) {
	            this._setPositionY(posY);
	        }
	        this.setPositionClasses(this.positionX, this.positionY);
	    }
	    MdMenu.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._keyManager = new FocusKeyManager(this.items).withWrap();
	        this._tabSubscription = this._keyManager.tabOut.subscribe(function () {
	            _this._emitCloseEvent();
	        });
	    };
	    MdMenu.prototype.ngOnDestroy = function () {
	        this._tabSubscription.unsubscribe();
	    };
	    Object.defineProperty(MdMenu.prototype, "classList", {
	        /**
	         * This method takes classes set on the host md-menu element and applies them on the
	         * menu template that displays in the overlay container.  Otherwise, it's difficult
	         * to style the containing menu from outside the component.
	         * @param classes list of class names
	         */
	        set: function (classes) {
	            this._classList = classes.split(' ').reduce(function (obj, className) {
	                obj[className] = true;
	                return obj;
	            }, {});
	            this.setPositionClasses(this.positionX, this.positionY);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Focus the first item in the menu. This method is used by the menu trigger
	     * to focus the first item when the menu is opened by the ENTER key.
	     */
	    MdMenu.prototype.focusFirstItem = function () {
	        this._keyManager.setFirstItemActive();
	    };
	    /**
	     * This emits a close event to which the trigger is subscribed. When emitted, the
	     * trigger will close the menu.
	     */
	    MdMenu.prototype._emitCloseEvent = function () {
	        this.close.emit();
	    };
	    MdMenu.prototype._setPositionX = function (pos) {
	        if (pos !== 'before' && pos !== 'after') {
	            throw new MdMenuInvalidPositionX();
	        }
	        this.positionX = pos;
	    };
	    MdMenu.prototype._setPositionY = function (pos) {
	        if (pos !== 'above' && pos !== 'below') {
	            throw new MdMenuInvalidPositionY();
	        }
	        this.positionY = pos;
	    };
	    /**
	     * It's necessary to set position-based classes to ensure the menu panel animation
	     * folds out from the correct direction.
	     */
	    MdMenu.prototype.setPositionClasses = function (posX, posY) {
	        this._classList['mat-menu-before'] = posX == 'before';
	        this._classList['mat-menu-after'] = posX == 'after';
	        this._classList['mat-menu-above'] = posY == 'above';
	        this._classList['mat-menu-below'] = posY == 'below';
	    };
	    __decorate$68([
	        _angular_core.ViewChild(_angular_core.TemplateRef), 
	        __metadata$68('design:type', _angular_core.TemplateRef)
	    ], MdMenu.prototype, "templateRef", void 0);
	    __decorate$68([
	        _angular_core.ContentChildren(MdMenuItem), 
	        __metadata$68('design:type', _angular_core.QueryList)
	    ], MdMenu.prototype, "items", void 0);
	    __decorate$68([
	        _angular_core.Input(), 
	        __metadata$68('design:type', Object)
	    ], MdMenu.prototype, "overlapTrigger", void 0);
	    __decorate$68([
	        _angular_core.Input('class'), 
	        __metadata$68('design:type', String), 
	        __metadata$68('design:paramtypes', [String])
	    ], MdMenu.prototype, "classList", null);
	    __decorate$68([
	        _angular_core.Output(), 
	        __metadata$68('design:type', Object)
	    ], MdMenu.prototype, "close", void 0);
	    MdMenu = __decorate$68([
	        _angular_core.Component({selector: 'md-menu, mat-menu',
	            host: { 'role': 'menu' },
	            template: "<template><div class=\"mat-menu-panel\" [ngClass]=\"_classList\" (keydown)=\"_keyManager.onKeydown($event)\" (click)=\"_emitCloseEvent()\" [@transformMenu]=\"'showing'\"><div class=\"mat-menu-content\" [@fadeInItems]=\"'showing'\"><ng-content></ng-content></div></div></template>",
	            styles: [".mat-menu-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh + 48px)}.mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:left top}.mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:left bottom}.mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:right top}.mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:right top}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:left top}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:left bottom}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content{padding-top:8px;padding-bottom:8px}.mat-menu-item{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;font-size:16px;font-family:Roboto,\"Helvetica Neue\",sans-serif;text-align:start;text-decoration:none;position:relative}.mat-menu-item[disabled]{cursor:default}.mat-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px}button.mat-menu-item{width:100%}.mat-menu-ripple{position:absolute;top:0;left:0;bottom:0;right:0}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            animations: [
	                transformMenu,
	                fadeInItems
	            ],
	            exportAs: 'mdMenu'
	        }),
	        __param$15(0, _angular_core.Attribute('x-position')),
	        __param$15(1, _angular_core.Attribute('y-position')), 
	        __metadata$68('design:paramtypes', [String, String])
	    ], MdMenu);
	    return MdMenu;
	}());
	
	var __decorate$70 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$70 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$16 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * This directive is intended to be used in conjunction with an md-menu tag.  It is
	 * responsible for toggling the display of the provided menu instance.
	 * TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors
	 */
	var MdMenuTrigger = (function () {
	    function MdMenuTrigger(_overlay, _element, _viewContainerRef, _renderer, _dir) {
	        this._overlay = _overlay;
	        this._element = _element;
	        this._viewContainerRef = _viewContainerRef;
	        this._renderer = _renderer;
	        this._dir = _dir;
	        this._menuOpen = false;
	        // tracking input type is necessary so it's possible to only auto-focus
	        // the first item of the list when the menu is opened via the keyboard
	        this._openedByMouse = false;
	        /** Event emitted when the associated menu is opened. */
	        this.onMenuOpen = new _angular_core.EventEmitter();
	        /** Event emitted when the associated menu is closed. */
	        this.onMenuClose = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(MdMenuTrigger.prototype, "_deprecatedMdMenuTriggerFor", {
	        /** @deprecated */
	        get: function () { return this.menu; },
	        set: function (v) { this.menu = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", {
	        /** @deprecated */
	        get: function () { return this.menu; },
	        set: function (v) { this.menu = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuTrigger.prototype, "_matMenuTriggerFor", {
	        // Trigger input for compatibility mode
	        get: function () { return this.menu; },
	        set: function (v) { this.menu = v; },
	        enumerable: true,
	        configurable: true
	    });
	    MdMenuTrigger.prototype.ngAfterViewInit = function () {
	        var _this = this;
	        this._checkMenu();
	        this.menu.close.subscribe(function () { return _this.closeMenu(); });
	    };
	    MdMenuTrigger.prototype.ngOnDestroy = function () { this.destroyMenu(); };
	    Object.defineProperty(MdMenuTrigger.prototype, "menuOpen", {
	        /** Whether the menu is open. */
	        get: function () { return this._menuOpen; },
	        enumerable: true,
	        configurable: true
	    });
	    /** Toggles the menu between the open and closed states. */
	    MdMenuTrigger.prototype.toggleMenu = function () {
	        return this._menuOpen ? this.closeMenu() : this.openMenu();
	    };
	    /** Opens the menu. */
	    MdMenuTrigger.prototype.openMenu = function () {
	        if (!this._menuOpen) {
	            this._createOverlay();
	            this._overlayRef.attach(this._portal);
	            this._subscribeToBackdrop();
	            this._initMenu();
	        }
	    };
	    /** Closes the menu. */
	    MdMenuTrigger.prototype.closeMenu = function () {
	        if (this._overlayRef) {
	            this._overlayRef.detach();
	            this._backdropSubscription.unsubscribe();
	            this._resetMenu();
	        }
	    };
	    /** Removes the menu from the DOM. */
	    MdMenuTrigger.prototype.destroyMenu = function () {
	        if (this._overlayRef) {
	            this._overlayRef.dispose();
	            this._overlayRef = null;
	            this._cleanUpSubscriptions();
	        }
	    };
	    /** Focuses the menu trigger. */
	    MdMenuTrigger.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._element.nativeElement, 'focus');
	    };
	    Object.defineProperty(MdMenuTrigger.prototype, "dir", {
	        /** The text direction of the containing app. */
	        get: function () {
	            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * This method ensures that the menu closes when the overlay backdrop is clicked.
	     * We do not use first() here because doing so would not catch clicks from within
	     * the menu, and it would fail to unsubscribe properly. Instead, we unsubscribe
	     * explicitly when the menu is closed or destroyed.
	     */
	    MdMenuTrigger.prototype._subscribeToBackdrop = function () {
	        var _this = this;
	        this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
	            _this.closeMenu();
	        });
	    };
	    /**
	     * This method sets the menu state to open and focuses the first item if
	     * the menu was opened via the keyboard.
	     */
	    MdMenuTrigger.prototype._initMenu = function () {
	        this._setIsMenuOpen(true);
	        // Should only set focus if opened via the keyboard, so keyboard users can
	        // can easily navigate menu items. According to spec, mouse users should not
	        // see the focus style.
	        if (!this._openedByMouse) {
	            this.menu.focusFirstItem();
	        }
	    };
	    
	    /**
	     * This method resets the menu when it's closed, most importantly restoring
	     * focus to the menu trigger if the menu was opened via the keyboard.
	     */
	    MdMenuTrigger.prototype._resetMenu = function () {
	        this._setIsMenuOpen(false);
	        // Focus only needs to be reset to the host element if the menu was opened
	        // by the keyboard and manually shifted to the first menu item.
	        if (!this._openedByMouse) {
	            this.focus();
	        }
	        this._openedByMouse = false;
	    };
	    // set state rather than toggle to support triggers sharing a menu
	    MdMenuTrigger.prototype._setIsMenuOpen = function (isOpen) {
	        this._menuOpen = isOpen;
	        this._menuOpen ? this.onMenuOpen.emit() : this.onMenuClose.emit();
	    };
	    /**
	     *  This method checks that a valid instance of MdMenu has been passed into
	     *  mdMenuTriggerFor. If not, an exception is thrown.
	     */
	    MdMenuTrigger.prototype._checkMenu = function () {
	        if (!this.menu) {
	            throw new MdMenuMissingError();
	        }
	    };
	    /**
	     *  This method creates the overlay from the provided menu's template and saves its
	     *  OverlayRef so that it can be attached to the DOM when openMenu is called.
	     */
	    MdMenuTrigger.prototype._createOverlay = function () {
	        if (!this._overlayRef) {
	            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);
	            var config = this._getOverlayConfig();
	            this._subscribeToPositions(config.positionStrategy);
	            this._overlayRef = this._overlay.create(config);
	        }
	    };
	    /**
	     * This method builds the configuration object needed to create the overlay, the OverlayState.
	     * @returns OverlayState
	     */
	    MdMenuTrigger.prototype._getOverlayConfig = function () {
	        var overlayState = new OverlayState();
	        overlayState.positionStrategy = this._getPosition()
	            .withDirection(this.dir);
	        overlayState.hasBackdrop = true;
	        overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
	        overlayState.direction = this.dir;
	        return overlayState;
	    };
	    /**
	     * Listens to changes in the position of the overlay and sets the correct classes
	     * on the menu based on the new position. This ensures the animation origin is always
	     * correct, even if a fallback position is used for the overlay.
	     */
	    MdMenuTrigger.prototype._subscribeToPositions = function (position) {
	        var _this = this;
	        this._positionSubscription = position.onPositionChange.subscribe(function (change) {
	            var posX = change.connectionPair.originX === 'start' ? 'after' : 'before';
	            var posY = change.connectionPair.originY === 'top' ? 'below' : 'above';
	            if (!_this.menu.overlapTrigger) {
	                posY = posY === 'below' ? 'above' : 'below';
	            }
	            _this.menu.setPositionClasses(posX, posY);
	        });
	    };
	    /**
	     * This method builds the position strategy for the overlay, so the menu is properly connected
	     * to the trigger.
	     * @returns ConnectedPositionStrategy
	     */
	    MdMenuTrigger.prototype._getPosition = function () {
	        var _a = this.menu.positionX === 'before' ? ['end', 'start'] : ['start', 'end'], posX = _a[0], fallbackX = _a[1];
	        var _b = this.menu.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], overlayY = _b[0], fallbackOverlayY = _b[1];
	        var originY = overlayY;
	        var fallbackOriginY = fallbackOverlayY;
	        if (!this.menu.overlapTrigger) {
	            originY = overlayY === 'top' ? 'bottom' : 'top';
	            fallbackOriginY = fallbackOverlayY === 'top' ? 'bottom' : 'top';
	        }
	        return this._overlay.position()
	            .connectedTo(this._element, { originX: posX, originY: originY }, { overlayX: posX, overlayY: overlayY })
	            .withFallbackPosition({ originX: fallbackX, originY: originY }, { overlayX: fallbackX, overlayY: overlayY })
	            .withFallbackPosition({ originX: posX, originY: fallbackOriginY }, { overlayX: posX, overlayY: fallbackOverlayY })
	            .withFallbackPosition({ originX: fallbackX, originY: fallbackOriginY }, { overlayX: fallbackX, overlayY: fallbackOverlayY });
	    };
	    MdMenuTrigger.prototype._cleanUpSubscriptions = function () {
	        if (this._backdropSubscription) {
	            this._backdropSubscription.unsubscribe();
	        }
	        if (this._positionSubscription) {
	            this._positionSubscription.unsubscribe();
	        }
	    };
	    MdMenuTrigger.prototype._handleMousedown = function (event) {
	        if (!isFakeMousedownFromScreenReader(event)) {
	            this._openedByMouse = true;
	        }
	    };
	    __decorate$70([
	        _angular_core.Input('md-menu-trigger-for'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "_deprecatedMdMenuTriggerFor", null);
	    __decorate$70([
	        _angular_core.Input('mat-menu-trigger-for'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", null);
	    __decorate$70([
	        _angular_core.Input('matMenuTriggerFor'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "_matMenuTriggerFor", null);
	    __decorate$70([
	        _angular_core.Input('mdMenuTriggerFor'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "menu", void 0);
	    __decorate$70([
	        _angular_core.Output(), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "onMenuOpen", void 0);
	    __decorate$70([
	        _angular_core.Output(), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "onMenuClose", void 0);
	    MdMenuTrigger = __decorate$70([
	        _angular_core.Directive({
	            selector: "[md-menu-trigger-for], [mat-menu-trigger-for], \n             [mdMenuTriggerFor], [matMenuTriggerFor]",
	            host: {
	                'aria-haspopup': 'true',
	                '(mousedown)': '_handleMousedown($event)',
	                '(click)': 'toggleMenu()',
	            },
	            exportAs: 'mdMenuTrigger'
	        }),
	        __param$16(4, _angular_core.Optional()), 
	        __metadata$70('design:paramtypes', [Overlay, _angular_core.ElementRef, _angular_core.ViewContainerRef, _angular_core.Renderer, Dir])
	    ], MdMenuTrigger);
	    return MdMenuTrigger;
	}());
	
	var __decorate$67 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$67 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdMenuModule = (function () {
	    function MdMenuModule() {
	    }
	    /** @deprecated */
	    MdMenuModule.forRoot = function () {
	        return {
	            ngModule: MdMenuModule,
	            providers: [],
	        };
	    };
	    MdMenuModule = __decorate$67([
	        _angular_core.NgModule({
	            imports: [OverlayModule, _angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [MdMenu, MdMenuItem, MdMenuTrigger, CompatibilityModule],
	            declarations: [MdMenu, MdMenuItem, MdMenuTrigger],
	        }), 
	        __metadata$67('design:paramtypes', [])
	    ], MdMenuModule);
	    return MdMenuModule;
	}());
	
	// TODO(jelbourn): resizing
	// TODO(jelbourn): afterOpen and beforeClose
	/**
	 * Reference to a dialog opened via the MdDialog service.
	 */
	var MdDialogRef = (function () {
	    function MdDialogRef(_overlayRef, config) {
	        this._overlayRef = _overlayRef;
	        this.config = config;
	        /** Subject for notifying the user that the dialog has finished closing. */
	        this._afterClosed = new rxjs_Subject.Subject();
	    }
	    /**
	     * Close the dialog.
	     * @param dialogResult Optional result to return to the dialog opener.
	     */
	    MdDialogRef.prototype.close = function (dialogResult) {
	        this._overlayRef.dispose();
	        this._afterClosed.next(dialogResult);
	        this._afterClosed.complete();
	    };
	    /**
	     * Gets an observable that is notified when the dialog is finished closing.
	     */
	    MdDialogRef.prototype.afterClosed = function () {
	        return this._afterClosed.asObservable();
	    };
	    return MdDialogRef;
	}());
	
	var MD_DIALOG_DATA = new _angular_core.OpaqueToken('MdDialogData');
	/** Custom injector type specifically for instantiating components with a dialog. */
	var DialogInjector = (function () {
	    function DialogInjector(_parentInjector, _dialogRef, _data) {
	        this._parentInjector = _parentInjector;
	        this._dialogRef = _dialogRef;
	        this._data = _data;
	    }
	    DialogInjector.prototype.get = function (token, notFoundValue) {
	        if (token === MdDialogRef) {
	            return this._dialogRef;
	        }
	        if (token === MD_DIALOG_DATA && this._data) {
	            return this._data;
	        }
	        return this._parentInjector.get(token, notFoundValue);
	    };
	    return DialogInjector;
	}());
	
	/**
	 * Configuration for opening a modal dialog with the MdDialog service.
	 */
	var MdDialogConfig = (function () {
	    function MdDialogConfig() {
	        /** The ARIA role of the dialog element. */
	        this.role = 'dialog';
	        /** Whether the user can use escape or clicking outside to close a modal. */
	        this.disableClose = false;
	        /** Width of the dialog. */
	        this.width = '';
	        /** Height of the dialog. */
	        this.height = '';
	    }
	    return MdDialogConfig;
	}());
	
	var __extends$23 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when a ComponentPortal is attached to a DomPortalHost without an origin.
	 * @docs-private
	 */
	var MdDialogContentAlreadyAttachedError = (function (_super) {
	    __extends$23(MdDialogContentAlreadyAttachedError, _super);
	    function MdDialogContentAlreadyAttachedError() {
	        _super.call(this, 'Attempting to attach dialog content after content is already attached');
	    }
	    return MdDialogContentAlreadyAttachedError;
	}(MdError));
	
	var __extends$22 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$73 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$73 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Internal component that wraps user-provided dialog content.
	 * @docs-private
	 */
	var MdDialogContainer = (function (_super) {
	    __extends$22(MdDialogContainer, _super);
	    function MdDialogContainer(_ngZone, _renderer) {
	        _super.call(this);
	        this._ngZone = _ngZone;
	        this._renderer = _renderer;
	        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
	        this._elementFocusedBeforeDialogWasOpened = null;
	    }
	    /**
	     * Attach a ComponentPortal as content to this dialog container.
	     * @param portal Portal to be attached as the dialog content.
	     */
	    MdDialogContainer.prototype.attachComponentPortal = function (portal) {
	        if (this._portalHost.hasAttached()) {
	            throw new MdDialogContentAlreadyAttachedError();
	        }
	        var attachResult = this._portalHost.attachComponentPortal(portal);
	        this._trapFocus();
	        return attachResult;
	    };
	    /**
	     * Attach a TemplatePortal as content to this dialog container.
	     * @param portal Portal to be attached as the dialog content.
	     */
	    MdDialogContainer.prototype.attachTemplatePortal = function (portal) {
	        if (this._portalHost.hasAttached()) {
	            throw new MdDialogContentAlreadyAttachedError();
	        }
	        var attachedResult = this._portalHost.attachTemplatePortal(portal);
	        this._trapFocus();
	        return attachedResult;
	    };
	    /**
	     * Moves the focus inside the focus trap.
	     * @private
	     */
	    MdDialogContainer.prototype._trapFocus = function () {
	        var _this = this;
	        // If were to attempt to focus immediately, then the content of the dialog would not yet be
	        // ready in instances where change detection has to run first. To deal with this, we simply
	        // wait for the microtask queue to be empty.
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this._elementFocusedBeforeDialogWasOpened = document.activeElement;
	            _this._focusTrap.focusFirstTabbableElement();
	        });
	    };
	    MdDialogContainer.prototype.ngOnDestroy = function () {
	        var _this = this;
	        // When the dialog is destroyed, return focus to the element that originally had it before
	        // the dialog was opened. Wait for the DOM to finish settling before changing the focus so
	        // that it doesn't end up back on the <body>. Also note that we need the extra check, because
	        // IE can set the `activeElement` to null in some cases.
	        if (this._elementFocusedBeforeDialogWasOpened) {
	            this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	                _this._renderer.invokeElementMethod(_this._elementFocusedBeforeDialogWasOpened, 'focus');
	            });
	        }
	    };
	    __decorate$73([
	        _angular_core.ViewChild(PortalHostDirective), 
	        __metadata$73('design:type', PortalHostDirective)
	    ], MdDialogContainer.prototype, "_portalHost", void 0);
	    __decorate$73([
	        _angular_core.ViewChild(FocusTrap), 
	        __metadata$73('design:type', FocusTrap)
	    ], MdDialogContainer.prototype, "_focusTrap", void 0);
	    MdDialogContainer = __decorate$73([
	        _angular_core.Component({selector: 'md-dialog-container, mat-dialog-container',
	            template: "<cdk-focus-trap><template cdkPortalHost></template></cdk-focus-trap>",
	            styles: [".mat-dialog-container{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:block;padding:24px;border-radius:2px;box-sizing:border-box;overflow:auto;max-width:80vw;width:100%;height:100%}@media screen and (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto}.mat-dialog-title{font-size:20px;font-weight:700;margin:0 0 20px;display:block}.mat-dialog-actions{padding:12px 0;display:flex}.mat-dialog-actions:last-child{margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}"],
	            host: {
	                '[class.mat-dialog-container]': 'true',
	                '[attr.role]': 'dialogConfig?.role',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$73('design:paramtypes', [_angular_core.NgZone, _angular_core.Renderer])
	    ], MdDialogContainer);
	    return MdDialogContainer;
	}(BasePortalHost));
	
	var __decorate$72 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$72 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$17 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	// TODO(jelbourn): animations
	/**
	 * Service to open Material Design modal dialogs.
	 */
	var MdDialog = (function () {
	    function MdDialog(_overlay, _injector, _parentDialog) {
	        this._overlay = _overlay;
	        this._injector = _injector;
	        this._parentDialog = _parentDialog;
	        this._openDialogsAtThisLevel = [];
	        this._afterAllClosedAtThisLevel = new rxjs_Subject.Subject();
	        this._afterOpenAtThisLevel = new rxjs_Subject.Subject();
	        this._boundKeydown = this._handleKeydown.bind(this);
	        /** Gets an observable that is notified when a dialog has been opened. */
	        this.afterOpen = this._afterOpen.asObservable();
	        /** Gets an observable that is notified when all open dialog have finished closing. */
	        this.afterAllClosed = this._afterAllClosed.asObservable();
	    }
	    Object.defineProperty(MdDialog.prototype, "_openDialogs", {
	        /** Keeps track of the currently-open dialogs. */
	        get: function () {
	            return this._parentDialog ? this._parentDialog._openDialogs : this._openDialogsAtThisLevel;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdDialog.prototype, "_afterOpen", {
	        /** Subject for notifying the user that all open dialogs have finished closing. */
	        get: function () {
	            return this._parentDialog ? this._parentDialog._afterOpen : this._afterOpenAtThisLevel;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdDialog.prototype, "_afterAllClosed", {
	        /** Subject for notifying the user that a dialog has opened. */
	        get: function () {
	            return this._parentDialog ?
	                this._parentDialog._afterAllClosed : this._afterAllClosedAtThisLevel;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Opens a modal dialog containing the given component.
	     * @param componentOrTemplateRef Type of the component to load into the dialog,
	     *     or a TemplateRef to instantiate as the dialog content.
	     * @param config Extra configuration options.
	     * @returns Reference to the newly-opened dialog.
	     */
	    MdDialog.prototype.open = function (componentOrTemplateRef, config) {
	        var _this = this;
	        config = _applyConfigDefaults$1(config);
	        var overlayRef = this._createOverlay(config);
	        var dialogContainer = this._attachDialogContainer(overlayRef, config);
	        var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
	        if (!this._openDialogs.length && !this._parentDialog) {
	            document.addEventListener('keydown', this._boundKeydown);
	        }
	        this._openDialogs.push(dialogRef);
	        dialogRef.afterClosed().subscribe(function () { return _this._removeOpenDialog(dialogRef); });
	        this._afterOpen.next(dialogRef);
	        return dialogRef;
	    };
	    /**
	     * Closes all of the currently-open dialogs.
	     */
	    MdDialog.prototype.closeAll = function () {
	        var i = this._openDialogs.length;
	        while (i--) {
	            // The `_openDialogs` property isn't updated after close until the rxjs subscription
	            // runs on the next microtask, in addition to modifying the array as we're going
	            // through it. We loop through all of them and call close without assuming that
	            // they'll be removed from the list instantaneously.
	            this._openDialogs[i].close();
	        }
	    };
	    /**
	     * Creates the overlay into which the dialog will be loaded.
	     * @param dialogConfig The dialog configuration.
	     * @returns A promise resolving to the OverlayRef for the created overlay.
	     */
	    MdDialog.prototype._createOverlay = function (dialogConfig) {
	        var overlayState = this._getOverlayState(dialogConfig);
	        return this._overlay.create(overlayState);
	    };
	    /**
	     * Attaches an MdDialogContainer to a dialog's already-created overlay.
	     * @param overlay Reference to the dialog's underlying overlay.
	     * @param config The dialog configuration.
	     * @returns A promise resolving to a ComponentRef for the attached container.
	     */
	    MdDialog.prototype._attachDialogContainer = function (overlay, config) {
	        var viewContainer = config ? config.viewContainerRef : null;
	        var containerPortal = new ComponentPortal(MdDialogContainer, viewContainer);
	        var containerRef = overlay.attach(containerPortal);
	        containerRef.instance.dialogConfig = config;
	        return containerRef.instance;
	    };
	    /**
	     * Attaches the user-provided component to the already-created MdDialogContainer.
	     * @param componentOrTemplateRef The type of component being loaded into the dialog,
	     *     or a TemplateRef to instantiate as the content.
	     * @param dialogContainer Reference to the wrapping MdDialogContainer.
	     * @param overlayRef Reference to the overlay in which the dialog resides.
	     * @param config The dialog configuration.
	     * @returns A promise resolving to the MdDialogRef that should be returned to the user.
	     */
	    MdDialog.prototype._attachDialogContent = function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
	        // Create a reference to the dialog we're creating in order to give the user a handle
	        // to modify and close it.
	        var dialogRef = new MdDialogRef(overlayRef, config);
	        if (!config.disableClose) {
	            // When the dialog backdrop is clicked, we want to close it.
	            overlayRef.backdropClick().first().subscribe(function () { return dialogRef.close(); });
	        }
	        // Set the dialogRef to the container so that it can use the ref to close the dialog.
	        dialogContainer.dialogRef = dialogRef;
	        // We create an injector specifically for the component we're instantiating so that it can
	        // inject the MdDialogRef. This allows a component loaded inside of a dialog to close itself
	        // and, optionally, to return a value.
	        var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
	        var dialogInjector = new DialogInjector(userInjector || this._injector, dialogRef, config.data);
	        if (componentOrTemplateRef instanceof _angular_core.TemplateRef) {
	            dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null));
	        }
	        else {
	            var contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, null, dialogInjector));
	            dialogRef.componentInstance = contentRef.instance;
	        }
	        return dialogRef;
	    };
	    /**
	     * Creates an overlay state from a dialog config.
	     * @param dialogConfig The dialog configuration.
	     * @returns The overlay configuration.
	     */
	    MdDialog.prototype._getOverlayState = function (dialogConfig) {
	        var state$$1 = new OverlayState();
	        var strategy = this._overlay.position().global();
	        var position = dialogConfig.position;
	        state$$1.hasBackdrop = true;
	        state$$1.positionStrategy = strategy;
	        if (position && (position.left || position.right)) {
	            position.left ? strategy.left(position.left) : strategy.right(position.right);
	        }
	        else {
	            strategy.centerHorizontally();
	        }
	        if (position && (position.top || position.bottom)) {
	            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
	        }
	        else {
	            strategy.centerVertically();
	        }
	        strategy.width(dialogConfig.width).height(dialogConfig.height);
	        return state$$1;
	    };
	    /**
	     * Removes a dialog from the array of open dialogs.
	     * @param dialogRef Dialog to be removed.
	     */
	    MdDialog.prototype._removeOpenDialog = function (dialogRef) {
	        var index = this._openDialogs.indexOf(dialogRef);
	        if (index > -1) {
	            this._openDialogs.splice(index, 1);
	            // no open dialogs are left, call next on afterAllClosed Subject
	            if (!this._openDialogs.length) {
	                this._afterAllClosed.next();
	                document.removeEventListener('keydown', this._boundKeydown);
	            }
	        }
	    };
	    /**
	     * Handles global key presses while there are open dialogs. Closes the
	     * top dialog when the user presses escape.
	     */
	    MdDialog.prototype._handleKeydown = function (event) {
	        var topDialog = this._openDialogs[this._openDialogs.length - 1];
	        if (event.keyCode === ESCAPE && topDialog && !topDialog.config.disableClose) {
	            topDialog.close();
	        }
	    };
	    MdDialog = __decorate$72([
	        _angular_core.Injectable(),
	        __param$17(2, _angular_core.Optional()),
	        __param$17(2, _angular_core.SkipSelf()), 
	        __metadata$72('design:paramtypes', [Overlay, _angular_core.Injector, MdDialog])
	    ], MdDialog);
	    return MdDialog;
	}());
	/**
	 * Applies default options to the dialog config.
	 * @param dialogConfig Config to be modified.
	 * @returns The new configuration object.
	 */
	function _applyConfigDefaults$1(dialogConfig) {
	    return extendObject(new MdDialogConfig(), dialogConfig);
	}
	
	var __decorate$74 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$74 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Button that will close the current dialog.
	 */
	var MdDialogClose = (function () {
	    function MdDialogClose(dialogRef) {
	        this.dialogRef = dialogRef;
	        /** Screenreader label for the button. */
	        this.ariaLabel = 'Close dialog';
	    }
	    __decorate$74([
	        _angular_core.Input('aria-label'), 
	        __metadata$74('design:type', String)
	    ], MdDialogClose.prototype, "ariaLabel", void 0);
	    MdDialogClose = __decorate$74([
	        _angular_core.Directive({
	            selector: 'button[md-dialog-close], button[mat-dialog-close]',
	            host: {
	                '(click)': 'dialogRef.close()',
	                '[attr.aria-label]': 'ariaLabel',
	                'type': 'button',
	            }
	        }), 
	        __metadata$74('design:paramtypes', [MdDialogRef])
	    ], MdDialogClose);
	    return MdDialogClose;
	}());
	/**
	 * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
	 */
	var MdDialogTitle = (function () {
	    function MdDialogTitle() {
	    }
	    MdDialogTitle = __decorate$74([
	        _angular_core.Directive({
	            selector: '[md-dialog-title], [mat-dialog-title]',
	            host: {
	                '[class.mat-dialog-title]': 'true'
	            }
	        }), 
	        __metadata$74('design:paramtypes', [])
	    ], MdDialogTitle);
	    return MdDialogTitle;
	}());
	/**
	 * Scrollable content container of a dialog.
	 */
	var MdDialogContent = (function () {
	    function MdDialogContent() {
	    }
	    MdDialogContent = __decorate$74([
	        _angular_core.Directive({
	            selector: '[md-dialog-content], md-dialog-content, [mat-dialog-content], mat-dialog-content',
	            host: {
	                '[class.mat-dialog-content]': 'true'
	            }
	        }), 
	        __metadata$74('design:paramtypes', [])
	    ], MdDialogContent);
	    return MdDialogContent;
	}());
	/**
	 * Container for the bottom action buttons in a dialog.
	 * Stays fixed to the bottom when scrolling.
	 */
	var MdDialogActions = (function () {
	    function MdDialogActions() {
	    }
	    MdDialogActions = __decorate$74([
	        _angular_core.Directive({
	            selector: '[md-dialog-actions], md-dialog-actions, [mat-dialog-actions], mat-dialog-actions',
	            host: {
	                '[class.mat-dialog-actions]': 'true'
	            }
	        }), 
	        __metadata$74('design:paramtypes', [])
	    ], MdDialogActions);
	    return MdDialogActions;
	}());
	
	var __decorate$71 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$71 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdDialogModule = (function () {
	    function MdDialogModule() {
	    }
	    /** @deprecated */
	    MdDialogModule.forRoot = function () {
	        return {
	            ngModule: MdDialogModule,
	            providers: [],
	        };
	    };
	    MdDialogModule = __decorate$71([
	        _angular_core.NgModule({
	            imports: [
	                OverlayModule,
	                PortalModule,
	                A11yModule,
	                CompatibilityModule,
	            ],
	            exports: [
	                MdDialogContainer,
	                MdDialogClose,
	                MdDialogTitle,
	                MdDialogContent,
	                MdDialogActions,
	                CompatibilityModule,
	            ],
	            declarations: [
	                MdDialogContainer,
	                MdDialogClose,
	                MdDialogTitle,
	                MdDialogActions,
	                MdDialogContent,
	            ],
	            providers: [
	                MdDialog,
	            ],
	            entryComponents: [MdDialogContainer],
	        }), 
	        __metadata$71('design:paramtypes', [])
	    ], MdDialogModule);
	    return MdDialogModule;
	}());
	
	var __decorate$76 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$76 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Autocomplete IDs need to be unique across components, so this counter exists outside of
	 * the component definition.
	 */
	var _uniqueAutocompleteIdCounter = 0;
	var MdAutocomplete = (function () {
	    function MdAutocomplete() {
	        /** Whether the autocomplete panel displays above or below its trigger. */
	        this.positionY = 'below';
	        /** Whether the autocomplete panel should be visible, depending on option length. */
	        this.showPanel = false;
	        /** Unique ID to be used by autocomplete trigger's "aria-owns" property. */
	        this.id = "md-autocomplete-" + _uniqueAutocompleteIdCounter++;
	    }
	    /**
	     * Sets the panel scrollTop. This allows us to manually scroll to display
	     * options below the fold, as they are not actually being focused when active.
	     */
	    MdAutocomplete.prototype._setScrollTop = function (scrollTop) {
	        if (this.panel) {
	            this.panel.nativeElement.scrollTop = scrollTop;
	        }
	    };
	    /** Panel should hide itself when the option list is empty. */
	    MdAutocomplete.prototype._setVisibility = function () {
	        var _this = this;
	        Promise.resolve().then(function () { return _this.showPanel = !!_this.options.length; });
	    };
	    /** Sets a class on the panel based on its position (used to set y-offset). */
	    MdAutocomplete.prototype._getClassList = function () {
	        return {
	            'mat-autocomplete-panel-below': this.positionY === 'below',
	            'mat-autocomplete-panel-above': this.positionY === 'above',
	            'mat-autocomplete-visible': this.showPanel,
	            'mat-autocomplete-hidden': !this.showPanel
	        };
	    };
	    __decorate$76([
	        _angular_core.ViewChild(_angular_core.TemplateRef), 
	        __metadata$76('design:type', _angular_core.TemplateRef)
	    ], MdAutocomplete.prototype, "template", void 0);
	    __decorate$76([
	        _angular_core.ViewChild('panel'), 
	        __metadata$76('design:type', _angular_core.ElementRef)
	    ], MdAutocomplete.prototype, "panel", void 0);
	    __decorate$76([
	        _angular_core.ContentChildren(MdOption), 
	        __metadata$76('design:type', _angular_core.QueryList)
	    ], MdAutocomplete.prototype, "options", void 0);
	    __decorate$76([
	        _angular_core.Input(), 
	        __metadata$76('design:type', Function)
	    ], MdAutocomplete.prototype, "displayWith", void 0);
	    MdAutocomplete = __decorate$76([
	        _angular_core.Component({selector: 'md-autocomplete, mat-autocomplete',
	            template: "<template><div class=\"mat-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_getClassList()\" #panel><ng-content></ng-content></div></template>",
	            styles: [".mat-autocomplete-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-height:256px;position:relative}.mat-autocomplete-panel.mat-autocomplete-panel-below{top:6px}.mat-autocomplete-panel.mat-autocomplete-panel-above{top:-24px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            exportAs: 'mdAutocomplete',
	            host: {
	                '[class.mat-autocomplete]': 'true'
	            }
	        }), 
	        __metadata$76('design:paramtypes', [])
	    ], MdAutocomplete);
	    return MdAutocomplete;
	}());
	
	var __extends$24 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ActiveDescendantKeyManager = (function (_super) {
	    __extends$24(ActiveDescendantKeyManager, _super);
	    function ActiveDescendantKeyManager(items) {
	        _super.call(this, items);
	    }
	    /**
	     * This method sets the active item to the item at the specified index.
	     * It also adds active styles to the newly active item and removes active
	     * styles from the previously active item.
	     */
	    ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {
	        if (this.activeItem) {
	            this.activeItem.setInactiveStyles();
	        }
	        _super.prototype.setActiveItem.call(this, index);
	        if (this.activeItem) {
	            this.activeItem.setActiveStyles();
	        }
	    };
	    return ActiveDescendantKeyManager;
	}(ListKeyManager));
	
	var __decorate$77 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$77 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$18 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * The following style constants are necessary to save here in order
	 * to properly calculate the scrollTop of the panel. Because we are not
	 * actually focusing the active item, scroll must be handled manually.
	 */
	/** The height of each autocomplete option. */
	var AUTOCOMPLETE_OPTION_HEIGHT = 48;
	/** The total height of the autocomplete panel. */
	var AUTOCOMPLETE_PANEL_HEIGHT = 256;
	/**
	 * Provider that allows the autocomplete to register as a ControlValueAccessor.
	 * @docs-private
	 */
	var MD_AUTOCOMPLETE_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdAutocompleteTrigger; }),
	    multi: true
	};
	var MdAutocompleteTrigger = (function () {
	    function MdAutocompleteTrigger(_element, _overlay, _viewContainerRef, _dir, _zone, _inputContainer) {
	        this._element = _element;
	        this._overlay = _overlay;
	        this._viewContainerRef = _viewContainerRef;
	        this._dir = _dir;
	        this._zone = _zone;
	        this._inputContainer = _inputContainer;
	        this._panelOpen = false;
	        /** Stream of blur events that should close the panel. */
	        this._blurStream = new rxjs_Subject.Subject();
	        /** View -> model callback called when value changes */
	        this._onChange = function (value) { };
	        /** View -> model callback called when autocomplete has been touched */
	        this._onTouched = function () { };
	    }
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "_matAutocomplete", {
	        /** Property with mat- prefix for no-conflict mode. */
	        get: function () {
	            return this.autocomplete;
	        },
	        set: function (autocomplete) {
	            this.autocomplete = autocomplete;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdAutocompleteTrigger.prototype.ngAfterContentInit = function () {
	        this._keyManager = new ActiveDescendantKeyManager(this.autocomplete.options).withWrap();
	    };
	    MdAutocompleteTrigger.prototype.ngOnDestroy = function () {
	        if (this._panelPositionSubscription) {
	            this._panelPositionSubscription.unsubscribe();
	        }
	        this._destroyPanel();
	    };
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "panelOpen", {
	        /* Whether or not the autocomplete panel is open. */
	        get: function () {
	            return this._panelOpen;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Opens the autocomplete suggestion panel. */
	    MdAutocompleteTrigger.prototype.openPanel = function () {
	        if (!this._overlayRef) {
	            this._createOverlay();
	        }
	        if (!this._overlayRef.hasAttached()) {
	            this._overlayRef.attach(this._portal);
	            this._subscribeToClosingActions();
	        }
	        this._panelOpen = true;
	        this._floatPlaceholder('always');
	    };
	    /** Closes the autocomplete suggestion panel. */
	    MdAutocompleteTrigger.prototype.closePanel = function () {
	        if (this._overlayRef && this._overlayRef.hasAttached()) {
	            this._overlayRef.detach();
	        }
	        this._panelOpen = false;
	        this._floatPlaceholder('auto');
	    };
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "panelClosingActions", {
	        /**
	         * A stream of actions that should close the autocomplete panel, including
	         * when an option is selected, on blur, and when TAB is pressed.
	         */
	        get: function () {
	            return rxjs_Observable.Observable.merge.apply(rxjs_Observable.Observable, this.optionSelections.concat([this._blurStream.asObservable(), this._keyManager.tabOut]));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "optionSelections", {
	        /** Stream of autocomplete option selections. */
	        get: function () {
	            return this.autocomplete.options.map(function (option) { return option.onSelect; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "activeOption", {
	        /** The currently active option, coerced to MdOption type. */
	        get: function () {
	            return this._keyManager.activeItem;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the autocomplete's value. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param value New value to be written to the model.
	     */
	    MdAutocompleteTrigger.prototype.writeValue = function (value) {
	        var _this = this;
	        Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });
	    };
	    /**
	     * Saves a callback function to be invoked when the autocomplete's value
	     * changes from user input. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the value changes.
	     */
	    MdAutocompleteTrigger.prototype.registerOnChange = function (fn) {
	        this._onChange = fn;
	    };
	    /**
	     * Saves a callback function to be invoked when the autocomplete is blurred
	     * by the user. Part of the ControlValueAccessor interface required
	     * to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the component has been touched.
	     */
	    MdAutocompleteTrigger.prototype.registerOnTouched = function (fn) {
	        this._onTouched = fn;
	    };
	    MdAutocompleteTrigger.prototype._handleKeydown = function (event) {
	        if (this.activeOption && event.keyCode === ENTER) {
	            this.activeOption._selectViaInteraction();
	        }
	        else {
	            this._keyManager.onKeydown(event);
	            if (event.keyCode === UP_ARROW || event.keyCode === DOWN_ARROW) {
	                this.openPanel();
	                this._scrollToOption();
	            }
	        }
	    };
	    MdAutocompleteTrigger.prototype._handleInput = function (value) {
	        this._onChange(value);
	        this.openPanel();
	    };
	    MdAutocompleteTrigger.prototype._handleBlur = function (newlyFocusedTag) {
	        this._onTouched();
	        // Only emit blur event if the new focus is *not* on an option.
	        if (newlyFocusedTag !== 'MD-OPTION') {
	            this._blurStream.next(null);
	        }
	    };
	    /**
	     * In "auto" mode, the placeholder will animate down as soon as focus is lost.
	     * This causes the value to jump when selecting an option with the mouse.
	     * This method manually floats the placeholder until the panel can be closed.
	     */
	    MdAutocompleteTrigger.prototype._floatPlaceholder = function (state$$1) {
	        if (this._inputContainer) {
	            this._inputContainer.floatPlaceholder = state$$1;
	        }
	    };
	    /**
	     * Given that we are not actually focusing active options, we must manually adjust scroll
	     * to reveal options below the fold. First, we find the offset of the option from the top
	     * of the panel. The new scrollTop will be that offset - the panel height + the option
	     * height, so the active option will be just visible at the bottom of the panel.
	     */
	    MdAutocompleteTrigger.prototype._scrollToOption = function () {
	        var optionOffset = this._keyManager.activeItemIndex * AUTOCOMPLETE_OPTION_HEIGHT;
	        var newScrollTop = Math.max(0, optionOffset - AUTOCOMPLETE_PANEL_HEIGHT + AUTOCOMPLETE_OPTION_HEIGHT);
	        this.autocomplete._setScrollTop(newScrollTop);
	    };
	    /**
	     * This method listens to a stream of panel closing actions and resets the
	     * stream every time the option list changes.
	     */
	    MdAutocompleteTrigger.prototype._subscribeToClosingActions = function () {
	        var _this = this;
	        // When the zone is stable initially, and when the option list changes...
	        rxjs_Observable.Observable.merge(this._zone.onStable.first(), this.autocomplete.options.changes)
	            .switchMap(function () {
	            _this._resetPanel();
	            return _this.panelClosingActions;
	        })
	            .first()
	            .subscribe(function (event) { return _this._setValueAndClose(event); });
	    };
	    /** Destroys the autocomplete suggestion panel. */
	    MdAutocompleteTrigger.prototype._destroyPanel = function () {
	        if (this._overlayRef) {
	            this.closePanel();
	            this._overlayRef.dispose();
	            this._overlayRef = null;
	        }
	    };
	    MdAutocompleteTrigger.prototype._setTriggerValue = function (value) {
	        this._element.nativeElement.value =
	            this.autocomplete.displayWith ? this.autocomplete.displayWith(value) : value;
	    };
	    /**
	    * This method closes the panel, and if a value is specified, also sets the associated
	    * control to that value. It will also mark the control as dirty if this interaction
	    * stemmed from the user.
	    */
	    MdAutocompleteTrigger.prototype._setValueAndClose = function (event) {
	        if (event) {
	            this._setTriggerValue(event.source.value);
	            this._onChange(event.source.value);
	        }
	        this.closePanel();
	    };
	    MdAutocompleteTrigger.prototype._createOverlay = function () {
	        this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);
	        this._overlayRef = this._overlay.create(this._getOverlayConfig());
	    };
	    MdAutocompleteTrigger.prototype._getOverlayConfig = function () {
	        var overlayState = new OverlayState();
	        overlayState.positionStrategy = this._getOverlayPosition();
	        overlayState.width = this._getHostWidth();
	        overlayState.direction = this._dir ? this._dir.value : 'ltr';
	        return overlayState;
	    };
	    MdAutocompleteTrigger.prototype._getOverlayPosition = function () {
	        this._positionStrategy = this._overlay.position().connectedTo(this._element, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
	            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' });
	        this._subscribeToPositionChanges(this._positionStrategy);
	        return this._positionStrategy;
	    };
	    /**
	     * This method subscribes to position changes in the autocomplete panel, so the panel's
	     * y-offset can be adjusted to match the new position.
	     */
	    MdAutocompleteTrigger.prototype._subscribeToPositionChanges = function (strategy) {
	        var _this = this;
	        this._panelPositionSubscription = strategy.onPositionChange.subscribe(function (change) {
	            _this.autocomplete.positionY = change.connectionPair.originY === 'top' ? 'above' : 'below';
	        });
	    };
	    /** Returns the width of the input element, so the panel width can match it. */
	    MdAutocompleteTrigger.prototype._getHostWidth = function () {
	        return this._element.nativeElement.getBoundingClientRect().width;
	    };
	    /** Reset active item to null so arrow events will activate the correct options.*/
	    MdAutocompleteTrigger.prototype._resetActiveItem = function () {
	        this._keyManager.setActiveItem(null);
	    };
	    /**
	     * Resets the active item and re-calculates alignment of the panel in case its size
	     * has changed due to fewer or greater number of options.
	     */
	    MdAutocompleteTrigger.prototype._resetPanel = function () {
	        this._resetActiveItem();
	        this._positionStrategy.recalculateLastPosition();
	        this.autocomplete._setVisibility();
	    };
	    __decorate$77([
	        _angular_core.Input('mdAutocomplete'), 
	        __metadata$77('design:type', MdAutocomplete)
	    ], MdAutocompleteTrigger.prototype, "autocomplete", void 0);
	    __decorate$77([
	        _angular_core.Input('matAutocomplete'), 
	        __metadata$77('design:type', MdAutocomplete)
	    ], MdAutocompleteTrigger.prototype, "_matAutocomplete", null);
	    MdAutocompleteTrigger = __decorate$77([
	        _angular_core.Directive({
	            selector: 'input[mdAutocomplete], input[matAutocomplete]',
	            host: {
	                'role': 'combobox',
	                'autocomplete': 'off',
	                'aria-autocomplete': 'list',
	                'aria-multiline': 'false',
	                '[attr.aria-activedescendant]': 'activeOption?.id',
	                '[attr.aria-expanded]': 'panelOpen.toString()',
	                '[attr.aria-owns]': 'autocomplete?.id',
	                '(focus)': 'openPanel()',
	                '(blur)': '_handleBlur($event.relatedTarget?.tagName)',
	                '(input)': '_handleInput($event.target.value)',
	                '(keydown)': '_handleKeydown($event)',
	            },
	            providers: [MD_AUTOCOMPLETE_VALUE_ACCESSOR]
	        }),
	        __param$18(3, _angular_core.Optional()),
	        __param$18(5, _angular_core.Optional()),
	        __param$18(5, _angular_core.Host()), 
	        __metadata$77('design:paramtypes', [_angular_core.ElementRef, Overlay, _angular_core.ViewContainerRef, Dir, _angular_core.NgZone, MdInputContainer])
	    ], MdAutocompleteTrigger);
	    return MdAutocompleteTrigger;
	}());
	
	var __decorate$75 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$75 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdAutocompleteModule = (function () {
	    function MdAutocompleteModule() {
	    }
	    /** @deprecated */
	    MdAutocompleteModule.forRoot = function () {
	        return {
	            ngModule: MdAutocompleteModule,
	            providers: [OVERLAY_PROVIDERS]
	        };
	    };
	    MdAutocompleteModule = __decorate$75([
	        _angular_core.NgModule({
	            imports: [MdOptionModule, OverlayModule, CompatibilityModule, _angular_common.CommonModule],
	            exports: [MdAutocomplete, MdOptionModule, MdAutocompleteTrigger, CompatibilityModule],
	            declarations: [MdAutocomplete, MdAutocompleteTrigger],
	        }), 
	        __metadata$75('design:paramtypes', [])
	    ], MdAutocompleteModule);
	    return MdAutocompleteModule;
	}());
	
	var __decorate$30 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$30 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MATERIAL_MODULES = [
	    MdAutocompleteModule,
	    MdButtonModule,
	    MdButtonToggleModule,
	    MdCardModule,
	    MdChipsModule,
	    MdCheckboxModule,
	    MdDialogModule,
	    MdGridListModule,
	    MdIconModule,
	    MdInputModule,
	    MdListModule,
	    MdMenuModule,
	    MdProgressBarModule,
	    MdProgressSpinnerModule,
	    MdRadioModule,
	    MdRippleModule,
	    MdSelectModule,
	    MdSidenavModule,
	    MdSliderModule,
	    MdSlideToggleModule,
	    MdSnackBarModule,
	    MdTabsModule,
	    MdToolbarModule,
	    MdTooltipModule,
	    OverlayModule,
	    PortalModule,
	    RtlModule,
	    StyleModule,
	    A11yModule,
	    PlatformModule,
	    ProjectionModule,
	    CompatibilityModule,
	    ObserveContentModule
	];
	var MaterialRootModule = (function () {
	    function MaterialRootModule() {
	    }
	    MaterialRootModule = __decorate$30([
	        _angular_core.NgModule({
	            imports: [
	                MdAutocompleteModule.forRoot(),
	                MdButtonModule.forRoot(),
	                MdCardModule.forRoot(),
	                MdChipsModule.forRoot(),
	                MdCheckboxModule.forRoot(),
	                MdGridListModule.forRoot(),
	                MdInputModule.forRoot(),
	                MdListModule.forRoot(),
	                MdProgressBarModule.forRoot(),
	                MdProgressSpinnerModule.forRoot(),
	                MdRippleModule.forRoot(),
	                MdSelectModule.forRoot(),
	                MdSidenavModule.forRoot(),
	                MdTabsModule.forRoot(),
	                MdToolbarModule.forRoot(),
	                PortalModule.forRoot(),
	                ProjectionModule.forRoot(),
	                RtlModule.forRoot(),
	                ObserveContentModule.forRoot(),
	                // These modules include providers.
	                A11yModule.forRoot(),
	                MdButtonToggleModule.forRoot(),
	                MdDialogModule.forRoot(),
	                MdIconModule.forRoot(),
	                MdMenuModule.forRoot(),
	                MdRadioModule.forRoot(),
	                MdSliderModule.forRoot(),
	                MdSlideToggleModule.forRoot(),
	                MdSnackBarModule.forRoot(),
	                MdTooltipModule.forRoot(),
	                PlatformModule.forRoot(),
	                OverlayModule.forRoot(),
	                CompatibilityModule.forRoot(),
	            ],
	            exports: MATERIAL_MODULES,
	        }), 
	        __metadata$30('design:paramtypes', [])
	    ], MaterialRootModule);
	    return MaterialRootModule;
	}());
	var MaterialModule = (function () {
	    function MaterialModule() {
	    }
	    /** @deprecated */
	    MaterialModule.forRoot = function () {
	        return { ngModule: MaterialRootModule };
	    };
	    MaterialModule = __decorate$30([
	        _angular_core.NgModule({
	            imports: MATERIAL_MODULES,
	            exports: MATERIAL_MODULES,
	        }), 
	        __metadata$30('design:paramtypes', [])
	    ], MaterialModule);
	    return MaterialModule;
	}());
	
	exports.MdCoreModule = MdCoreModule;
	exports.Dir = Dir;
	exports.RtlModule = RtlModule;
	exports.ObserveContentModule = ObserveContentModule;
	exports.ObserveContent = ObserveContent;
	exports.MdOptionModule = MdOptionModule;
	exports.MdOption = MdOption;
	exports.Portal = Portal;
	exports.BasePortalHost = BasePortalHost;
	exports.ComponentPortal = ComponentPortal;
	exports.TemplatePortal = TemplatePortal;
	exports.PortalHostDirective = PortalHostDirective;
	exports.TemplatePortalDirective = TemplatePortalDirective;
	exports.PortalModule = PortalModule;
	exports.DomPortalHost = DomPortalHost;
	exports.MdPlatform = Platform;
	exports.Overlay = Overlay;
	exports.OVERLAY_PROVIDERS = OVERLAY_PROVIDERS;
	exports.OverlayContainer = OverlayContainer;
	exports.FullscreenOverlayContainer = FullscreenOverlayContainer;
	exports.OverlayRef = OverlayRef;
	exports.OverlayState = OverlayState;
	exports.ConnectedOverlayDirective = ConnectedOverlayDirective;
	exports.OverlayOrigin = OverlayOrigin;
	exports.OverlayModule = OverlayModule;
	exports.ScrollDispatcher = ScrollDispatcher;
	exports.GestureConfig = GestureConfig;
	exports.MdRipple = MdRipple;
	exports.MdRippleModule = MdRippleModule;
	exports.LiveAnnouncer = LiveAnnouncer;
	exports.LIVE_ANNOUNCER_ELEMENT_TOKEN = LIVE_ANNOUNCER_ELEMENT_TOKEN;
	exports.LIVE_ANNOUNCER_PROVIDER = LIVE_ANNOUNCER_PROVIDER;
	exports.MdLiveAnnouncer = LiveAnnouncer;
	exports.FocusTrap = FocusTrap;
	exports.InteractivityChecker = InteractivityChecker;
	exports.isFakeMousedownFromScreenReader = isFakeMousedownFromScreenReader;
	exports.A11yModule = A11yModule;
	exports.UniqueSelectionDispatcher = UniqueSelectionDispatcher;
	exports.UNIQUE_SELECTION_DISPATCHER_PROVIDER = UNIQUE_SELECTION_DISPATCHER_PROVIDER;
	exports.MdUniqueSelectionDispatcher = UniqueSelectionDispatcher;
	exports.MdLineModule = MdLineModule;
	exports.MdLine = MdLine;
	exports.MdLineSetter = MdLineSetter;
	exports.MdError = MdError;
	exports.coerceBooleanProperty = coerceBooleanProperty;
	exports.coerceNumberProperty = coerceNumberProperty;
	exports.CompatibilityModule = CompatibilityModule;
	exports.NoConflictStyleCompatibilityMode = NoConflictStyleCompatibilityMode;
	exports.DomProjectionHost = DomProjectionHost;
	exports.DomProjection = DomProjection;
	exports.ProjectionModule = ProjectionModule;
	exports.PlatformModule = PlatformModule;
	exports.Platform = Platform;
	exports.getSupportedInputTypes = getSupportedInputTypes;
	exports.ConnectedPositionStrategy = ConnectedPositionStrategy;
	exports.ConnectionPositionPair = ConnectionPositionPair;
	exports.ScrollableViewProperties = ScrollableViewProperties;
	exports.ConnectedOverlayPositionChange = ConnectedOverlayPositionChange;
	exports.SelectionModel = SelectionModel;
	exports.SelectionChange = SelectionChange;
	exports.StyleModule = StyleModule;
	exports.TOUCH_BUFFER_MS = TOUCH_BUFFER_MS;
	exports.FocusOriginMonitor = FocusOriginMonitor;
	exports.CdkFocusClasses = CdkFocusClasses;
	exports.FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY = FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY;
	exports.FOCUS_ORIGIN_MONITOR_PROVIDER = FOCUS_ORIGIN_MONITOR_PROVIDER;
	exports.applyCssTransform = applyCssTransform;
	exports.UP_ARROW = UP_ARROW;
	exports.DOWN_ARROW = DOWN_ARROW;
	exports.RIGHT_ARROW = RIGHT_ARROW;
	exports.LEFT_ARROW = LEFT_ARROW;
	exports.PAGE_UP = PAGE_UP;
	exports.PAGE_DOWN = PAGE_DOWN;
	exports.HOME = HOME;
	exports.END = END;
	exports.ENTER = ENTER;
	exports.SPACE = SPACE;
	exports.TAB = TAB;
	exports.ESCAPE = ESCAPE;
	exports.BACKSPACE = BACKSPACE;
	exports.DELETE = DELETE;
	exports.MATERIAL_COMPATIBILITY_MODE = MATERIAL_COMPATIBILITY_MODE;
	exports.MAT_ELEMENTS_SELECTOR = MAT_ELEMENTS_SELECTOR;
	exports.MD_ELEMENTS_SELECTOR = MD_ELEMENTS_SELECTOR;
	exports.MatPrefixRejector = MatPrefixRejector;
	exports.MdPrefixRejector = MdPrefixRejector;
	exports.AnimationCurves = AnimationCurves;
	exports.AnimationDurations = AnimationDurations;
	exports.MdSelectionModule = MdSelectionModule;
	exports.MdPseudoCheckbox = MdPseudoCheckbox;
	exports.MaterialRootModule = MaterialRootModule;
	exports.MaterialModule = MaterialModule;
	exports.MdAutocompleteModule = MdAutocompleteModule;
	exports.MdAutocomplete = MdAutocomplete;
	exports.AUTOCOMPLETE_OPTION_HEIGHT = AUTOCOMPLETE_OPTION_HEIGHT;
	exports.AUTOCOMPLETE_PANEL_HEIGHT = AUTOCOMPLETE_PANEL_HEIGHT;
	exports.MD_AUTOCOMPLETE_VALUE_ACCESSOR = MD_AUTOCOMPLETE_VALUE_ACCESSOR;
	exports.MdAutocompleteTrigger = MdAutocompleteTrigger;
	exports.MdButtonCssMatStyler = MdButtonCssMatStyler;
	exports.MdRaisedButtonCssMatStyler = MdRaisedButtonCssMatStyler;
	exports.MdIconButtonCssMatStyler = MdIconButtonCssMatStyler;
	exports.MdFabCssMatStyler = MdFabCssMatStyler;
	exports.MdMiniFabCssMatStyler = MdMiniFabCssMatStyler;
	exports.MdButton = MdButton;
	exports.MdAnchor = MdAnchor;
	exports.MdButtonModule = MdButtonModule;
	exports.MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR;
	exports.MdButtonToggleChange = MdButtonToggleChange;
	exports.MdButtonToggleGroup = MdButtonToggleGroup;
	exports.MdButtonToggleGroupMultiple = MdButtonToggleGroupMultiple;
	exports.MdButtonToggle = MdButtonToggle;
	exports.MdButtonToggleModule = MdButtonToggleModule;
	exports.MdCardContent = MdCardContent;
	exports.MdCardTitle = MdCardTitle;
	exports.MdCardSubtitle = MdCardSubtitle;
	exports.MdCardActions = MdCardActions;
	exports.MdCardFooter = MdCardFooter;
	exports.MdCardSmImage = MdCardSmImage;
	exports.MdCardMdImage = MdCardMdImage;
	exports.MdCardLgImage = MdCardLgImage;
	exports.MdCardImage = MdCardImage;
	exports.MdCardXlImage = MdCardXlImage;
	exports.MdCardAvatar = MdCardAvatar;
	exports.MdCard = MdCard;
	exports.MdCardHeader = MdCardHeader;
	exports.MdCardTitleGroup = MdCardTitleGroup;
	exports.MdCardModule = MdCardModule;
	exports.MdChipList = MdChipList;
	exports.MdChipsModule = MdChipsModule;
	exports.MdChip = MdChip;
	exports.MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = MD_CHECKBOX_CONTROL_VALUE_ACCESSOR;
	exports.MdCheckboxChange = MdCheckboxChange;
	exports.MdCheckbox = MdCheckbox;
	exports.MdCheckboxModule = MdCheckboxModule;
	exports.MdDialogModule = MdDialogModule;
	exports.MD_DIALOG_DATA = MD_DIALOG_DATA;
	exports.MdDialog = MdDialog;
	exports.MdDialogContainer = MdDialogContainer;
	exports.MdDialogClose = MdDialogClose;
	exports.MdDialogTitle = MdDialogTitle;
	exports.MdDialogContent = MdDialogContent;
	exports.MdDialogActions = MdDialogActions;
	exports.MdDialogConfig = MdDialogConfig;
	exports.MdDialogRef = MdDialogRef;
	exports.MdGridList = MdGridList;
	exports.MdGridListModule = MdGridListModule;
	exports.MdIconInvalidNameError = MdIconInvalidNameError;
	exports.MdIcon = MdIcon;
	exports.ICON_REGISTRY_PROVIDER_FACTORY = ICON_REGISTRY_PROVIDER_FACTORY;
	exports.ICON_REGISTRY_PROVIDER = ICON_REGISTRY_PROVIDER;
	exports.MdIconModule = MdIconModule;
	exports.MdIconRegistry = MdIconRegistry;
	exports.MdInputModule = MdInputModule;
	exports.MdTextareaAutosize = MdTextareaAutosize;
	exports.MdPlaceholder = MdPlaceholder;
	exports.MdHint = MdHint;
	exports.MdInputDirective = MdInputDirective;
	exports.MdInputContainer = MdInputContainer;
	exports.MdInputContainerPlaceholderConflictError = MdInputContainerPlaceholderConflictError;
	exports.MdInputContainerUnsupportedTypeError = MdInputContainerUnsupportedTypeError;
	exports.MdInputContainerDuplicatedHintError = MdInputContainerDuplicatedHintError;
	exports.MdInputContainerMissingMdInputError = MdInputContainerMissingMdInputError;
	exports.MdListDivider = MdListDivider;
	exports.MdList = MdList;
	exports.MdListCssMatStyler = MdListCssMatStyler;
	exports.MdNavListCssMatStyler = MdNavListCssMatStyler;
	exports.MdDividerCssMatStyler = MdDividerCssMatStyler;
	exports.MdListAvatarCssMatStyler = MdListAvatarCssMatStyler;
	exports.MdListIconCssMatStyler = MdListIconCssMatStyler;
	exports.MdListSubheaderCssMatStyler = MdListSubheaderCssMatStyler;
	exports.MdListItem = MdListItem;
	exports.MdListModule = MdListModule;
	exports.MdMenuTrigger = MdMenuTrigger;
	exports.fadeInItems = fadeInItems;
	exports.transformMenu = transformMenu;
	exports.MdMenu = MdMenu;
	exports.MdMenuItem = MdMenuItem;
	exports.MdMenuModule = MdMenuModule;
	exports.MdProgressBar = MdProgressBar;
	exports.MdProgressBarModule = MdProgressBarModule;
	exports.MdProgressCircle = MdProgressSpinner;
	exports.MdProgressCircleModule = MdProgressSpinnerModule;
	exports.MdProgressSpinnerCssMatStyler = MdProgressSpinnerCssMatStyler;
	exports.MdProgressCircleCssMatStyler = MdProgressCircleCssMatStyler;
	exports.MdProgressSpinner = MdProgressSpinner;
	exports.MdSpinner = MdSpinner;
	exports.MdProgressSpinnerModule = MdProgressSpinnerModule;
	exports.MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR;
	exports.MdRadioChange = MdRadioChange;
	exports.MdRadioGroup = MdRadioGroup;
	exports.MdRadioButton = MdRadioButton;
	exports.MdRadioModule = MdRadioModule;
	exports.MdSelectModule = MdSelectModule;
	exports.fadeInContent = fadeInContent;
	exports.transformPanel = transformPanel;
	exports.transformPlaceholder = transformPlaceholder;
	exports.SELECT_OPTION_HEIGHT = SELECT_OPTION_HEIGHT;
	exports.SELECT_PANEL_MAX_HEIGHT = SELECT_PANEL_MAX_HEIGHT;
	exports.SELECT_MAX_OPTIONS_DISPLAYED = SELECT_MAX_OPTIONS_DISPLAYED;
	exports.SELECT_TRIGGER_HEIGHT = SELECT_TRIGGER_HEIGHT;
	exports.SELECT_OPTION_HEIGHT_ADJUSTMENT = SELECT_OPTION_HEIGHT_ADJUSTMENT;
	exports.SELECT_PANEL_PADDING_X = SELECT_PANEL_PADDING_X;
	exports.SELECT_PANEL_PADDING_Y = SELECT_PANEL_PADDING_Y;
	exports.SELECT_PANEL_VIEWPORT_PADDING = SELECT_PANEL_VIEWPORT_PADDING;
	exports.MdSelectChange = MdSelectChange;
	exports.MdSelect = MdSelect;
	exports.MdDuplicatedSidenavError = MdDuplicatedSidenavError;
	exports.MdSidenavToggleResult = MdSidenavToggleResult;
	exports.MdSidenav = MdSidenav;
	exports.MdSidenavContainer = MdSidenavContainer;
	exports.MdSidenavModule = MdSidenavModule;
	exports.MD_SLIDER_VALUE_ACCESSOR = MD_SLIDER_VALUE_ACCESSOR;
	exports.MdSliderChange = MdSliderChange;
	exports.MdSlider = MdSlider;
	exports.SliderRenderer = SliderRenderer;
	exports.MdSliderModule = MdSliderModule;
	exports.MD_SLIDE_TOGGLE_VALUE_ACCESSOR = MD_SLIDE_TOGGLE_VALUE_ACCESSOR;
	exports.MdSlideToggleChange = MdSlideToggleChange;
	exports.MdSlideToggle = MdSlideToggle;
	exports.MdSlideToggleModule = MdSlideToggleModule;
	exports.MdSnackBarModule = MdSnackBarModule;
	exports.MdSnackBar = MdSnackBar;
	exports.SHOW_ANIMATION = SHOW_ANIMATION;
	exports.HIDE_ANIMATION = HIDE_ANIMATION;
	exports.MdSnackBarContainer = MdSnackBarContainer;
	exports.MdSnackBarConfig = MdSnackBarConfig;
	exports.MdSnackBarRef = MdSnackBarRef;
	exports.SimpleSnackBar = SimpleSnackBar;
	exports.MdInkBar = MdInkBar;
	exports.MdTabBody = MdTabBody;
	exports.MdTabHeader = MdTabHeader;
	exports.MdTabLabelWrapper = MdTabLabelWrapper;
	exports.MdTab = MdTab;
	exports.MdTabLabel = MdTabLabel;
	exports.MdTabChangeEvent = MdTabChangeEvent;
	exports.MdTabGroup = MdTabGroup;
	exports.MdTabsModule = MdTabsModule;
	exports.MdTabNavBar = MdTabNavBar;
	exports.MdTabLink = MdTabLink;
	exports.MdTabLinkRipple = MdTabLinkRipple;
	exports.MdToolbarRow = MdToolbarRow;
	exports.MdToolbar = MdToolbar;
	exports.MdToolbarModule = MdToolbarModule;
	exports.TOUCHEND_HIDE_DELAY = TOUCHEND_HIDE_DELAY;
	exports.SCROLL_THROTTLE_MS = SCROLL_THROTTLE_MS;
	exports.MdTooltip = MdTooltip;
	exports.TooltipComponent = TooltipComponent;
	exports.MdTooltipModule = MdTooltipModule;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },

/***/ 99:
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(83), __webpack_require__(84), __webpack_require__(3), __webpack_require__(31), __webpack_require__(22)) :
	    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/add/operator/map', 'rxjs/add/operator/filter', '@angular/core', 'rxjs/BehaviorSubject', '@angular/common'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.flexLayout = global.ng.flexLayout || {}),global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.core,global.Rx,global.ng.common));
	}(this, (function (exports,rxjs_add_operator_map,rxjs_add_operator_filter,_angular_core,rxjs_BehaviorSubject,_angular_common) { 'use strict';
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/** Applies CSS prefixes to appropriate style keys.*/
	function applyCssPrefixes(target) {
	    for (var key in target) {
	        var value = target[key];
	        switch (key) {
	            case 'display':
	                target['display'] = value;
	                // also need 'display : -webkit-box' and 'display : -ms-flexbox;'
	                break;
	            case 'flex':
	                target['-ms-flex'] = value;
	                target['-webkit-box-flex'] = value.split(" ")[0];
	                break;
	            case 'flex-direction':
	                value = value || "row";
	                target['flex-direction'] = value;
	                target['-ms-flex-direction'] = value;
	                target['-webkit-box-orient'] = toBoxOrient(value);
	                target['-webkit-box-direction'] = toBoxDirection(value);
	                break;
	            case 'flex-wrap':
	                target['-ms-flex-wrap'] = value;
	                break;
	            case 'order':
	                if (isNaN(value)) {
	                    value = "0";
	                }
	                target['order'] = value;
	                target['-ms-flex-order'] = value;
	                target['-webkit-box-ordinal-group'] = toBoxOrdinal(value);
	                break;
	            case 'justify-content':
	                target['-ms-flex-pack'] = toBoxValue(value);
	                target['-webkit-box-pack'] = toBoxValue(value);
	                break;
	            case 'align-items':
	                target['-ms-flex-align'] = toBoxValue(value);
	                target['-webkit-box-align'] = toBoxValue(value);
	                break;
	            case 'align-self':
	                target['-ms-flex-item-align'] = toBoxValue(value);
	                break;
	            case 'align-content':
	                target['-ms-align-content'] = toAlignContentValue(value);
	                target['-ms-flex-line-pack'] = toAlignContentValue(value);
	                break;
	        }
	    }
	    return target;
	}
	function toAlignContentValue(value) {
	    switch (value) {
	        case "space-between":
	            return "justify";
	        case "space-around":
	            return "distribute";
	        default:
	            return toBoxValue(value);
	    }
	}
	/** Convert flex values flex-start, flex-end to start, end. */
	function toBoxValue(value) {
	    if (value === void 0) { value = ""; }
	    return (value == 'flex-start') ? 'start' : ((value == 'flex-end') ? 'end' : value);
	}
	/** Convert flex Direction to Box orientation */
	function toBoxOrient(flexDirection) {
	    if (flexDirection === void 0) { flexDirection = 'row'; }
	    return flexDirection.indexOf('column') === -1 ? 'horizontal' : 'vertical';
	}
	/** Convert flex Direction to Box direction type */
	function toBoxDirection(flexDirection) {
	    if (flexDirection === void 0) { flexDirection = 'row'; }
	    return flexDirection.indexOf('reverse') !== -1 ? 'reverse' : 'normal';
	}
	/** Convert flex order to Box ordinal group */
	function toBoxOrdinal(order) {
	    if (order === void 0) { order = '0'; }
	    var value = order ? parseInt(order) + 1 : 1;
	    return isNaN(value) ? "0" : value.toString();
	}
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Extends an object with the *enumerable* and *own* properties of one or more source objects,
	 * similar to Object.assign.
	 *
	 * @param dest The object which will have properties copied to it.
	 * @param sources The source objects from which properties will be copied.
	 */
	function extendObject(dest) {
	    var sources = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        sources[_i - 1] = arguments[_i];
	    }
	    if (dest == null) {
	        throw TypeError('Cannot convert undefined or null to object');
	    }
	    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
	        var source = sources_1[_a];
	        if (source != null) {
	            for (var key in source) {
	                if (source.hasOwnProperty(key)) {
	                    dest[key] = source[key];
	                }
	            }
	        }
	    }
	    return dest;
	}
	
	var KeyOptions = (function () {
	    function KeyOptions(baseKey, defaultValue, inputKeys) {
	        this.baseKey = baseKey;
	        this.defaultValue = defaultValue;
	        this.inputKeys = inputKeys;
	    }
	    return KeyOptions;
	}());
	/**
	 * ResponsiveActivation acts as a proxy between the MonitorMedia service (which emits mediaQuery
	 * changes) and the fx API directives. The MQA proxies mediaQuery change events and notifies the
	 * directive via the specified callback.
	 *
	 * - The MQA also determines which directive property should be used to determine the
	 *   current change 'value'... BEFORE the original `onMediaQueryChanges()` method is called.
	 * - The `ngOnDestroy()` method is also head-hooked to enable auto-unsubscribe from the
	 *   MediaQueryServices.
	 *
	 * NOTE: these interceptions enables the logic in the fx API directives to remain terse and clean.
	 */
	var ResponsiveActivation = (function () {
	    /**
	     * Constructor
	     */
	    function ResponsiveActivation(_options, _mediaMonitor, _onMediaChanges) {
	        this._options = _options;
	        this._mediaMonitor = _mediaMonitor;
	        this._onMediaChanges = _onMediaChanges;
	        this._subscribers = [];
	        this._subscribers = this._configureChangeObservers();
	    }
	    Object.defineProperty(ResponsiveActivation.prototype, "mediaMonitor", {
	        /**
	         * Accessor to the DI'ed directive property
	         * Each directive instance has a reference to the MediaMonitor which is
	         * used HERE to subscribe to mediaQuery change notifications.
	         */
	        get: function () {
	            return this._mediaMonitor;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResponsiveActivation.prototype, "activatedInputKey", {
	        /**
	         * Determine which directive @Input() property is currently active (for the viewport size):
	         * The key must be defined (in use) or fallback to the 'closest' overlapping property key
	         * that is defined; otherwise the default property key will be used.
	         * e.g.
	         *      if `<div fxHide fxHide.gt-sm="false">` is used but the current activated mediaQuery alias
	         *      key is `.md` then `.gt-sm` should be used instead
	         */
	        get: function () {
	            return this._activatedInputKey || this._options.baseKey;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResponsiveActivation.prototype, "activatedInput", {
	        /**
	         * Get the currently activated @Input value or the fallback default @Input value
	         */
	        get: function () {
	            var key = this.activatedInputKey;
	            return this.hasKeyValue(key) ? this._lookupKeyValue(key) : this._options.defaultValue;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Fast validator for presence of attribute on the host element
	     */
	    ResponsiveActivation.prototype.hasKeyValue = function (key) {
	        var value = this._options.inputKeys[key];
	        return typeof value !== 'undefined';
	    };
	    /**
	     * Remove interceptors, restore original functions, and forward the onDestroy() call
	     */
	    ResponsiveActivation.prototype.destroy = function () {
	        this._subscribers.forEach(function (link) {
	            link.unsubscribe();
	        });
	        this._subscribers = [];
	    };
	    /**
	     * For each *defined* API property, register a callback to `_onMonitorEvents( )`
	     * Cache 1..n subscriptions for internal auto-unsubscribes when the the directive destructs
	     */
	    ResponsiveActivation.prototype._configureChangeObservers = function () {
	        var _this = this;
	        var subscriptions = [];
	        this._buildRegistryMap().forEach(function (bp) {
	            if (_this._keyInUse(bp.key)) {
	                // Inject directive default property key name: to let onMediaChange() calls
	                // know which property is being triggered...
	                var buildChanges = function (change) {
	                    change.property = _this._options.baseKey;
	                    return change;
	                };
	                subscriptions.push(_this.mediaMonitor.observe(bp.alias)
	                    .map(buildChanges)
	                    .subscribe(function (change) {
	                    _this._onMonitorEvents(change);
	                }));
	            }
	        });
	        return subscriptions;
	    };
	    /**
	     * Build mediaQuery key-hashmap; only for the directive properties that are actually defined/used
	     * in the HTML markup
	     */
	    ResponsiveActivation.prototype._buildRegistryMap = function () {
	        var _this = this;
	        return this.mediaMonitor.breakpoints
	            .map(function (bp) {
	            return extendObject({}, bp, {
	                baseKey: _this._options.baseKey,
	                key: _this._options.baseKey + bp.suffix // e.g.  layoutGtSm, layoutMd, layoutGtLg
	            });
	        })
	            .filter(function (bp) { return _this._keyInUse(bp.key); });
	    };
	    /**
	     * Synchronizes change notifications with the current mq-activated @Input and calculates the
	     * mq-activated input value or the default value
	     */
	    ResponsiveActivation.prototype._onMonitorEvents = function (change) {
	        if (change.property == this._options.baseKey) {
	            change.value = this._calculateActivatedValue(change);
	            this._onMediaChanges(change);
	        }
	    };
	    /**
	     * Has the key been specified in the HTML markup and thus is intended
	     * to participate in activation processes.
	     */
	    ResponsiveActivation.prototype._keyInUse = function (key) {
	        return this._lookupKeyValue(key) !== undefined;
	    };
	    /**
	     *  Map input key associated with mediaQuery activation to closest defined input key
	     *  then return the values associated with the targeted input property
	     *
	     *  !! change events may arrive out-of-order (activate before deactivate)
	     *     so make sure the deactivate is used ONLY when the keys match
	     *     (since a different activate may be in use)
	     */
	    ResponsiveActivation.prototype._calculateActivatedValue = function (current) {
	        var currentKey = this._options.baseKey + current.suffix; // e.g. suffix == 'GtSm',
	        var newKey = this._activatedInputKey; // e.g. newKey == hideGtSm
	        newKey = current.matches ? currentKey : ((newKey == currentKey) ? null : newKey);
	        this._activatedInputKey = this._validateInputKey(newKey);
	        return this.activatedInput;
	    };
	    /**
	     * For the specified input property key, validate it is defined (used in the markup)
	     * If not see if a overlapping mediaQuery-related input key fallback has been defined
	     *
	     * NOTE: scans in the order defined by activeOverLaps (largest viewport ranges -> smallest ranges)
	     */
	    ResponsiveActivation.prototype._validateInputKey = function (inputKey) {
	        var _this = this;
	        var items = this.mediaMonitor.activeOverlaps;
	        var isMissingKey = function (key) { return !_this._keyInUse(key); };
	        if (isMissingKey(inputKey)) {
	            items.some(function (bp) {
	                var key = _this._options.baseKey + bp.suffix;
	                if (!isMissingKey(key)) {
	                    inputKey = key;
	                    return true; // exit .some()
	                }
	                return false;
	            });
	        }
	        return inputKey;
	    };
	    /**
	     * Get the value (if any) for the directive instances @Input property (aka key)
	     */
	    ResponsiveActivation.prototype._lookupKeyValue = function (key) {
	        return this._options.inputKeys[key];
	    };
	    return ResponsiveActivation;
	}());
	
	/** Abstract base class for the Layout API styling directives. */
	var BaseFxDirective = (function () {
	    /**
	     *
	     */
	    function BaseFxDirective(_mediaMonitor, _elementRef, _renderer) {
	        this._mediaMonitor = _mediaMonitor;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /**
	         *  Dictionary of input keys with associated values
	         */
	        this._inputMap = {};
	        this._display = this._getDisplayStyle();
	    }
	    // *********************************************
	    // Accessor Methods
	    // *********************************************
	    /**
	     * Access the current value (if any) of the @Input property.
	     */
	    BaseFxDirective.prototype._queryInput = function (key) {
	        return this._inputMap[key];
	    };
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    BaseFxDirective.prototype.ngOnDestroy = function () {
	        if (this._mqActivation) {
	            this._mqActivation.destroy();
	        }
	        this._mediaMonitor = null;
	    };
	    // *********************************************
	    // Protected Methods
	    // *********************************************
	    /**
	     * Was the directive's default selector used ?
	     * If not, use the fallback value!
	     */
	    BaseFxDirective.prototype._getDefaultVal = function (key, fallbackVal) {
	        var val = this._queryInput(key);
	        var hasDefaultVal = (val !== undefined && val !== null);
	        return (hasDefaultVal && val !== '') ? val : fallbackVal;
	    };
	    /**
	     * Quick accessor to the current HTMLElement's `display` style
	     * Note: this allows use to preserve the original style
	     * and optional restore it when the mediaQueries deactivate
	     */
	    BaseFxDirective.prototype._getDisplayStyle = function (source) {
	        var element = source || this._elementRef.nativeElement;
	        var value = element.style['display'] || getComputedStyle(element)['display'];
	        return value.trim();
	    };
	    /**
	     * Applies styles given via string pair or object map to the directive element.
	     */
	    BaseFxDirective.prototype._applyStyleToElement = function (style, value, nativeElement) {
	        var styles = {};
	        var element = nativeElement || this._elementRef.nativeElement;
	        if (typeof style === 'string') {
	            styles[style] = value;
	            style = styles;
	        }
	        styles = applyCssPrefixes(style);
	        // Iterate all properties in hashMap and set styles
	        for (var key in styles) {
	            this._renderer.setElementStyle(element, key, styles[key]);
	        }
	    };
	    /**
	     * Applies styles given via string pair or object map to the directive element.
	     */
	    BaseFxDirective.prototype._applyStyleToElements = function (style, elements) {
	        var _this = this;
	        var styles = applyCssPrefixes(style);
	        elements.forEach(function (el) {
	            // Iterate all properties in hashMap and set styles
	            for (var key in styles) {
	                _this._renderer.setElementStyle(el, key, styles[key]);
	            }
	        });
	    };
	    /**
	     *  Save the property value; which may be a complex object.
	     *  Complex objects support property chains
	     */
	    BaseFxDirective.prototype._cacheInput = function (key, source) {
	        if (typeof source === 'object') {
	            for (var prop in source) {
	                this._inputMap[prop] = source[prop];
	            }
	        }
	        else {
	            this._inputMap[key] = source;
	        }
	    };
	    /**
	     *  Build a ResponsiveActivation object used to manage subscriptions to mediaChange notifications
	     *  and intelligent lookup of the directive's property value that corresponds to that mediaQuery
	     *  (or closest match).
	     */
	    BaseFxDirective.prototype._listenForMediaQueryChanges = function (key, defaultValue, onMediaQueryChange) {
	        var _this = this;
	        var keyOptions = new KeyOptions(key, defaultValue, this._inputMap);
	        return this._mqActivation = new ResponsiveActivation(keyOptions, this._mediaMonitor, function (change) { return onMediaQueryChange.call(_this, change); });
	    };
	    Object.defineProperty(BaseFxDirective.prototype, "childrenNodes", {
	        /**
	         * Special accessor to query for all child 'element' nodes regardless of type, class, etc.
	         */
	        get: function () {
	            var obj = this._elementRef.nativeElement.childNodes;
	            var buffer = [];
	            // iterate backwards ensuring that length is an UInt32
	            for (var i = obj.length; i--;) {
	                buffer[i] = obj[i];
	            }
	            return buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Fast validator for presence of attribute on the host element
	     */
	    BaseFxDirective.prototype.hasKeyValue = function (key) {
	        return this._mqActivation.hasKeyValue(key);
	    };
	    return BaseFxDirective;
	}());
	
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Adapter to the BaseFxDirective abstract class so it can be used via composition.
	 * @see BaseFxDirective
	 */
	var BaseFxDirectiveAdapter = (function (_super) {
	    __extends(BaseFxDirectiveAdapter, _super);
	    function BaseFxDirectiveAdapter() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(BaseFxDirectiveAdapter.prototype, "inputMap", {
	        get: function () {
	            return this._inputMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseFxDirectiveAdapter.prototype, "mqActivation", {
	        /**
	         * @see BaseFxDirective._mqActivation
	         */
	        get: function () {
	            return this._mqActivation;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @see BaseFxDirective._queryInput
	     */
	    BaseFxDirectiveAdapter.prototype.queryInput = function (key) {
	        return this._queryInput(key);
	    };
	    /**
	     *  Save the property value.
	     */
	    BaseFxDirectiveAdapter.prototype.cacheInput = function (key, source, cacheRaw) {
	        if (cacheRaw === void 0) { cacheRaw = false; }
	        if (cacheRaw) {
	            this._cacheInputRaw(key, source);
	        }
	        else if (Array.isArray(source)) {
	            this._cacheInputArray(key, source);
	        }
	        else if (typeof source === 'object') {
	            this._cacheInputObject(key, source);
	        }
	        else if (typeof source === 'string') {
	            this._cacheInputString(key, source);
	        }
	        else {
	            throw new Error('Invalid class value provided. Did you want to cache the raw value?');
	        }
	    };
	    /**
	     * @see BaseFxDirective._listenForMediaQueryChanges
	     */
	    BaseFxDirectiveAdapter.prototype.listenForMediaQueryChanges = function (key, defaultValue, onMediaQueryChange) {
	        return this._listenForMediaQueryChanges(key, defaultValue, onMediaQueryChange);
	    };
	    // ************************************************************
	    // Protected Methods
	    // ************************************************************
	    /**
	     * No implicit transforms of the source.
	     * Required when caching values expected later for KeyValueDiffers
	     */
	    BaseFxDirectiveAdapter.prototype._cacheInputRaw = function (key, source) {
	        this._inputMap[key] = source;
	    };
	    /**
	     *  Save the property value for Array values.
	     */
	    BaseFxDirectiveAdapter.prototype._cacheInputArray = function (key, source) {
	        this._inputMap[key] = source.join(' ');
	    };
	    /**
	     *  Save the property value for key/value pair values.
	     */
	    BaseFxDirectiveAdapter.prototype._cacheInputObject = function (key, source) {
	        var classes = [];
	        for (var prop in source) {
	            if (!!source[prop]) {
	                classes.push(prop);
	            }
	        }
	        this._inputMap[key] = classes.join(' ');
	    };
	    /**
	     *  Save the property value for string values.
	     */
	    BaseFxDirectiveAdapter.prototype._cacheInputString = function (key, source) {
	        this._inputMap[key] = source;
	    };
	    return BaseFxDirectiveAdapter;
	}(BaseFxDirective));
	
	var RESPONSIVE_ALIASES = [
	    'xs', 'gt-xs', 'sm', 'gt-sm', 'md', 'gt-md', 'lg', 'gt-lg', 'xl'
	];
	var RAW_DEFAULTS = [
	    {
	        alias: 'xs',
	        suffix: 'Xs',
	        overlapping: false,
	        mediaQuery: 'screen and (max-width: 599px)'
	    },
	    {
	        alias: 'gt-xs',
	        suffix: 'GtXs',
	        overlapping: true,
	        mediaQuery: 'screen and (min-width: 600px)'
	    },
	    {
	        alias: 'sm',
	        suffix: 'Sm',
	        overlapping: false,
	        mediaQuery: 'screen and (min-width: 600px) and (max-width: 959px)'
	    },
	    {
	        alias: 'gt-sm',
	        suffix: 'GtSm',
	        overlapping: true,
	        mediaQuery: 'screen and (min-width: 960px)'
	    },
	    {
	        alias: 'md',
	        suffix: 'Md',
	        overlapping: false,
	        mediaQuery: 'screen and (min-width: 960px) and (max-width: 1279px)'
	    },
	    {
	        alias: 'gt-md',
	        suffix: 'GtMd',
	        overlapping: true,
	        mediaQuery: 'screen and (min-width: 1280px)'
	    },
	    {
	        alias: 'lg',
	        suffix: 'Lg',
	        overlapping: false,
	        mediaQuery: 'screen and (min-width: 1280px) and (max-width: 1919px)'
	    },
	    {
	        alias: 'gt-lg',
	        suffix: 'GtLg',
	        overlapping: true,
	        mediaQuery: 'screen and (min-width: 1920px)'
	    },
	    {
	        alias: 'xl',
	        suffix: 'Xl',
	        overlapping: false,
	        mediaQuery: 'screen and (min-width: 1920px) and (max-width: 5000px)'
	    }
	];
	/**
	 *  Opaque Token unique to the flex-layout library.
	 *  Use this token when build a custom provider (see below).
	 */
	var BREAKPOINTS = new _angular_core.OpaqueToken('fxRawBreakpoints');
	/**
	 *  Provider to return observable to ALL known BreakPoint(s)
	 *  Developers should build custom providers to override
	 *  this default BreakPointRegistry dataset provider
	 *  NOTE: !! custom breakpoints lists MUST contain the following aliases & suffixes:
	 *        [xs, gt-xs, sm, gt-sm, md, gt-md, lg, gt-lg, xl]
	 */
	var BreakPointsProvider = {
	    provide: BREAKPOINTS,
	    useValue: RAW_DEFAULTS
	};
	
	var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$2 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Registry of 1..n MediaQuery breakpoint ranges
	 * This is published as a provider and may be overriden from custom, application-specific ranges
	 *
	 */
	var BreakPointRegistry = (function () {
	    function BreakPointRegistry(_registry) {
	        this._registry = _registry;
	    }
	    Object.defineProperty(BreakPointRegistry.prototype, "items", {
	        /**
	         * Accessor to raw list
	         */
	        get: function () {
	            return this._registry.slice();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Search breakpoints by alias (e.g. gt-xs)
	     */
	    BreakPointRegistry.prototype.findByAlias = function (alias) {
	        return this._registry.find(function (bp) { return bp.alias == alias; });
	    };
	    BreakPointRegistry.prototype.findByQuery = function (query) {
	        return this._registry.find(function (bp) { return bp.mediaQuery == query; });
	    };
	    Object.defineProperty(BreakPointRegistry.prototype, "overlappings", {
	        /**
	         * Get all the breakpoints whose ranges could overlapping `normal` ranges;
	         * e.g. gt-sm overlaps md, lg, and xl
	         */
	        get: function () {
	            return this._registry.filter(function (it) { return it.overlapping == true; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BreakPointRegistry.prototype, "aliases", {
	        /**
	         * Get list of all registered (non-empty) breakpoint aliases
	         */
	        get: function () {
	            return this._registry.map(function (it) { return it.alias; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BreakPointRegistry.prototype, "suffixes", {
	        /**
	         * Aliases are mapped to properties using suffixes
	         * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'
	         * for property layoutGtSM.
	         */
	        get: function () {
	            return this._registry.map(function (it) { return it.suffix; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BreakPointRegistry = __decorate$2([
	        _angular_core.Injectable(),
	        __param(0, _angular_core.Inject(BREAKPOINTS)), 
	        __metadata$2('design:paramtypes', [Array])
	    ], BreakPointRegistry);
	    return BreakPointRegistry;
	}());
	
	/**
	 * Class instances emitted [to observers] for each mql notification
	 */
	var MediaChange = (function () {
	    function MediaChange(matches, // Is the mq currently activated
	        mediaQuery, // e.g.   (min-width: 600px) and (max-width: 959px)
	        mqAlias, // e.g.   gt-sm, md, gt-lg
	        suffix // e.g.   GtSM, Md, GtLg
	        ) {
	        if (matches === void 0) { matches = false; }
	        if (mediaQuery === void 0) { mediaQuery = 'all'; }
	        if (mqAlias === void 0) { mqAlias = ''; }
	        if (suffix === void 0) { suffix = ''; }
	        this.matches = matches;
	        this.mediaQuery = mediaQuery;
	        this.mqAlias = mqAlias;
	        this.suffix = suffix;
	    }
	    return MediaChange;
	}());
	
	var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$3 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * MediaMonitor configures listeners to mediaQuery changes and publishes an Observable facade to
	 * convert mediaQuery change callbacks to subscriber notifications. These notifications will be
	 * performed within the ng Zone to trigger change detections and component updates.
	 *
	 * NOTE: both mediaQuery activations and de-activations are announced in notifications
	 */
	var MatchMedia = (function () {
	    function MatchMedia(_zone) {
	        this._zone = _zone;
	        this._registry = new Map();
	        this._source = new rxjs_BehaviorSubject.BehaviorSubject(new MediaChange(true));
	        this._observable$ = this._source.asObservable();
	    }
	    /**
	     * For the specified mediaQuery?
	     */
	    MatchMedia.prototype.isActive = function (mediaQuery) {
	        if (this._registry.has(mediaQuery)) {
	            var mql = this._registry.get(mediaQuery);
	            return mql.matches;
	        }
	        return false;
	    };
	    /**
	     * External observers can watch for all (or a specific) mql changes.
	     * Typically used by the MediaQueryAdaptor; optionally available to components
	     * who wish to use the MediaMonitor as mediaMonitor$ observable service.
	     *
	     * NOTE: if a mediaQuery is not specified, then ALL mediaQuery activations will
	     *       be announced.
	     */
	    MatchMedia.prototype.observe = function (mediaQuery) {
	        this.registerQuery(mediaQuery);
	        return this._observable$.filter(function (change) {
	            return mediaQuery ? (change.mediaQuery === mediaQuery) : true;
	        });
	    };
	    /**
	     * Based on the BreakPointRegistry provider, register internal listeners for each unique
	     * mediaQuery. Each listener emits specific MediaChange data to observers
	     */
	    MatchMedia.prototype.registerQuery = function (mediaQuery) {
	        var _this = this;
	        if (mediaQuery) {
	            var mql = this._registry.get(mediaQuery);
	            var onMQLEvent = function (e) {
	                _this._zone.run(function () {
	                    var change = new MediaChange(e.matches, mediaQuery);
	                    _this._source.next(change);
	                });
	            };
	            if (!mql) {
	                mql = this._buildMQL(mediaQuery);
	                mql.addListener(onMQLEvent);
	                this._registry.set(mediaQuery, mql);
	            }
	            if (mql.matches) {
	                onMQLEvent(mql); // Announce activate range for initial subscribers
	            }
	        }
	    };
	    /**
	     * Call window.matchMedia() to build a MediaQueryList; which
	     * supports 0..n listeners for activation/deactivation
	     */
	    MatchMedia.prototype._buildMQL = function (query) {
	        prepareQueryCSS(query);
	        var canListen = !!window.matchMedia('all').addListener;
	        return canListen ? window.matchMedia(query) : {
	            matches: query === 'all' || query === '',
	            media: query,
	            addListener: function () {
	            },
	            removeListener: function () {
	            }
	        };
	    };
	    MatchMedia = __decorate$3([
	        _angular_core.Injectable(), 
	        __metadata$3('design:paramtypes', [_angular_core.NgZone])
	    ], MatchMedia);
	    return MatchMedia;
	}());
	/**
	 * Private global registry for all dynamically-created, injected style tags
	 * @see prepare(query)
	 */
	var ALL_STYLES = {};
	/**
	 * For Webkit engines that only trigger the MediaQueryListListener
	 * when there is at least one CSS selector for the respective media query.
	 *
	 * @param query string The mediaQuery used to create a faux CSS selector
	 *
	 */
	function prepareQueryCSS(query) {
	    if (!ALL_STYLES[query]) {
	        try {
	            var style = document.createElement('style');
	            style.setAttribute('type', 'text/css');
	            if (!style['styleSheet']) {
	                var cssText = "@media " + query + " {.fx-query-test{ }}";
	                style.appendChild(document.createTextNode(cssText));
	            }
	            document.getElementsByTagName('head')[0].appendChild(style);
	            // Store in private global registry
	            ALL_STYLES[query] = style;
	        }
	        catch (e) {
	            console.error(e);
	        }
	    }
	}
	
	/**
	 * For the specified MediaChange, make sure it contains the breakpoint alias
	 * and suffix (if available).
	 */
	function mergeAlias(dest, source) {
	    return extendObject(dest, source ? {
	        mqAlias: source.alias,
	        suffix: source.suffix
	    } : {});
	}
	
	var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$1 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * MediaMonitor uses the MatchMedia service to observe mediaQuery changes (both activations and
	 * deactivations). These changes are are published as MediaChange notifications.
	 *
	 * Note: all notifications will be performed within the
	 * ng Zone to trigger change detections and component updates.
	 *
	 * It is the MediaMonitor that:
	 *  - auto registers all known breakpoints
	 *  - injects alias information into each raw MediaChange event
	 *  - provides accessor to the currently active BreakPoint
	 *  - publish list of overlapping BreakPoint(s); used by ResponsiveActivation
	 */
	var MediaMonitor = (function () {
	    function MediaMonitor(_breakpoints, _matchMedia) {
	        this._breakpoints = _breakpoints;
	        this._matchMedia = _matchMedia;
	        this._registerBreakpoints();
	    }
	    Object.defineProperty(MediaMonitor.prototype, "breakpoints", {
	        /**
	         * Read-only accessor to the list of breakpoints configured in the BreakPointRegistry provider
	         */
	        get: function () {
	            return this._breakpoints.items.slice();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MediaMonitor.prototype, "activeOverlaps", {
	        get: function () {
	            var _this = this;
	            var items = this._breakpoints.overlappings.reverse();
	            return items.filter(function (bp) {
	                return _this._matchMedia.isActive(bp.mediaQuery);
	            });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MediaMonitor.prototype, "active", {
	        get: function () {
	            var _this = this;
	            var found = null, items = this.breakpoints.reverse();
	            items.forEach(function (bp) {
	                if (bp.alias !== '') {
	                    if (!found && _this._matchMedia.isActive(bp.mediaQuery)) {
	                        found = bp;
	                    }
	                }
	            });
	            var first = this.breakpoints[0];
	            return found || (this._matchMedia.isActive(first.mediaQuery) ? first : null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * For the specified mediaQuery alias, is the mediaQuery range active?
	     */
	    MediaMonitor.prototype.isActive = function (alias) {
	        var bp = this._breakpoints.findByAlias(alias) || this._breakpoints.findByQuery(alias);
	        return this._matchMedia.isActive(bp ? bp.mediaQuery : alias);
	    };
	    /**
	     * External observers can watch for all (or a specific) mql changes.
	     * If specific breakpoint is observed, only return *activated* events
	     * otherwise return all events for BOTH activated + deactivated changes.
	     */
	    MediaMonitor.prototype.observe = function (alias) {
	        var bp = this._breakpoints.findByAlias(alias) || this._breakpoints.findByQuery(alias);
	        var hasAlias = function (change) { return (bp ? change.mqAlias !== "" : true); };
	        // Note: the raw MediaChange events [from MatchMedia] do not contain important alias information
	        return this._matchMedia
	            .observe(bp ? bp.mediaQuery : alias)
	            .map(function (change) { return mergeAlias(change, bp); })
	            .filter(hasAlias);
	    };
	    /**
	     * Immediate calls to matchMedia() to establish listeners
	     * and prepare for immediate subscription notifications
	     */
	    MediaMonitor.prototype._registerBreakpoints = function () {
	        var _this = this;
	        this._breakpoints.items.forEach(function (bp) {
	            _this._matchMedia.registerQuery(bp.mediaQuery);
	        });
	    };
	    MediaMonitor = __decorate$1([
	        _angular_core.Injectable(), 
	        __metadata$1('design:paramtypes', [BreakPointRegistry, MatchMedia])
	    ], MediaMonitor);
	    return MediaMonitor;
	}());
	
	var __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$5 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Base class for MediaService and pseudo-token for
	 */
	var ObservableMedia = (function () {
	    function ObservableMedia() {
	    }
	    return ObservableMedia;
	}());
	/**
	 * Class internalizes a MatchMedia service and exposes an Subscribable and Observable interface.
	
	 * This an Observable with that exposes a feature to subscribe to mediaQuery
	 * changes and a validator method (`isActive(<alias>)`) to test if a mediaQuery (or alias) is
	 * currently active.
	 *
	 * !! Only mediaChange activations (not de-activations) are announced by the ObservableMedia
	 *
	 * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange
	 * notification. For custom mediaQuery notifications, alias information will not be injected and
	 * those fields will be ''.
	 *
	 * !! This is not an actual Observable. It is a wrapper of an Observable used to publish additional
	 * methods like `isActive(<alias>). To access the Observable and use RxJS operators, use
	 * `.asObservable()` with syntax like media.asObservable().map(....).
	 *
	 *  @usage
	 *
	 *  // RxJS
	 *  import 'rxjs/add/operator/filter';
	 *  import { ObservableMedia } from '@angular/flex-layout';
	 *
	 *  @Component({ ... })
	 *  export class AppComponent {
	 *    status : string = '';
	 *
	 *    constructor(  media:ObservableMedia ) {
	 *      let onChange = (change:MediaChange) => {
	 *        this.status = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : "";
	 *      };
	 *
	 *      // Subscribe directly or access observable to use filter/map operators
	 *      // e.g.
	 *      //      media.subscribe(onChange);
	 *
	 *      media.asObservable()
	 *        .filter((change:MediaChange) => true)   // silly noop filter
	 *        .subscribe(onChange);
	 *    }
	 *  }
	 */
	var MediaService = (function () {
	    function MediaService(mediaWatcher, breakpoints) {
	        this.mediaWatcher = mediaWatcher;
	        this.breakpoints = breakpoints;
	        /**
	         * Should we announce gt-<xxx> breakpoint activations ?
	         */
	        this.filterOverlaps = true;
	        this.observable$ = this._buildObservable();
	        this._registerBreakPoints();
	    }
	    /**
	     * Test if specified query/alias is active.
	     */
	    MediaService.prototype.isActive = function (alias) {
	        var query = this._toMediaQuery(alias);
	        return this.mediaWatcher.isActive(query);
	    };
	    
	    /**
	     * Proxy to the Observable subscribe method
	     */
	    MediaService.prototype.subscribe = function (next, error, complete) {
	        return this.observable$.subscribe(next, error, complete);
	    };
	    
	    /**
	     * Access to observable for use with operators like
	     * .filter(), .map(), etc.
	     */
	    MediaService.prototype.asObservable = function () {
	        return this.observable$;
	    };
	    // ************************************************
	    // Internal Methods
	    // ************************************************
	    /**
	     * Register all the mediaQueries registered in the BreakPointRegistry
	     * This is needed so subscribers can be auto-notified of all standard, registered
	     * mediaQuery activations
	     */
	    MediaService.prototype._registerBreakPoints = function () {
	        var _this = this;
	        this.breakpoints.items.forEach(function (bp) {
	            _this.mediaWatcher.registerQuery(bp.mediaQuery);
	            return bp;
	        });
	    };
	    /**
	     * Prepare internal observable
	     * NOTE: the raw MediaChange events [from MatchMedia] do not contain important alias information
	     * these must be injected into the MediaChange
	     */
	    MediaService.prototype._buildObservable = function () {
	        var _this = this;
	        return this.mediaWatcher.observe()
	            .filter(function (change) {
	            // Only pass/announce activations (not de-activations)
	            return change.matches === true;
	        })
	            .map(function (change) {
	            // Inject associated (if any) alias information into the MediaChange event
	            return mergeAlias(change, _this._findByQuery(change.mediaQuery));
	        })
	            .filter(function (change) {
	            var bp = _this.breakpoints.findByQuery(change.mediaQuery);
	            return !bp ? true : !(_this.filterOverlaps && bp.overlapping);
	        });
	    };
	    /**
	     * Breakpoint locator by alias
	     */
	    MediaService.prototype._findByAlias = function (alias) {
	        return this.breakpoints.findByAlias(alias);
	    };
	    /**
	     * Breakpoint locator by mediaQuery
	     */
	    MediaService.prototype._findByQuery = function (query) {
	        return this.breakpoints.findByQuery(query);
	    };
	    
	    /**
	     * Find associated breakpoint (if any)
	     */
	    MediaService.prototype._toMediaQuery = function (query) {
	        var bp = this._findByAlias(query) || this._findByQuery(query);
	        return bp ? bp.mediaQuery : query;
	    };
	    
	    MediaService = __decorate$5([
	        _angular_core.Injectable(), 
	        __metadata$5('design:paramtypes', [MatchMedia, BreakPointRegistry])
	    ], MediaService);
	    return MediaService;
	}());
	/**
	 *  Provider to return observable to ALL MediaQuery events
	 *  Developers should build custom providers to override this default MediaQuery Observable
	 */
	var ObservableMediaProvider = {
	    provide: ObservableMedia,
	    useClass: MediaService,
	    deps: [MatchMedia, BreakPointRegistry]
	};
	
	var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$4 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * *****************************************************************
	 * Define module for the MediaQuery API
	 * *****************************************************************
	 */
	var MediaQueriesModule = (function () {
	    function MediaQueriesModule() {
	    }
	    MediaQueriesModule = __decorate$4([
	        _angular_core.NgModule({
	            providers: [
	                MatchMedia,
	                BreakPointsProvider,
	                BreakPointRegistry,
	                MediaMonitor,
	                ObservableMediaProvider // easy subscription injectable `media$` matchMedia observable
	            ]
	        }), 
	        __metadata$4('design:paramtypes', [])
	    ], MediaQueriesModule);
	    return MediaQueriesModule;
	}());
	
	var __extends$2 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$7 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];
	/**
	 * 'layout' flexbox styling directive
	 * Defines the positioning flow direction for the child elements: row or column
	 * Optional values: column or row (default)
	 * @see https://css-tricks.com/almanac/properties/f/flex-direction/
	 *
	 */
	var LayoutDirective = (function (_super) {
	    __extends$2(LayoutDirective, _super);
	    /**
	     *
	     */
	    function LayoutDirective(monitor, elRef, renderer) {
	        _super.call(this, monitor, elRef, renderer);
	        this._announcer = new rxjs_BehaviorSubject.BehaviorSubject("row");
	        this.layout$ = this._announcer.asObservable();
	    }
	    Object.defineProperty(LayoutDirective.prototype, "layout", {
	        set: function (val) { this._cacheInput("layout", val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutXs", {
	        set: function (val) { this._cacheInput('layoutXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutGtXs", {
	        set: function (val) { this._cacheInput('layoutGtXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutSm", {
	        set: function (val) { this._cacheInput('layoutSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutGtSm", {
	        set: function (val) { this._cacheInput('layoutGtSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutMd", {
	        set: function (val) { this._cacheInput('layoutMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutGtMd", {
	        set: function (val) { this._cacheInput('layoutGtMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutLg", {
	        set: function (val) { this._cacheInput('layoutLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutGtLg", {
	        set: function (val) { this._cacheInput('layoutGtLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutDirective.prototype, "layoutXl", {
	        set: function (val) { this._cacheInput('layoutXl', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    /**
	     * On changes to any @Input properties...
	     * Default to use the non-responsive Input value ('fxLayout')
	     * Then conditionally override with the mq-activated Input's current value
	     */
	    LayoutDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['layout'] != null || this._mqActivation) {
	            this._updateWithDirection();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    LayoutDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._listenForMediaQueryChanges('layout', 'row', function (changes) {
	            _this._updateWithDirection(changes.value);
	        });
	        this._updateWithDirection();
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    /**
	     * Validate the direction value and then update the host's inline flexbox styles
	     */
	    LayoutDirective.prototype._updateWithDirection = function (direction) {
	        direction = direction || this._queryInput("layout") || 'row';
	        if (this._mqActivation) {
	            direction = this._mqActivation.activatedInput;
	        }
	        direction = this._validateValue(direction);
	        // Update styles and announce to subscribers the *new* direction
	        this._applyStyleToElement(this._buildCSS(direction));
	        this._announcer.next(direction);
	    };
	    /**
	     * Build the CSS that should be assigned to the element instance
	     * BUG:
	     *
	     *   1) min-height on a column flex container wont apply to its flex item children in IE 10-11.
	     *      Use height instead if possible; height : <xxx>vh;
	     *
	     * @todo - update all child containers to have "box-sizing: border-box"
	     *         This way any padding or border specified on the child elements are
	     *         laid out and drawn inside that element's specified width and height.
	     *
	     */
	    LayoutDirective.prototype._buildCSS = function (value) {
	        return { 'display': 'flex', 'box-sizing': 'border-box', 'flex-direction': value };
	    };
	    /**
	     * Validate the value to be one of the acceptable value options
	     * Use default fallback of "row"
	     */
	    LayoutDirective.prototype._validateValue = function (value) {
	        value = value ? value.toLowerCase() : '';
	        return LAYOUT_VALUES.find(function (x) { return x === value; }) ? value : LAYOUT_VALUES[0]; // "row"
	    };
	    __decorate$7([
	        _angular_core.Input('fxLayout'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layout", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.xs'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutXs", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.gt-xs'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutGtXs", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.sm'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutSm", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.gt-sm'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutGtSm", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.md'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutMd", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.gt-md'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutGtMd", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.lg'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutLg", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.gt-lg'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutGtLg", null);
	    __decorate$7([
	        _angular_core.Input('fxLayout.xl'), 
	        __metadata$7('design:type', Object), 
	        __metadata$7('design:paramtypes', [Object])
	    ], LayoutDirective.prototype, "layoutXl", null);
	    LayoutDirective = __decorate$7([
	        _angular_core.Directive({ selector: "\n  [fxLayout],\n  [fxLayout.xs],\n  [fxLayout.gt-xs],\n  [fxLayout.sm],\n  [fxLayout.gt-sm],\n  [fxLayout.md],\n  [fxLayout.gt-md],\n  [fxLayout.lg],\n  [fxLayout.gt-lg],\n  [fxLayout.xl]\n" }), 
	        __metadata$7('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer])
	    ], LayoutDirective);
	    return LayoutDirective;
	}(BaseFxDirective));
	
	var __extends$3 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$8 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$8 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$2 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * 'layout-wrap' flexbox styling directive
	 * Defines wrapping of child elements in layout container
	 * Optional values: reverse, wrap-reverse, none, nowrap, wrap (default)]
	 * @see https://css-tricks.com/almanac/properties/f/flex-wrap/
	 */
	var LayoutWrapDirective = (function (_super) {
	    __extends$3(LayoutWrapDirective, _super);
	    function LayoutWrapDirective(monitor, elRef, renderer, container) {
	        _super.call(this, monitor, elRef, renderer);
	        this._layout = 'row'; // default flex-direction
	        if (container) {
	            this._layoutWatcher = container.layout$.subscribe(this._onLayoutChange.bind(this));
	        }
	    }
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrap", {
	        set: function (val) { this._cacheInput("wrap", val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapXs", {
	        set: function (val) { this._cacheInput('wrapXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapGtXs", {
	        set: function (val) { this._cacheInput('wrapGtXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapSm", {
	        set: function (val) { this._cacheInput('wrapSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapGtSm", {
	        set: function (val) { this._cacheInput('wrapGtSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapMd", {
	        set: function (val) { this._cacheInput('wrapMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapGtMd", {
	        set: function (val) { this._cacheInput('wrapGtMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapLg", {
	        set: function (val) { this._cacheInput('wrapLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapGtLg", {
	        set: function (val) { this._cacheInput('wrapGtLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutWrapDirective.prototype, "wrapXl", {
	        set: function (val) { this._cacheInput('wrapXl', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    LayoutWrapDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['wrap'] != null || this._mqActivation) {
	            this._updateWithValue();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    LayoutWrapDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._listenForMediaQueryChanges('wrap', 'wrap', function (changes) {
	            _this._updateWithValue(changes.value);
	        });
	        this._updateWithValue();
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    /**
	     * Cache the parent container 'flex-direction' and update the 'flex' styles
	     */
	    LayoutWrapDirective.prototype._onLayoutChange = function (direction) {
	        var _this = this;
	        this._layout = (direction || '').toLowerCase().replace('-reverse', '');
	        if (!LAYOUT_VALUES.find(function (x) { return x === _this._layout; })) {
	            this._layout = 'row';
	        }
	        this._updateWithValue();
	    };
	    LayoutWrapDirective.prototype._updateWithValue = function (value) {
	        value = value || this._queryInput("wrap") || 'wrap';
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        value = this._validateValue(value);
	        this._applyStyleToElement(this._buildCSS(value));
	    };
	    /**
	     * Build the CSS that should be assigned to the element instance
	     */
	    LayoutWrapDirective.prototype._buildCSS = function (value) {
	        return extendObject({ 'flex-wrap': value }, {
	            'display': 'flex',
	            'flex-direction': this._layout || 'row'
	        });
	    };
	    /**
	     * Convert layout-wrap="<value>" to expected flex-wrap style
	     */
	    LayoutWrapDirective.prototype._validateValue = function (value) {
	        switch (value.toLowerCase()) {
	            case 'reverse':
	            case 'wrap-reverse':
	                value = 'wrap-reverse';
	                break;
	            case 'no':
	            case 'none':
	            case 'nowrap':
	                value = 'nowrap';
	                break;
	            // All other values fallback to "wrap"
	            default:
	                value = 'wrap';
	                break;
	        }
	        return value;
	    };
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrap", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.xs'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapXs", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.gt-xs'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapGtXs", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.sm'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapSm", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.gt-sm'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapGtSm", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.md'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapMd", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.gt-md'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapGtMd", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.lg'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapLg", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.gt-lg'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapGtLg", null);
	    __decorate$8([
	        _angular_core.Input('fxLayoutWrap.xl'), 
	        __metadata$8('design:type', Object), 
	        __metadata$8('design:paramtypes', [Object])
	    ], LayoutWrapDirective.prototype, "wrapXl", null);
	    LayoutWrapDirective = __decorate$8([
	        _angular_core.Directive({ selector: "\n  [fxLayoutWrap],\n  [fxLayoutWrap.xs],\n  [fxLayoutWrap.gt-xs],\n  [fxLayoutWrap.sm],\n  [fxLayoutWrap.gt-sm],\n  [fxLayoutWrap.md],\n  [fxLayoutWrap.gt-md],\n  [fxLayoutWrap.lg],\n  [fxLayoutWrap.gt-lg],\n  [fxLayoutWrap.xl]\n" }),
	        __param$2(3, _angular_core.Optional()),
	        __param$2(3, _angular_core.Self()), 
	        __metadata$8('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer, LayoutDirective])
	    ], LayoutWrapDirective);
	    return LayoutWrapDirective;
	}(BaseFxDirective));
	
	var __extends$1 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$6 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Directive to control the size of a flex item using flex-basis, flex-grow, and flex-shrink.
	 * Corresponds to the css `flex` shorthand property.
	 *
	 * @see https://css-tricks.com/snippets/css/a-guide-to-flexbox/
	 */
	var FlexDirective = (function (_super) {
	    __extends$1(FlexDirective, _super);
	    // Explicitly @SkipSelf on LayoutDirective and LayoutWrapDirective because we want the
	    // parent flex container for this flex item.
	    function FlexDirective(monitor, elRef, renderer, _container, _wrap) {
	        var _this = this;
	        _super.call(this, monitor, elRef, renderer);
	        this._container = _container;
	        this._wrap = _wrap;
	        /** The flex-direction of this element's flex container. Defaults to 'row'. */
	        this._layout = 'row';
	        this._cacheInput("flex", "");
	        this._cacheInput("shrink", 1);
	        this._cacheInput("grow", 1);
	        if (_container) {
	            // If this flex item is inside of a flex container marked with
	            // Subscribe to layout immediate parent direction changes
	            this._layoutWatcher = _container.layout$.subscribe(function (direction) {
	                // `direction` === null if parent container does not have a `fxLayout`
	                _this._onLayoutChange(direction);
	            });
	        }
	    }
	    Object.defineProperty(FlexDirective.prototype, "flex", {
	        set: function (val) {
	            this._cacheInput("flex", val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexDirective.prototype, "shrink", {
	        set: function (val) {
	            this._cacheInput("shrink", val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexDirective.prototype, "grow", {
	        set: function (val) {
	            this._cacheInput("grow", val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexDirective.prototype, "flexXs", {
	        set: function (val) {
	            this._cacheInput('flexXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexDirective.prototype, "flexGtXs", {
	        set: function (val) {
	            this._cacheInput('flexGtXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexDirective.prototype, "flexSm", {
	        set: function (val) {
	            this._cacheInput('flexSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexDirective.prototype, "flexGtSm", {
	        set: function (val) {
	            this._cacheInput('flexGtSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexDirective.prototype, "flexMd", {
	        set: function (val) {
	            this._cacheInput('flexMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexDirective.prototype, "flexGtMd", {
	        set: function (val) {
	            this._cacheInput('flexGtMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexDirective.prototype, "flexLg", {
	        set: function (val) {
	            this._cacheInput('flexLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexDirective.prototype, "flexGtLg", {
	        set: function (val) {
	            this._cacheInput('flexGtLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexDirective.prototype, "flexXl", {
	        set: function (val) {
	            this._cacheInput('flexXl', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    /**
	     * For @Input changes on the current mq activation property, see onMediaQueryChanges()
	     */
	    FlexDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['flex'] != null || this._mqActivation) {
	            this._onLayoutChange();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    FlexDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._listenForMediaQueryChanges('flex', '', function (changes) {
	            _this._updateStyle(changes.value);
	        });
	        this._onLayoutChange();
	    };
	    FlexDirective.prototype.ngOnDestroy = function () {
	        _super.prototype.ngOnDestroy.call(this);
	        if (this._layoutWatcher) {
	            this._layoutWatcher.unsubscribe();
	        }
	    };
	    /**
	     * Caches the parent container's 'flex-direction' and updates the element's style.
	     * Used as a handler for layout change events from the parent flex container.
	     */
	    FlexDirective.prototype._onLayoutChange = function (direction) {
	        this._layout = direction || this._layout || "row";
	        this._updateStyle();
	    };
	    FlexDirective.prototype._updateStyle = function (value) {
	        var flexBasis = value || this._queryInput("flex") || '';
	        if (this._mqActivation) {
	            flexBasis = this._mqActivation.activatedInput;
	        }
	        this._applyStyleToElement(this._validateValue.apply(this, this._parseFlexParts(String(flexBasis))));
	    };
	    /**
	     * If the used the short-form `fxFlex="1 0 37%"`, then parse the parts
	     */
	    FlexDirective.prototype._parseFlexParts = function (basis) {
	        basis = basis.replace(";", "");
	        var hasCalc = basis && basis.indexOf("calc") > -1;
	        var matches = !hasCalc ? basis.split(" ") : this._getPartsWithCalc(basis.trim());
	        return (matches.length === 3) ? matches : [this._queryInput("grow"),
	            this._queryInput("shrink"), basis];
	    };
	    /**
	     * Extract more complicated short-hand versions.
	     * e.g.
	     * fxFlex="3 3 calc(15em + 20px)"
	     */
	    FlexDirective.prototype._getPartsWithCalc = function (value) {
	        var parts = [this._queryInput("grow"), this._queryInput("shrink"), value];
	        var j = value.indexOf('calc');
	        if (j > 0) {
	            parts[2] = value.substring(j);
	            var matches = value.substr(0, j).trim().split(" ");
	            if (matches.length == 2) {
	                parts[0] = matches[0];
	                parts[1] = matches[1];
	            }
	        }
	        return parts;
	    };
	    /**
	     * Validate the value to be one of the acceptable value options
	     * Use default fallback of "row"
	     */
	    FlexDirective.prototype._validateValue = function (grow, shrink, basis) {
	        var css, isValue;
	        var direction = (this._layout === 'column') || (this._layout == 'column-reverse') ?
	            'column' :
	            'row';
	        if (grow == "0") {
	            grow = 0;
	        }
	        if (shrink == "0") {
	            shrink = 0;
	        }
	        // flex-basis allows you to specify the initial/starting main-axis size of the element,
	        // before anything else is computed. It can either be a percentage or an absolute value.
	        // It is, however, not the breaking point for flex-grow/shrink properties
	        //
	        // flex-grow can be seen as this:
	        //   0: Do not stretch. Either size to element's content width, or obey 'flex-basis'.
	        //   1: (Default value). Stretch; will be the same size to all other flex items on
	        //       the same row since they have a default value of 1.
	        //   2 (integer n): Stretch. Will be n times the size of other elements
	        //      with 'flex-grow: 1' on the same row.
	        // Use `null` to clear existing styles.
	        var clearStyles = {
	            'max-width': null,
	            'max-height': null,
	            'min-width': null,
	            'min-height': null
	        };
	        switch (basis || '') {
	            case '':
	                css = extendObject(clearStyles, { 'flex': '1 1 0.000000001px' });
	                break;
	            case 'initial': // default
	            case 'nogrow':
	                grow = 0;
	                css = extendObject(clearStyles, { 'flex': '0 1 auto' });
	                break;
	            case 'grow':
	                css = extendObject(clearStyles, { 'flex': '1 1 100%' });
	                break;
	            case 'noshrink':
	                shrink = 0;
	                css = extendObject(clearStyles, { 'flex': '1 0 auto' });
	                break;
	            case 'auto':
	                css = extendObject(clearStyles, { 'flex': grow + " " + shrink + " auto" });
	                break;
	            case 'none':
	                grow = 0;
	                shrink = 0;
	                css = extendObject(clearStyles, { 'flex': '0 0 auto' });
	                break;
	            default:
	                var isPercent = String(basis).indexOf('%') > -1;
	                isValue = String(basis).indexOf('px') > -1 ||
	                    String(basis).indexOf('calc') > -1 ||
	                    String(basis).indexOf('em') > -1 ||
	                    String(basis).indexOf('vw') > -1 ||
	                    String(basis).indexOf('vh') > -1;
	                // Defaults to percentage sizing unless `px` is explicitly set
	                if (!isValue && !isPercent && !isNaN(basis)) {
	                    basis = basis + '%';
	                }
	                if (basis === '0px') {
	                    basis = '0%';
	                }
	                // Set max-width = basis if using layout-wrap
	                // tslint:disable-next-line:max-line-length
	                // @see https://github.com/philipwalton/flexbugs#11-min-and-max-size-declarations-are-ignored-when-wrappifl-flex-items
	                css = extendObject(clearStyles, {
	                    'flex': grow + " " + shrink + " " + ((isValue || this._wrap) ? basis : '100%'),
	                });
	                break;
	        }
	        var max = (direction === 'row') ? 'max-width' : 'max-height';
	        var min = (direction === 'row') ? 'min-width' : 'min-height';
	        var usingCalc = (String(basis).indexOf('calc') > -1) || (basis == 'auto');
	        var isPx = String(basis).indexOf('px') > -1 || usingCalc;
	        // make box inflexible when shrink and grow are both zero
	        // should not set a min when the grow is zero
	        // should not set a max when the shrink is zero
	        var isFixed = !grow && !shrink;
	        css[min] = (basis == '0%') ? 0 : isFixed || (isPx && grow) ? basis : null;
	        css[max] = (basis == '0%') ? 0 : isFixed || (!usingCalc && shrink) ? basis : null;
	        return extendObject(css, { 'box-sizing': 'border-box' });
	    };
	    __decorate$6([
	        _angular_core.Input('fxFlex'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flex", null);
	    __decorate$6([
	        _angular_core.Input('fxShrink'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "shrink", null);
	    __decorate$6([
	        _angular_core.Input('fxGrow'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "grow", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.xs'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexXs", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.gt-xs'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexGtXs", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.sm'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexSm", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.gt-sm'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexGtSm", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.md'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexMd", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.gt-md'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexGtMd", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.lg'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexLg", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.gt-lg'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexGtLg", null);
	    __decorate$6([
	        _angular_core.Input('fxFlex.xl'), 
	        __metadata$6('design:type', Object), 
	        __metadata$6('design:paramtypes', [Object])
	    ], FlexDirective.prototype, "flexXl", null);
	    FlexDirective = __decorate$6([
	        _angular_core.Directive({ selector: "\n  [fxFlex],\n  [fxFlex.xs],\n  [fxFlex.gt-xs],\n  [fxFlex.sm],\n  [fxFlex.gt-sm],\n  [fxFlex.md],\n  [fxFlex.gt-md],\n  [fxFlex.lg],\n  [fxFlex.gt-lg],\n  [fxFlex.xl]\n"
	        }),
	        __param$1(3, _angular_core.Optional()),
	        __param$1(3, _angular_core.SkipSelf()),
	        __param$1(4, _angular_core.Optional()),
	        __param$1(4, _angular_core.SkipSelf()), 
	        __metadata$6('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer, LayoutDirective, LayoutWrapDirective])
	    ], FlexDirective);
	    return FlexDirective;
	}(BaseFxDirective));
	
	var __extends$4 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$9 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$9 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$3 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var FALSY = ['false', false, 0];
	/**
	 * For fxHide selectors, we invert the 'value'
	 * and assign to the equivalent fxShow selector cache
	 *  - When 'hide' === '' === true, do NOT show the element
	 *  - When 'hide' === false or 0... we WILL show the element
	 */
	function negativeOf(hide) {
	    return (hide === "") ? false :
	        ((hide === "false") || (hide === 0)) ? true : !hide;
	}
	/**
	 * 'show' Layout API directive
	 *
	 */
	var ShowHideDirective = (function (_super) {
	    __extends$4(ShowHideDirective, _super);
	    /**
	     *
	     */
	    function ShowHideDirective(monitor, _layout, elRef, renderer) {
	        var _this = this;
	        _super.call(this, monitor, elRef, renderer);
	        this._layout = _layout;
	        this.elRef = elRef;
	        this.renderer = renderer;
	        this._display = this._getDisplayStyle(); // re-invoke override to use `this._layout`
	        if (_layout) {
	            /**
	             * The Layout can set the display:flex (and incorrectly affect the Hide/Show directives.
	             * Whenever Layout [on the same element] resets its CSS, then update the Hide/Show CSS
	             */
	            this._layoutWatcher = _layout.layout$.subscribe(function () { return _this._updateWithValue(); });
	        }
	    }
	    Object.defineProperty(ShowHideDirective.prototype, "show", {
	        set: function (val) {
	            this._cacheInput("show", val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShowHideDirective.prototype, "hide", {
	        set: function (val) {
	            this._cacheInput("show", negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShowHideDirective.prototype, "showXs", {
	        set: function (val) {
	            this._cacheInput('showXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShowHideDirective.prototype, "hideXs", {
	        set: function (val) {
	            this._cacheInput("showXs", negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShowHideDirective.prototype, "showGtXs", {
	        set: function (val) {
	            this._cacheInput('showGtXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideGtXs", {
	        set: function (val) {
	            this._cacheInput('showGtXs', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "showSm", {
	        set: function (val) {
	            this._cacheInput('showSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideSm", {
	        set: function (val) {
	            this._cacheInput('showSm', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "showGtSm", {
	        set: function (val) {
	            this._cacheInput('showGtSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideGtSm", {
	        set: function (val) {
	            this._cacheInput('showGtSm', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "showMd", {
	        set: function (val) {
	            this._cacheInput('showMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideMd", {
	        set: function (val) {
	            this._cacheInput('showMd', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "showGtMd", {
	        set: function (val) {
	            this._cacheInput('showGtMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideGtMd", {
	        set: function (val) {
	            this._cacheInput('showGtMd', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "showLg", {
	        set: function (val) {
	            this._cacheInput('showLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideLg", {
	        set: function (val) {
	            this._cacheInput('showLg', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "showGtLg", {
	        set: function (val) {
	            this._cacheInput('showGtLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideGtLg", {
	        set: function (val) {
	            this._cacheInput('showGtLg', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "showXl", {
	        set: function (val) {
	            this._cacheInput('showXl', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ShowHideDirective.prototype, "hideXl", {
	        set: function (val) {
	            this._cacheInput('showXl', negativeOf(val));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    /**
	     * Override accessor to the current HTMLElement's `display` style
	     * Note: Show/Hide will not change the display to 'flex' but will set it to 'block'
	     * unless it was already explicitly defined.
	     */
	    ShowHideDirective.prototype._getDisplayStyle = function () {
	        return this._layout ? "flex" : _super.prototype._getDisplayStyle.call(this);
	    };
	    /**
	     * On changes to any @Input properties...
	     * Default to use the non-responsive Input value ('fxShow')
	     * Then conditionally override with the mq-activated Input's current value
	     */
	    ShowHideDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['show'] != null || this._mqActivation) {
	            this._updateWithValue();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    ShowHideDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        var value = this._getDefaultVal("show", true);
	        // Build _mqActivation controller
	        this._listenForMediaQueryChanges('show', value, function (changes) {
	            _this._updateWithValue(changes.value);
	        });
	        this._updateWithValue();
	    };
	    ShowHideDirective.prototype.ngOnDestroy = function () {
	        _super.prototype.ngOnDestroy.call(this);
	        if (this._layoutWatcher) {
	            this._layoutWatcher.unsubscribe();
	        }
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    /** Validate the visibility value and then update the host's inline display style */
	    ShowHideDirective.prototype._updateWithValue = function (value) {
	        value = value || this._getDefaultVal("show", true);
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        var shouldShow = this._validateTruthy(value);
	        this._applyStyleToElement(this._buildCSS(shouldShow));
	    };
	    /** Build the CSS that should be assigned to the element instance */
	    ShowHideDirective.prototype._buildCSS = function (show) {
	        return { 'display': show ? this._display : 'none' };
	    };
	    /**  Validate the to be not FALSY */
	    ShowHideDirective.prototype._validateTruthy = function (show) {
	        return (FALSY.indexOf(show) == -1);
	    };
	    __decorate$9([
	        _angular_core.Input('fxShow'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "show", null);
	    __decorate$9([
	        _angular_core.Input('fxHide'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hide", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.xs'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showXs", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.xs'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideXs", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.gt-xs'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showGtXs", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.gt-xs'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideGtXs", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.sm'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showSm", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.sm'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideSm", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.gt-sm'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showGtSm", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.gt-sm'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideGtSm", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.md'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showMd", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.md'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideMd", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.gt-md'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showGtMd", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.gt-md'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideGtMd", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.lg'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showLg", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.lg'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideLg", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.gt-lg'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showGtLg", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.gt-lg'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideGtLg", null);
	    __decorate$9([
	        _angular_core.Input('fxShow.xl'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "showXl", null);
	    __decorate$9([
	        _angular_core.Input('fxHide.xl'), 
	        __metadata$9('design:type', Object), 
	        __metadata$9('design:paramtypes', [Object])
	    ], ShowHideDirective.prototype, "hideXl", null);
	    ShowHideDirective = __decorate$9([
	        _angular_core.Directive({
	            selector: "\n  [fxShow],\n  [fxShow.xs],[fxShow.gt-xs],[fxShow.sm],[fxShow.gt-sm],\n  [fxShow.md],[fxShow.gt-md],[fxShow.lg],[fxShow.gt-lg],[fxShow.xl],  \n  [fxHide],\n  [fxHide.xs],[fxHide.gt-xs],[fxHide.sm],[fxHide.gt-sm],\n  [fxHide.md],[fxHide.gt-md],[fxHide.lg],[fxHide.gt-lg],[fxHide.xl]  \n"
	        }),
	        __param$3(1, _angular_core.Optional()),
	        __param$3(1, _angular_core.Self()), 
	        __metadata$9('design:paramtypes', [MediaMonitor, LayoutDirective, _angular_core.ElementRef, _angular_core.Renderer])
	    ], ShowHideDirective);
	    return ShowHideDirective;
	}(BaseFxDirective));
	
	var __extends$5 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$10 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$10 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * 'flex-align' flexbox styling directive
	 * Allows element-specific overrides for cross-axis alignments in a layout container
	 * @see https://css-tricks.com/almanac/properties/a/align-self/
	 */
	var FlexAlignDirective = (function (_super) {
	    __extends$5(FlexAlignDirective, _super);
	    function FlexAlignDirective(monitor, elRef, renderer) {
	        _super.call(this, monitor, elRef, renderer);
	    }
	    Object.defineProperty(FlexAlignDirective.prototype, "align", {
	        set: function (val) {
	            this._cacheInput('align', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexAlignDirective.prototype, "alignXs", {
	        set: function (val) {
	            this._cacheInput('alignXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexAlignDirective.prototype, "alignGtXs", {
	        set: function (val) {
	            this._cacheInput('alignGtXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexAlignDirective.prototype, "alignSm", {
	        set: function (val) {
	            this._cacheInput('alignSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexAlignDirective.prototype, "alignGtSm", {
	        set: function (val) {
	            this._cacheInput('alignGtSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexAlignDirective.prototype, "alignMd", {
	        set: function (val) {
	            this._cacheInput('alignMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexAlignDirective.prototype, "alignGtMd", {
	        set: function (val) {
	            this._cacheInput('alignGtMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexAlignDirective.prototype, "alignLg", {
	        set: function (val) {
	            this._cacheInput('alignLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexAlignDirective.prototype, "alignGtLg", {
	        set: function (val) {
	            this._cacheInput('alignGtLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexAlignDirective.prototype, "alignXl", {
	        set: function (val) {
	            this._cacheInput('alignXl', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    /**
	     * For @Input changes on the current mq activation property, see onMediaQueryChanges()
	     */
	    FlexAlignDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['align'] != null || this._mqActivation) {
	            this._updateWithValue();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    FlexAlignDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._listenForMediaQueryChanges('align', 'stretch', function (changes) {
	            _this._updateWithValue(changes.value);
	        });
	        this._updateWithValue();
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    FlexAlignDirective.prototype._updateWithValue = function (value) {
	        value = value || this._queryInput("align") || 'stretch';
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        this._applyStyleToElement(this._buildCSS(value));
	    };
	    FlexAlignDirective.prototype._buildCSS = function (align) {
	        var css = {};
	        // Cross-axis
	        switch (align) {
	            case 'start':
	                css['align-self'] = 'flex-start';
	                break;
	            case 'end':
	                css['align-self'] = 'flex-end';
	                break;
	            default:
	                css['align-self'] = align;
	                break;
	        }
	        return css;
	    };
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "align", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.xs'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignXs", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.gt-xs'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignGtXs", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.sm'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignSm", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.gt-sm'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignGtSm", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.md'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignMd", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.gt-md'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignGtMd", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.lg'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignLg", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.gt-lg'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignGtLg", null);
	    __decorate$10([
	        _angular_core.Input('fxFlexAlign.xl'), 
	        __metadata$10('design:type', Object), 
	        __metadata$10('design:paramtypes', [Object])
	    ], FlexAlignDirective.prototype, "alignXl", null);
	    FlexAlignDirective = __decorate$10([
	        _angular_core.Directive({
	            selector: "\n  [fxFlexAlign],\n  [fxFlexAlign.xs],\n  [fxFlexAlign.gt-xs],\n  [fxFlexAlign.sm],\n  [fxFlexAlign.gt-sm],\n  [fxFlexAlign.md],\n  [fxFlexAlign.gt-md],\n  [fxFlexAlign.lg],\n  [fxFlexAlign.gt-lg],\n  [fxFlexAlign.xl]\n"
	        }), 
	        __metadata$10('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer])
	    ], FlexAlignDirective);
	    return FlexAlignDirective;
	}(BaseFxDirective));
	
	var __extends$6 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$11 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$11 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var FLEX_FILL_CSS = {
	    'margin': 0,
	    'width': '100%',
	    'height': '100%',
	    'min-width': '100%',
	    'min-height': '100%'
	};
	/**
	 * 'fxFill' flexbox styling directive
	 *  Maximizes width and height of element in a layout container
	 *
	 *  NOTE: fxFill is NOT responsive API!!
	 */
	var FlexFillDirective = (function (_super) {
	    __extends$6(FlexFillDirective, _super);
	    function FlexFillDirective(monitor, elRef, renderer) {
	        _super.call(this, monitor, elRef, renderer);
	        this.elRef = elRef;
	        this.renderer = renderer;
	        this._applyStyleToElement(FLEX_FILL_CSS);
	    }
	    FlexFillDirective = __decorate$11([
	        _angular_core.Directive({ selector: "\n  [fxFill],\n  [fxFlexFill]\n" }), 
	        __metadata$11('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer])
	    ], FlexFillDirective);
	    return FlexFillDirective;
	}(BaseFxDirective));
	
	var __extends$7 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$12 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$12 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * 'flex-offset' flexbox styling directive
	 * Configures the 'margin-left' of the element in a layout container
	 */
	var FlexOffsetDirective = (function (_super) {
	    __extends$7(FlexOffsetDirective, _super);
	    function FlexOffsetDirective(monitor, elRef, renderer) {
	        _super.call(this, monitor, elRef, renderer);
	    }
	    Object.defineProperty(FlexOffsetDirective.prototype, "offset", {
	        set: function (val) { this._cacheInput('offset', val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetXs", {
	        set: function (val) { this._cacheInput('offsetXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetGtXs", {
	        set: function (val) { this._cacheInput('offsetGtXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetSm", {
	        set: function (val) { this._cacheInput('offsetSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetGtSm", {
	        set: function (val) { this._cacheInput('offsetGtSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetMd", {
	        set: function (val) { this._cacheInput('offsetMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetGtMd", {
	        set: function (val) { this._cacheInput('offsetGtMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetLg", {
	        set: function (val) { this._cacheInput('offsetLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetGtLg", {
	        set: function (val) { this._cacheInput('offsetGtLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOffsetDirective.prototype, "offsetXl", {
	        set: function (val) { this._cacheInput('offsetXl', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    /**
	     * For @Input changes on the current mq activation property, see onMediaQueryChanges()
	     */
	    FlexOffsetDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['offset'] != null || this._mqActivation) {
	            this._updateWithValue();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    FlexOffsetDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._listenForMediaQueryChanges('offset', 0, function (changes) {
	            _this._updateWithValue(changes.value);
	        });
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    FlexOffsetDirective.prototype._updateWithValue = function (value) {
	        value = value || this._queryInput("offset") || 0;
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        this._applyStyleToElement(this._buildCSS(value));
	    };
	    FlexOffsetDirective.prototype._buildCSS = function (offset) {
	        var isPercent = String(offset).indexOf('%') > -1;
	        var isPx = String(offset).indexOf('px') > -1;
	        if (!isPx && !isPercent && !isNaN(offset)) {
	            offset = offset + '%';
	        }
	        return { 'margin-left': "" + offset };
	    };
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offset", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.xs'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetXs", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.gt-xs'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetGtXs", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.sm'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetSm", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.gt-sm'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetGtSm", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.md'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetMd", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.gt-md'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetGtMd", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.lg'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetLg", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.gt-lg'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetGtLg", null);
	    __decorate$12([
	        _angular_core.Input('fxFlexOffset.xl'), 
	        __metadata$12('design:type', Object), 
	        __metadata$12('design:paramtypes', [Object])
	    ], FlexOffsetDirective.prototype, "offsetXl", null);
	    FlexOffsetDirective = __decorate$12([
	        _angular_core.Directive({ selector: "\n  [fxFlexOffset],\n  [fxFlexOffset.xs],\n  [fxFlexOffset.gt-xs],\n  [fxFlexOffset.sm],\n  [fxFlexOffset.gt-sm],\n  [fxFlexOffset.md],\n  [fxFlexOffset.gt-md],\n  [fxFlexOffset.lg],\n  [fxFlexOffset.gt-lg],\n  [fxFlexOffset.xl]\n" }), 
	        __metadata$12('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer])
	    ], FlexOffsetDirective);
	    return FlexOffsetDirective;
	}(BaseFxDirective));
	
	var __extends$8 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$13 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$13 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * 'flex-order' flexbox styling directive
	 * Configures the positional ordering of the element in a sorted layout container
	 * @see https://css-tricks.com/almanac/properties/o/order/
	 */
	var FlexOrderDirective = (function (_super) {
	    __extends$8(FlexOrderDirective, _super);
	    function FlexOrderDirective(monitor, elRef, renderer) {
	        _super.call(this, monitor, elRef, renderer);
	    }
	    Object.defineProperty(FlexOrderDirective.prototype, "order", {
	        set: function (val) { this._cacheInput('order', val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexOrderDirective.prototype, "orderXs", {
	        set: function (val) { this._cacheInput('orderXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FlexOrderDirective.prototype, "orderGtXs", {
	        set: function (val) { this._cacheInput('orderGtXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOrderDirective.prototype, "orderSm", {
	        set: function (val) { this._cacheInput('orderSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOrderDirective.prototype, "orderGtSm", {
	        set: function (val) { this._cacheInput('orderGtSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOrderDirective.prototype, "orderMd", {
	        set: function (val) { this._cacheInput('orderMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOrderDirective.prototype, "orderGtMd", {
	        set: function (val) { this._cacheInput('orderGtMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOrderDirective.prototype, "orderLg", {
	        set: function (val) { this._cacheInput('orderLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOrderDirective.prototype, "orderGtLg", {
	        set: function (val) { this._cacheInput('orderGtLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(FlexOrderDirective.prototype, "orderXl", {
	        set: function (val) { this._cacheInput('orderXl', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    /**
	     * For @Input changes on the current mq activation property, see onMediaQueryChanges()
	     */
	    FlexOrderDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['order'] != null || this._mqActivation) {
	            this._updateWithValue();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    FlexOrderDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._listenForMediaQueryChanges('order', '0', function (changes) {
	            _this._updateWithValue(changes.value);
	        });
	        this._updateWithValue();
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    FlexOrderDirective.prototype._updateWithValue = function (value) {
	        value = value || this._queryInput("order") || '0';
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        this._applyStyleToElement(this._buildCSS(value));
	    };
	    FlexOrderDirective.prototype._buildCSS = function (value) {
	        value = parseInt(value, 10);
	        return { order: isNaN(value) ? 0 : value };
	    };
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "order", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.xs'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderXs", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.gt-xs'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderGtXs", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.sm'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderSm", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.gt-sm'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderGtSm", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.md'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderMd", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.gt-md'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderGtMd", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.lg'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderLg", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.gt-lg'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderGtLg", null);
	    __decorate$13([
	        _angular_core.Input('fxFlexOrder.xl'), 
	        __metadata$13('design:type', Object), 
	        __metadata$13('design:paramtypes', [Object])
	    ], FlexOrderDirective.prototype, "orderXl", null);
	    FlexOrderDirective = __decorate$13([
	        _angular_core.Directive({ selector: "\n  [fxFlexOrder],\n  [fxFlexOrder.xs],\n  [fxFlexOrder.gt-xs],\n  [fxFlexOrder.sm],\n  [fxFlexOrder.gt-sm],\n  [fxFlexOrder.md],\n  [fxFlexOrder.gt-md],\n  [fxFlexOrder.lg],\n  [fxFlexOrder.gt-lg],\n  [fxFlexOrder.xl]\n" }), 
	        __metadata$13('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer])
	    ], FlexOrderDirective);
	    return FlexOrderDirective;
	}(BaseFxDirective));
	
	var __extends$9 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$14 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$14 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$4 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * 'layout-align' flexbox styling directive
	 *  Defines positioning of child elements along main and cross axis in a layout container
	 *  Optional values: {main-axis} values or {main-axis cross-axis} value pairs
	 *
	 *  @see https://css-tricks.com/almanac/properties/j/justify-content/
	 *  @see https://css-tricks.com/almanac/properties/a/align-items/
	 *  @see https://css-tricks.com/almanac/properties/a/align-content/
	 */
	var LayoutAlignDirective = (function (_super) {
	    __extends$9(LayoutAlignDirective, _super);
	    function LayoutAlignDirective(monitor, elRef, renderer, container) {
	        _super.call(this, monitor, elRef, renderer);
	        this._layout = 'row'; // default flex-direction
	        if (container) {
	            this._layoutWatcher = container.layout$.subscribe(this._onLayoutChange.bind(this));
	        }
	    }
	    Object.defineProperty(LayoutAlignDirective.prototype, "align", {
	        set: function (val) { this._cacheInput('align', val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignXs", {
	        set: function (val) { this._cacheInput('alignXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignGtXs", {
	        set: function (val) { this._cacheInput('alignGtXs', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignSm", {
	        set: function (val) { this._cacheInput('alignSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignGtSm", {
	        set: function (val) { this._cacheInput('alignGtSm', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignMd", {
	        set: function (val) { this._cacheInput('alignMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignGtMd", {
	        set: function (val) { this._cacheInput('alignGtMd', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignLg", {
	        set: function (val) { this._cacheInput('alignLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignGtLg", {
	        set: function (val) { this._cacheInput('alignGtLg', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutAlignDirective.prototype, "alignXl", {
	        set: function (val) { this._cacheInput('alignXl', val); },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    LayoutAlignDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['align'] != null || this._mqActivation) {
	            this._updateWithValue();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    LayoutAlignDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._listenForMediaQueryChanges('align', 'start stretch', function (changes) {
	            _this._updateWithValue(changes.value);
	        });
	        this._updateWithValue();
	    };
	    LayoutAlignDirective.prototype.ngOnDestroy = function () {
	        _super.prototype.ngOnDestroy.call(this);
	        if (this._layoutWatcher) {
	            this._layoutWatcher.unsubscribe();
	        }
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    /**
	     *
	     */
	    LayoutAlignDirective.prototype._updateWithValue = function (value) {
	        value = value || this._queryInput("align") || 'start stretch';
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        this._applyStyleToElement(this._buildCSS(value));
	        this._allowStretching(value, !this._layout ? "row" : this._layout);
	    };
	    /**
	     * Cache the parent container 'flex-direction' and update the 'flex' styles
	     */
	    LayoutAlignDirective.prototype._onLayoutChange = function (direction) {
	        var _this = this;
	        this._layout = (direction || '').toLowerCase();
	        if (!LAYOUT_VALUES.find(function (x) { return x === _this._layout; })) {
	            this._layout = 'row';
	        }
	        var value = this._queryInput("align") || 'start stretch';
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        this._allowStretching(value, this._layout || "row");
	    };
	    LayoutAlignDirective.prototype._buildCSS = function (align) {
	        var css = {}, _a = align.split(' '), main_axis = _a[0], cross_axis = _a[1]; // tslint:disable-line:variable-name
	        css['justify-content'] = 'flex-start'; // default main axis
	        css['align-items'] = 'stretch'; // default cross axis
	        css['align-content'] = 'stretch'; // default cross axis
	        // Main axis
	        switch (main_axis) {
	            case 'center':
	                css['justify-content'] = 'center';
	                break;
	            case 'space-around':
	                css['justify-content'] = 'space-around';
	                break;
	            case 'space-between':
	                css['justify-content'] = 'space-between';
	                break;
	            case 'end':
	                css['justify-content'] = 'flex-end';
	                break;
	        }
	        // Cross-axis
	        switch (cross_axis) {
	            case 'start':
	                css['align-items'] = css['align-content'] = 'flex-start';
	                break;
	            case 'baseline':
	                css['align-items'] = 'baseline';
	                break;
	            case 'center':
	                css['align-items'] = css['align-content'] = 'center';
	                break;
	            case 'end':
	                css['align-items'] = css['align-content'] = 'flex-end';
	                break;
	            default:
	                break;
	        }
	        return extendObject(css, {
	            'display': 'flex',
	            'flex-direction': this._layout || "row",
	            'box-sizing': 'border-box'
	        });
	    };
	    /**
	     * Update container element to 'stretch' as needed...
	     * NOTE: this is only done if the crossAxis is explicitly set to 'stretch'
	     */
	    LayoutAlignDirective.prototype._allowStretching = function (align, layout) {
	        var _a = align.split(' '), cross_axis = _a[1]; // tslint:disable-line:variable-name
	        if (cross_axis == 'stretch') {
	            // Use `null` values to remove style
	            this._applyStyleToElement({
	                'box-sizing': 'border-box',
	                'max-width': (layout === 'column') ? '100%' : null,
	                'max-height': (layout === 'row') ? '100%' : null
	            });
	        }
	    };
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "align", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.xs'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignXs", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.gt-xs'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignGtXs", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.sm'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignSm", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.gt-sm'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignGtSm", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.md'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignMd", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.gt-md'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignGtMd", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.lg'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignLg", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.gt-lg'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignGtLg", null);
	    __decorate$14([
	        _angular_core.Input('fxLayoutAlign.xl'), 
	        __metadata$14('design:type', Object), 
	        __metadata$14('design:paramtypes', [Object])
	    ], LayoutAlignDirective.prototype, "alignXl", null);
	    LayoutAlignDirective = __decorate$14([
	        _angular_core.Directive({ selector: "\n  [fxLayoutAlign],\n  [fxLayoutAlign.xs],\n  [fxLayoutAlign.gt-xs],\n  [fxLayoutAlign.sm],\n  [fxLayoutAlign.gt-sm],\n  [fxLayoutAlign.md],\n  [fxLayoutAlign.gt-md],\n  [fxLayoutAlign.lg],\n  [fxLayoutAlign.gt-lg],\n  [fxLayoutAlign.xl]\n" }),
	        __param$4(3, _angular_core.Optional()),
	        __param$4(3, _angular_core.Self()), 
	        __metadata$14('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer, LayoutDirective])
	    ], LayoutAlignDirective);
	    return LayoutAlignDirective;
	}(BaseFxDirective));
	
	var __extends$10 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$15 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$15 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$5 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * 'layout-padding' styling directive
	 *  Defines padding of child elements in a layout container
	 */
	var LayoutGapDirective = (function (_super) {
	    __extends$10(LayoutGapDirective, _super);
	    function LayoutGapDirective(monitor, elRef, renderer, container) {
	        _super.call(this, monitor, elRef, renderer);
	        this._layout = 'row'; // default flex-direction
	        if (container) {
	            this._layoutWatcher = container.layout$.subscribe(this._onLayoutChange.bind(this));
	        }
	    }
	    Object.defineProperty(LayoutGapDirective.prototype, "gap", {
	        set: function (val) {
	            this._cacheInput('gap', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LayoutGapDirective.prototype, "gapXs", {
	        set: function (val) {
	            this._cacheInput('gapXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LayoutGapDirective.prototype, "gapGtXs", {
	        set: function (val) {
	            this._cacheInput('gapGtXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutGapDirective.prototype, "gapSm", {
	        set: function (val) {
	            this._cacheInput('gapSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutGapDirective.prototype, "gapGtSm", {
	        set: function (val) {
	            this._cacheInput('gapGtSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutGapDirective.prototype, "gapMd", {
	        set: function (val) {
	            this._cacheInput('gapMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutGapDirective.prototype, "gapGtMd", {
	        set: function (val) {
	            this._cacheInput('gapGtMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutGapDirective.prototype, "gapLg", {
	        set: function (val) {
	            this._cacheInput('gapLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutGapDirective.prototype, "gapGtLg", {
	        set: function (val) {
	            this._cacheInput('gapGtLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(LayoutGapDirective.prototype, "gapXl", {
	        set: function (val) {
	            this._cacheInput('gapXl', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    // *********************************************
	    // Lifecycle Methods
	    // *********************************************
	    LayoutGapDirective.prototype.ngOnChanges = function (changes) {
	        if (changes['gap'] != null || this._mqActivation) {
	            this._updateWithValue();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    LayoutGapDirective.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._watchContentChanges();
	        this._listenForMediaQueryChanges('gap', '0', function (changes) {
	            _this._updateWithValue(changes.value);
	        });
	        this._updateWithValue();
	    };
	    LayoutGapDirective.prototype.ngOnDestroy = function () {
	        _super.prototype.ngOnDestroy.call(this);
	        if (this._layoutWatcher) {
	            this._layoutWatcher.unsubscribe();
	        }
	        if (this._observer) {
	            this._observer.disconnect();
	        }
	    };
	    // *********************************************
	    // Protected methods
	    // *********************************************
	    /**
	     * Watch for child nodes to be added... and apply the layout gap styles to each.
	     * NOTE: this does NOT! differentiate between viewChildren and contentChildren
	     */
	    LayoutGapDirective.prototype._watchContentChanges = function () {
	        var _this = this;
	        var onMutationCallback = function (mutations) {
	            var validatedChanges = function (it) {
	                return (it.addedNodes && it.addedNodes.length) ||
	                    (it.removedNodes && it.removedNodes.length);
	            };
	            // update gap styles only for child 'added' or 'removed' events
	            if (mutations.filter(validatedChanges).length) {
	                _this._updateWithValue();
	            }
	        };
	        this._observer = new MutationObserver(onMutationCallback);
	        this._observer.observe(this._elementRef.nativeElement, { childList: true });
	    };
	    /**
	     * Cache the parent container 'flex-direction' and update the 'margin' styles
	     */
	    LayoutGapDirective.prototype._onLayoutChange = function (direction) {
	        var _this = this;
	        this._layout = (direction || '').toLowerCase();
	        if (!LAYOUT_VALUES.find(function (x) { return x === _this._layout; })) {
	            this._layout = 'row';
	        }
	        this._updateWithValue();
	    };
	    /**
	     *
	     */
	    LayoutGapDirective.prototype._updateWithValue = function (value) {
	        var _this = this;
	        value = value || this._queryInput("gap") || '0';
	        if (this._mqActivation) {
	            value = this._mqActivation.activatedInput;
	        }
	        // Gather all non-hidden Element nodes
	        var items = this.childrenNodes
	            .filter(function (el) { return (el.nodeType === 1); }) // only Element types
	            .filter(function (el) { return _this._getDisplayStyle(el) != "none"; });
	        var numItems = items.length;
	        if (numItems > 1) {
	            var lastItem = items[numItems - 1];
	            // For each `element` children EXCEPT the last,
	            // set the margin right/bottom styles...
	            items = items.filter(function (el, j) { return j < numItems - 1; });
	            this._applyStyleToElements(this._buildCSS(value), items);
	            // Clear all gaps for all visible elements
	            this._applyStyleToElements(this._buildCSS(), [lastItem]);
	        }
	    };
	    /**
	     * Prepare margin CSS, remove any previous explicitly
	     * assigned margin assignments
	     */
	    LayoutGapDirective.prototype._buildCSS = function (value) {
	        if (value === void 0) { value = null; }
	        var key, margins = {
	            'margin-left': null,
	            'margin-right': null,
	            'margin-top': null,
	            'margin-bottom': null
	        };
	        switch (this._layout) {
	            case 'column':
	            case 'column-reverse':
	                key = 'margin-bottom';
	                break;
	            case "row":
	            case 'row-reverse':
	            default:
	                key = 'margin-right';
	                break;
	        }
	        margins[key] = value;
	        return margins;
	    };
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gap", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.xs'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapXs", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.gt-xs'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapGtXs", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.sm'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapSm", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.gt-sm'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapGtSm", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.md'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapMd", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.gt-md'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapGtMd", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.lg'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapLg", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.gt-lg'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapGtLg", null);
	    __decorate$15([
	        _angular_core.Input('fxLayoutGap.xl'), 
	        __metadata$15('design:type', Object), 
	        __metadata$15('design:paramtypes', [Object])
	    ], LayoutGapDirective.prototype, "gapXl", null);
	    LayoutGapDirective = __decorate$15([
	        _angular_core.Directive({ selector: "\n  [fxLayoutGap],\n  [fxLayoutGap.xs],\n  [fxLayoutGap.gt-xs],\n  [fxLayoutGap.sm],\n  [fxLayoutGap.gt-sm]\n  [fxLayoutGap.md],\n  [fxLayoutGap.gt-md]\n  [fxLayoutGap.lg],\n  [fxLayoutGap.gt-lg],\n  [fxLayoutGap.xl]\n"
	        }),
	        __param$5(3, _angular_core.Optional()),
	        __param$5(3, _angular_core.Self()), 
	        __metadata$15('design:paramtypes', [MediaMonitor, _angular_core.ElementRef, _angular_core.Renderer, LayoutDirective])
	    ], LayoutGapDirective);
	    return LayoutGapDirective;
	}(BaseFxDirective));
	
	var __extends$11 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$16 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$16 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive to add responsive support for ngClass.
	 */
	var ClassDirective = (function (_super) {
	    __extends$11(ClassDirective, _super);
	    function ClassDirective(monitor, _bpRegistry, _iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	        _super.call(this, _iterableDiffers, _keyValueDiffers, _ngEl, _renderer);
	        this.monitor = monitor;
	        this._bpRegistry = _bpRegistry;
	        this._base = new BaseFxDirectiveAdapter(monitor, _ngEl, _renderer);
	    }
	    Object.defineProperty(ClassDirective.prototype, "classXs", {
	        set: function (val) {
	            this._base.cacheInput('classXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ClassDirective.prototype, "classGtXs", {
	        set: function (val) {
	            this._base.cacheInput('classGtXs', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ClassDirective.prototype, "classSm", {
	        set: function (val) {
	            this._base.cacheInput('classSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ClassDirective.prototype, "classGtSm", {
	        set: function (val) {
	            this._base.cacheInput('classGtSm', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ClassDirective.prototype, "classMd", {
	        set: function (val) {
	            this._base.cacheInput('classMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ClassDirective.prototype, "classGtMd", {
	        set: function (val) {
	            this._base.cacheInput('classGtMd', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ClassDirective.prototype, "classLg", {
	        set: function (val) {
	            this._base.cacheInput('classLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ClassDirective.prototype, "classGtLg", {
	        set: function (val) {
	            this._base.cacheInput('classGtLg', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ClassDirective.prototype, "classXl", {
	        set: function (val) {
	            this._base.cacheInput('classXl', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    /**
	     * For @Input changes on the current mq activation property, see onMediaQueryChanges()
	     */
	    ClassDirective.prototype.ngOnChanges = function (changes) {
	        var changed = this._bpRegistry.items.some(function (it) { return "class" + it.suffix in changes; });
	        if (changed || this._base.mqActivation) {
	            this._updateStyle();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    ClassDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._base.listenForMediaQueryChanges('class', '', function (changes) {
	            _this._updateStyle(changes.value);
	        });
	        this._updateStyle();
	    };
	    ClassDirective.prototype.ngOnDestroy = function () {
	        this._base.ngOnDestroy();
	    };
	    ClassDirective.prototype._updateStyle = function (value) {
	        var clazz = value || this._base.queryInput("class") || '';
	        if (this._base.mqActivation) {
	            clazz = this._base.mqActivation.activatedInput;
	        }
	        // Delegate subsequent activity to the NgClass logic
	        this.ngClass = clazz;
	    };
	    __decorate$16([
	        _angular_core.Input('class.xs'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classXs", null);
	    __decorate$16([
	        _angular_core.Input('class.gt-xs'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classGtXs", null);
	    __decorate$16([
	        _angular_core.Input('class.sm'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classSm", null);
	    __decorate$16([
	        _angular_core.Input('class.gt-sm'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classGtSm", null);
	    __decorate$16([
	        _angular_core.Input('class.md'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classMd", null);
	    __decorate$16([
	        _angular_core.Input('class.gt-md'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classGtMd", null);
	    __decorate$16([
	        _angular_core.Input('class.lg'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classLg", null);
	    __decorate$16([
	        _angular_core.Input('class.gt-lg'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classGtLg", null);
	    __decorate$16([
	        _angular_core.Input('class.xl'), 
	        __metadata$16('design:type', Object), 
	        __metadata$16('design:paramtypes', [Object])
	    ], ClassDirective.prototype, "classXl", null);
	    ClassDirective = __decorate$16([
	        _angular_core.Directive({
	            selector: "\n    [class.xs],\n    [class.gt-xs],\n    [class.sm],\n    [class.gt-sm],\n    [class.md],\n    [class.gt-md],\n    [class.lg],\n    [class.gt-lg],\n    [class.xl]\n  "
	        }), 
	        __metadata$16('design:paramtypes', [MediaMonitor, BreakPointRegistry, _angular_core.IterableDiffers, _angular_core.KeyValueDiffers, _angular_core.ElementRef, _angular_core.Renderer])
	    ], ClassDirective);
	    return ClassDirective;
	}(_angular_common.NgClass));
	
	var __extends$12 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$17 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$17 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive to add responsive support for ngStyle.
	 *
	 */
	var StyleDirective = (function (_super) {
	    __extends$12(StyleDirective, _super);
	    /**
	     *
	     */
	    function StyleDirective(monitor, _bpRegistry, _differs, _ngEl, _renderer) {
	        _super.call(this, _differs, _ngEl, _renderer);
	        this.monitor = monitor;
	        this._bpRegistry = _bpRegistry;
	        this._base = new BaseFxDirectiveAdapter(monitor, _ngEl, _renderer);
	    }
	    Object.defineProperty(StyleDirective.prototype, "styleXs", {
	        set: function (val) {
	            this._base.cacheInput('styleXs', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StyleDirective.prototype, "styleGtXs", {
	        set: function (val) {
	            this._base.cacheInput('styleGtXs', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(StyleDirective.prototype, "styleSm", {
	        set: function (val) {
	            this._base.cacheInput('styleSm', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(StyleDirective.prototype, "styleGtSm", {
	        set: function (val) {
	            this._base.cacheInput('styleGtSm', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(StyleDirective.prototype, "styleMd", {
	        set: function (val) {
	            this._base.cacheInput('styleMd', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(StyleDirective.prototype, "styleGtMd", {
	        set: function (val) {
	            this._base.cacheInput('styleGtMd', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(StyleDirective.prototype, "styleLg", {
	        set: function (val) {
	            this._base.cacheInput('styleLg', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(StyleDirective.prototype, "styleGtLg", {
	        set: function (val) {
	            this._base.cacheInput('styleGtLg', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(StyleDirective.prototype, "styleXl", {
	        set: function (val) {
	            this._base.cacheInput('styleXl', val, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    /**
	     * For @Input changes on the current mq activation property, see onMediaQueryChanges()
	     */
	    StyleDirective.prototype.ngOnChanges = function (changes) {
	        var changed = this._bpRegistry.items.some(function (it) { return "style" + it.suffix in changes; });
	        if (changed || this._base.mqActivation) {
	            this._updateStyle();
	        }
	    };
	    /**
	     * After the initial onChanges, build an mqActivation object that bridges
	     * mql change events to onMediaQueryChange handlers
	     */
	    StyleDirective.prototype.ngOnInit = function () {
	        var _this = this;
	        this._base.listenForMediaQueryChanges('style', '', function (changes) {
	            _this._updateStyle(changes.value);
	        });
	        this._updateStyle();
	    };
	    StyleDirective.prototype.ngOnDestroy = function () {
	        this._base.ngOnDestroy();
	    };
	    StyleDirective.prototype._updateStyle = function (value) {
	        var style = value || this._base.queryInput("style") || '';
	        if (this._base.mqActivation) {
	            style = this._base.mqActivation.activatedInput;
	        }
	        // Delegate subsequent activity to the NgStyle logic
	        this.ngStyle = style;
	    };
	    __decorate$17([
	        _angular_core.Input('style.xs'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleXs", null);
	    __decorate$17([
	        _angular_core.Input('style.gt-xs'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleGtXs", null);
	    __decorate$17([
	        _angular_core.Input('style.sm'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleSm", null);
	    __decorate$17([
	        _angular_core.Input('style.gt-sm'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleGtSm", null);
	    __decorate$17([
	        _angular_core.Input('style.md'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleMd", null);
	    __decorate$17([
	        _angular_core.Input('style.gt-md'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleGtMd", null);
	    __decorate$17([
	        _angular_core.Input('style.lg'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleLg", null);
	    __decorate$17([
	        _angular_core.Input('style.gt-lg'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleGtLg", null);
	    __decorate$17([
	        _angular_core.Input('style.xl'), 
	        __metadata$17('design:type', Object), 
	        __metadata$17('design:paramtypes', [Object])
	    ], StyleDirective.prototype, "styleXl", null);
	    StyleDirective = __decorate$17([
	        _angular_core.Directive({
	            selector: "\n    [style.xs],\n    [style.gt-xs],\n    [style.sm],\n    [style.gt-sm],\n    [style.md],\n    [style.gt-md],\n    [style.lg],\n    [style.gt-lg],\n    [style.xl]\n  "
	        }), 
	        __metadata$17('design:paramtypes', [MediaMonitor, BreakPointRegistry, _angular_core.KeyValueDiffers, _angular_core.ElementRef, _angular_core.Renderer])
	    ], StyleDirective);
	    return StyleDirective;
	}(_angular_common.NgStyle));
	
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Since the equivalent results are easily achieved with a css class attached to each
	 * layout child, these have been deprecated and removed from the API.
	 *
	 *  import {LayoutPaddingDirective} from './api/layout-padding';
	 *  import {LayoutMarginDirective} from './api/layout-margin';
	 */
	var ALL_DIRECTIVES = [
	    LayoutDirective,
	    LayoutWrapDirective,
	    LayoutGapDirective,
	    LayoutAlignDirective,
	    FlexDirective,
	    FlexOrderDirective,
	    FlexOffsetDirective,
	    FlexFillDirective,
	    FlexAlignDirective,
	    ShowHideDirective,
	    ClassDirective,
	    StyleDirective,
	];
	/**
	 *
	 */
	var FlexLayoutModule = (function () {
	    function FlexLayoutModule() {
	    }
	    /** @deprecated */
	    FlexLayoutModule.forRoot = function () {
	        return {
	            ngModule: FlexLayoutModule
	        };
	    };
	    FlexLayoutModule = __decorate([
	        _angular_core.NgModule({
	            declarations: ALL_DIRECTIVES,
	            imports: [MediaQueriesModule],
	            exports: [MediaQueriesModule].concat(ALL_DIRECTIVES),
	            providers: [MediaMonitor]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], FlexLayoutModule);
	    return FlexLayoutModule;
	}());
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	
	exports.BaseFxDirective = BaseFxDirective;
	exports.BaseFxDirectiveAdapter = BaseFxDirectiveAdapter;
	exports.KeyOptions = KeyOptions;
	exports.ResponsiveActivation = ResponsiveActivation;
	exports.FlexLayoutModule = FlexLayoutModule;
	exports.BreakPointRegistry = BreakPointRegistry;
	exports.RESPONSIVE_ALIASES = RESPONSIVE_ALIASES;
	exports.RAW_DEFAULTS = RAW_DEFAULTS;
	exports.BREAKPOINTS = BREAKPOINTS;
	exports.BreakPointsProvider = BreakPointsProvider;
	exports.ObservableMedia = ObservableMedia;
	exports.MediaService = MediaService;
	exports.ObservableMediaProvider = ObservableMediaProvider;
	exports.MatchMedia = MatchMedia;
	exports.MediaChange = MediaChange;
	exports.MediaMonitor = MediaMonitor;
	exports.MediaQueriesModule = MediaQueriesModule;
	exports.applyCssPrefixes = applyCssPrefixes;
	exports.toAlignContentValue = toAlignContentValue;
	exports.toBoxValue = toBoxValue;
	exports.toBoxOrient = toBoxOrient;
	exports.toBoxDirection = toBoxDirection;
	exports.toBoxOrdinal = toBoxOrdinal;
	exports.extendObject = extendObject;
	exports.mergeAlias = mergeAlias;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },

/***/ 100:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var common_1 = __webpack_require__(22);
	// import { RouterModule, Routes } from '@angular/router';
	var material_1 = __webpack_require__(64);
	var flex_layout_1 = __webpack_require__(99);
	var appContentRouter_module_1 = __webpack_require__(101);
	var content_component_1 = __webpack_require__(102);
	var public_module_1 = __webpack_require__(106);
	var personal_component_1 = __webpack_require__(632);
	var assets_component_1 = __webpack_require__(634);
	var auditing_component_1 = __webpack_require__(636);
	var myresources_component_1 = __webpack_require__(638);
	var personnel_component_1 = __webpack_require__(640);
	var preparingexams_component_1 = __webpack_require__(642);
	var preparinglesson_component_1 = __webpack_require__(644);
	var resources_component_1 = __webpack_require__(646);
	var appContentModule = (function () {
	    function appContentModule() {
	    }
	    return appContentModule;
	}());
	appContentModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            material_1.MaterialModule.forRoot(),
	            flex_layout_1.FlexLayoutModule.forRoot(),
	            common_1.CommonModule,
	            public_module_1.PublicModule,
	            appContentRouter_module_1.appContentRoutesModule,
	        ],
	        declarations: [
	            content_component_1.ContentComponent,
	            personal_component_1.PersonalComponent,
	            assets_component_1.AssetsComponent,
	            auditing_component_1.AuditingComponent,
	            myresources_component_1.MyresourcesComponent,
	            personnel_component_1.PersonnelComponent,
	            preparinglesson_component_1.PreparinglessonComponent,
	            preparingexams_component_1.PreparingexamsComponent,
	            resources_component_1.ResourcesComponent,
	        ]
	    })
	], appContentModule);
	exports.appContentModule = appContentModule;


/***/ },

/***/ 101:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var router_1 = __webpack_require__(30);
	var content_component_1 = __webpack_require__(102);
	var personal_component_1 = __webpack_require__(632);
	var assets_component_1 = __webpack_require__(634);
	var auditing_component_1 = __webpack_require__(636);
	var myresources_component_1 = __webpack_require__(638);
	var personnel_component_1 = __webpack_require__(640);
	var preparingexams_component_1 = __webpack_require__(642);
	var preparinglesson_component_1 = __webpack_require__(644);
	var resources_component_1 = __webpack_require__(646);
	exports.appContentRoutes = [
	    {
	        path: 'content',
	        component: content_component_1.ContentComponent,
	        children: [
	            { path: '', redirectTo: 'personal', pathMatch: 'full' },
	            { path: 'personal', component: personal_component_1.PersonalComponent },
	            { path: 'assets', component: assets_component_1.AssetsComponent },
	            { path: 'auditing', component: auditing_component_1.AuditingComponent },
	            { path: 'myresources', component: myresources_component_1.MyresourcesComponent },
	            { path: 'personnel', component: personnel_component_1.PersonnelComponent },
	            { path: 'preparingexams', component: preparingexams_component_1.PreparingexamsComponent },
	            { path: 'preparinglesson', component: preparinglesson_component_1.PreparinglessonComponent },
	            { path: 'resources', component: resources_component_1.ResourcesComponent }
	        ]
	    }
	];
	var appContentRoutesModule = (function () {
	    function appContentRoutesModule() {
	    }
	    return appContentRoutesModule;
	}());
	appContentRoutesModule = __decorate([
	    core_1.NgModule({
	        //   imports: [ RouterModule.forChild(appContentRoutes) ],
	        exports: [router_1.RouterModule]
	    })
	], appContentRoutesModule);
	exports.appContentRoutesModule = appContentRoutesModule;


/***/ },

/***/ 102:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var menu_1 = __webpack_require__(103);
	var ContentComponent = (function () {
	    function ContentComponent() {
	        this.menu = [];
	        this.notes = [];
	        this.menu = menu_1.Menu;
	    }
	    return ContentComponent;
	}());
	ContentComponent = __decorate([
	    core_1.Component({
	        selector: 'content-container',
	        template: __webpack_require__(104),
	    }),
	    __metadata("design:paramtypes", [])
	], ContentComponent);
	exports.ContentComponent = ContentComponent;


/***/ },

/***/ 103:
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Menu = [
	    {
	        name: '',
	        iconFont: 'person',
	        url: 'personal'
	    },
	    {
	        name: '',
	        iconFont: 'work',
	        url: 'myresources'
	    },
	    {
	        name: '',
	        iconFont: 'person_add',
	        url: 'personnel'
	    },
	    {
	        name: '',
	        iconFont: 'visibility',
	        url: 'auditing'
	    },
	    {
	        name: '',
	        iconFont: 'view_module',
	        url: 'resources'
	    },
	    {
	        name: '',
	        iconFont: 'touch_app',
	        url: 'personal'
	    },
	    {
	        name: '',
	        iconFont: 'receipt',
	        url: 'preparinglesson'
	    },
	    {
	        name: '',
	        iconFont: 'assessment',
	        url: 'preparingexams'
	    },
	    {
	        name: '',
	        iconFont: 'account_balance',
	        url: 'assets'
	    },
	    {
	        name: '',
	        iconFont: 'file_download',
	        url: 'personal'
	    }
	];


/***/ },

/***/ 104:
/***/ function(module, exports) {

	module.exports = "<md-sidenav-container class=\"container\" color=\"primary\">\r\n  <md-sidenav #sidenav class=\"sidenav\" mode=\"side\" >\r\n\t<md-list>\r\n\t\t<h3 md-subheader  fxLayout=\"row\" fxLayoutAlign=\" center\" ><md-icon color=\"primary\">cloud</md-icon><span>&nbsp;</span></h3>\r\n\t\t<md-divider></md-divider>\r\n\t\t<a md-menu-item routerLink=\"{{menuitem.url}}\" *ngFor=\"let menuitem of menu\">\r\n\t\t\t<md-icon>{{menuitem.iconFont}}</md-icon>\r\n\t\t\t<span>{{menuitem.name}}</span>\r\n\t\t</a>\r\n\t\t\r\n\t</md-list>\r\n\r\n  </md-sidenav>\r\n\r\n  <div class=\"sidenav-content\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\" >\r\n  \t<md-toolbar color=\"primary\">\r\n\t  <md-toolbar-row>\r\n\t    <!-- <span>Third Line</span> -->\r\n\t    <button md-icon-button (click)=\"sidenav.toggle()\">\r\n\t      <md-icon >menuitem</md-icon>\r\n\t    </button>\r\n\t  \r\n\t   \r\n\t\t<div class=\"spacer\"></div>\r\n\t\t<button md-icon-button [mdMenuTriggerFor]=\"menubtn\">\r\n\t\t    <md-icon>more_vert</md-icon>\r\n\t\t</button>\r\n\t\t<md-menu #menubtn=\"mdMenu\">\r\n\t\t    <button md-menu-item>\r\n\t\t        <md-icon>dialpad</md-icon>\r\n\t\t        <span>Redial</span>\r\n\t\t    </button>\r\n\t\t    <button md-menu-item disabled>\r\n\t\t        <md-icon>voicemail</md-icon>\r\n\t\t        <span>Check voicemail</span>\r\n\t\t    </button>\r\n\t\t    <button md-menu-item>\r\n\t\t        <md-icon>notifications_off</md-icon>\r\n\t\t        <span>Disable alerts</span>\r\n\t\t    </button>\r\n\t\t</md-menu>\r\n\r\n    \r\n\t  </md-toolbar-row>\r\n\t</md-toolbar>\r\n    \r\n    \r\n    \r\n  </div>\r\n  <div class=\"content-container\">\r\n  \t<router-outlet></router-outlet>\r\n  </div>\r\n\r\n</md-sidenav-container>\r\n\r\n\r\n\r\n\r\n";

/***/ },

/***/ 106:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var header_component_1 = __webpack_require__(107);
	var PublicModule = (function () {
	    function PublicModule() {
	    }
	    return PublicModule;
	}());
	PublicModule = __decorate([
	    core_1.NgModule({
	        imports: [],
	        declarations: [
	            header_component_1.PublickHeaderComponent
	        ],
	        exports: [
	            header_component_1.PublickHeaderComponent
	        ],
	    })
	], PublicModule);
	exports.PublicModule = PublicModule;


/***/ },

/***/ 107:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var PublickHeaderComponent = (function () {
	    function PublickHeaderComponent() {
	    }
	    return PublickHeaderComponent;
	}());
	PublickHeaderComponent = __decorate([
	    core_1.Component({
	        selector: 'public-header',
	        template: "<div>public header</div>",
	    })
	], PublickHeaderComponent);
	exports.PublickHeaderComponent = PublickHeaderComponent;


/***/ },

/***/ 108:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var AppComponent = (function () {
	    function AppComponent() {
	    }
	    return AppComponent;
	}());
	AppComponent = __decorate([
	    core_1.Component({
	        selector: 'my-app',
	        template: "<router-outlet></router-outlet>",
	    })
	], AppComponent);
	exports.AppComponent = AppComponent;


/***/ },

/***/ 109:
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },

/***/ 632:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var PersonalComponent = (function () {
	    function PersonalComponent() {
	    }
	    return PersonalComponent;
	}());
	PersonalComponent = __decorate([
	    core_1.Component({
	        selector: 'personal-component',
	        template: __webpack_require__(633),
	    })
	], PersonalComponent);
	exports.PersonalComponent = PersonalComponent;


/***/ },

/***/ 633:
/***/ function(module, exports) {

	module.exports = "\r\npersonal";

/***/ },

/***/ 634:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var AssetsComponent = (function () {
	    function AssetsComponent() {
	    }
	    return AssetsComponent;
	}());
	AssetsComponent = __decorate([
	    core_1.Component({
	        selector: 'assets-component',
	        template: __webpack_require__(635),
	    })
	], AssetsComponent);
	exports.AssetsComponent = AssetsComponent;


/***/ },

/***/ 635:
/***/ function(module, exports) {

	module.exports = "\r\nassets";

/***/ },

/***/ 636:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var AuditingComponent = (function () {
	    function AuditingComponent() {
	    }
	    return AuditingComponent;
	}());
	AuditingComponent = __decorate([
	    core_1.Component({
	        selector: 'auditing-component',
	        template: __webpack_require__(637),
	    })
	], AuditingComponent);
	exports.AuditingComponent = AuditingComponent;


/***/ },

/***/ 637:
/***/ function(module, exports) {

	module.exports = "\r\nauditing";

/***/ },

/***/ 638:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var MyresourcesComponent = (function () {
	    function MyresourcesComponent() {
	    }
	    return MyresourcesComponent;
	}());
	MyresourcesComponent = __decorate([
	    core_1.Component({
	        selector: 'myresources-component',
	        template: __webpack_require__(639),
	    })
	], MyresourcesComponent);
	exports.MyresourcesComponent = MyresourcesComponent;


/***/ },

/***/ 639:
/***/ function(module, exports) {

	module.exports = "\r\nmyresources";

/***/ },

/***/ 640:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var PersonnelComponent = (function () {
	    function PersonnelComponent() {
	    }
	    return PersonnelComponent;
	}());
	PersonnelComponent = __decorate([
	    core_1.Component({
	        selector: 'personnel-component',
	        template: __webpack_require__(641),
	    })
	], PersonnelComponent);
	exports.PersonnelComponent = PersonnelComponent;


/***/ },

/***/ 641:
/***/ function(module, exports) {

	module.exports = "\r\npersonnel";

/***/ },

/***/ 642:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var PreparingexamsComponent = (function () {
	    function PreparingexamsComponent() {
	    }
	    return PreparingexamsComponent;
	}());
	PreparingexamsComponent = __decorate([
	    core_1.Component({
	        selector: 'preparingexams-component',
	        template: __webpack_require__(643),
	    })
	], PreparingexamsComponent);
	exports.PreparingexamsComponent = PreparingexamsComponent;


/***/ },

/***/ 643:
/***/ function(module, exports) {

	module.exports = "\r\npreparingexams";

/***/ },

/***/ 644:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var PreparinglessonComponent = (function () {
	    function PreparinglessonComponent() {
	    }
	    return PreparinglessonComponent;
	}());
	PreparinglessonComponent = __decorate([
	    core_1.Component({
	        selector: 'preparinglesson-component',
	        template: __webpack_require__(645),
	    })
	], PreparinglessonComponent);
	exports.PreparinglessonComponent = PreparinglessonComponent;


/***/ },

/***/ 645:
/***/ function(module, exports) {

	module.exports = "\r\npreparinglesson";

/***/ },

/***/ 646:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var ResourcesComponent = (function () {
	    function ResourcesComponent() {
	    }
	    return ResourcesComponent;
	}());
	ResourcesComponent = __decorate([
	    core_1.Component({
	        selector: 'resources-component',
	        template: __webpack_require__(647),
	    })
	], ResourcesComponent);
	exports.ResourcesComponent = ResourcesComponent;


/***/ },

/***/ 647:
/***/ function(module, exports) {

	module.exports = "\r\nresources";

/***/ }

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcC5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi8uMi40LjhAQGFuZ3VsYXIvZm9ybXMvYnVuZGxlcy9mb3Jtcy51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBSb3V0ZXJNb2R1bGUvYXBwUm91dGVyLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcExvZ2luTW9kdWxlL2xvZ2luLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcExvZ2luTW9kdWxlL2xvZ2luMS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBMb2dpbk1vZHVsZS9sb2dpbjEuaHRtbCIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL21hdGVyaWFsL2J1bmRsZXMvbWF0ZXJpYWwudW1kLmpzIiwid2VicGFjazovLy8uL34vQGFuZ3VsYXIvZmxleC1sYXlvdXQvYnVuZGxlcy9mbGV4LWxheW91dC51bWQuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbnRlbnQubW9kdWxlLnRzIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwUm91dGVyTW9kdWxlL2FwcENvbnRlbnRSb3V0ZXIubW9kdWxlLnRzIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb250ZW50LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvbW9ja0RhdGEvbWVudS50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29udGVudC5odG1sIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwUHVibGljTW9kdWxlL3B1YmxpYy5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBQdWJsaWNNb2R1bGUvaGVhZGVyLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hc3NldHMvc3R5bGUvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3BlcnNvbmFsL3BlcnNvbmFsLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3BlcnNvbmFsL3BlcnNvbmFsLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvYXNzZXRzL2Fzc2V0cy5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9hc3NldHMvYXNzZXRzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvYXVkaXRpbmcvYXVkaXRpbmcuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvYXVkaXRpbmcvYXVkaXRpbmcuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9teXJlc291cmNlcy9teXJlc291cmNlcy5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9teXJlc291cmNlcy9teXJlc291cmNlcy5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3BlcnNvbm5lbC9wZXJzb25uZWwuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvcGVyc29ubmVsL3BlcnNvbm5lbC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3ByZXBhcmluZ2V4YW1zL3ByZXBhcmluZ2V4YW1zLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3ByZXBhcmluZ2V4YW1zL3ByZXBhcmluZ2V4YW1zLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvcHJlcGFyaW5nbGVzc29uL3ByZXBhcmluZ2xlc3Nvbi5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9wcmVwYXJpbmdsZXNzb24vcHJlcGFyaW5nbGVzc29uLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvcmVzb3VyY2VzL3Jlc291cmNlcy5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9yZXNvdXJjZXMvcmVzb3VyY2VzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx5REFBMkU7QUFDM0UsNENBQXNDO0FBSXRDLGtEQUFzQixFQUFFLENBQUMsZUFBZSxDQUFDLHNCQUFTLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xwRCxxQ0FBeUQ7QUFDekQsa0RBQTJEO0FBQzNELHVDQUE2QztBQUM3QyxzQ0FBOEM7QUFHOUMsa0RBQW9FO0FBRXBFLGdEQUE2QztBQUU3QyxvQkFBTyxDQUFDLEdBQTJCLENBQUMsQ0FBQztBQUNyQyxpQ0FBZ0M7QUFDaEMsc0JBQWMsRUFBRSxDQUFDO0FBQ2pCLEtBQUk7QUFhSixLQUFhLFNBQVM7S0FDbEI7S0FDQSxDQUFDO0tBQ0wsZ0JBQUM7QUFBRCxFQUFDO0FBSFksVUFBUztLQVpyQixlQUFR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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsaUNBQWlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEwQixpQkFBaUIsRUFBRTtBQUM3Qyw0QkFBMkIsY0FBYyxFQUFFO0FBQzNDO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBb0UsdUNBQXVDLDJCQUEyQixFQUFFLEVBQUUsRUFBRTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsc0JBQXNCLEVBQUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsd0NBQXdDLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsK0JBQStCLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCxvREFBb0QsRUFBRTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXFFLHdDQUF3QyxFQUFFO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnRUFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLHNDQUFzQyxHQUFHLHFDQUFxQztBQUM5RyxpQ0FBZ0MsbUNBQW1DLEdBQUcsd0NBQXdDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkI7QUFDM0IsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLDJCQUEyQjtBQUNsRCw0Q0FBMkMseUVBQXlFLEdBQUcsNkVBQTZFO0FBQ3BNO0FBQ0E7QUFDQSxpRUFBZ0UsdUNBQXVDLEVBQUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHVCQUF1QixFQUFFO0FBQ25ELDhCQUE2Qiw2Q0FBNkMsRUFBRTtBQUM1RTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxpREFBaUQsRUFBRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRCxxQ0FBcUMsRUFBRTtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTBELHNDQUFzQyxFQUFFO0FBQ2xHLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxxQ0FBcUMsRUFBRTtBQUMzRSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE0RCwwREFBMEQsRUFBRTtBQUN4SCx1REFBc0Qsa0RBQWtELEVBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyw2QkFBNkIsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxvQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXVELDRCQUE0QixFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBK0Q7QUFDL0Q7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTJGLDJDQUEyQyxFQUFFO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTRFLHVCQUF1QixFQUFFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQix1QkFBdUIsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTRFLHNCQUFzQixFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiw0QkFBNEIsRUFBRTtBQUN4RCxnQ0FBK0Isb0RBQW9ELEVBQUU7QUFDckY7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQSx5Q0FBd0MscUJBQXFCLGlEQUFpRCxpQkFBaUIsZUFBZSxvQkFBb0IscUJBQXFCLG1CQUFtQixxQkFBcUIsc0JBQXNCLHFCQUFxQixZQUFZLGtCQUFrQixXQUFXLFFBQVEsZ0RBQWdELHNCQUFzQixZQUFZLE9BQU8sTUFBTSxXQUFXLGtCQUFrQixrQkFBa0Isd0JBQXdCLG1DQUFtQyxpQkFBaUIsbUJBQW1CLHdCQUF3Qiw0REFBNEQsbUJBQW1CLDJDQUEyQyxvQkFBb0IseUJBQXlCLHFCQUFxQixRQUFRLG9CQUFvQixpQkFBaUIsZ0JBQWdCLG1DQUFtQyxrQkFBa0IsZUFBZSxnREFBZ0QsU0FBUyxlQUFlLGtCQUFrQiwwREFBMEQsZ0JBQWdCLGlCQUFpQix5REFBeUQsZUFBZSxrQkFBa0Isa0JBQWtCLFdBQVcsVUFBVSxZQUFZLGFBQWEsa0JBQWtCLFVBQVUsb0JBQW9CO0FBQzV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFD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bEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsbUNBQW1DLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQix3QkFBd0IsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEwQixvQkFBb0IsRUFBRTtBQUNoRDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsdUNBQXVDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLFNBQVM7QUFDdEMsOEJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QVU7QUFDem1LO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EscUJBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQSxxQ0FBb0MsYUFBYTtBQUNqRDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLDZCQUE2QixFQUFFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLG9CQUFvQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFD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Q0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDRCQUE0QixFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDLDJCQUEwQix5QkFBeUIsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRCwyQkFBMkI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsNkJBQTZCLEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBLHVDQUFzQyxhQUFhLGdCQUFnQixrQkFBa0IsY0FBYyxlQUFlLGlCQUFpQixZQUFZLGVBQWUsZUFBZSxpREFBaUQsZ0JBQWdCLGVBQWUsc0JBQXNCLG1CQUFtQixXQUFXLGdCQUFnQixrQkFBa0Isa0JBQWtCLHFCQUFxQixVQUFVLFVBQVUseUJBQXlCLGVBQWUsZ0JBQWdCLGFBQWEsa0JBQWtCLFNBQVMsV0FBVyx5Q0FBeUMsNENBQTRDLFlBQVksTUFBTSwyQkFBMkIsa0JBQWtCLGFBQWEsdUJBQXVCLG1CQUFtQixlQUFlLGVBQWUsVUFBVSx1RkFBdUYsYUFBYSx1RkFBdUYsaUJBQWlCLDZKQUE2SiwwQkFBMEIsdUZBQXVGLGtCQUFrQiw2SkFBNkosd0JBQXdCLG1DQUFtQyxtQkFBbUIseUJBQXlCLFdBQVcsV0FBVyxVQUFVLG9DQUFvQyxnQkFBZ0IsZUFBZSx1RUFBdUUsa0JBQWtCLHlCQUF5QixhQUFhLFlBQVksZ0JBQWdCLFVBQVUsY0FBYyxZQUFZLGtCQUFrQixtREFBbUQ7QUFDbjBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiw0QkFBNEIsRUFBRTtBQUN4RCxnQ0FBK0Isb0RBQW9ELEVBQUU7QUFDckY7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTBCLDRCQUE0QixFQUFFO0FBQ3hELGdDQUErQiw2QkFBNkIsRUFBRTtBQUM5RDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsMkJBQTBCLDRCQUE0QixFQUFFO0FBQ3hEO0FBQ0EsZ0NBQStCLDZCQUE2QixFQUFFO0FBQzlEO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNERBQTJELG9CQUFvQixFQUFFO0FBQ2pGLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakMsZ1JBQStRLDRjQUE0YyxlQUFlLDhJQUE4STtBQUN4M0IsNkJBQTRCLGFBQWEsc0JBQXNCLGlEQUFpRCxvQ0FBb0MsOEJBQThCLGVBQWUsaUJBQWlCLFlBQVksZUFBZSxlQUFlLGlEQUFpRCxnQkFBZ0IsZUFBZSxzQkFBc0IsbUJBQW1CLFdBQVcsZ0JBQWdCLGtCQUFrQixrQkFBa0IscUJBQXFCLFVBQVUsVUFBVSx5QkFBeUIsZUFBZSxnQkFBZ0IsNkVBQTZFLGFBQWEsWUFBWSxzQkFBc0Isa0JBQWtCLGdCQUFnQixhQUFhLGdEQUFnRCxjQUFjLGtCQUFrQixNQUFNLE9BQU8sUUFBUSxTQUFTLGNBQWMsZ0JBQWdCLGtDQUFrQyxrQkFBa0Isa0JBQWtCLGdCQUFnQixVQUFVLFlBQVkscUVBQXFFLGtCQUFrQixrQkFBa0IsZUFBZSxvQkFBb0I7QUFDcGtDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0Esa0VBQWlFLGFBQWEsc0JBQXNCLFdBQVcsYUFBYSxlQUFlLGdCQUFnQixpREFBaUQsZUFBZSxzQkFBc0IsZ0JBQWdCLDhCQUE4QixtQkFBbUIsbUJBQW1CLG1CQUFtQixpQkFBaUIsWUFBWSxvREFBb0QsYUFBYSxnQkFBZ0IsaUJBQWlCLGFBQWEscURBQXFELGFBQWEsZ0JBQWdCLGlCQUFpQixhQUFhO0FBQ3BsQjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQix1QkFBdUIsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTBCLHVCQUF1QixFQUFFO0FBQ25ELGdDQUErQix3QkFBd0IsRUFBRTtBQUN6RDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMEIsc0JBQXNCLEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMEIscUJBQXFCLEVBQUU7QUFDakQsNEJBQTJCLGtCQUFrQixFQUFFO0FBQy9DO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEwQixxQkFBcUIsRUFBRTtBQUNqRCw0QkFBMkIsa0JBQWtCLEVBQUU7QUFDL0M7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTBCLHNCQUFzQixFQUFFO0FBQ2xELDRCQUEyQixtQkFBbUIsRUFBRTtBQUNoRDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMEIsdUJBQXVCLEVBQUU7QUFDbkQsNEJBQTJCLG9CQUFvQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEwQix1QkFBdUIsRUFBRTtBQUNuRCw0QkFBMkIsb0JBQW9CLEVBQUU7QUFDakQ7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0Msa0NBQWtDLEVBQUU7QUFDeEUsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBLDZDQUE0QywwR0FBMEcsY0FBYyxhQUFhLGtCQUFrQixzQkFBc0IsY0FBYyxlQUFlLFdBQVcsWUFBWSw2Q0FBNkMsc0JBQXNCLG1CQUFtQixvQkFBb0IsY0FBYyxlQUFlLGVBQWUsZ0JBQWdCLGNBQWMsa0JBQWtCLGVBQWUsZ0JBQWdCLGdCQUFnQixjQUFjLG9CQUFvQixlQUFlLGFBQWEsK0JBQStCLG9CQUFvQiwrQkFBK0IseUJBQXlCLGtDQUFrQyx1QkFBdUI7QUFDcHVCO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQsMkNBQTJDLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUFzRSwwQkFBMEIsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0Qsc0NBQXNDLEVBQUU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSwwQ0FBeUMsdUNBQXVDLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBc0Ysc0NBQXNDLEdBQUcscUNBQXFDO0FBQ3BLLG9DQUFtQyxtQ0FBbUMsR0FBRyx3Q0FBd0M7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEMsY0FBYzs7QUFFNUQsRUFBQzs7Ozs7Ozs7QUN0aGZEO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxtREFBbUQ7QUFDNUYsRUFBQyw4SEFBOEg7O0FBRS9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxrQkFBa0I7QUFDOUI7QUFDQSxpQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDLGVBQWUsT0FBTyxrQkFBa0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixpQ0FBaUMsRUFBRTtBQUNoRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixxQ0FBcUMsRUFBRTtBQUNwRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixxQ0FBcUMsRUFBRTtBQUNwRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixxQ0FBcUMsRUFBRTtBQUNwRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixxQ0FBcUMsRUFBRTtBQUNwRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFnRCxvQkFBb0IsRUFBRSw2QkFBNkI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsNk1BQTZNO0FBQzlPO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLCtCQUErQixFQUFFO0FBQzlEO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSw4QkFBNkIsaUNBQWlDLEVBQUU7QUFDaEU7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixpQ0FBaUMsRUFBRTtBQUNoRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixpQ0FBaUMsRUFBRTtBQUNoRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixpQ0FBaUMsRUFBRTtBQUNoRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixtQ0FBbUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLDhCQUE2QixpQ0FBaUMsRUFBRTtBQUNoRTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLDRCQUE0QixFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLHFQQUFxUDtBQUN0UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1B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Q0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWdFLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4Qyw0QkFBNEIsRUFBRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsNEJBQTRCLEVBQUU7QUFDakUsb0NBQW1DLDZDQUE2QyxFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQseUJBQXlCLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWlFLHVDQUF1QyxFQUFFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFpRSx1Q0FBdUMsRUFBRTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtB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QU8sQ0FBQyxHQUFrQyxDQUFDO01BRXZELENBQUM7SUFDVyx3QkFBd0IsQ0FBRztBQUEzQiw2REFBd0I7Ozs7Ozs7O0FDUHJDLHdDOzs7Ozs7Ozs7Ozs7Ozs7QUNBQSxxQ0FBd0M7QUFPeEMsS0FBYSxrQkFBa0I7S0FBL0I7S0FBaUMsQ0FBQztLQUFELHlCQUFDO0FBQUQsRUFBQztBQUFyQixtQkFBa0I7S0FMOUIsZ0JBQVMsQ0FBQztTQUNULFFBQVEsRUFBRSxxQkFBcUI7U0FDL0IsUUFBUSxFQUFHLG1CQUFPLENBQUMsR0FBNEIsQ0FBQztNQUVqRCxDQUFDO0lBQ1csa0JBQWtCLENBQUc7QUFBckIsaURBQWtCOzs7Ozs7OztBQ1AvQixrQyIsImZpbGUiOiJidWlsZC9qcy9hcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbmltcG9ydCB7QXBwTW9kdWxlfSBmcm9tICcuL2FwcC5tb2R1bGUnXG5cblxuXG5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+Ly4wLjYuMkBhbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcC50cyIsImltcG9ydCB7IE5nTW9kdWxlLGVuYWJsZVByb2RNb2RlICB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gIGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgSHR0cE1vZHVsZSB9ICAgIGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xyXG5cclxuXHJcbmltcG9ydCB7QXBwUm91dGluZ01vZHVsZX0gZnJvbSAnLi9hcHBSb3V0ZXJNb2R1bGUvYXBwUm91dGVyLm1vZHVsZSc7XHJcblxyXG5pbXBvcnQge0FwcENvbXBvbmVudH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcclxuXHJcbnJlcXVpcmUoJy4vYXNzZXRzL3N0eWxlL3N0eWxlLnNjc3MnKTtcclxuLy8gaWYgKGVudmlyb25tZW50LnByb2R1Y3Rpb24pIHtcclxuZW5hYmxlUHJvZE1vZGUoKTtcclxuLy8gfVxyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogW1xyXG4gICAgXHRGb3Jtc01vZHVsZSxcclxuICAgICAgICBCcm93c2VyTW9kdWxlLFxyXG4gICAgICAgIEh0dHBNb2R1bGUsXHJcbiAgICAgICAgQXBwUm91dGluZ01vZHVsZSwgICAgICAgIFxyXG4gICAgXSxcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgXHRBcHBDb21wb25lbnQsXHJcbiAgICBdLFxyXG4gICAgYm9vdHN0cmFwOiBbQXBwQ29tcG9uZW50XVxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwLm1vZHVsZS50cyIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi40LjhcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL3RvUHJvbWlzZScpLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyksIHJlcXVpcmUoJ3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJywgJ3J4anMvU3ViamVjdCcsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuZm9ybXMgPSBnbG9iYWwubmcuZm9ybXMgfHwge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUngsZ2xvYmFsLlJ4LGdsb2JhbC5SeC5PYnNlcnZhYmxlKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUscnhqc19vcGVyYXRvcl90b1Byb21pc2Uscnhqc19TdWJqZWN0LHJ4anNfT2JzZXJ2YWJsZSxyeGpzX29ic2VydmFibGVfZnJvbVByb21pc2UpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGNvbnRyb2wgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIE9ubHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoZSBmb3JtcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkJyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudmFsaWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmludmFsaWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGVuZGluZ1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnBlbmRpbmcgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZXJyb3JzIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wucHJpc3RpbmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5kaXJ0eSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudG91Y2hlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC51bnRvdWNoZWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5kaXNhYmxlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZW5hYmxlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdGF0dXNDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuc3RhdHVzQ2hhbmdlcyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC52YWx1ZUNoYW5nZXMgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXJyb3JDb2RlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmhhc0Vycm9yKGVycm9yQ29kZSwgcGF0aCkgOiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXJyb3JDb2RlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBkaXJlY3RpdmUgdGhhdCBjb250YWlucyBtdWx0aXBsZSB7XFxAbGluayBOZ0NvbnRyb2x9cy5cbiAgICAgKlxuICAgICAqIE9ubHkgdXNlZCBieSB0aGUgZm9ybXMgbW9kdWxlLlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbnRyb2xDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShDb250cm9sQ29udGFpbmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDb250cm9sQ29udGFpbmVyKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGZvcm0gdG8gd2hpY2ggdGhpcyBjb250YWluZXIgYmVsb25ncy5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQ29udGFpbmVyLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBwYXRoIHRvIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIENvbnRyb2xDb250YWluZXI7XG4gICAgfShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUpKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhXG4gICAgICogQHBhcmFtIHs/fSBiXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb29zZUlkZW50aWNhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbyA9PT0gJ29iamVjdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xuICAgICAqL1xuICAgIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBtMVxuICAgICAgICAgKiBAcGFyYW0gez99IG0yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG0xKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTFba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gT2JqZWN0LmtleXMobTIpOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBtMVxuICAgICAgICAgKiBAcGFyYW0gez99IG0yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMaXN0V3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhcnJcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIExpc3RXcmFwcGVyLmZpbmRMYXN0ID0gZnVuY3Rpb24gKGFyciwgY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uKGFycltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGlzdFxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBbGwgPSBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsaXN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFcbiAgICAgICAgICogQHBhcmFtIHs/fSBiXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsaXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoZmxhdCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IExpc3RXcmFwcGVyLmZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKGZsYXQpKS5jb25jYXQoZmxhdEl0ZW0pO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzUHJvbWlzZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5pc1Byb21pc2U7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPYnNlcnZhYmxlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmlzT2JzZXJ2YWJsZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHlJbnB1dFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIGZvciBzdHJpbmcgaGVyZSBzbyBpdCBhbHNvIHdvcmtzIHdpdGggYXJyYXlzXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIGZvciB2YWxpZGF0b3JzIHRvIGJlIHVzZWQgZm9yIHtAbGluayBGb3JtQ29udHJvbH1zIGluIGEgZm9ybS5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgdGhpcyB1c2luZyBgbXVsdGk6IHRydWVgIHRvIGFkZCB2YWxpZGF0b3JzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2Zvcm1zL3RzL25nX3ZhbGlkYXRvcnMvbmdfdmFsaWRhdG9ycy50cyByZWdpb249J25nX3ZhbGlkYXRvcnMnfVxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBOR19WQUxJREFUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nVmFsaWRhdG9ycycpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyBmb3IgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMgdG8gYmUgdXNlZCBmb3Ige0BsaW5rIEZvcm1Db250cm9sfXNcbiAgICAgKiBpbiBhIGZvcm0uXG4gICAgICpcbiAgICAgKiBQcm92aWRlIHRoaXMgdXNpbmcgYG11bHRpOiB0cnVlYCB0byBhZGQgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgTkdfVkFMSURBVE9SU30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBOR19BU1lOQ19WQUxJREFUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nQXN5bmNWYWxpZGF0b3JzJyk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBzZXQgb2YgdmFsaWRhdG9ycyB1c2VkIGJ5IGZvcm0gY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBBIHZhbGlkYXRvciBpcyBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9IG9yIGNvbGxlY3Rpb24gb2ZcbiAgICAgKiBjb250cm9scyBhbmQgcmV0dXJucyBhIG1hcCBvZiBlcnJvcnMuIEEgbnVsbCBtYXAgbWVhbnMgdGhhdCB2YWxpZGF0aW9uIGhhcyBwYXNzZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHZhciBsb2dpbkNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woXCJcIiwgVmFsaWRhdG9ycy5yZXF1aXJlZClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBWYWxpZGF0b3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmFsaWRhdG9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIG5vbi1lbXB0eSB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLnJlcXVpcmVkID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSA/IHsgJ3JlcXVpcmVkJzogdHJ1ZSB9IDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2wgdmFsdWUgdG8gYmUgdHJ1ZS5cbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLnJlcXVpcmVkVHJ1ZSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbC52YWx1ZSA9PT0gdHJ1ZSA/IG51bGwgOiB7ICdyZXF1aXJlZCc6IHRydWUgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2xzIHRvIGhhdmUgYSB2YWx1ZSBvZiBhIG1pbmltdW0gbGVuZ3RoLlxuICAgICAgICAgKiBAcGFyYW0gez99IG1pbkxlbmd0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5taW5MZW5ndGggPSBmdW5jdGlvbiAobWluTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHZhbGlkYXRlIGVtcHR5IHZhbHVlcyB0byBhbGxvdyBvcHRpb25hbCBjb250cm9sc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW5ndGggPSBjb250cm9sLnZhbHVlID8gY29udHJvbC52YWx1ZS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggPCBtaW5MZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICB7ICdtaW5sZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1pbkxlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IGxlbmd0aCB9IH0gOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2xzIHRvIGhhdmUgYSB2YWx1ZSBvZiBhIG1heGltdW0gbGVuZ3RoLlxuICAgICAgICAgKiBAcGFyYW0gez99IG1heExlbmd0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5tYXhMZW5ndGggPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW5ndGggPSBjb250cm9sLnZhbHVlID8gY29udHJvbC52YWx1ZS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggPiBtYXhMZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICB7ICdtYXhsZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1heExlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IGxlbmd0aCB9IH0gOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGEgY29udHJvbCB0byBtYXRjaCBhIHJlZ2V4IHRvIGl0cyB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXR0ZXJuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLnBhdHRlcm4gPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHJldHVybiBWYWxpZGF0b3JzLm51bGxWYWxpZGF0b3I7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWdleDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZ2V4U3RyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZ2V4U3RyID0gXCJeXCIgKyBwYXR0ZXJuICsgXCIkXCI7XG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2V4U3RyID0gcGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gcGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSkgPyBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgeyAncGF0dGVybic6IHsgJ3JlcXVpcmVkUGF0dGVybic6IHJlZ2V4U3RyLCAnYWN0dWFsVmFsdWUnOiB2YWx1ZSB9IH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTm8tb3AgdmFsaWRhdG9yLlxuICAgICAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9zZSBtdWx0aXBsZSB2YWxpZGF0b3JzIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB1bmlvblxuICAgICAgICAgKiBvZiB0aGUgaW5kaXZpZHVhbCBlcnJvciBtYXBzLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMuY29tcG9zZSA9IGZ1bmN0aW9uICh2YWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRvcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgICAgICAgICBpZiAocHJlc2VudFZhbGlkYXRvcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21lcmdlRXJyb3JzKF9leGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCBwcmVzZW50VmFsaWRhdG9ycykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMgPSBmdW5jdGlvbiAodmFsaWRhdG9ycykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlc2VudFZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzLmZpbHRlcihpc1ByZXNlbnQpO1xuICAgICAgICAgICAgaWYgKHByZXNlbnRWYWxpZGF0b3JzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvbWlzZXMgPSBfZXhlY3V0ZUFzeW5jVmFsaWRhdG9ycyhjb250cm9sLCBwcmVzZW50VmFsaWRhdG9ycykubWFwKF9jb252ZXJ0VG9Qcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oX21lcmdlRXJyb3JzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWYWxpZGF0b3JzO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jb252ZXJ0VG9Qcm9taXNlKG9iaikge1xuICAgICAgICByZXR1cm4gaXNQcm9taXNlKG9iaikgPyBvYmogOiByeGpzX29wZXJhdG9yX3RvUHJvbWlzZS50b1Byb21pc2UuY2FsbChvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9leGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdihjb250cm9sKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVBc3luY1ZhbGlkYXRvcnMoY29udHJvbCwgdmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9ycy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYoY29udHJvbCk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFycmF5T2ZFcnJvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9tZXJnZUVycm9ycyhhcnJheU9mRXJyb3JzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IGFycmF5T2ZFcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChlcnJvcnMpID8gU3RyaW5nTWFwV3JhcHBlci5tZXJnZShyZXMsIGVycm9ycykgOiByZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlcykubGVuZ3RoID09PSAwID8gbnVsbCA6IHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHByb3ZpZGUgYSB7QGxpbmsgQ29udHJvbFZhbHVlQWNjZXNzb3J9IGZvciBmb3JtIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBEZWZhdWx0VmFsdWVBY2Nlc3Nvcn0gZm9yIGhvdyB0byBpbXBsZW1lbnQgb25lLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBOR19WQUxVRV9BQ0NFU1NPUiA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdOZ1ZhbHVlQWNjZXNzb3InKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIENIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmFtZT1cInJlbWVtYmVyTG9naW5cIiBuZ01vZGVsPlxuICAgICAqICBgYGBcbiAgICAgKlxuICAgICAqICBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9Y2hlY2tib3hdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQuY2hlY2tlZCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gREVGQVVMVF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVmYXVsdFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtcXEBsaW5rIE5nTW9kZWx9LCB7XFxAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7XFxAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJzZWFyY2hRdWVyeVwiIG5nTW9kZWw+XG4gICAgICogIGBgYFxuICAgICAqXG4gICAgICogIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEZWZhdWx0VmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0VmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtmb3JtQ29udHJvbE5hbWVdLHRleHRhcmVhW2Zvcm1Db250cm9sTmFtZV0saW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbZm9ybUNvbnRyb2xdLHRleHRhcmVhW2Zvcm1Db250cm9sXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtuZ01vZGVsXSx0ZXh0YXJlYVtuZ01vZGVsXSxbbmdEZWZhdWx0Q29udHJvbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdnNhdmtpbiByZXBsYWNlIHRoZSBhYm92ZSBzZWxlY3RvciB3aXRoIHRoZSBvbmUgYmVsb3cgaXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0b3I6ICdbbmdDb250cm9sXSxbbmdNb2RlbF0sW25nRm9ybUNvbnRyb2xdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbREVGQVVMVF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gRGVmYXVsdFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoKCh2YWxpZGF0b3IpKS52YWxpZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiAoKHZhbGlkYXRvcikpLnZhbGlkYXRlKGMpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh2YWxpZGF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVBc3luY1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKCgodmFsaWRhdG9yKSkudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gKCh2YWxpZGF0b3IpKS52YWxpZGF0ZShjKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsaWRhdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIE5VTUJFUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTnVtYmVyVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSBudW1iZXIgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIHRoYXQgaXMgdXNlZCBieSB0aGVcbiAgICAgKiB7XFxAbGluayBOZ01vZGVsfSwge1xcQGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge1xcQGxpbmsgRm9ybUNvbnRyb2xOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIFsobmdNb2RlbCldPVwiYWdlXCI+XG4gICAgICogIGBgYFxuICAgICAqL1xuICAgIHZhciBOdW1iZXJWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE51bWJlclZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgbmVlZHMgdG8gYmUgbm9ybWFsaXplZCBmb3IgSUU5LCBvdGhlcndpc2UgaXQgaXMgc2V0IHRvICdudWxsJyB3aGVuIG51bGxcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHsgZm4odmFsdWUgPT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTlVNQkVSX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIE51bWJlclZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGJhc2UgY2xhc3MgdGhhdCBhbGwgY29udHJvbCBkaXJlY3RpdmUgZXh0ZW5kLlxuICAgICAqIEl0IGJpbmRzIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9IG9iamVjdCB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IGJ5IEFuZ3VsYXIgZm9ybXMuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoTmdDb250cm9sLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ0NvbnRyb2woKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHVuaW1wbGVtZW50ZWQoKSk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHVuaW1wbGVtZW50ZWQoKSk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nQ29udHJvbC5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHsgfTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbDtcbiAgICB9KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSkpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUkFESU9fVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2xhc3MgdXNlZCBieSBBbmd1bGFyIHRvIHVuY2hlY2sgcmFkaW8gYnV0dG9ucyB3aXRoIHRoZSBtYXRjaGluZyBuYW1lLlxuICAgICAqL1xuICAgIHZhciBSYWRpb0NvbnRyb2xSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbFJlZ2lzdHJ5KCkge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcGFyYW0gez99IGFjY2Vzc29yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNvbnRyb2wsIGFjY2Vzc29yKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMucHVzaChbY29udHJvbCwgYWNjZXNzb3JdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYWNjZXNzb3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRoaXMuX2FjY2Vzc29ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY2Nlc3NvcnNbaV1bMV0gPT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFjY2Vzc29yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzU2FtZUdyb3VwKGMsIGFjY2Vzc29yKSAmJiBjWzFdICE9PSBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgICAgICBjWzFdLmZpcmVVbmNoZWNrKGFjY2Vzc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFBhaXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBhY2Nlc3NvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLl9pc1NhbWVHcm91cCA9IGZ1bmN0aW9uIChjb250cm9sUGFpciwgYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbFBhaXJbMF0uY29udHJvbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbFBhaXJbMF0uX3BhcmVudCA9PT0gYWNjZXNzb3IuX2NvbnRyb2wuX3BhcmVudCAmJlxuICAgICAgICAgICAgICAgIGNvbnRyb2xQYWlyWzFdLm5hbWUgPT09IGFjY2Vzc29yLm5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgcmV0dXJuIFJhZGlvQ29udHJvbFJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBXcml0ZXMgcmFkaW8gY29udHJvbCB2YWx1ZXMgYW5kIGxpc3RlbnMgdG8gcmFkaW8gY29udHJvbCBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVXNlZCBieSB7XFxAbGluayBOZ01vZGVsfSwge1xcQGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge1xcQGxpbmsgRm9ybUNvbnRyb2xOYW1lfVxuICAgICAqIHRvIGtlZXAgdGhlIHZpZXcgc3luY2VkIHdpdGggdGhlIHtcXEBsaW5rIEZvcm1Db250cm9sfSBtb2RlbC5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBpbXBvcnRlZCB0aGUge1xcQGxpbmsgRm9ybXNNb2R1bGV9IG9yIHRoZSB7XFxAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfSwgdGhpc1xuICAgICAqIHZhbHVlIGFjY2Vzc29yIHdpbGwgYmUgYWN0aXZlIG9uIGFueSByYWRpbyBjb250cm9sIHRoYXQgaGFzIGEgZm9ybSBkaXJlY3RpdmUuIFlvdSBkb1xuICAgICAqICoqbm90KiogbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yIHRvIGFjdGl2YXRlIGl0LlxuICAgICAqXG4gICAgICogIyMjIEhvdyB0byB1c2UgcmFkaW8gYnV0dG9ucyB3aXRoIGZvcm0gZGlyZWN0aXZlc1xuICAgICAqXG4gICAgICogVG8gdXNlIHJhZGlvIGJ1dHRvbnMgaW4gYSB0ZW1wbGF0ZS1kcml2ZW4gZm9ybSwgeW91J2xsIHdhbnQgdG8gZW5zdXJlIHRoYXQgcmFkaW8gYnV0dG9uc1xuICAgICAqIGluIHRoZSBzYW1lIGdyb3VwIGhhdmUgdGhlIHNhbWUgYG5hbWVgIGF0dHJpYnV0ZS4gIFJhZGlvIGJ1dHRvbnMgd2l0aCBkaWZmZXJlbnQgYG5hbWVgXG4gICAgICogYXR0cmlidXRlcyBkbyBub3QgYWZmZWN0IGVhY2ggb3RoZXIuXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9yYWRpb0J1dHRvbnMvcmFkaW9fYnV0dG9uX2V4YW1wbGUudHMgcmVnaW9uPSdUZW1wbGF0ZURyaXZlbid9XG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIHJhZGlvIGJ1dHRvbnMgaW4gYSByZWFjdGl2ZSBmb3JtLCByYWRpbyBidXR0b25zIGluIHRoZSBzYW1lIGdyb3VwIHNob3VsZCBoYXZlIHRoZVxuICAgICAqIHNhbWUgYGZvcm1Db250cm9sTmFtZWAuIFlvdSBjYW4gYWxzbyBhZGQgYSBgbmFtZWAgYXR0cmlidXRlLCBidXQgaXQncyBvcHRpb25hbC5cbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL3JlYWN0aXZlUmFkaW9CdXR0b25zL3JlYWN0aXZlX3JhZGlvX2J1dHRvbl9leGFtcGxlLnRzIHJlZ2lvbj0nUmVhY3RpdmUnfVxuICAgICAqXG4gICAgICogICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3JlZ2lzdHJ5XG4gICAgICAgICAqIEBwYXJhbSB7P30gX2luamVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYsIF9yZWdpc3RyeSwgX2luamVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdHJ5ID0gX3JlZ2lzdHJ5O1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSB0aGlzLl9pbmplY3Rvci5nZXQoTmdDb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkuYWRkKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZWdpc3RyeS5yZW1vdmUodGhpcyk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB0aGlzLl9zdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm4oX3RoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWdpc3RyeS5zZWxlY3QoX3RoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLmZpcmVVbmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMud3JpdGVWYWx1ZSh2YWx1ZSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9jaGVja05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lICYmIHRoaXMuZm9ybUNvbnRyb2xOYW1lICYmIHRoaXMubmFtZSAhPT0gdGhpcy5mb3JtQ29udHJvbE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd05hbWVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUpXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5mb3JtQ29udHJvbE5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX3Rocm93TmFtZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgSWYgeW91IGRlZmluZSBib3RoIGEgbmFtZSBhbmQgYSBmb3JtQ29udHJvbE5hbWUgYXR0cmlidXRlIG9uIHlvdXIgcmFkaW8gYnV0dG9uLCB0aGVpciB2YWx1ZXNcXG4gICAgICBtdXN0IG1hdGNoLiBFeDogPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBmb3JtQ29udHJvbE5hbWU9XFxcImZvb2RcXFwiIG5hbWU9XFxcImZvb2RcXFwiPlxcbiAgICBcIik7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9cmFkaW9dW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9cmFkaW9dW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkFESU9fVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RvciwgfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAnZm9ybUNvbnRyb2xOYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIFJBTkdFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSYW5nZVZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgcmFuZ2UgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIHRoYXQgaXMgdXNlZCBieSB0aGVcbiAgICAgKiB7XFxAbGluayBOZ01vZGVsfSwge1xcQGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge1xcQGxpbmsgRm9ybUNvbnRyb2xOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgWyhuZ01vZGVsKV09XCJhZ2VcIiA+XG4gICAgICogIGBgYFxuICAgICAqL1xuICAgIHZhciBSYW5nZVZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmFuZ2VWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHsgZm4odmFsdWUgPT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1yYW5nZV1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXJhbmdlXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1yYW5nZV1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkFOR0VfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBSYW5nZVZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIFNFTEVDVF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9idWlsZFZhbHVlU3RyaW5nKGlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIChpZCArIFwiOiBcIiArIHZhbHVlKS5zbGljZSgwLCA1MCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVTdHJpbmdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9leHRyYWN0SWQodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nLnNwbGl0KCc6JylbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgV3JpdGVzIHZhbHVlcyBhbmQgbGlzdGVucyB0byBjaGFuZ2VzIG9uIGEgc2VsZWN0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHtcXEBsaW5rIE5nTW9kZWx9LCB7XFxAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7XFxAbGluayBGb3JtQ29udHJvbE5hbWV9XG4gICAgICogdG8ga2VlcCB0aGUgdmlldyBzeW5jZWQgd2l0aCB0aGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9IG1vZGVsLlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGltcG9ydGVkIHRoZSB7XFxAbGluayBGb3Jtc01vZHVsZX0gb3IgdGhlIHtcXEBsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9LCB0aGlzXG4gICAgICogdmFsdWUgYWNjZXNzb3Igd2lsbCBiZSBhY3RpdmUgb24gYW55IHNlbGVjdCBjb250cm9sIHRoYXQgaGFzIGEgZm9ybSBkaXJlY3RpdmUuIFlvdSBkb1xuICAgICAqICoqbm90KiogbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yIHRvIGFjdGl2YXRlIGl0LlxuICAgICAqXG4gICAgICogIyMjIEhvdyB0byB1c2Ugc2VsZWN0IGNvbnRyb2xzIHdpdGggZm9ybSBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgYSBzZWxlY3QgaW4gYSB0ZW1wbGF0ZS1kcml2ZW4gZm9ybSwgc2ltcGx5IGFkZCBhbiBgbmdNb2RlbGAgYW5kIGEgYG5hbWVgXG4gICAgICogYXR0cmlidXRlIHRvIHRoZSBtYWluIGA8c2VsZWN0PmAgdGFnLlxuICAgICAqXG4gICAgICogSWYgeW91ciBvcHRpb24gdmFsdWVzIGFyZSBzaW1wbGUgc3RyaW5ncywgeW91IGNhbiBiaW5kIHRvIHRoZSBub3JtYWwgYHZhbHVlYCBwcm9wZXJ0eVxuICAgICAqIG9uIHRoZSBvcHRpb24uICBJZiB5b3VyIG9wdGlvbiB2YWx1ZXMgaGFwcGVuIHRvIGJlIG9iamVjdHMgKGFuZCB5b3UnZCBsaWtlIHRvIHNhdmUgdGhlXG4gICAgICogc2VsZWN0aW9uIGluIHlvdXIgZm9ybSBhcyBhbiBvYmplY3QpLCB1c2UgYG5nVmFsdWVgIGluc3RlYWQ6XG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9zZWxlY3RDb250cm9sL3NlbGVjdF9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogSW4gcmVhY3RpdmUgZm9ybXMsIHlvdSdsbCBhbHNvIHdhbnQgdG8gYWRkIHlvdXIgZm9ybSBkaXJlY3RpdmUgKGBmb3JtQ29udHJvbE5hbWVgIG9yXG4gICAgICogYGZvcm1Db250cm9sYCkgb24gdGhlIG1haW4gYDxzZWxlY3Q+YCB0YWcuIExpa2UgaW4gdGhlIGZvcm1lciBleGFtcGxlLCB5b3UgaGF2ZSB0aGVcbiAgICAgKiBjaG9pY2Ugb2YgYmluZGluZyB0byB0aGUgIGB2YWx1ZWAgb3IgYG5nVmFsdWVgIHByb3BlcnR5IG9uIHRoZSBzZWxlY3QncyBvcHRpb25zLlxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVTZWxlY3RDb250cm9sL3JlYWN0aXZlX3NlbGVjdF9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogTm90ZTogV2UgbGlzdGVuIHRvIHRoZSAnY2hhbmdlJyBldmVudCBiZWNhdXNlICdpbnB1dCcgZXZlbnRzIGFyZW4ndCBmaXJlZFxuICAgICAqIGZvciBzZWxlY3RzIGluIEZpcmVmb3ggYW5kIElFOlxuICAgICAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjQzNTBcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy80NjYwMDQ1L1xuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX2dldE9wdGlvbklkKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3NlbGVjdGVkSW5kZXgnLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVN0cmluZyA9IF9idWlsZFZhbHVlU3RyaW5nKGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZVN0cmluZyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlU3RyaW5nO1xuICAgICAgICAgICAgICAgIGZuKF90aGlzLl9nZXRPcHRpb25WYWx1ZSh2YWx1ZVN0cmluZykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX3JlZ2lzdGVyT3B0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25JZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IEFycmF5LmZyb20odGhpcy5fb3B0aW9uTWFwLmtleXMoKSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChsb29zZUlkZW50aWNhbCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVTdHJpbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gX2V4dHJhY3RJZCh2YWx1ZVN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uTWFwLmhhcyhpZCkgPyB0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKSA6IHZhbHVlU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtmb3JtQ29udHJvbE5hbWVdLHNlbGVjdDpub3QoW211bHRpcGxlXSlbZm9ybUNvbnRyb2xdLHNlbGVjdDpub3QoW211bHRpcGxlXSlbbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFNlZSBkb2NzIGZvciB7XFxAbGluayBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvcn0gZm9yIHVzYWdlIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU2VsZWN0T3B0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfc2VsZWN0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ1NlbGVjdE9wdGlvbihfZWxlbWVudCwgX3JlbmRlcmVyLCBfc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdCA9IF9zZWxlY3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KVxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLl9zZWxlY3QuX3JlZ2lzdGVyT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZSwgXCJuZ1ZhbHVlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5zZXQodGhpcy5pZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ1ZhbHVlJyxdIH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsndmFsdWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTZWxlY3RPcHRpb247XG4gICAgfSgpKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIFNFTEVDVF9NVUxUSVBMRV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmckMShpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHZhbHVlID0gXCInXCIgKyB2YWx1ZSArIFwiJ1wiO1xuICAgICAgICBpZiAoIWlzUHJpbWl0aXZlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gJ09iamVjdCc7XG4gICAgICAgIHJldHVybiAoaWQgKyBcIjogXCIgKyB2YWx1ZSkuc2xpY2UoMCwgNTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlU3RyaW5nXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXh0cmFjdElkJDEodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nLnNwbGl0KCc6JylbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiBhIHNlbGVjdCBlbGVtZW50LlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2lkQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9uU2VsZWN0ZWRTdGF0ZVNldHRlcjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdmFsdWVzIHRvIGlkc1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkc18xID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5fZ2V0T3B0aW9uSWQodik7IH0pO1xuICAgICAgICAgICAgICAgIG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIgPSBmdW5jdGlvbiAob3B0LCBvKSB7IG9wdC5fc2V0U2VsZWN0ZWQoaWRzXzEuaW5kZXhPZihvLnRvU3RyaW5nKCkpID4gLTEpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uU2VsZWN0ZWRTdGF0ZVNldHRlciA9IGZ1bmN0aW9uIChvcHQsIG8pIHsgb3B0Ll9zZXRTZWxlY3RlZChmYWxzZSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAuZm9yRWFjaChvcHRpb25TZWxlY3RlZFN0YXRlU2V0dGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChfLmhhc093blByb3BlcnR5KCdzZWxlY3RlZE9wdGlvbnMnKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gXy5zZWxlY3RlZE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHQgPSBvcHRpb25zLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBfdGhpcy5fZ2V0T3B0aW9uVmFsdWUob3B0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0aW9ucyA9IChfLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0ID0gb3B0aW9ucy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IF90aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgICAgIGZuKHNlbGVjdGVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX3JlZ2lzdGVyT3B0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9ICh0aGlzLl9pZENvdW50ZXIrKykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25JZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IEFycmF5LmZyb20odGhpcy5fb3B0aW9uTWFwLmtleXMoKSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChsb29zZUlkZW50aWNhbCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKS5fdmFsdWUsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlU3RyaW5nXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gX2V4dHJhY3RJZCQxKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25NYXAuaGFzKGlkKSA/IHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLl92YWx1ZSA6IHZhbHVlU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3RbbXVsdGlwbGVdW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbF0sc2VsZWN0W211bHRpcGxlXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0KScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtTRUxFQ1RfTVVMVElQTEVfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE1hcmtzIGA8b3B0aW9uPmAgYXMgZHluYW1pYywgc28gQW5ndWxhciBjYW4gYmUgbm90aWZpZWQgd2hlbiBvcHRpb25zIGNoYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8c2VsZWN0IG11bHRpcGxlIG5hbWU9XCJjaXR5XCIgbmdNb2RlbD5cbiAgICAgKiAgIDxvcHRpb24gKm5nRm9yPVwibGV0IGMgb2YgY2l0aWVzXCIgW3ZhbHVlXT1cImNcIj48L29wdGlvbj5cbiAgICAgKiA8L3NlbGVjdD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3NlbGVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTmdTZWxlY3RNdWx0aXBsZU9wdGlvbihfZWxlbWVudCwgX3JlbmRlcmVyLCBfc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdCA9IF9zZWxlY3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLCBcIm5nVmFsdWVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nJDEodGhpcy5pZCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUoX2J1aWxkVmFsdWVTdHJpbmckMSh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLl9zZXRFbGVtZW50VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gc2VsZWN0ZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLl9zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ29wdGlvbicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdWYWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdWYWx1ZScsXSB9LF0sXG4gICAgICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU2VsZWN0TXVsdGlwbGVPcHRpb247XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250cm9sUGF0aChuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wYXRoLmNvbmNhdChbbmFtZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0VXBDb250cm9sKGNvbnRyb2wsIGRpcikge1xuICAgICAgICBpZiAoIWNvbnRyb2wpXG4gICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdDYW5ub3QgZmluZCBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgaWYgKCFkaXIudmFsdWVBY2Nlc3NvcilcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICBjb250cm9sLnZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbY29udHJvbC52YWxpZGF0b3IsIGRpci52YWxpZGF0b3JdKTtcbiAgICAgICAgY29udHJvbC5hc3luY1ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFtjb250cm9sLmFzeW5jVmFsaWRhdG9yLCBkaXIuYXN5bmNWYWxpZGF0b3JdKTtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShjb250cm9sLnZhbHVlKTtcbiAgICAgICAgLy8gdmlldyAtPiBtb2RlbFxuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0VmFsdWUobmV3VmFsdWUsIHsgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlOiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRvdWNoZWRcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7IH0pO1xuICAgICAgICBjb250cm9sLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKG5ld1ZhbHVlLCBlbWl0TW9kZWxFdmVudCkge1xuICAgICAgICAgICAgLy8gY29udHJvbCAtPiB2aWV3XG4gICAgICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgLT4gbmdNb2RlbFxuICAgICAgICAgICAgaWYgKGVtaXRNb2RlbEV2ZW50KVxuICAgICAgICAgICAgICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICAgICAgY29udHJvbC5yZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2UoZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtcnVuIHZhbGlkYXRpb24gd2hlbiB2YWxpZGF0b3IgYmluZGluZyBjaGFuZ2VzLCBlLmcuIG1pbmxlbmd0aD0zIC0+IG1pbmxlbmd0aD00XG4gICAgICAgIGRpci5fcmF3VmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICgoKHZhbGlkYXRvcikpLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpXG4gICAgICAgICAgICAgICAgKCh2YWxpZGF0b3IpKS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpci5fcmF3QXN5bmNWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKCgodmFsaWRhdG9yKSkucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSlcbiAgICAgICAgICAgICAgICAoKHZhbGlkYXRvcikpLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFuVXBDb250cm9sKGNvbnRyb2wsIGRpcikge1xuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9ub0NvbnRyb2xFcnJvcihkaXIpOyB9KTtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX25vQ29udHJvbEVycm9yKGRpcik7IH0pO1xuICAgICAgICBkaXIuX3Jhd1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpci5fcmF3QXN5bmNWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29udHJvbClcbiAgICAgICAgICAgIGNvbnRyb2wuX2NsZWFyQ2hhbmdlRm5zKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRVcEZvcm1Db250YWluZXIoY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGNvbnRyb2wpKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGNvbnRyb2wudmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFtjb250cm9sLnZhbGlkYXRvciwgZGlyLnZhbGlkYXRvcl0pO1xuICAgICAgICBjb250cm9sLmFzeW5jVmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW2NvbnRyb2wuYXN5bmNWYWxpZGF0b3IsIGRpci5hc3luY1ZhbGlkYXRvcl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX25vQ29udHJvbEVycm9yKGRpcikge1xuICAgICAgICByZXR1cm4gX3Rocm93RXJyb3IoZGlyLCAnVGhlcmUgaXMgbm8gRm9ybUNvbnRyb2wgaW5zdGFuY2UgYXR0YWNoZWQgdG8gZm9ybSBjb250cm9sIGVsZW1lbnQgd2l0aCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX3Rocm93RXJyb3IoZGlyLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2VFbmQ7XG4gICAgICAgIGlmIChkaXIucGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gXCJwYXRoOiAnXCIgKyBkaXIucGF0aC5qb2luKCcgLT4gJykgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIucGF0aFswXSkge1xuICAgICAgICAgICAgbWVzc2FnZUVuZCA9IFwibmFtZTogJ1wiICsgZGlyLnBhdGggKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSAndW5zcGVjaWZpZWQgbmFtZSBhdHRyaWJ1dGUnO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICsgXCIgXCIgKyBtZXNzYWdlRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodmFsaWRhdG9ycykgPyBWYWxpZGF0b3JzLmNvbXBvc2UodmFsaWRhdG9ycy5tYXAobm9ybWFsaXplVmFsaWRhdG9yKSkgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHZhbGlkYXRvcnMpID8gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmModmFsaWRhdG9ycy5tYXAobm9ybWFsaXplQXN5bmNWYWxpZGF0b3IpKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0gez99IHZpZXdNb2RlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdmlld01vZGVsKSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbW9kZWwnKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhbmdlID0gY2hhbmdlc1snbW9kZWwnXTtcbiAgICAgICAgaWYgKGNoYW5nZS5pc0ZpcnN0Q2hhbmdlKCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICFsb29zZUlkZW50aWNhbCh2aWV3TW9kZWwsIGNoYW5nZS5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBCVUlMVElOX0FDQ0VTU09SUyA9IFtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVBY2Nlc3NvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCdWlsdEluQWNjZXNzb3IodmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICByZXR1cm4gQlVJTFRJTl9BQ0NFU1NPUlMuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gdmFsdWVBY2Nlc3Nvci5jb25zdHJ1Y3RvciA9PT0gYTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZUFjY2Vzc29yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VsZWN0VmFsdWVBY2Nlc3NvcihkaXIsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgIGlmICghdmFsdWVBY2Nlc3NvcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVmYXVsdEFjY2Vzc29yO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBidWlsdGluQWNjZXNzb3I7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1c3RvbUFjY2Vzc29yO1xuICAgICAgICB2YWx1ZUFjY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PT0gRGVmYXVsdFZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCdWlsdEluQWNjZXNzb3IodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbkFjY2Vzc29yKVxuICAgICAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdNb3JlIHRoYW4gb25lIGJ1aWx0LWluIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXMgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgICAgICAgICBidWlsdGluQWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yKVxuICAgICAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdNb3JlIHRoYW4gb25lIGN1c3RvbSB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUFjY2Vzc29yO1xuICAgICAgICBpZiAoYnVpbHRpbkFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWx0aW5BY2Nlc3NvcjtcbiAgICAgICAgaWYgKGRlZmF1bHRBY2Nlc3NvcilcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QWNjZXNzb3I7XG4gICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBiYXNlIGNsYXNzIGZvciBjb2RlIHNoYXJlZCBiZXR3ZWVuIHtcXEBsaW5rIE5nTW9kZWxHcm91cH0gYW5kIHtcXEBsaW5rIEZvcm1Hcm91cE5hbWV9LlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkRm9ybUdyb3VwKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlRm9ybUdyb3VwKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHtcXEBsaW5rIEZvcm1Hcm91cH0gYmFja2luZyB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRGb3JtR3JvdXAodGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHBhdGggdG8gdGhpcyBjb250cm9sIGdyb3VwLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHtcXEBsaW5rIEZvcm19IHRvIHdoaWNoIHRoaXMgZ3JvdXAgYmVsb25ncy5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2xTdGF0dXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDb250cm9sU3RhdHVzKGNkKSB7XG4gICAgICAgICAgICB0aGlzLl9jZCA9IGNkO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NVbnRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLnVudG91Y2hlZCA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1RvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLnRvdWNoZWQgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NQcmlzdGluZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wucHJpc3RpbmUgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NEaXJ0eVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wuZGlydHkgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NWYWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wudmFsaWQgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NJbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5pbnZhbGlkIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzUGVuZGluZ1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wucGVuZGluZyA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbFN0YXR1cztcbiAgICB9KCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udHJvbFN0YXR1c0hvc3QgPSB7XG4gICAgICAgICdbY2xhc3MubmctdW50b3VjaGVkXSc6ICduZ0NsYXNzVW50b3VjaGVkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy10b3VjaGVkXSc6ICduZ0NsYXNzVG91Y2hlZCcsXG4gICAgICAgICdbY2xhc3MubmctcHJpc3RpbmVdJzogJ25nQ2xhc3NQcmlzdGluZScsXG4gICAgICAgICdbY2xhc3MubmctZGlydHldJzogJ25nQ2xhc3NEaXJ0eScsXG4gICAgICAgICdbY2xhc3MubmctdmFsaWRdJzogJ25nQ2xhc3NWYWxpZCcsXG4gICAgICAgICdbY2xhc3MubmctaW52YWxpZF0nOiAnbmdDbGFzc0ludmFsaWQnLFxuICAgICAgICAnW2NsYXNzLm5nLXBlbmRpbmddJzogJ25nQ2xhc3NQZW5kaW5nJyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gQW5ndWxhciBmb3JtIGNvbnRyb2xzIHRoYXQgc2V0cyBDU1MgY2xhc3Nlc1xuICAgICAqIGJhc2VkIG9uIGNvbnRyb2wgc3RhdHVzICh2YWxpZC9pbnZhbGlkL2RpcnR5L2V0YykuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sU3RhdHVzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoTmdDb250cm9sU3RhdHVzLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzKGNkKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmdDb250cm9sU3RhdHVzLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbE5hbWVdLFtuZ01vZGVsXSxbZm9ybUNvbnRyb2xdJywgaG9zdDogbmdDb250cm9sU3RhdHVzSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nQ29udHJvbFN0YXR1cy5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBOZ0NvbnRyb2xTdGF0dXM7XG4gICAgfShBYnN0cmFjdENvbnRyb2xTdGF0dXMpKTtcbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgYXV0b21hdGljYWxseSBhcHBsaWVkIHRvIEFuZ3VsYXIgZm9ybSBncm91cHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gICAgICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0NvbnRyb2xTdGF0dXNHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKE5nQ29udHJvbFN0YXR1c0dyb3VwLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzR3JvdXAoY2QpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNkKTtcbiAgICAgICAgfVxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdDb250cm9sU3RhdHVzR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1c0dyb3VwO1xuICAgIH0oQWJzdHJhY3RDb250cm9sU3RhdHVzKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIGJ5IGRpcmVjdGl2ZXMgYW5kIGNvbXBvbmVudHMgdG8gZW1pdCBjdXN0b20gRXZlbnRzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGBaaXBweWAgYWx0ZXJuYXRpdmVseSBlbWl0cyBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdoZW4gaXRzXG4gICAgICogdGl0bGUgZ2V0cyBjbGlja2VkOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnemlwcHknLFxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJ6aXBweVwiPlxuICAgICAqICAgICA8ZGl2IChjbGljayk9XCJ0b2dnbGUoKVwiPlRvZ2dsZTwvZGl2PlxuICAgICAqICAgICA8ZGl2IFtoaWRkZW5dPVwiIXZpc2libGVcIj5cbiAgICAgKiAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICA8L2Rpdj5gfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgWmlwcHkge1xuICAgICAqICAgdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgICogICBcXEBPdXRwdXQoKSBvcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKiAgIFxcQE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKlxuICAgICAqICAgdG9nZ2xlKCkge1xuICAgICAqICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICAgICAqICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICogICAgICAgdGhpcy5vcGVuLmVtaXQobnVsbCk7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgdGhpcy5jbG9zZS5lbWl0KG51bGwpO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIGV2ZW50cyBwYXlsb2FkIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGUgcGFyYW1ldGVyIGAkZXZlbnRgIG9uIHRoZSBjb21wb25lbnRzIG91dHB1dCBldmVudFxuICAgICAqIGhhbmRsZXI6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8emlwcHkgKG9wZW4pPVwib25PcGVuKCRldmVudClcIiAoY2xvc2UpPVwib25DbG9zZSgkZXZlbnQpXCI+PC96aXBweT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzZXMgUnguT2JzZXJ2YWJsZSBidXQgcHJvdmlkZXMgYW4gYWRhcHRlciB0byBtYWtlIGl0IHdvcmsgYXMgc3BlY2lmaWVkIGhlcmU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2podXNhaW4vb2JzZXJ2YWJsZS1zcGVjXG4gICAgICpcbiAgICAgKiBPbmNlIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjIGlzIGF2YWlsYWJsZSwgc3dpdGNoIHRvIGl0LlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNShFdmVudEVtaXR0ZXIsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFtFdmVudEVtaXR0ZXJdLCB3aGljaCBkZXBlbmRpbmcgb24gW2lzQXN5bmNdLFxuICAgICAgICAgKiBkZWxpdmVycyBldmVudHMgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gaXNBc3luY1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGlzQXN5bmMpIHtcbiAgICAgICAgICAgIGlmIChpc0FzeW5jID09PSB2b2lkIDApIHsgaXNBc3luYyA9IGZhbHNlOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID0gaXNBc3luYztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSBnZW5lcmF0b3JPck5leHRcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZXJyb3JcbiAgICAgICAgICogQHBhcmFtIHs/PX0gY29tcGxldGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGdlbmVyYXRvck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlZHVsZXJGbjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yRm4gPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGxldGVGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0ICYmIHR5cGVvZiBnZW5lcmF0b3JPck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKGVycik7IH0pOyB9IDogZnVuY3Rpb24gKGVycikgeyBlcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSgpOyB9KTsgfSA6IGZ1bmN0aW9uICgpIHsgY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBzY2hlZHVsZXJGbiwgZXJyb3JGbiwgY29tcGxldGVGbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfShyeGpzX1N1YmplY3QuU3ViamVjdCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgdmFsaWQsIGkuZS4gdGhhdCBubyBlcnJvcnMgZXhpc3QgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFZBTElEID0gJ1ZBTElEJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIGludmFsaWQsIGkuZS4gdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIElOVkFMSUQgPSAnSU5WQUxJRCc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyBwZW5kaW5nLCBpLmUuIHRoYXQgYXN5bmMgdmFsaWRhdGlvbiBpcyBvY2N1cnJpbmcgYW5kXG4gICAgICogZXJyb3JzIGFyZSBub3QgeWV0IGF2YWlsYWJsZSBmb3IgdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFBFTkRJTkcgPSAnUEVORElORyc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyBkaXNhYmxlZCwgaS5lLiB0aGF0IHRoZSBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIGFuY2VzdG9yXG4gICAgICogY2FsY3VsYXRpb25zIG9mIHZhbGlkaXR5IG9yIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIERJU0FCTEVEID0gJ0RJU0FCTEVEJztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgKiBAcGFyYW0gez99IHBhdGhcbiAgICAgKiBAcGFyYW0gez99IGRlbGltaXRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2ZpbmQoY29udHJvbCwgcGF0aCwgZGVsaW1pdGVyKSB7XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgcGF0aCA9ICgocGF0aCkpLnNwbGl0KGRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBBcnJheSAmJiAocGF0aC5sZW5ndGggPT09IDApKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiAoKHBhdGgpKS5yZWR1Y2UoZnVuY3Rpb24gKHYsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgRm9ybUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuY29udHJvbHNbbmFtZV0gfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgRm9ybUFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuYXQoLyoqIEB0eXBlIHs/fSAqLyAobmFtZSkpIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgY29udHJvbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9PYnNlcnZhYmxlKHIpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJvbWlzZShyKSA/IHJ4anNfb2JzZXJ2YWJsZV9mcm9tUHJvbWlzZS5mcm9tUHJvbWlzZShyKSA6IHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb2VyY2VUb1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsaWRhdG9yKSA/IGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcikgOiB2YWxpZGF0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN5bmNWYWxpZGF0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvZXJjZVRvQXN5bmNWYWxpZGF0b3IoYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXN5bmNWYWxpZGF0b3IpID8gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcikgOiBhc3luY1ZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciB7XFxAbGluayBGb3JtQ29udHJvbH0sIHtcXEBsaW5rIEZvcm1Hcm91cH0sIGFuZFxuICAgICAqIHtcXEBsaW5rIEZvcm1BcnJheX0uXG4gICAgICpcbiAgICAgKiBJdCBwcm92aWRlcyBzb21lIG9mIHRoZSBzaGFyZWQgYmVoYXZpb3IgdGhhdCBhbGwgY29udHJvbHMgYW5kIGdyb3VwcyBvZiBjb250cm9scyBoYXZlLCBsaWtlXG4gICAgICogcnVubmluZyB2YWxpZGF0b3JzLCBjYWxjdWxhdGluZyBzdGF0dXMsIGFuZCByZXNldHRpbmcgc3RhdGUuIEl0IGFsc28gZGVmaW5lcyB0aGUgcHJvcGVydGllc1xuICAgICAqIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBzdWItY2xhc3NlcywgbGlrZSBgdmFsdWVgLCBgdmFsaWRgLCBhbmQgYGRpcnR5YC4gSXQgc2hvdWxkbid0IGJlXG4gICAgICogaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Q29udHJvbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvclxuICAgICAgICAgKiBAcGFyYW0gez99IGFzeW5jVmFsaWRhdG9yXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2wodmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4gICAgICAgICAgICB0aGlzLmFzeW5jVmFsaWRhdG9yID0gYXN5bmNWYWxpZGF0b3I7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHBhcmVudCBjb250cm9sLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2wuIFRoZXJlIGFyZSBmb3VyIHBvc3NpYmxlXG4gICAgICAgICAgICAgKiB2YWxpZGF0aW9uIHN0YXR1c2VzOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICogKipWQUxJRCoqOiAgY29udHJvbCBoYXMgcGFzc2VkIGFsbCB2YWxpZGF0aW9uIGNoZWNrc1xuICAgICAgICAgICAgICogKiAqKklOVkFMSUQqKjogY29udHJvbCBoYXMgZmFpbGVkIGF0IGxlYXN0IG9uZSB2YWxpZGF0aW9uIGNoZWNrXG4gICAgICAgICAgICAgKiAqICoqUEVORElORyoqOiBjb250cm9sIGlzIGluIHRoZSBtaWRzdCBvZiBjb25kdWN0aW5nIGEgdmFsaWRhdGlvbiBjaGVja1xuICAgICAgICAgICAgICogKiAqKkRJU0FCTEVEKio6IGNvbnRyb2wgaXMgZXhlbXB0IGZyb20gdmFsaWRhdGlvbiBjaGVja3NcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGVzZSBzdGF0dXNlcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLCBzbyBhIGNvbnRyb2wgY2Fubm90IGJlXG4gICAgICAgICAgICAgKiBib3RoIHZhbGlkIEFORCBpbnZhbGlkIG9yIGludmFsaWQgQU5EIGRpc2FibGVkLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgdmFsaWRgIHdoZW4gaXRzIGBzdGF0dXMgPT09IFZBTElEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGhhdmUgcGFzc2VkIGFsbCBpdHNcbiAgICAgICAgICAgICAqIHZhbGlkYXRpb24gY2hlY2tzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IFZBTElEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgaW52YWxpZGAgd2hlbiBpdHMgYHN0YXR1cyA9PT0gSU5WQUxJRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3JkZXIgdG8gaGF2ZSB0aGlzIHN0YXR1cywgdGhlIGNvbnRyb2wgbXVzdCBoYXZlIGZhaWxlZFxuICAgICAgICAgICAgICogYXQgbGVhc3Qgb25lIG9mIGl0cyB2YWxpZGF0aW9uIGNoZWNrcy5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09PSBJTlZBTElEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicGVuZGluZ1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgcGVuZGluZ2Agd2hlbiBpdHMgYHN0YXR1cyA9PT0gUEVORElOR2AuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3JkZXIgdG8gaGF2ZSB0aGlzIHN0YXR1cywgdGhlIGNvbnRyb2wgbXVzdCBiZSBpbiB0aGVcbiAgICAgICAgICAgICAqIG1pZGRsZSBvZiBjb25kdWN0aW5nIGEgdmFsaWRhdGlvbiBjaGVjay5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09IFBFTkRJTkc7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZGlzYWJsZWRgIHdoZW4gaXRzIGBzdGF0dXMgPT09IERJU0FCTEVEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBEaXNhYmxlZCBjb250cm9scyBhcmUgZXhlbXB0IGZyb20gdmFsaWRhdGlvbiBjaGVja3MgYW5kXG4gICAgICAgICAgICAgKiBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlaXIgYW5jZXN0b3JcbiAgICAgICAgICAgICAqIGNvbnRyb2xzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IERJU0FCTEVEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZW5hYmxlZGAgYXMgbG9uZyBhcyBpdHMgYHN0YXR1cyAhPT0gRElTQUJMRURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzLCBpdCBoYXMgYSBzdGF0dXMgb2YgYFZBTElEYCwgYElOVkFMSURgLCBvclxuICAgICAgICAgICAgICogYFBFTkRJTkdgLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgIT09IERJU0FCTEVEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbnkgZXJyb3JzIGdlbmVyYXRlZCBieSBmYWlsaW5nIHZhbGlkYXRpb24uIElmIHRoZXJlXG4gICAgICAgICAgICAgKiBhcmUgbm8gZXJyb3JzLCBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lcnJvcnM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwcmlzdGluZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgcHJpc3RpbmVgIGlmIHRoZSB1c2VyIGhhcyBub3QgeWV0IGNoYW5nZWRcbiAgICAgICAgICAgICAqIHRoZSB2YWx1ZSBpbiB0aGUgVUkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHByb2dyYW1tYXRpYyBjaGFuZ2VzIHRvIGEgY29udHJvbCdzIHZhbHVlIHdpbGxcbiAgICAgICAgICAgICAqICpub3QqIG1hcmsgaXQgZGlydHkuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByaXN0aW5lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYGRpcnR5YCBpZiB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAqIGluIHRoZSBVSS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgcHJvZ3JhbW1hdGljIGNoYW5nZXMgdG8gYSBjb250cm9sJ3MgdmFsdWUgd2lsbFxuICAgICAgICAgICAgICogKm5vdCogbWFyayBpdCBkaXJ0eS5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMucHJpc3RpbmU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIG1hcmtlZCBgdG91Y2hlZGAgb25jZSB0aGUgdXNlciBoYXMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdG91Y2hlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInVudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgdW50b3VjaGVkYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5fdG91Y2hlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IGV2ZXJ5IHRpbWUgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sIGNoYW5nZXMsIGluXG4gICAgICAgICAgICAgKiB0aGUgVUkgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVDaGFuZ2VzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwic3RhdHVzQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IGV2ZXJ5IHRpbWUgdGhlIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sXG4gICAgICAgICAgICAgKiBpcyByZS1jYWxjdWxhdGVkLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXNDaGFuZ2VzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHN5bmNocm9ub3VzIHZhbGlkYXRvcnMgdGhhdCBhcmUgYWN0aXZlIG9uIHRoaXMgY29udHJvbC4gIENhbGxpbmdcbiAgICAgICAgICogdGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3Rpbmcgc3luYyB2YWxpZGF0b3JzLlxuICAgICAgICAgKiBAcGFyYW0gez99IG5ld1ZhbGlkYXRvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRWYWxpZGF0b3JzID0gZnVuY3Rpb24gKG5ld1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBjb2VyY2VUb1ZhbGlkYXRvcihuZXdWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYXN5bmMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiBDYWxsaW5nIHRoaXNcbiAgICAgICAgICogd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGFzeW5jIHZhbGlkYXRvcnMuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsaWRhdG9yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldEFzeW5jVmFsaWRhdG9ycyA9IGZ1bmN0aW9uIChuZXdWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKG5ld1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbXB0aWVzIG91dCB0aGUgc3luYyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuY2xlYXJWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkgeyB0aGlzLnZhbGlkYXRvciA9IG51bGw7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbXB0aWVzIG91dCB0aGUgYXN5bmMgdmFsaWRhdG9yIGxpc3QuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmNsZWFyQXN5bmNWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkgeyB0aGlzLmFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGB0b3VjaGVkYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIGFsc28gbWFyayBhbGwgZGlyZWN0IGFuY2VzdG9ycyBhcyBgdG91Y2hlZGAgdG8gbWFpbnRhaW5cbiAgICAgICAgICogdGhlIG1vZGVsLlxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzVG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGB1bnRvdWNoZWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgYW55IGNoaWxkcmVuLCBpdCB3aWxsIGFsc28gbWFyayBhbGwgY2hpbGRyZW4gYXMgYHVudG91Y2hlZGBcbiAgICAgICAgICogdG8gbWFpbnRhaW4gdGhlIG1vZGVsLCBhbmQgcmUtY2FsY3VsYXRlIHRoZSBgdG91Y2hlZGAgc3RhdHVzIG9mIGFsbCBwYXJlbnRcbiAgICAgICAgICogY29udHJvbHMuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNVbnRvdWNoZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5tYXJrQXNVbnRvdWNoZWQoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBkaXJ0eWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBhbHNvIG1hcmsgYWxsIGRpcmVjdCBhbmNlc3RvcnMgYXMgYGRpcnR5YCB0byBtYWludGFpblxuICAgICAgICAgKiB0aGUgbW9kZWwuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNEaXJ0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNEaXJ0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwcmlzdGluZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGl0IHdpbGwgYWxzbyBtYXJrIGFsbCBjaGlsZHJlbiBhcyBgcHJpc3RpbmVgXG4gICAgICAgICAqIHRvIG1haW50YWluIHRoZSBtb2RlbCwgYW5kIHJlLWNhbGN1bGF0ZSB0aGUgYHByaXN0aW5lYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1ByaXN0aW5lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wubWFya0FzUHJpc3RpbmUoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgcGVuZGluZ2AuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNQZW5kaW5nID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc1BlbmRpbmcoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCB3aWxsIGJlIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgKiBleGNsdWRlZCBmcm9tIHRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgYW55IHBhcmVudC4gSXRzIHN0YXR1cyBpcyBgRElTQUJMRURgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiB3aWxsIGJlIGRpc2FibGVkIHRvIG1haW50YWluIHRoZSBtb2RlbC5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBESVNBQkxFRDtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5kaXNhYmxlKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChlbWl0RXZlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzLmVtaXQodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5jZXN0b3JzKG9ubHlTZWxmKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlRm4pIHsgcmV0dXJuIGNoYW5nZUZuKHRydWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbnRyb2wuIFRoaXMgbWVhbnMgdGhlIGNvbnRyb2wgd2lsbCBiZSBpbmNsdWRlZCBpbiB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgICAgICogdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiBpdHMgcGFyZW50LiBJdHMgc3RhdHVzIGlzIHJlLWNhbGN1bGF0ZWQgYmFzZWQgb24gaXRzIHZhbHVlIGFuZFxuICAgICAgICAgKiBpdHMgdmFsaWRhdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGNoaWxkcmVuLCBhbGwgY2hpbGRyZW4gd2lsbCBiZSBlbmFibGVkLlxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gVkFMSUQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5lbmFibGUoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBbmNlc3RvcnMob25seVNlbGYpO1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VGbikgeyByZXR1cm4gY2hhbmdlRm4oZmFsc2UpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gb25seVNlbGZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZUFuY2VzdG9ycyA9IGZ1bmN0aW9uIChvbmx5U2VsZikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHsgdGhpcy5fcGFyZW50ID0gcGFyZW50OyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wuIEFic3RyYWN0IG1ldGhvZCAoaW1wbGVtZW50ZWQgaW4gc3ViLWNsYXNzZXMpLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC4gQWJzdHJhY3QgbWV0aG9kIChpbXBsZW1lbnRlZCBpbiBzdWItY2xhc3NlcykuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUucGF0Y2hWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBjb250cm9sLiBBYnN0cmFjdCBtZXRob2QgKGltcGxlbWVudGVkIGluIHN1Yi1jbGFzc2VzKS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlLWNhbGN1bGF0ZXMgdGhlIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgaXQgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IG9mIGl0cyBhbmNlc3RvcnMuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fc2V0SW5pdGlhbFN0YXR1cygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLl9ydW5WYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB0aGlzLl9jYWxjdWxhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID09PSBWQUxJRCB8fCB0aGlzLl9zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVuQXN5bmNWYWxpZGF0b3IoZW1pdEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcy5lbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVUcmVlVmFsaWRpdHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBlbWl0RXZlbnQgPSAoX2EgPT09IHZvaWQgMCA/IHsgZW1pdEV2ZW50OiB0cnVlIH0gOiBfYSkuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjdHJsKSB7IHJldHVybiBjdHJsLl91cGRhdGVUcmVlVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fc2V0SW5pdGlhbFN0YXR1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fc3RhdHVzID0gdGhpcy5fYWxsQ29udHJvbHNEaXNhYmxlZCgpID8gRElTQUJMRUQgOiBWQUxJRDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9ydW5WYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IgPyB0aGlzLnZhbGlkYXRvcih0aGlzKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGVtaXRFdmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fcnVuQXN5bmNWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEV4aXN0aW5nU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JzID0gdG9PYnNlcnZhYmxlKHRoaXMuYXN5bmNWYWxpZGF0b3IodGhpcykpO1xuICAgICAgICAgICAgICAgIGlmICghKGlzT2JzZXJ2YWJsZShvYnMpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCB0aGUgZm9sbG93aW5nIHZhbGlkYXRvciB0byByZXR1cm4gUHJvbWlzZSBvciBPYnNlcnZhYmxlOiBcIiArIHRoaXMuYXN5bmNWYWxpZGF0b3IgKyBcIi4gSWYgeW91IGFyZSB1c2luZyBGb3JtQnVpbGRlcjsgZGlkIHlvdSBmb3JnZXQgdG8gYnJhY2UgeW91ciB2YWxpZGF0b3JzIGluIGFuIGFycmF5P1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgb2JzLnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLnNldEVycm9ycyhyZXMsIHsgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGVycm9ycyBvbiBhIGZvcm0gY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHdoZW4gdmFsaWRhdGlvbnMgYXJlIHJ1biBtYW51YWxseSBieSB0aGUgdXNlciwgcmF0aGVyIHRoYW4gYXV0b21hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FsbGluZyBgc2V0RXJyb3JzYCB3aWxsIGFsc28gdXBkYXRlIHRoZSB2YWxpZGl0eSBvZiB0aGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBjb25zdCBsb2dpbiA9IG5ldyBGb3JtQ29udHJvbChcInNvbWVMb2dpblwiKTtcbiAgICAgICAgICogbG9naW4uc2V0RXJyb3JzKHtcbiAgICAgICAgICogICBcIm5vdFVuaXF1ZVwiOiB0cnVlXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QobG9naW4udmFsaWQpLnRvRXF1YWwoZmFsc2UpO1xuICAgICAgICAgKiBleHBlY3QobG9naW4uZXJyb3JzKS50b0VxdWFsKHtcIm5vdFVuaXF1ZVwiOiB0cnVlfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGxvZ2luLnNldFZhbHVlKFwic29tZU90aGVyTG9naW5cIik7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbCh0cnVlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBfYSkge1xuICAgICAgICAgICAgdmFyIGVtaXRFdmVudCA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udHJvbHNFcnJvcnMoZW1pdEV2ZW50ICE9PSBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYSBjaGlsZCBjb250cm9sIGdpdmVuIHRoZSBjb250cm9sJ3MgbmFtZSBvciBwYXRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXRocyBjYW4gYmUgcGFzc2VkIGluIGFzIGFuIGFycmF5IG9yIGEgc3RyaW5nIGRlbGltaXRlZCBieSBhIGRvdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gZ2V0IGEgY29udHJvbCBuZXN0ZWQgd2l0aGluIGEgYHBlcnNvbmAgc3ViLWdyb3VwOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGB0aGlzLmZvcm0uZ2V0KCdwZXJzb24ubmFtZScpO2BcbiAgICAgICAgICpcbiAgICAgICAgICogLU9SLVxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGB0aGlzLmZvcm0uZ2V0KFsncGVyc29uJywgJ25hbWUnXSk7YFxuICAgICAgICAgKiBAcGFyYW0gez99IHBhdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIF9maW5kKHRoaXMsIHBhdGgsICcuJyk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gcGF0aCBoYXMgdGhlIGVycm9yIHNwZWNpZmllZC4gT3RoZXJ3aXNlXG4gICAgICAgICAqIHJldHVybnMgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vIHBhdGggaXMgZ2l2ZW4sIGl0IGNoZWNrcyBmb3IgdGhlIGVycm9yIG9uIHRoZSBwcmVzZW50IGNvbnRyb2wuXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXJyb3JDb2RlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250cm9sID0gcGF0aCA/IHRoaXMuZ2V0KHBhdGgpIDogdGhpcztcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sICYmIGNvbnRyb2wuX2Vycm9ycyA/IGNvbnRyb2wuX2Vycm9yc1tlcnJvckNvZGVdIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBwYXRoIGhhcyB0aGUgZXJyb3Igc3BlY2lmaWVkLiBPdGhlcndpc2VcbiAgICAgICAgICogcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgaXQgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIHByZXNlbnQgY29udHJvbC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvckNvZGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgdG9wLWxldmVsIGFuY2VzdG9yIG9mIHRoaXMgY29udHJvbC5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHggPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlICh4Ll9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHguX3BhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gZW1pdEV2ZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVDb250cm9sc0Vycm9ycyA9IGZ1bmN0aW9uIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlQ29udHJvbHNFcnJvcnMoZW1pdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9pbml0T2JzZXJ2YWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2NhbGN1bGF0ZVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbGxDb250cm9sc0Rpc2FibGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERJU0FCTEVEO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9ycylcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbnlDb250cm9sc0hhdmVTdGF0dXMoUEVORElORykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBFTkRJTkc7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW55Q29udHJvbHNIYXZlU3RhdHVzKElOVkFMSUQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgcmV0dXJuIFZBTElEO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IGNiXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHN0YXR1c1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHNIYXZlU3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnN0YXR1cyA9PT0gc3RhdHVzOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmRpcnR5OyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc1RvdWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wudG91Y2hlZDsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVByaXN0aW5lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSAhdGhpcy5fYW55Q29udHJvbHNEaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVUb3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IHRoaXMuX2FueUNvbnRyb2xzVG91Y2hlZCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGZvcm1TdGF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5faXNCb3hlZFZhbHVlID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtU3RhdGUgPT09ICdvYmplY3QnICYmIGZvcm1TdGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGZvcm1TdGF0ZSkubGVuZ3RoID09PSAyICYmICd2YWx1ZScgaW4gZm9ybVN0YXRlICYmICdkaXNhYmxlZCcgaW4gZm9ybVN0YXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2w7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzIG9mIGFuIGluZGl2aWR1YWwgZm9ybSBjb250cm9sLlxuICAgICAqXG4gICAgICogSXQgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3Mgb2YgQW5ndWxhciBmb3JtcywgYWxvbmcgd2l0aFxuICAgICAqIHtcXEBsaW5rIEZvcm1Hcm91cH0gYW5kIHtcXEBsaW5rIEZvcm1BcnJheX0uXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogV2hlbiBpbnN0YW50aWF0aW5nIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9LCB5b3UgY2FuIHBhc3MgaW4gYW4gaW5pdGlhbCB2YWx1ZSBhcyB0aGVcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCgnc29tZSB2YWx1ZScpO1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwudmFsdWUpOyAgICAgLy8gJ3NvbWUgdmFsdWUnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5pdGlhbGl6ZSB0aGUgY29udHJvbCB3aXRoIGEgZm9ybSBzdGF0ZSBvYmplY3Qgb24gaW5zdGFudGlhdGlvbixcbiAgICAgKiB3aGljaCBpbmNsdWRlcyBib3RoIHRoZSB2YWx1ZSBhbmQgd2hldGhlciBvciBub3QgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG4gICAgICogWW91IGNhbid0IHVzZSB0aGUgdmFsdWUga2V5IHdpdGhvdXQgdGhlIGRpc2FibGVkIGtleTsgYm90aCBhcmUgcmVxdWlyZWRcbiAgICAgKiB0byB1c2UgdGhpcyB3YXkgb2YgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiAnbi9hJywgZGlzYWJsZWQ6IHRydWV9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICduL2EnXG4gICAgICogY29uc29sZS5sb2coY3RybC5zdGF0dXMpOyAgIC8vICdESVNBQkxFRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRvIGluY2x1ZGUgYSBzeW5jIHZhbGlkYXRvciAob3IgYW4gYXJyYXkgb2Ygc3luYyB2YWxpZGF0b3JzKSB3aXRoIHRoZSBjb250cm9sLFxuICAgICAqIHBhc3MgaXQgaW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gQXN5bmMgdmFsaWRhdG9ycyBhcmUgYWxzbyBzdXBwb3J0ZWQsIGJ1dFxuICAgICAqIGhhdmUgdG8gYmUgcGFzc2VkIGluIHNlcGFyYXRlbHkgYXMgdGhlIHRoaXJkIGFyZy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICogY29uc29sZS5sb2coY3RybC52YWx1ZSk7ICAgICAvLyAnJ1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwuc3RhdHVzKTsgICAvLyAnSU5WQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBpdHMgc3VwZXJjbGFzcywge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sfSwgZm9yIG1vcmUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEZvcm1Db250cm9sLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZm9ybVN0YXRlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbGlkYXRvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBhc3luY1ZhbGlkYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2woZm9ybVN0YXRlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZm9ybVN0YXRlID09PSB2b2lkIDApIHsgZm9ybVN0YXRlID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgY29lcmNlVG9WYWxpZGF0b3IodmFsaWRhdG9yKSwgY29lcmNlVG9Bc3luY1ZhbGlkYXRvcihhc3luY1ZhbGlkYXRvcikpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Rm9ybVN0YXRlKGZvcm1TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBmb3JtIGNvbnRyb2wgdG8gYHZhbHVlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYG9ubHlTZWxmYCBpcyBgdHJ1ZWAsIHRoaXMgY2hhbmdlIHdpbGwgb25seSBhZmZlY3QgdGhlIHZhbGlkYXRpb24gb2YgdGhpcyBgRm9ybUNvbnRyb2xgXG4gICAgICAgICAqIGFuZCBub3QgaXRzIHBhcmVudCBjb21wb25lbnQuIFRoaXMgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0RXZlbnRgIGlzIGB0cnVlYCwgdGhpc1xuICAgICAgICAgKiBjaGFuZ2Ugd2lsbCBjYXVzZSBhIGB2YWx1ZUNoYW5nZXNgIGV2ZW50IG9uIHRoZSBgRm9ybUNvbnRyb2xgIHRvIGJlIGVtaXR0ZWQuIFRoaXMgZGVmYXVsdHNcbiAgICAgICAgICogdG8gdHJ1ZSAoYXMgaXQgZmFsbHMgdGhyb3VnaCB0byBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eWApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlYCBpcyBgdHJ1ZWAsIHRoZSB2aWV3IHdpbGwgYmUgbm90aWZpZWQgYWJvdXQgdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgKiB2aWEgYW4gYG9uQ2hhbmdlYCBldmVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiBgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlYCBpcyBub3RcbiAgICAgICAgICogc3BlY2lmaWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZW1pdFZpZXdUb01vZGVsQ2hhbmdlYCBpcyBgdHJ1ZWAsIGFuIG5nTW9kZWxDaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCB0byB1cGRhdGUgdGhlXG4gICAgICAgICAqIG1vZGVsLiAgVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiBgZW1pdFZpZXdUb01vZGVsQ2hhbmdlYCBpcyBub3Qgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQsIGVtaXRNb2RlbFRvVmlld0NoYW5nZSA9IF9iLmVtaXRNb2RlbFRvVmlld0NoYW5nZSwgZW1pdFZpZXdUb01vZGVsQ2hhbmdlID0gX2IuZW1pdFZpZXdUb01vZGVsQ2hhbmdlO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZS5sZW5ndGggJiYgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZUZuKSB7IHJldHVybiBjaGFuZ2VGbihfdGhpcy5fdmFsdWUsIGVtaXRWaWV3VG9Nb2RlbENoYW5nZSAhPT0gZmFsc2UpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRjaGVzIHRoZSB2YWx1ZSBvZiBhIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIHtcXEBsaW5rIEZvcm1Db250cm9sLnNldFZhbHVlfSBhdCB0aGlzIGxldmVsLlxuICAgICAgICAgKiBJdCBleGlzdHMgZm9yIHN5bW1ldHJ5IHdpdGgge1xcQGxpbmsgRm9ybUdyb3VwLnBhdGNoVmFsdWV9IG9uIGBGb3JtR3JvdXBzYCBhbmQgYEZvcm1BcnJheXNgLFxuICAgICAgICAgKiB3aGVyZSBpdCBkb2VzIGJlaGF2ZSBkaWZmZXJlbnRseS5cbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucGF0Y2hWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBmb3JtIGNvbnRyb2wuIFRoaXMgbWVhbnMgYnkgZGVmYXVsdDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBpdCBpcyBtYXJrZWQgYXMgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIGl0IGlzIG1hcmtlZCBhcyBgdW50b3VjaGVkYFxuICAgICAgICAgKiAqIHZhbHVlIGlzIHNldCB0byBudWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyByZXNldCB0byBhIHNwZWNpZmljIGZvcm0gc3RhdGUgYnkgcGFzc2luZyB0aHJvdWdoIGEgc3RhbmRhbG9uZVxuICAgICAgICAgKiB2YWx1ZSBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXRlXG4gICAgICAgICAqICh0aGVzZSBhcmUgdGhlIG9ubHkgdHdvIHByb3BlcnRpZXMgdGhhdCBjYW5ub3QgYmUgY2FsY3VsYXRlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4OlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiB0aGlzLmNvbnRyb2wucmVzZXQoJ05hbmN5Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuY29udHJvbC52YWx1ZSk7ICAvLyAnTmFuY3knXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBPUlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogdGhpcy5jb250cm9sLnJlc2V0KHt2YWx1ZTogJ05hbmN5JywgZGlzYWJsZWQ6IHRydWV9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5jb250cm9sLnZhbHVlKTsgIC8vICdOYW5jeSdcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5jb250cm9sLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez89fSBmb3JtU3RhdGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZm9ybVN0YXRlLCBfYSkge1xuICAgICAgICAgICAgaWYgKGZvcm1TdGF0ZSA9PT0gdm9pZCAwKSB7IGZvcm1TdGF0ZSA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvcm1TdGF0ZShmb3JtU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5tYXJrQXNQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMubWFya0FzVW50b3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSwgeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIGZvciBjaGFuZ2UgZXZlbnRzLlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZS5wdXNoKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2NsZWFyQ2hhbmdlRm5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGRpc2FibGVkIGV2ZW50cy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5wdXNoKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNiKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZvcm1TdGF0ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hcHBseUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChmb3JtU3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0JveGVkVmFsdWUoZm9ybVN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gZm9ybVN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZS5kaXNhYmxlZCA/IHRoaXMuZGlzYWJsZSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gZm9ybVN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2w7XG4gICAgfShBYnN0cmFjdENvbnRyb2wpKTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGEgZ3JvdXAgb2Yge1xcQGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQSBgRm9ybUdyb3VwYCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBjaGlsZCB7XFxAbGluayBGb3JtQ29udHJvbH0gaW50byBvbmUgb2JqZWN0LFxuICAgICAqIHdpdGggZWFjaCBjb250cm9sIG5hbWUgYXMgdGhlIGtleS4gIEl0IGNhbGN1bGF0ZXMgaXRzIHN0YXR1cyBieSByZWR1Y2luZyB0aGUgc3RhdHVzZXNcbiAgICAgKiBvZiBpdHMgY2hpbGRyZW4uIEZvciBleGFtcGxlLCBpZiBvbmUgb2YgdGhlIGNvbnRyb2xzIGluIGEgZ3JvdXAgaXMgaW52YWxpZCwgdGhlIGVudGlyZVxuICAgICAqIGdyb3VwIGJlY29tZXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIGBGb3JtR3JvdXBgIGlzIG9uZSBvZiB0aGUgdGhyZWUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2tzIHVzZWQgdG8gZGVmaW5lIGZvcm1zIGluIEFuZ3VsYXIsXG4gICAgICogYWxvbmcgd2l0aCB7XFxAbGluayBGb3JtQ29udHJvbH0gYW5kIHtcXEBsaW5rIEZvcm1BcnJheX0uXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogV2hlbiBpbnN0YW50aWF0aW5nIGEge1xcQGxpbmsgRm9ybUdyb3VwfSwgcGFzcyBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGQgY29udHJvbHMgYXMgdGhlIGZpcnN0XG4gICAgICogYXJndW1lbnQuIFRoZSBrZXkgZm9yIGVhY2ggY2hpbGQgd2lsbCBiZSB0aGUgbmFtZSB1bmRlciB3aGljaCBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woJ05hbmN5JywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdEcmV3JyksXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q7ICdEcmV3J31cbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5jbHVkZSBncm91cC1sZXZlbCB2YWxpZGF0b3JzIGFzIHRoZSBzZWNvbmQgYXJnLCBvciBncm91cC1sZXZlbCBhc3luY1xuICAgICAqIHZhbGlkYXRvcnMgYXMgdGhlIHRoaXJkIGFyZy4gVGhlc2UgY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAqIHRoYXQgY29uc2lkZXJzIHRoZSB2YWx1ZSBvZiBtb3JlIHRoYW4gb25lIGNoaWxkIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgcGFzc3dvcmQ6IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgcGFzc3dvcmRDb25maXJtOiBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKSxcbiAgICAgKiB9LCBwYXNzd29yZE1hdGNoVmFsaWRhdG9yKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogZnVuY3Rpb24gcGFzc3dvcmRNYXRjaFZhbGlkYXRvcihnOiBGb3JtR3JvdXApIHtcbiAgICAgKiAgICByZXR1cm4gZy5nZXQoJ3Bhc3N3b3JkJykudmFsdWUgPT09IGcuZ2V0KCdwYXNzd29yZENvbmZpcm0nKS52YWx1ZVxuICAgICAqICAgICAgID8gbnVsbCA6IHsnbWlzbWF0Y2gnOiB0cnVlfTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYFxcQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUdyb3VwLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sc1xuICAgICAgICAgKiBAcGFyYW0gez89fSB2YWxpZGF0b3JcbiAgICAgICAgICogQHBhcmFtIHs/PX0gYXN5bmNWYWxpZGF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Hcm91cChjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBjb250cm9sIHdpdGggdGhlIGdyb3VwJ3MgbGlzdCBvZiBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgdXBkYXRlIHZhbHVlIG9yIHZhbGlkaXR5IG9mIHRoZSBjb250cm9sLCBzbyBmb3JcbiAgICAgICAgICogbW9zdCBjYXNlcyB5b3UnbGwgd2FudCB0byB1c2Uge1xcQGxpbmsgRm9ybUdyb3VwLmFkZENvbnRyb2x9IGluc3RlYWQuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUucmVnaXN0ZXJDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW25hbWVdKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW25hbWVdO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sc1tuYW1lXSA9IGNvbnRyb2w7XG4gICAgICAgICAgICBjb250cm9sLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIGNvbnRyb2wgdG8gdGhpcyBncm91cC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIGNvbnRyb2wgZnJvbSB0aGlzIGdyb3VwLlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgZGVsZXRlICh0aGlzLmNvbnRyb2xzW25hbWVdKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlIGFuIGV4aXN0aW5nIGNvbnRyb2wuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuc2V0Q29udHJvbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgZGVsZXRlICh0aGlzLmNvbnRyb2xzW25hbWVdKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sKVxuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgdGhlcmUgaXMgYW4gZW5hYmxlZCBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3IgZGlzYWJsZWQgY29udHJvbHMuIElmIHlvdSdkIGxpa2UgdG8gY2hlY2sgZm9yXG4gICAgICAgICAqIGV4aXN0ZW5jZSBpbiB0aGUgZ3JvdXAgb25seSwgdXNlIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IGluc3RlYWQuXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbE5hbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmhhc093blByb3BlcnR5KGNvbnRyb2xOYW1lKSAmJiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xOYW1lXS5lbmFibGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSB7XFxAbGluayBGb3JtR3JvdXB9LiBJdCBhY2NlcHRzIGFuIG9iamVjdCB0aGF0IG1hdGNoZXNcbiAgICAgICAgICogIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdyb3VwLCB3aXRoIGNvbnRyb2wgbmFtZXMgYXMga2V5cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgc3RyaWN0IGNoZWNrcywgc28gaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5XG4gICAgICAgICAqIHRvIHNldCB0aGUgdmFsdWUgb2YgYSBjb250cm9sIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgKiAgICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIH0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgZm9ybS5zZXRWYWx1ZSh7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q6ICdEcmV3J30pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiAnRHJldyd9XG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCh2YWx1ZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90aHJvd0lmQ29udHJvbE1pc3NpbmcobmFtZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbHNbbmFtZV0uc2V0VmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFBhdGNoZXMgdGhlIHZhbHVlIG9mIHRoZSB7XFxAbGluayBGb3JtR3JvdXB9LiBJdCBhY2NlcHRzIGFuIG9iamVjdCB3aXRoIGNvbnRyb2xcbiAgICAgICAgICogIG5hbWVzIGFzIGtleXMsIGFuZCB3aWxsIGRvIGl0cyBiZXN0IHRvIG1hdGNoIHRoZSB2YWx1ZXMgdG8gdGhlIGNvcnJlY3QgY29udHJvbHNcbiAgICAgICAgICogIGluIHRoZSBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgZ3JvdXAgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICogICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICB9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogbnVsbCwgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGZvcm0ucGF0Y2hWYWx1ZSh7Zmlyc3Q6ICdOYW5jeSd9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb250cm9sc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sc1tuYW1lXS5wYXRjaFZhbHVlKHZhbHVlW25hbWVdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIHtcXEBsaW5rIEZvcm1Hcm91cH0uIFRoaXMgbWVhbnMgYnkgZGVmYXVsdDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBUaGUgZ3JvdXAgYW5kIGFsbCBkZXNjZW5kYW50cyBhcmUgbWFya2VkIGBwcmlzdGluZWBcbiAgICAgICAgICogKiBUaGUgZ3JvdXAgYW5kIGFsbCBkZXNjZW5kYW50cyBhcmUgbWFya2VkIGB1bnRvdWNoZWRgXG4gICAgICAgICAqICogVGhlIHZhbHVlIG9mIGFsbCBkZXNjZW5kYW50cyB3aWxsIGJlIG51bGwgb3IgbnVsbCBtYXBzXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyByZXNldCB0byBhIHNwZWNpZmljIGZvcm0gc3RhdGUgYnkgcGFzc2luZyBpbiBhIG1hcCBvZiBzdGF0ZXNcbiAgICAgICAgICogdGhhdCBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgeW91ciBmb3JtLCB3aXRoIGNvbnRyb2wgbmFtZXMgYXMga2V5cy4gVGhlIHN0YXRlXG4gICAgICAgICAqIGNhbiBiZSBhIHN0YW5kYWxvbmUgdmFsdWUgb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB3aXRoIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZFxuICAgICAgICAgKiBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuZm9ybS5yZXNldCh7Zmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLnZhbHVlKTsgIC8vIHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ31cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gT1IgLVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogdGhpcy5mb3JtLnJlc2V0KHtcbiAgICAgICAgICogICBmaXJzdDoge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgICAgICogICBsYXN0OiAnbGFzdCdcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuZm9ybS52YWx1ZSk7ICAvLyB7Zmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuZm9ybS5nZXQoJ2ZpcnN0Jykuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0ge307IH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc2V0KHZhbHVlW25hbWVdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlIHtcXEBsaW5rIEZvcm1Hcm91cH0sIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSdkIGxpa2UgdG8gaW5jbHVkZSBhbGwgdmFsdWVzIHJlZ2FyZGxlc3Mgb2YgZGlzYWJsZWQgc3RhdHVzLCB1c2UgdGhpcyBtZXRob2QuXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgdGhlIGJlc3Qgd2F5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIGdyb3VwLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgZnVuY3Rpb24gKGFjYywgY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCA/IGNvbnRyb2wudmFsdWUgOiAoKGNvbnRyb2wpKS5nZXRSYXdWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5jb250cm9scykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgICBUaGVyZSBhcmUgbm8gZm9ybSBjb250cm9scyByZWdpc3RlcmVkIHdpdGggdGhpcyBncm91cCB5ZXQuICBJZiB5b3UncmUgdXNpbmcgbmdNb2RlbCxcXG4gICAgICAgIHlvdSBtYXkgd2FudCB0byBjaGVjayBuZXh0IHRpY2sgKGUuZy4gdXNlIHNldFRpbWVvdXQpLlxcbiAgICAgIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9sc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZvcm0gY29udHJvbCB3aXRoIG5hbWU6IFwiICsgbmFtZSArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIGNiKF90aGlzLmNvbnRyb2xzW2tdLCBrKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fc2V0VXBDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnNldFBhcmVudChfdGhpcyk7XG4gICAgICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoX3RoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmFsdWUgPSB0aGlzLl9yZWR1Y2VWYWx1ZSgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2FueUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzIHx8IChfdGhpcy5jb250YWlucyhuYW1lKSAmJiBjb25kaXRpb24oY29udHJvbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3JlZHVjZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgZnVuY3Rpb24gKGFjYywgY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmVuYWJsZWQgfHwgX3RoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbml0VmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoaW5pdFZhbHVlLCBmbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gaW5pdFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7IHJlcyA9IGZuKHJlcywgY29udHJvbCwgbmFtZSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9hbGxDb250cm9sc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sTmFtZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tjb250cm9sTmFtZV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmxlbmd0aCA+IDAgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgYSB2YWx1ZSBmb3IgZm9ybSBjb250cm9sIHdpdGggbmFtZTogJ1wiICsgbmFtZSArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXA7XG4gICAgfShBYnN0cmFjdENvbnRyb2wpKTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGFuIGFycmF5IG9mIHtcXEBsaW5rIEZvcm1Db250cm9sfSxcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9IG9yIHtcXEBsaW5rIEZvcm1BcnJheX0gaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQSBgRm9ybUFycmF5YCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBjaGlsZCB7XFxAbGluayBGb3JtQ29udHJvbH0gaW50byBhbiBhcnJheS5cbiAgICAgKiBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1c2VzIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZlxuICAgICAqIHRoZSBjb250cm9scyBpbiBhIGBGb3JtQXJyYXlgIGlzIGludmFsaWQsIHRoZSBlbnRpcmUgYXJyYXkgYmVjb21lcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogYEZvcm1BcnJheWAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAgICAgKiBhbG9uZyB3aXRoIHtcXEBsaW5rIEZvcm1Db250cm9sfSBhbmQge1xcQGxpbmsgRm9ybUdyb3VwfS5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7XFxAbGluayBGb3JtQXJyYXl9LCBwYXNzIGluIGFuIGFycmF5IG9mIGNoaWxkIGNvbnRyb2xzIGFzIHRoZSBmaXJzdFxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAqICAgbmV3IEZvcm1Db250cm9sKCdOYW5jeScsIFZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKSxcbiAgICAgKiAgIG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICAgICAqIGNvbnNvbGUubG9nKGFyci5zdGF0dXMpOyAgLy8gJ1ZBTElEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIGluY2x1ZGUgYXJyYXktbGV2ZWwgdmFsaWRhdG9ycyBhcyB0aGUgc2Vjb25kIGFyZywgb3IgYXJyYXktbGV2ZWwgYXN5bmNcbiAgICAgKiB2YWxpZGF0b3JzIGFzIHRoZSB0aGlyZCBhcmcuIFRoZXNlIGNvbWUgaW4gaGFuZHkgd2hlbiB5b3Ugd2FudCB0byBwZXJmb3JtIHZhbGlkYXRpb25cbiAgICAgKiB0aGF0IGNvbnNpZGVycyB0aGUgdmFsdWUgb2YgbW9yZSB0aGFuIG9uZSBjaGlsZCBjb250cm9sLlxuICAgICAqXG4gICAgICogIyMjIEFkZGluZyBvciByZW1vdmluZyBjb250cm9sc1xuICAgICAqXG4gICAgICogVG8gY2hhbmdlIHRoZSBjb250cm9scyBpbiB0aGUgYXJyYXksIHVzZSB0aGUgYHB1c2hgLCBgaW5zZXJ0YCwgb3IgYHJlbW92ZUF0YCBtZXRob2RzXG4gICAgICogaW4gYEZvcm1BcnJheWAgaXRzZWxmLiBUaGVzZSBtZXRob2RzIGVuc3VyZSB0aGUgY29udHJvbHMgYXJlIHByb3Blcmx5IHRyYWNrZWQgaW4gdGhlXG4gICAgICogZm9ybSdzIGhpZXJhcmNoeS4gRG8gbm90IG1vZGlmeSB0aGUgYXJyYXkgb2YgYEFic3RyYWN0Q29udHJvbGBzIHVzZWQgdG8gaW5zdGFudGlhdGVcbiAgICAgKiB0aGUgYEZvcm1BcnJheWAgZGlyZWN0bHksIGFzIHRoYXQgd2lsbCByZXN1bHQgaW4gc3RyYW5nZSBhbmQgdW5leHBlY3RlZCBiZWhhdmlvciBzdWNoXG4gICAgICogYXMgYnJva2VuIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYFxcQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUFycmF5LCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sc1xuICAgICAgICAgKiBAcGFyYW0gez89fSB2YWxpZGF0b3JcbiAgICAgICAgICogQHBhcmFtIHs/PX0gYXN5bmNWYWxpZGF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEZvcm1BcnJheShjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRyb2xzW2luZGV4XTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIG5ldyB7XFxAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGEgbmV3IHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tpbmRleF0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBjb250cm9sLlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5zZXRDb250cm9sID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tpbmRleF0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5LnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZW5ndGggb2YgdGhlIGNvbnRyb2wgYXJyYXkuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUge1xcQGxpbmsgRm9ybUFycmF5fS4gSXQgYWNjZXB0cyBhbiBhcnJheSB0aGF0IG1hdGNoZXNcbiAgICAgICAgICogIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHN0cmljdCBjaGVja3MsIHNvIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeVxuICAgICAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgeW91IGV4Y2x1ZGUgdGhlXG4gICAgICAgICAqIHZhbHVlIG9mIGEgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKCksXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAgICAgKiAgXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFtudWxsLCBudWxsXVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYXJyLnNldFZhbHVlKFsnTmFuY3knLCAnRHJldyddKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gWydOYW5jeScsICdEcmV3J11cbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50KHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG5ld1ZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90aHJvd0lmQ29udHJvbE1pc3NpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5zZXRWYWx1ZShuZXdWYWx1ZSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUGF0Y2hlcyB0aGUgdmFsdWUgb2YgdGhlIHtcXEBsaW5rIEZvcm1BcnJheX0uIEl0IGFjY2VwdHMgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZVxuICAgICAgICAgKiAgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLCBhbmQgd2lsbCBkbyBpdHMgYmVzdCB0byBtYXRjaCB0aGUgdmFsdWVzIHRvIHRoZSBjb3JyZWN0XG4gICAgICAgICAqICBjb250cm9scyBpbiB0aGUgZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqICBJdCBhY2NlcHRzIGJvdGggc3VwZXItc2V0cyBhbmQgc3ViLXNldHMgb2YgdGhlIGFycmF5IHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIF0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbbnVsbCwgbnVsbF1cbiAgICAgICAgICpcbiAgICAgICAgICogIGFyci5wYXRjaFZhbHVlKFsnTmFuY3knXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCBudWxsXVxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG5ld1ZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLnBhdGNoVmFsdWUobmV3VmFsdWUsIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUge1xcQGxpbmsgRm9ybUFycmF5fS4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBhcnJheSBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIFRoZSBhcnJheSBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiBUaGUgdmFsdWUgb2YgYWxsIGRlc2NlbmRhbnRzIHdpbGwgYmUgbnVsbCBvciBudWxsIG1hcHNcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIGluIGFuIGFycmF5IG9mIHN0YXRlc1xuICAgICAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbC4gVGhlIHN0YXRlIGNhbiBiZSBhIHN0YW5kYWxvbmUgdmFsdWVcbiAgICAgICAgICogb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB3aXRoIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuYXJyLnJlc2V0KFsnbmFtZScsICdsYXN0IG5hbWUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLnZhbHVlKTsgIC8vIFsnbmFtZScsICdsYXN0IG5hbWUnXVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBPUiAtXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmFyci5yZXNldChbXG4gICAgICAgICAqICAge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgICAgICogICAnbGFzdCdcbiAgICAgICAgICogXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLnZhbHVlKTsgIC8vIFsnbmFtZScsICdsYXN0IG5hbWUnXVxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmFyci5nZXQoMCkuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gW107IH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5yZXNldCh2YWx1ZVtpbmRleF0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUgYXJyYXksIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSdkIGxpa2UgdG8gaW5jbHVkZSBhbGwgdmFsdWVzIHJlZ2FyZGxlc3Mgb2YgZGlzYWJsZWQgc3RhdHVzLCB1c2UgdGhpcyBtZXRob2QuXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgdGhlIGJlc3Qgd2F5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLm1hcChmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sIGluc3RhbmNlb2YgRm9ybUNvbnRyb2wgPyBjb250cm9sLnZhbHVlIDogKChjb250cm9sKSkuZ2V0UmF3VmFsdWUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgICBUaGVyZSBhcmUgbm8gZm9ybSBjb250cm9scyByZWdpc3RlcmVkIHdpdGggdGhpcyBhcnJheSB5ZXQuICBJZiB5b3UncmUgdXNpbmcgbmdNb2RlbCxcXG4gICAgICAgIHlvdSBtYXkgd2FudCB0byBjaGVjayBuZXh0IHRpY2sgKGUuZy4gdXNlIHNldFRpbWVvdXQpLlxcbiAgICAgIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5hdChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmb3JtIGNvbnRyb2wgYXQgaW5kZXggXCIgKyBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGNiXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbCwgaW5kZXgpIHsgY2IoY29udHJvbCwgaW5kZXgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY29udHJvbHMuZmlsdGVyKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmVuYWJsZWQgfHwgX3RoaXMuZGlzYWJsZWQ7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC52YWx1ZTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5zb21lKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmVuYWJsZWQgJiYgY29uZGl0aW9uKGNvbnRyb2wpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9zZXRVcENvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gX3RoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgaSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGEgdmFsdWUgZm9yIGZvcm0gY29udHJvbCBhdCBpbmRleDogXCIgKyBpICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jb250cm9sczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5lbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5sZW5ndGggPiAwIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3JlZ2lzdGVyQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICBjb250cm9sLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQXJyYXk7XG4gICAgfShBYnN0cmFjdENvbnRyb2wpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3JtRGlyZWN0aXZlUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdGb3JtOyB9KVxuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHRvcC1sZXZlbCB7XFxAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIGFuZCBiaW5kcyBpdCB0byBhIGZvcm1cbiAgICAgKiB0byB0cmFjayBhZ2dyZWdhdGUgZm9ybSB2YWx1ZSBhbmQgdmFsaWRhdGlvbiBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogQXMgc29vbiBhcyB5b3UgaW1wb3J0IHRoZSBgRm9ybXNNb2R1bGVgLCB0aGlzIGRpcmVjdGl2ZSBiZWNvbWVzIGFjdGl2ZSBieSBkZWZhdWx0IG9uXG4gICAgICogYWxsIGA8Zm9ybT5gIHRhZ3MuICBZb3UgZG9uJ3QgbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogWW91IGNhbiBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmcgYG5nRm9ybWAgYXMgdGhlIGtleVxuICAgICAqIChleDogYCNteUZvcm09XCJuZ0Zvcm1cImApLiBUaGlzIGlzIG9wdGlvbmFsLCBidXQgdXNlZnVsLiAgTWFueSBwcm9wZXJ0aWVzIGZyb20gdGhlIHVuZGVybHlpbmdcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIGFyZSBkdXBsaWNhdGVkIG9uIHRoZSBkaXJlY3RpdmUgaXRzZWxmLCBzbyBhIHJlZmVyZW5jZSB0byBpdFxuICAgICAqIHdpbGwgZ2l2ZSB5b3UgYWNjZXNzIHRvIHRoZSBhZ2dyZWdhdGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXR1cyBvZiB0aGUgZm9ybSwgYXMgd2VsbCBhc1xuICAgICAqIHVzZXIgaW50ZXJhY3Rpb24gcHJvcGVydGllcyBsaWtlIGBkaXJ0eWAgYW5kIGB0b3VjaGVkYC5cbiAgICAgKlxuICAgICAqIFRvIHJlZ2lzdGVyIGNoaWxkIGNvbnRyb2xzIHdpdGggdGhlIGZvcm0sIHlvdSdsbCB3YW50IHRvIHVzZSB7XFxAbGluayBOZ01vZGVsfSB3aXRoIGFcbiAgICAgKiBgbmFtZWAgYXR0cmlidXRlLiAgWW91IGNhbiBhbHNvIHVzZSB7XFxAbGluayBOZ01vZGVsR3JvdXB9IGlmIHlvdSdkIGxpa2UgdG8gY3JlYXRlXG4gICAgICogc3ViLWdyb3VwcyB3aXRoaW4gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGxpc3RlbiB0byB0aGUgZGlyZWN0aXZlJ3MgYG5nU3VibWl0YCBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhhc1xuICAgICAqIHRyaWdnZXJlZCBhIGZvcm0gc3VibWlzc2lvbi4gVGhlIGBuZ1N1Ym1pdGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIG9yaWdpbmFsIGZvcm1cbiAgICAgKiBzdWJtaXNzaW9uIGV2ZW50LlxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybS9zaW1wbGVfZm9ybV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiAgXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nRm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KE5nRm9ybSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFzeW5jVmFsaWRhdG9yc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTmdGb3JtKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm0gPVxuICAgICAgICAgICAgICAgIG5ldyBGb3JtR3JvdXAoe30sIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpLCBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInN1Ym1pdHRlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3VibWl0dGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiY29udHJvbHNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybS5jb250cm9sczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgZGlyLl9jb250cm9sID0gKGNvbnRhaW5lci5yZWdpc3RlckNvbnRyb2woZGlyLm5hbWUsIGRpci5jb250cm9sKSk7XG4gICAgICAgICAgICAgICAgc2V0VXBDb250cm9sKGRpci5jb250cm9sLCBkaXIpO1xuICAgICAgICAgICAgICAgIGRpci5jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5nZXRDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gKHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDb250cm9sKGRpci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgICAgICAgICAgICAgc2V0VXBGb3JtQ29udGFpbmVyKGdyb3VwLCBkaXIpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlckNvbnRyb2woZGlyLm5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICBncm91cC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5nZXRGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAodGhpcy5mb3JtLmdldChkaXIucGF0aCkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChkaXIsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0cmwgPSAoX3RoaXMuZm9ybS5nZXQoZGlyLnBhdGgpKTtcbiAgICAgICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSAkZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUub25TdWJtaXQgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdC5lbWl0KCRldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5vblJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0Rm9ybSgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVzZXRGb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgdGhpcy5mb3JtLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXRoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLl9maW5kQ29udGFpbmVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPyAodGhpcy5mb3JtLmdldChwYXRoKSkgOiB0aGlzLmZvcm07XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybTpub3QoW25nTm9Gb3JtXSk6bm90KFtmb3JtR3JvdXBdKSxuZ0Zvcm0sW25nRm9ybV0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhzdWJtaXQpJzogJ29uU3VibWl0KCRldmVudCknLCAnKHJlc2V0KSc6ICdvblJlc2V0KCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbJ25nU3VibWl0J10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nRm9ybSdcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0Zvcm0uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBOZ0Zvcm07XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gRXhhbXBsZXMgPSB7XG4gICAgICAgIGZvcm1Db250cm9sTmFtZTogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtR3JvdXBOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgZm9ybUNvbnRyb2xOYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBwZXJzb246IG5ldyBGb3JtR3JvdXAoeyBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpIH0pXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtQXJyYXlOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICA8ZGl2IGZvcm1BcnJheU5hbWU9XFxcImNpdGllc1xcXCI+XFxuICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IGNpdHkgb2YgY2l0eUFycmF5LmNvbnRyb2xzOyBsZXQgaT1pbmRleFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiaVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMuY2l0eUFycmF5ID0gbmV3IEZvcm1BcnJheShbbmV3IEZvcm1Db250cm9sKCdTRicpXSk7XFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgIGNpdGllczogdGhpcy5jaXR5QXJyYXlcXG4gICAgfSk7XCIsXG4gICAgICAgIG5nTW9kZWxHcm91cDogXCJcXG4gICAgPGZvcm0+XFxuICAgICAgIDxkaXYgbmdNb2RlbEdyb3VwPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInBlcnNvbi5uYW1lXFxcIiBuYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9mb3JtPlwiLFxuICAgICAgICBuZ01vZGVsV2l0aEZvcm1Hcm91cDogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwic2hvd01vcmVDb250cm9sc1xcXCIgW25nTW9kZWxPcHRpb25zXT1cXFwie3N0YW5kYWxvbmU6IHRydWV9XFxcIj5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgIH07XG5cbiAgICB2YXIgVGVtcGxhdGVEcml2ZW5FcnJvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZURyaXZlbkVycm9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgbmdNb2RlbCBjYW5ub3QgYmUgdXNlZCB0byByZWdpc3RlciBmb3JtIGNvbnRyb2xzIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFRyeSB1c2luZ1xcbiAgICAgIGZvcm1Hcm91cCdzIHBhcnRuZXIgZGlyZWN0aXZlIFxcXCJmb3JtQ29udHJvbE5hbWVcXFwiIGluc3RlYWQuICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lICsgXCJcXG5cXG4gICAgICBPciwgaWYgeW91J2QgbGlrZSB0byBhdm9pZCByZWdpc3RlcmluZyB0aGlzIGZvcm0gY29udHJvbCwgaW5kaWNhdGUgdGhhdCBpdCdzIHN0YW5kYWxvbmUgaW4gbmdNb2RlbE9wdGlvbnM6XFxuXFxuICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxXaXRoRm9ybUdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5mb3JtR3JvdXBOYW1lRXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgbmdNb2RlbCBjYW5ub3QgYmUgdXNlZCB0byByZWdpc3RlciBmb3JtIGNvbnRyb2xzIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwTmFtZSBvciBmb3JtQXJyYXlOYW1lIGRpcmVjdGl2ZS5cXG5cXG4gICAgICBPcHRpb24gMTogVXNlIGZvcm1Db250cm9sTmFtZSBpbnN0ZWFkIG9mIG5nTW9kZWwgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUgKyBcIlxcblxcbiAgICAgIE9wdGlvbiAyOiAgVXBkYXRlIG5nTW9kZWwncyBwYXJlbnQgYmUgbmdNb2RlbEdyb3VwICh0ZW1wbGF0ZS1kcml2ZW4gc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5taXNzaW5nTmFtZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIG5nTW9kZWwgaXMgdXNlZCB3aXRoaW4gYSBmb3JtIHRhZywgZWl0aGVyIHRoZSBuYW1lIGF0dHJpYnV0ZSBtdXN0IGJlIHNldCBvciB0aGUgZm9ybVxcbiAgICAgIGNvbnRyb2wgbXVzdCBiZSBkZWZpbmVkIGFzICdzdGFuZGFsb25lJyBpbiBuZ01vZGVsT3B0aW9ucy5cXG5cXG4gICAgICBFeGFtcGxlIDE6IDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicGVyc29uLmZpcnN0TmFtZVxcXCIgbmFtZT1cXFwiZmlyc3RcXFwiPlxcbiAgICAgIEV4YW1wbGUgMjogPGlucHV0IFsobmdNb2RlbCldPVxcXCJwZXJzb24uZmlyc3ROYW1lXFxcIiBbbmdNb2RlbE9wdGlvbnNdPVxcXCJ7c3RhbmRhbG9uZTogdHJ1ZX1cXFwiPlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbEdyb3VwUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgbmdNb2RlbEdyb3VwIGNhbm5vdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS5cXG5cXG4gICAgICBPcHRpb24gMTogVXNlIGZvcm1Hcm91cE5hbWUgaW5zdGVhZCBvZiBuZ01vZGVsR3JvdXAgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUgKyBcIlxcblxcbiAgICAgIE9wdGlvbiAyOiAgVXNlIGEgcmVndWxhciBmb3JtIHRhZyBpbnN0ZWFkIG9mIHRoZSBmb3JtR3JvdXAgZGlyZWN0aXZlICh0ZW1wbGF0ZS1kcml2ZW4gc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRlbXBsYXRlRHJpdmVuRXJyb3JzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kZWxHcm91cFByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nTW9kZWxHcm91cDsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgQ3JlYXRlcyBhbmQgYmluZHMgYSB7XFxAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBhcyBhIGNoaWxkIG9mIHtcXEBsaW5rIE5nRm9ybX0gKG9yIGluIG90aGVyIHdvcmRzLFxuICAgICAqIHdpdGhpbiBgPGZvcm0+YCB0YWdzKS5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdGl2ZSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZSBhIHN1Yi1ncm91cCB3aXRoaW4gYSBmb3JtLiBUaGlzIGNhblxuICAgICAqIGNvbWUgaW4gaGFuZHkgaWYgeW91IHdhbnQgdG8gdmFsaWRhdGUgYSBzdWItZ3JvdXAgb2YgeW91ciBmb3JtIHNlcGFyYXRlbHkgZnJvbVxuICAgICAqIHRoZSByZXN0IG9mIHlvdXIgZm9ybSwgb3IgaWYgc29tZSB2YWx1ZXMgaW4geW91ciBkb21haW4gbW9kZWwgbWFrZSBtb3JlIHNlbnNlIHRvXG4gICAgICogY29uc3VtZSB0b2dldGhlciBpbiBhIG5lc3RlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBQYXNzIGluIHRoZSBuYW1lIHlvdSdkIGxpa2UgdGhpcyBzdWItZ3JvdXAgdG8gaGF2ZSBhbmQgaXQgd2lsbCBiZWNvbWUgdGhlIGtleVxuICAgICAqIGZvciB0aGUgc3ViLWdyb3VwIGluIHRoZSBmb3JtJ3MgZnVsbCB2YWx1ZS4gWW91IGNhbiBhbHNvIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG9cbiAgICAgKiBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ01vZGVsR3JvdXBgIChleDogYCNteUdyb3VwPVwibmdNb2RlbEdyb3VwXCJgKS5cbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL25nTW9kZWxHcm91cC9uZ19tb2RlbF9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2RlbEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDgoTmdNb2RlbEdyb3VwLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN5bmNWYWxpZGF0b3JzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ01vZGVsR3JvdXAocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdGb3JtKSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsR3JvdXBQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbEdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ01vZGVsR3JvdXBdJywgcHJvdmlkZXJzOiBbbW9kZWxHcm91cFByb3ZpZGVyXSwgZXhwb3J0QXM6ICduZ01vZGVsR3JvdXAnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdNb2RlbEdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbEdyb3VwJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kZWxHcm91cDtcbiAgICB9KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9ybUNvbnRyb2xCaW5kaW5nID0ge1xuICAgICAgICBwcm92aWRlOiBOZ0NvbnRyb2wsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdNb2RlbDsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBuZ01vZGVsYCBmb3JjZXMgYW4gYWRkaXRpb25hbCBjaGFuZ2UgZGV0ZWN0aW9uIHJ1biB3aGVuIGl0cyBpbnB1dHMgY2hhbmdlOlxuICAgICAqIEUuZy46XG4gICAgICogYGBgXG4gICAgICogPGRpdj57e215TW9kZWwudmFsaWR9fTwvZGl2PlxuICAgICAqIDxpbnB1dCBbKG5nTW9kZWwpXT1cIm15VmFsdWVcIiAjbXlNb2RlbD1cIm5nTW9kZWxcIj5cbiAgICAgKiBgYGBcbiAgICAgKiBJLmUuIGBuZ01vZGVsYCBjYW4gZXhwb3J0IGl0c2VsZiBvbiB0aGUgZWxlbWVudCBhbmQgdGhlbiBiZSB1c2VkIGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiBOb3JtYWxseSwgdGhpcyB3b3VsZCByZXN1bHQgaW4gZXhwcmVzc2lvbnMgYmVmb3JlIHRoZSBgaW5wdXRgIHRoYXQgdXNlIHRoZSBleHBvcnRlZCBkaXJlY3RpdmVcbiAgICAgKiB0byBoYXZlIGFuZCBvbGQgdmFsdWUgYXMgdGhleSBoYXZlIGJlZW5cbiAgICAgKiBkaXJ0eSBjaGVja2VkIGJlZm9yZS4gQXMgdGhpcyBpcyBhIHZlcnkgY29tbW9uIGNhc2UgZm9yIGBuZ01vZGVsYCwgd2UgYWRkZWQgdGhpcyBzZWNvbmQgY2hhbmdlXG4gICAgICogZGV0ZWN0aW9uIHJ1bi5cbiAgICAgKlxuICAgICAqIE5vdGVzOlxuICAgICAqIC0gdGhpcyBpcyBqdXN0IG9uZSBleHRyYSBydW4gbm8gbWF0dGVyIGhvdyBtYW55IGBuZ01vZGVsYCBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgKiAtIHRoaXMgaXMgYSBnZW5lcmFsIHByb2JsZW0gd2hlbiB1c2luZyBgZXhwb3J0QXNgIGZvciBkaXJlY3RpdmVzIVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkUHJvbWlzZSQxID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBmcm9tIGEgZG9tYWluIG1vZGVsIGFuZCBiaW5kcyBpdFxuICAgICAqIHRvIGEgZm9ybSBjb250cm9sIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBUaGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIHdpbGwgdHJhY2sgdGhlIHZhbHVlLCB1c2VyIGludGVyYWN0aW9uLCBhbmRcbiAgICAgKiB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbCBhbmQga2VlcCB0aGUgdmlldyBzeW5jZWQgd2l0aCB0aGUgbW9kZWwuIElmIHVzZWRcbiAgICAgKiB3aXRoaW4gYSBwYXJlbnQgZm9ybSwgdGhlIGRpcmVjdGl2ZSB3aWxsIGFsc28gcmVnaXN0ZXIgaXRzZWxmIHdpdGggdGhlIGZvcm0gYXMgYSBjaGlsZFxuICAgICAqIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgYnkgaXRzZWxmIG9yIGFzIHBhcnQgb2YgYSBsYXJnZXIgZm9ybS4gQWxsIHlvdSBuZWVkIGlzIHRoZVxuICAgICAqIGBuZ01vZGVsYCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYSBkb21haW4gbW9kZWwgYXMgYW4gb3B0aW9uYWwge1xcQGxpbmsgXFxASW5wdXR9LiBJZiB5b3UgaGF2ZSBhIG9uZS13YXkgYmluZGluZ1xuICAgICAqIHRvIGBuZ01vZGVsYCB3aXRoIGBbXWAgc3ludGF4LCBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIGRvbWFpbiBtb2RlbCBpbiB0aGUgY29tcG9uZW50XG4gICAgICogY2xhc3Mgd2lsbCBzZXQgdGhlIHZhbHVlIGluIHRoZSB2aWV3LiBJZiB5b3UgaGF2ZSBhIHR3by13YXkgYmluZGluZyB3aXRoIGBbKCldYCBzeW50YXhcbiAgICAgKiAoYWxzbyBrbm93biBhcyAnYmFuYW5hLWJveCBzeW50YXgnKSwgdGhlIHZhbHVlIGluIHRoZSBVSSB3aWxsIGFsd2F5cyBiZSBzeW5jZWQgYmFjayB0b1xuICAgICAqIHRoZSBkb21haW4gbW9kZWwgaW4geW91ciBjbGFzcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogSWYgeW91IHdpc2ggdG8gaW5zcGVjdCB0aGUgcHJvcGVydGllcyBvZiB0aGUgYXNzb2NpYXRlZCB7XFxAbGluayBGb3JtQ29udHJvbH0gKGxpa2VcbiAgICAgKiB2YWxpZGl0eSBzdGF0ZSksIHlvdSBjYW4gYWxzbyBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmdcbiAgICAgKiBgbmdNb2RlbGAgYXMgdGhlIGtleSAoZXg6IGAjbXlWYXI9XCJuZ01vZGVsXCJgKS4gWW91IGNhbiB0aGVuIGFjY2VzcyB0aGUgY29udHJvbCB1c2luZyB0aGVcbiAgICAgKiBkaXJlY3RpdmUncyBgY29udHJvbGAgcHJvcGVydHksIGJ1dCBtb3N0IHByb3BlcnRpZXMgeW91J2xsIG5lZWQgKGxpa2UgYHZhbGlkYCBhbmQgYGRpcnR5YClcbiAgICAgKiB3aWxsIGZhbGwgdGhyb3VnaCB0byB0aGUgY29udHJvbCBhbnl3YXksIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuIFlvdSBjYW4gc2VlIGFcbiAgICAgKiBmdWxsIGxpc3Qgb2YgcHJvcGVydGllcyBkaXJlY3RseSBhdmFpbGFibGUgaW4ge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgYW4gZXhhbXBsZSBvZiBhIHNpbXBsZSBzdGFuZGFsb25lIGNvbnRyb2wgdXNpbmcgYG5nTW9kZWxgOlxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlTmdNb2RlbC9zaW1wbGVfbmdfbW9kZWxfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIHRoZSBgbmdNb2RlbGAgd2l0aGluIGA8Zm9ybT5gIHRhZ3MsIHlvdSdsbCBhbHNvIG5lZWQgdG8gc3VwcGx5IGEgYG5hbWVgIGF0dHJpYnV0ZVxuICAgICAqIHNvIHRoYXQgdGhlIGNvbnRyb2wgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgcGFyZW50IGZvcm0gdW5kZXIgdGhhdCBuYW1lLlxuICAgICAqXG4gICAgICogSXQncyB3b3J0aCBub3RpbmcgdGhhdCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBmb3JtLCB5b3Ugb2Z0ZW4gY2FuIHNraXAgb25lLXdheSBvclxuICAgICAqIHR3by13YXkgYmluZGluZyBiZWNhdXNlIHRoZSBwYXJlbnQgZm9ybSB3aWxsIHN5bmMgdGhlIHZhbHVlIGZvciB5b3UuIFlvdSBjYW4gYWNjZXNzXG4gICAgICogaXRzIHByb3BlcnRpZXMgYnkgZXhwb3J0aW5nIGl0IGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdGb3JtYCAoZXg6XG4gICAgICogYCNmPVwibmdGb3JtXCJgKS4gVGhlbiB5b3UgY2FuIHBhc3MgaXQgd2hlcmUgaXQgbmVlZHMgdG8gZ28gb24gc3VibWl0LlxuICAgICAqXG4gICAgICogSWYgeW91IGRvIG5lZWQgdG8gcG9wdWxhdGUgaW5pdGlhbCB2YWx1ZXMgaW50byB5b3VyIGZvcm0sIHVzaW5nIGEgb25lLXdheSBiaW5kaW5nIGZvclxuICAgICAqIGBuZ01vZGVsYCB0ZW5kcyB0byBiZSBzdWZmaWNpZW50IGFzIGxvbmcgYXMgeW91IHVzZSB0aGUgZXhwb3J0ZWQgZm9ybSdzIHZhbHVlIHJhdGhlclxuICAgICAqIHRoYW4gdGhlIGRvbWFpbiBtb2RlbCdzIHZhbHVlIG9uIHN1Ym1pdC5cbiAgICAgKlxuICAgICAqIFRha2UgYSBsb29rIGF0IGFuIGV4YW1wbGUgb2YgdXNpbmcgYG5nTW9kZWxgIHdpdGhpbiBhIGZvcm06XG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtL3NpbXBsZV9mb3JtX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogVG8gc2VlIGBuZ01vZGVsYCBleGFtcGxlcyB3aXRoIGRpZmZlcmVudCBmb3JtIGNvbnRyb2wgdHlwZXMsIHNlZTpcbiAgICAgKlxuICAgICAqICogUmFkaW8gYnV0dG9uczoge1xcQGxpbmsgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvcn1cbiAgICAgKiAqIFNlbGVjdHM6IHtcXEBsaW5rIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjogYEZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ01vZGVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDcoTmdNb2RlbCwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFzeW5jVmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlQWNjZXNzb3JzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ01vZGVsKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jb250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JFcnJvcnMoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVnaXN0ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2woKTtcbiAgICAgICAgICAgIGlmICgnaXNEaXNhYmxlZCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb3JtRGlyZWN0aXZlICYmIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udHJvbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KSA6IFt0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3NldFVwQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU3RhbmRhbG9uZSgpID8gdGhpcy5fc2V0VXBTdGFuZGFsb25lKCkgOlxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2lzU3RhbmRhbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fcGFyZW50IHx8ICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnN0YW5kYWxvbmUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9zZXRVcFN0YW5kYWxvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRVcENvbnRyb2wodGhpcy5fY29udHJvbCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja0ZvckVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNTdGFuZGFsb25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5mb3JtR3JvdXBOYW1lRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ0Zvcm0pKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fY2hlY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNTdGFuZGFsb25lKCkgJiYgIXRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1pc3NpbmdOYW1lRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UkMS50aGVuKGZ1bmN0aW9uICgpIHsgX3RoaXMuY29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwgeyBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlIH0pOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3VwZGF0ZURpc2FibGVkID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXNhYmxlZFZhbHVlID0gY2hhbmdlc1snaXNEaXNhYmxlZCddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzRGlzYWJsZWQgPSBkaXNhYmxlZFZhbHVlID09PSAnJyB8fCAoZGlzYWJsZWRWYWx1ZSAmJiBkaXNhYmxlZFZhbHVlICE9PSAnZmFsc2UnKTtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSQxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkICYmICFfdGhpcy5jb250cm9sLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEaXNhYmxlZCAmJiBfdGhpcy5jb250cm9sLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ01vZGVsXTpub3QoW2Zvcm1Db250cm9sTmFtZV0pOm5vdChbZm9ybUNvbnRyb2xdKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtQ29udHJvbEJpbmRpbmddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ01vZGVsJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nTW9kZWwuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBOZ01vZGVsLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICdpc0Rpc2FibGVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydkaXNhYmxlZCcsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWxPcHRpb25zJyxdIH0sXSxcbiAgICAgICAgICAgICd1cGRhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCwgYXJnczogWyduZ01vZGVsQ2hhbmdlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kZWw7XG4gICAgfShOZ0NvbnRyb2wpKTtcblxuICAgIHZhciBSZWFjdGl2ZUVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlYWN0aXZlRXJyb3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuY29udHJvbFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Db250cm9sTmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXFxuICAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cXG5cXG4gICAgICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5uZ01vZGVsR3JvdXBFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtQ29udHJvbE5hbWUgY2Fubm90IGJlIHVzZWQgd2l0aCBhbiBuZ01vZGVsR3JvdXAgcGFyZW50LiBJdCBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCBwYXJlbnRzXFxuICAgICAgIHRoYXQgYWxzbyBoYXZlIGEgXFxcImZvcm1cXFwiIHByZWZpeDogZm9ybUdyb3VwTmFtZSwgZm9ybUFycmF5TmFtZSwgb3IgZm9ybUdyb3VwLlxcblxcbiAgICAgICBPcHRpb24gMTogIFVwZGF0ZSB0aGUgcGFyZW50IHRvIGJlIGZvcm1Hcm91cE5hbWUgKHJlYWN0aXZlIGZvcm0gc3RyYXRlZ3kpXFxuXFxuICAgICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUgKyBcIlxcblxcbiAgICAgICAgT3B0aW9uIDI6IFVzZSBuZ01vZGVsIGluc3RlYWQgb2YgZm9ybUNvbnRyb2xOYW1lICh0ZW1wbGF0ZS1kcml2ZW4gc3RyYXRlZ3kpXFxuXFxuICAgICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxHcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVhY3RpdmVFcnJvcnMubWlzc2luZ0Zvcm1FeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtR3JvdXAgZXhwZWN0cyBhIEZvcm1Hcm91cCBpbnN0YW5jZS4gUGxlYXNlIHBhc3Mgb25lIGluLlxcblxcbiAgICAgICBFeGFtcGxlOlxcblxcbiAgICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuZ3JvdXBQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtR3JvdXBOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICBkaXJlY3RpdmUgYW5kIHBhc3MgaXQgYW4gZXhpc3RpbmcgRm9ybUdyb3VwIGluc3RhbmNlICh5b3UgY2FuIGNyZWF0ZSBvbmUgaW4geW91ciBjbGFzcykuXFxuXFxuICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmFycmF5UGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUFycmF5TmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXFxuICAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cXG5cXG4gICAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgICBcIiArIEV4YW1wbGVzLmZvcm1BcnJheU5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmRpc2FibGVkQXR0cldhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcXG4gICAgICBJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHdpdGggYSByZWFjdGl2ZSBmb3JtIGRpcmVjdGl2ZS4gSWYgeW91IHNldCBkaXNhYmxlZCB0byB0cnVlXFxuICAgICAgd2hlbiB5b3Ugc2V0IHVwIHRoaXMgY29udHJvbCBpbiB5b3VyIGNvbXBvbmVudCBjbGFzcywgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB3aWxsIGFjdHVhbGx5IGJlIHNldCBpbiB0aGUgRE9NIGZvclxcbiAgICAgIHlvdS4gV2UgcmVjb21tZW5kIHVzaW5nIHRoaXMgYXBwcm9hY2ggdG8gYXZvaWQgJ2NoYW5nZWQgYWZ0ZXIgY2hlY2tlZCcgZXJyb3JzLlxcbiAgICAgICBcXG4gICAgICBFeGFtcGxlOiBcXG4gICAgICBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKHt2YWx1ZTogJ05hbmN5JywgZGlzYWJsZWQ6IHRydWV9LCBWYWxpZGF0b3JzLnJlcXVpcmVkKSxcXG4gICAgICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycsIFZhbGlkYXRvcnMucmVxdWlyZWQpXFxuICAgICAgfSk7XFxuICAgIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlYWN0aXZlRXJyb3JzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9ybUNvbnRyb2xCaW5kaW5nJDEgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtQ29udHJvbERpcmVjdGl2ZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgU3luY3MgYSBzdGFuZGFsb25lIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICAgICAqXG4gICAgICogSW4gb3RoZXIgd29yZHMsIHRoaXMgZGlyZWN0aXZlIGVuc3VyZXMgdGhhdCBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIHtcXEBsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlIHByb2dyYW1tYXRpY2FsbHkgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCAobW9kZWwgLT4gdmlldykuIENvbnZlcnNlbHksXG4gICAgICogYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCB0aHJvdWdoIHVzZXIgaW5wdXQgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlXG4gICAgICoge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlICh2aWV3IC0+IG1vZGVsKS5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBkaXJlY3RpdmUgaWYgeW91J2QgbGlrZSB0byBjcmVhdGUgYW5kIG1hbmFnZSBhIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgICAgKiBTaW1wbHkgY3JlYXRlIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9LCBzYXZlIGl0IHRvIHlvdXIgY29tcG9uZW50IGNsYXNzLCBhbmQgcGFzcyBpdCBpbnRvIHRoZVxuICAgICAqIHtcXEBsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYXMgYSBzdGFuZGFsb25lIGNvbnRyb2wuICBVbmxpa2Uge1xcQGxpbmsgRm9ybUNvbnRyb2xOYW1lfSxcbiAgICAgKiBpdCBkb2VzIG5vdCByZXF1aXJlIHRoYXQgeW91ciB7XFxAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgYmUgcGFydCBvZiBhbnkgcGFyZW50XG4gICAgICoge1xcQGxpbmsgRm9ybUdyb3VwfSwgYW5kIGl0IHdvbid0IGJlIHJlZ2lzdGVyZWQgdG8gYW55IHtcXEBsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gdGhhdFxuICAgICAqIGV4aXN0cyBhYm92ZSBpdC5cbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlLiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW5cbiAgICAgKiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogKipTZXQgdGhlIHZhbHVlKio6IFlvdSBjYW4gcGFzcyBpbiBhbiBpbml0aWFsIHZhbHVlIHdoZW4gaW5zdGFudGlhdGluZyB0aGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9LFxuICAgICAqIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmcge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvclxuICAgICAqIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtQ29udHJvbC9zaW1wbGVfZm9ybV9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBSZWFjdGl2ZUZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQ29udHJvbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KEZvcm1Db250cm9sRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN5bmNWYWxpZGF0b3JzXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVBY2Nlc3NvcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sRGlyZWN0aXZlKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gdmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoaXNEaXNhYmxlZCkgeyBSZWFjdGl2ZUVycm9ycy5kaXNhYmxlZEF0dHJXYXJuaW5nKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29udHJvbENoYW5nZWQoY2hhbmdlcykpIHtcbiAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2wodGhpcy5mb3JtLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmRpc2FibGVkICYmIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0udXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnNldFZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUuX2lzQ29udHJvbENoYW5nZWQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2Zvcm0nKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sXScsIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZyQxXSwgZXhwb3J0QXM6ICduZ0Zvcm0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdmb3JtJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtQ29udHJvbCcsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Db250cm9sRGlyZWN0aXZlO1xuICAgIH0oTmdDb250cm9sKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvcm1EaXJlY3RpdmVQcm92aWRlciQxID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Hcm91cERpcmVjdGl2ZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgQmluZHMgYW4gZXhpc3Rpbmcge1xcQGxpbmsgRm9ybUdyb3VwfSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGFjY2VwdHMgYW4gZXhpc3Rpbmcge1xcQGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZS4gSXQgd2lsbCB0aGVuIHVzZSB0aGlzXG4gICAgICoge1xcQGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB0byBtYXRjaCBhbnkgY2hpbGQge1xcQGxpbmsgRm9ybUNvbnRyb2x9LCB7XFxAbGluayBGb3JtR3JvdXB9LFxuICAgICAqIGFuZCB7XFxAbGluayBGb3JtQXJyYXl9IGluc3RhbmNlcyB0byBjaGlsZCB7XFxAbGluayBGb3JtQ29udHJvbE5hbWV9LCB7XFxAbGluayBGb3JtR3JvdXBOYW1lfSxcbiAgICAgKiBhbmQge1xcQGxpbmsgRm9ybUFycmF5TmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICoqU2V0IHZhbHVlKio6IFlvdSBjYW4gc2V0IHRoZSBmb3JtJ3MgaW5pdGlhbCB2YWx1ZSB3aGVuIGluc3RhbnRpYXRpbmcgdGhlXG4gICAgICoge1xcQGxpbmsgRm9ybUdyb3VwfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB0aGUge1xcQGxpbmsgRm9ybUdyb3VwfSdzXG4gICAgICoge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvciB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX0gbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgZm9ybSwgeW91IGNhbiBzdWJzY3JpYmVcbiAgICAgKiB0byB0aGUge1xcQGxpbmsgRm9ybUdyb3VwfSdzIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIGl0cyB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogRnVydGhlcm1vcmUsIHlvdSBjYW4gbGlzdGVuIHRvIHRoZSBkaXJlY3RpdmUncyBgbmdTdWJtaXRgIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHVzZXIgaGFzXG4gICAgICogdHJpZ2dlcmVkIGEgZm9ybSBzdWJtaXNzaW9uLiBUaGUgYG5nU3VibWl0YCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgZm9ybVxuICAgICAqIHN1Ym1pc3Npb24gZXZlbnQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogSW4gdGhpcyBleGFtcGxlLCB3ZSBjcmVhdGUgZm9ybSBjb250cm9scyBmb3IgZmlyc3QgbmFtZSBhbmQgbGFzdCBuYW1lLlxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybUdyb3VwL3NpbXBsZV9mb3JtX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjoge1xcQGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX1cbiAgICAgKlxuICAgICAqICBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDExKEZvcm1Hcm91cERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3ZhbGlkYXRvcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBfYXN5bmNWYWxpZGF0b3JzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBGb3JtR3JvdXBEaXJlY3RpdmUoX3ZhbGlkYXRvcnMsIF9hc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IF92YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gX2FzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9ybVByZXNlbnQoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdmb3JtJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVWYWxpZGF0b3JzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVSZWdpc3RyYXRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInN1Ym1pdHRlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3VibWl0dGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcENvbnRyb2woY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0cmw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gKHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLmRpcmVjdGl2ZXMsIGRpcik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5hZGRGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAodGhpcy5mb3JtLmdldChkaXIucGF0aCkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkRm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgc2V0VXBGb3JtQ29udGFpbmVyKGN0cmwsIGRpcik7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVtb3ZlRm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0Rm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gKHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RybCA9ICh0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKSk7XG4gICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gJGV2ZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm9uU3VibWl0ID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQuZW1pdCgkZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUub25SZXNldCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5yZXNldEZvcm0oKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlc2V0Rm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVEb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3Q3RybCA9IF90aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyLl9jb250cm9sICE9PSBuZXdDdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVXBDb250cm9sKGRpci5fY29udHJvbCwgZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0N0cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2wobmV3Q3RybCwgZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgZGlyLl9jb250cm9sID0gbmV3Q3RybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5fdXBkYXRlVHJlZVZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVSZWdpc3RyYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZm9ybS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3VwZGF0ZURvbVZhbHVlKCk7IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29sZEZvcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkRm9ybS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29sZEZvcm0gPSB0aGlzLmZvcm07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bmMgPSBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl92YWxpZGF0b3JzKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS52YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW3RoaXMuZm9ybS52YWxpZGF0b3IsIHN5bmNdKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzeW5jID0gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLmFzeW5jVmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW3RoaXMuZm9ybS5hc3luY1ZhbGlkYXRvciwgYXN5bmNdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja0Zvcm1QcmVzZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5taXNzaW5nRm9ybUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tmb3JtR3JvdXBdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlciQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhzdWJtaXQpJzogJ29uU3VibWl0KCRldmVudCknLCAnKHJlc2V0KSc6ICdvblJlc2V0KCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nRm9ybSdcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdmb3JtJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtR3JvdXAnLF0gfSxdLFxuICAgICAgICAgICAgJ25nU3VibWl0JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3JtR3JvdXBOYW1lUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUdyb3VwTmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgU3luY3MgYSBuZXN0ZWQge1xcQGxpbmsgRm9ybUdyb3VwfSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7XFxAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBuZXN0ZWQge1xcQGxpbmsgRm9ybUdyb3VwfSB5b3Ugd2FudCB0byBsaW5rLCBhbmRcbiAgICAgKiB3aWxsIGxvb2sgZm9yIGEge1xcQGxpbmsgRm9ybUdyb3VwfSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZSBwYXJlbnRcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHlvdSBwYXNzZWQgaW50byB7XFxAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogTmVzdGVkIGZvcm0gZ3JvdXBzIGNhbiBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gdmFsaWRhdGUgYSBzdWItZ3JvdXAgb2YgYVxuICAgICAqIGZvcm0gc2VwYXJhdGVseSBmcm9tIHRoZSByZXN0IG9yIHdoZW4geW91J2QgbGlrZSB0byBncm91cCB0aGUgdmFsdWVzIG9mIGNlcnRhaW5cbiAgICAgKiBjb250cm9scyBpbnRvIHRoZWlyIG93biBuZXN0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGdyb3VwKio6IFlvdSBjYW4gYWNjZXNzIHRoZSBhc3NvY2lhdGVkIHtcXEBsaW5rIEZvcm1Hcm91cH0gdXNpbmcgdGhlXG4gICAgICoge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gbWV0aG9kLiBFeDogYHRoaXMuZm9ybS5nZXQoJ25hbWUnKWAuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gYWNjZXNzIGluZGl2aWR1YWwgY29udHJvbHMgd2l0aGluIHRoZSBncm91cCB1c2luZyBkb3Qgc3ludGF4LlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnbmFtZS5maXJzdCcpYFxuICAgICAqXG4gICAgICogKipHZXQgdGhlIHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9LiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW4ge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICoqU2V0IHRoZSB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciBlYWNoIGNoaWxkIGNvbnRyb2wgd2hlbiBpbnN0YW50aWF0aW5nXG4gICAgICogdGhlIHtcXEBsaW5rIEZvcm1Hcm91cH0sIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmdcbiAgICAgKiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgZ3JvdXAsIHlvdSBjYW5cbiAgICAgKiBzdWJzY3JpYmUgdG8gdGhlIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvbmVzdGVkRm9ybUdyb3VwL25lc3RlZF9mb3JtX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBSZWFjdGl2ZUZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Hcm91cE5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTIoRm9ybUdyb3VwTmFtZSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFzeW5jVmFsaWRhdG9yc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwTmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cE5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2hhc0ludmFsaWRQYXJlbnQodGhpcy5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmdyb3VwUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cE5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdJywgcHJvdmlkZXJzOiBbZm9ybUdyb3VwTmFtZVByb3ZpZGVyXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Hcm91cE5hbWUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBGb3JtR3JvdXBOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Hcm91cE5hbWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUdyb3VwTmFtZTtcbiAgICB9KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9ybUFycmF5TmFtZVByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1BcnJheU5hbWU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFN5bmNzIGEgbmVzdGVkIHtcXEBsaW5rIEZvcm1BcnJheX0gdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggYSBwYXJlbnQge1xcQGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSAoc2VsZWN0b3I6XG4gICAgICogYFtmb3JtR3JvdXBdYCkuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIHtcXEBsaW5rIEZvcm1BcnJheX0geW91IHdhbnQgdG8gbGluaywgYW5kXG4gICAgICogd2lsbCBsb29rIGZvciBhIHtcXEBsaW5rIEZvcm1BcnJheX0gcmVnaXN0ZXJlZCB3aXRoIHRoYXQgbmFtZSBpbiB0aGUgcGFyZW50XG4gICAgICoge1xcQGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB5b3UgcGFzc2VkIGludG8ge1xcQGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIE5lc3RlZCBmb3JtIGFycmF5cyBjYW4gY29tZSBpbiBoYW5keSB3aGVuIHlvdSBoYXZlIGEgZ3JvdXAgb2YgZm9ybSBjb250cm9scyBidXRcbiAgICAgKiB5b3UncmUgbm90IHN1cmUgaG93IG1hbnkgdGhlcmUgd2lsbCBiZS4gRm9ybSBhcnJheXMgYWxsb3cgeW91IHRvIGNyZWF0ZSBuZXdcbiAgICAgKiBmb3JtIGNvbnRyb2xzIGR5bmFtaWNhbGx5LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGFycmF5Kio6IFlvdSBjYW4gYWNjZXNzIHRoZSBhc3NvY2lhdGVkIHtcXEBsaW5rIEZvcm1BcnJheX0gdXNpbmcgdGhlXG4gICAgICoge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gbWV0aG9kIG9uIHRoZSBwYXJlbnQge1xcQGxpbmsgRm9ybUdyb3VwfS5cbiAgICAgKiBFeDogYHRoaXMuZm9ybS5nZXQoJ2NpdGllcycpYC5cbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge1xcQGxpbmsgRm9ybUFycmF5fS4gU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAqKlNldCB0aGUgdmFsdWUqKjogWW91IGNhbiBzZXQgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgZWFjaCBjaGlsZCBjb250cm9sIHdoZW4gaW5zdGFudGlhdGluZ1xuICAgICAqIHRoZSB7XFxAbGluayBGb3JtQXJyYXl9LCBvciB5b3UgY2FuIHNldCB0aGUgdmFsdWUgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB0aGVcbiAgICAgKiB7XFxAbGluayBGb3JtQXJyYXl9J3Mge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvciB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX1cbiAgICAgKiBtZXRob2RzLlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBhcnJheSwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge1xcQGxpbmsgRm9ybUFycmF5fSdzIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvXG4gICAgICogbGlzdGVuIHRvIGl0cyB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvblxuICAgICAqIHN0YXR1cyBpcyByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogKipBZGQgbmV3IGNvbnRyb2xzKio6IFlvdSBjYW4gYWRkIG5ldyBjb250cm9scyB0byB0aGUge1xcQGxpbmsgRm9ybUFycmF5fSBkeW5hbWljYWxseSBieVxuICAgICAqIGNhbGxpbmcgaXRzIHtcXEBsaW5rIEZvcm1BcnJheS5wdXNofSBtZXRob2QuXG4gICAgICogIEV4OiBgdGhpcy5mb3JtLmdldCgnY2l0aWVzJykucHVzaChuZXcgRm9ybUNvbnRyb2woKSk7YFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL25lc3RlZEZvcm1BcnJheS9uZXN0ZWRfZm9ybV9hcnJheV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgUmVhY3RpdmVGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQXJyYXlOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEyKEZvcm1BcnJheU5hbWUsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3luY1ZhbGlkYXRvcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEZvcm1BcnJheU5hbWUocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1BcnJheSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldEZvcm1BcnJheSh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/ICh0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSkgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl92YWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9oYXNJbnZhbGlkUGFyZW50KHRoaXMuX3BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5hcnJheVBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtQXJyYXlOYW1lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQXJyYXlOYW1lXScsIHByb3ZpZGVyczogW2Zvcm1BcnJheU5hbWVQcm92aWRlcl0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQXJyYXlOYW1lLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZiB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtQXJyYXlOYW1lJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1BcnJheU5hbWU7XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9oYXNJbnZhbGlkUGFyZW50KHBhcmVudCkge1xuICAgICAgICByZXR1cm4gIShwYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBOYW1lKSAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cERpcmVjdGl2ZSkgJiZcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUFycmF5TmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250cm9sTmFtZUJpbmRpbmcgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtQ29udHJvbE5hbWU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFN5bmNzIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGluIGFuIGV4aXN0aW5nIHtcXEBsaW5rIEZvcm1Hcm91cH0gdG8gYSBmb3JtIGNvbnRyb2xcbiAgICAgKiBlbGVtZW50IGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgdGhpcyBkaXJlY3RpdmUgZW5zdXJlcyB0aGF0IGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2UgcHJvZ3JhbW1hdGljYWxseSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IChtb2RlbCAtPiB2aWV3KS4gQ29udmVyc2VseSxcbiAgICAgKiBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IHRocm91Z2ggdXNlciBpbnB1dCB3aWxsIGJlIHJlZmxlY3RlZCBpbiB0aGVcbiAgICAgKiB7XFxAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgKHZpZXcgLT4gbW9kZWwpLlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7XFxAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSB7XFxAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgeW91IHdhbnQgdG9cbiAgICAgKiBsaW5rLCBhbmQgd2lsbCBsb29rIGZvciBhIHtcXEBsaW5rIEZvcm1Db250cm9sfSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZVxuICAgICAqIGNsb3Nlc3Qge1xcQGxpbmsgRm9ybUdyb3VwfSBvciB7XFxAbGluayBGb3JtQXJyYXl9IGFib3ZlIGl0LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGNvbnRyb2wqKjogWW91IGNhbiBhY2Nlc3MgdGhlIHtcXEBsaW5rIEZvcm1Db250cm9sfSBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiB0aGlzIGRpcmVjdGl2ZSBieSB1c2luZyB0aGUge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gbWV0aG9kLlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnZmlyc3QnKTtgXG4gICAgICpcbiAgICAgKiAqKkdldCB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlIHtcXEBsaW5rIEZvcm1Db250cm9sfS5cbiAgICAgKiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW4ge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICAqKlNldCB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciB0aGUgY29udHJvbCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlXG4gICAgICogIHtcXEBsaW5rIEZvcm1Db250cm9sfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZ1xuICAgICAqICB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNyZWF0ZSBmb3JtIGNvbnRyb2xzIGZvciBmaXJzdCBuYW1lIGFuZCBsYXN0IG5hbWUuXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBUbyBzZWUgYGZvcm1Db250cm9sTmFtZWAgZXhhbXBsZXMgd2l0aCBkaWZmZXJlbnQgZm9ybSBjb250cm9sIHR5cGVzLCBzZWU6XG4gICAgICpcbiAgICAgKiAqIFJhZGlvIGJ1dHRvbnM6IHtcXEBsaW5rIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICogKiBTZWxlY3RzOiB7XFxAbGluayBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvcn1cbiAgICAgKlxuICAgICAqICoqbnBtIHBhY2thZ2UqKjogYFxcQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqKk5nTW9kdWxlKio6IHtcXEBsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9XG4gICAgICpcbiAgICAgKiAgXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sTmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMChGb3JtQ29udHJvbE5hbWUsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3luY1ZhbGlkYXRvcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZUFjY2Vzc29yc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2xOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gdmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImlzRGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZygpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FkZGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUudXBkYXRlTW9kZWwodGhpcywgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250cm9sOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBOYW1lKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMubmdNb2RlbEdyb3VwRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwRGlyZWN0aXZlKSAmJlxuICAgICAgICAgICAgICAgICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUFycmF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5jb250cm9sUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5fc2V0VXBDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sID0gdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmRpc2FibGVkICYmIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xOYW1lXScsIHByb3ZpZGVyczogW2NvbnRyb2xOYW1lQmluZGluZ10gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1IsXSB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Db250cm9sTmFtZScsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Db250cm9sTmFtZTtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgdmFyIF9fZXh0ZW5kcyQxMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFJFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSZXF1aXJlZFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBDSEVDS0JPWF9SRVFVSVJFRF9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yIHRvIGFueSBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAgICAgKiBgcmVxdWlyZWRgIGF0dHJpYnV0ZSwgdmlhIHRoZSB7XFxAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxpbnB1dCBuYW1lPVwiZnVsbE5hbWVcIiBuZ01vZGVsIHJlcXVpcmVkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFJlcXVpcmVkVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVxdWlyZWRWYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiBcIlwiICsgdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZCA/IFZhbGlkYXRvcnMucmVxdWlyZWQoYykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJzpub3QoW3R5cGU9Y2hlY2tib3hdKVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW2Zvcm1Db250cm9sXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JFUVVJUkVEX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5yZXF1aXJlZF0nOiAncmVxdWlyZWQgPyBcIlwiIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ3JlcXVpcmVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gY2hlY2tib3ggY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gICAgICogYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHZpYSB0aGUge1xcQGxpbmsgTkdfVkFMSURBVE9SU30gYmluZGluZy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmFtZT1cImFjdGl2ZVwiIG5nTW9kZWwgcmVxdWlyZWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZWQgPyBWYWxpZGF0b3JzLnJlcXVpcmVkVHJ1ZShjKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW3JlcXVpcmVkXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9Y2hlY2tib3hdW3JlcXVpcmVkXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0NIRUNLQk9YX1JFUVVJUkVEX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5yZXF1aXJlZF0nOiAncmVxdWlyZWQgPyBcIlwiIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgcmV0dXJuIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfShSZXF1aXJlZFZhbGlkYXRvcikpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1pbkxlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vZm9ybXMvdHMvdmFsaWRhdG9ycy92YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbWluJ31cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBNSU5fTEVOR1RIX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBkaXJlY3RpdmUgd2hpY2ggaW5zdGFsbHMgdGhlIHtcXEBsaW5rIE1pbkxlbmd0aFZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lYCxcbiAgICAgKiBgZm9ybUNvbnRyb2xgLCBvciBjb250cm9sIHdpdGggYG5nTW9kZWxgIHRoYXQgYWxzbyBoYXMgYSBgbWlubGVuZ3RoYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTWluTGVuZ3RoVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWluTGVuZ3RoVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKCdtaW5sZW5ndGgnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlubGVuZ3RoID09IG51bGwgPyBudWxsIDogdGhpcy5fdmFsaWRhdG9yKGMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5taW5MZW5ndGgocGFyc2VJbnQodGhpcy5taW5sZW5ndGgsIDEwKSk7XG4gICAgICAgIH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWlubGVuZ3RoXVtmb3JtQ29udHJvbF0sW21pbmxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUlOX0xFTkdUSF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIubWlubGVuZ3RoXSc6ICdtaW5sZW5ndGggPyBtaW5sZW5ndGggOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdtaW5sZW5ndGgnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1heExlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vZm9ybXMvdHMvdmFsaWRhdG9ycy92YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbWF4J31cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBNQVhfTEVOR1RIX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhMZW5ndGhWYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBkaXJlY3RpdmUgd2hpY2ggaW5zdGFsbHMgdGhlIHtcXEBsaW5rIE1heExlbmd0aFZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lLFxuICAgICAqIGBmb3JtQ29udHJvbGAsXG4gICAgICogb3IgY29udHJvbCB3aXRoIGBuZ01vZGVsYCB0aGF0IGFsc28gaGFzIGEgYG1heGxlbmd0aGAgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE1heExlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1heExlbmd0aFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICgnbWF4bGVuZ3RoJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heGxlbmd0aCAhPSBudWxsID8gdGhpcy5fdmFsaWRhdG9yKGMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMubWF4TGVuZ3RoKHBhcnNlSW50KHRoaXMubWF4bGVuZ3RoLCAxMCkpO1xuICAgICAgICB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXhsZW5ndGhdW2Zvcm1Db250cm9sTmFtZV0sW21heGxlbmd0aF1bZm9ybUNvbnRyb2xdLFttYXhsZW5ndGhdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01BWF9MRU5HVEhfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLm1heGxlbmd0aF0nOiAnbWF4bGVuZ3RoID8gbWF4bGVuZ3RoIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbWF4bGVuZ3RoJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNYXhMZW5ndGhWYWxpZGF0b3I7XG4gICAgfSgpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBQQVRURVJOX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBQYXR0ZXJuVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHBhdHRlcm5gIHZhbGlkYXRvciB0byBhbnkgY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gICAgICogYHBhdHRlcm5gIGF0dHJpYnV0ZSwgdmlhIHRoZSB7XFxAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLiBVc2VzIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIGFzIHRoZSByZWdleCB0byB2YWxpZGF0ZSBDb250cm9sIHZhbHVlIGFnYWluc3QuICBGb2xsb3dzIHBhdHRlcm4gYXR0cmlidXRlXG4gICAgICogc2VtYW50aWNzOyBpLmUuIHJlZ2V4IG11c3QgbWF0Y2ggZW50aXJlIENvbnRyb2wgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGlucHV0IFtuYW1lXT1cImZ1bGxOYW1lXCIgcGF0dGVybj1cIlthLXpBLVogXSpcIiBuZ01vZGVsPlxuICAgICAqIGBgYFxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQYXR0ZXJuVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGF0dGVyblZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoJ3BhdHRlcm4nIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLnBhdHRlcm4odGhpcy5wYXR0ZXJuKTsgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3BhdHRlcm5dW2Zvcm1Db250cm9sTmFtZV0sW3BhdHRlcm5dW2Zvcm1Db250cm9sXSxbcGF0dGVybl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUEFUVEVSTl9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIucGF0dGVybl0nOiAncGF0dGVybiA/IHBhdHRlcm4gOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ3BhdHRlcm4nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBhdHRlcm5WYWxpZGF0b3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgQ3JlYXRlcyBhbiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2x9IGZyb20gYSB1c2VyLXNwZWNpZmllZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogSXQgaXMgZXNzZW50aWFsbHkgc3ludGFjdGljIHN1Z2FyIHRoYXQgc2hvcnRlbnMgdGhlIGBuZXcgRm9ybUdyb3VwKClgLFxuICAgICAqIGBuZXcgRm9ybUNvbnRyb2woKWAsIGFuZCBgbmV3IEZvcm1BcnJheSgpYCBib2lsZXJwbGF0ZSB0aGF0IGNhbiBidWlsZCB1cCBpbiBsYXJnZXJcbiAgICAgKiBmb3Jtcy5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUbyB1c2UsIGluamVjdCBgRm9ybUJ1aWxkZXJgIGludG8geW91ciBjb21wb25lbnQgY2xhc3MuIFlvdSBjYW4gdGhlbiBjYWxsIGl0cyBtZXRob2RzXG4gICAgICogZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9mb3JtQnVpbGRlci9mb3JtX2J1aWxkZXJfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAgKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogICogKipOZ01vZHVsZSoqOiB7XFxAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfVxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUJ1aWxkZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyB7XFxAbGluayBGb3JtR3JvdXB9IHdpdGggdGhlIGdpdmVuIG1hcCBvZiBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBWYWxpZCBrZXlzIGZvciB0aGUgYGV4dHJhYCBwYXJhbWV0ZXIgbWFwIGFyZSBgdmFsaWRhdG9yYCBhbmQgYGFzeW5jVmFsaWRhdG9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIHRoZSB7XFxAbGluayBGb3JtR3JvdXB9IGNvbnN0cnVjdG9yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbHNDb25maWdcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZXh0cmFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZywgZXh0cmEpIHtcbiAgICAgICAgICAgIGlmIChleHRyYSA9PT0gdm9pZCAwKSB7IGV4dHJhID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udHJvbHMgPSB0aGlzLl9yZWR1Y2VDb250cm9scyhjb250cm9sc0NvbmZpZyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWxpZGF0b3IgPSBpc1ByZXNlbnQoZXh0cmEpID8gZXh0cmFbJ3ZhbGlkYXRvciddIDogbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzeW5jVmFsaWRhdG9yID0gaXNQcmVzZW50KGV4dHJhKSA/IGV4dHJhWydhc3luY1ZhbGlkYXRvciddIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUdyb3VwKGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyB7XFxAbGluayBGb3JtQ29udHJvbH0gd2l0aCB0aGUgZ2l2ZW4gYGZvcm1TdGF0ZWAsYHZhbGlkYXRvcmAsIGFuZFxuICAgICAgICAgKiBgYXN5bmNWYWxpZGF0b3JgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgZm9ybVN0YXRlYCBjYW4gZWl0aGVyIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZSBmb3IgdGhlIGZvcm0gY29udHJvbCBvciBhbiBvYmplY3RcbiAgICAgICAgICogdGhhdCBjb250YWlucyBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdHVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZvcm1TdGF0ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSB2YWxpZGF0b3JcbiAgICAgICAgICogQHBhcmFtIHs/PX0gYXN5bmNWYWxpZGF0b3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5jb250cm9sID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEge1xcQGxpbmsgRm9ybUFycmF5fSBmcm9tIHRoZSBnaXZlbiBgY29udHJvbHNDb25maWdgIGFycmF5IG9mXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24sIHdpdGggdGhlIGdpdmVuIG9wdGlvbmFsIGB2YWxpZGF0b3JgIGFuZCBgYXN5bmNWYWxpZGF0b3JgLlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xzQ29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbGlkYXRvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBhc3luY1ZhbGlkYXRvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udHJvbHMgPSBjb250cm9sc0NvbmZpZy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVDb250cm9sKGMpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbHNDb25maWdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5fcmVkdWNlQ29udHJvbHMgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250cm9scyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJvbHNDb25maWcpLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbE5hbWVdID0gX3RoaXMuX2NyZWF0ZUNvbnRyb2woY29udHJvbHNDb25maWdbY29udHJvbE5hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sQ29uZmlnXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCB8fCBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgRm9ybUdyb3VwIHx8XG4gICAgICAgICAgICAgICAgY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gY29udHJvbENvbmZpZ1swXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWxpZGF0b3IgPSBjb250cm9sQ29uZmlnLmxlbmd0aCA+IDEgPyBjb250cm9sQ29uZmlnWzFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3luY1ZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMiA/IGNvbnRyb2xDb25maWdbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wodmFsdWUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbChjb250cm9sQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUJ1aWxkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQnVpbGRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gRm9ybUJ1aWxkZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBWRVJTSU9OID0gbmV3IF9hbmd1bGFyX2NvcmUuVmVyc2lvbignMi40LjgnKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIFNIQVJFRF9GT1JNX0RJUkVDVElWRVMgPSBbXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLFxuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLFxuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3NvcixcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgTmdDb250cm9sU3RhdHVzLFxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCxcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvcixcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLFxuICAgICAgICBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yLFxuICAgIF07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVMgPSBbTmdNb2RlbCwgTmdNb2RlbEdyb3VwLCBOZ0Zvcm1dO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFJFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW0Zvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kdWxlIHVzZWQgZm9yIHNoYXJpbmcgZGlyZWN0aXZlcyBiZXR3ZWVuIEZvcm1zTW9kdWxlIGFuZCBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gICAgICovXG4gICAgdmFyIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFNIQVJFRF9GT1JNX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5nIG1vZHVsZSBmb3IgZm9ybXMuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1zTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRm9ybXNNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRm9ybXNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSYWRpb0NvbnRyb2xSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVNdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybXNNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1zTW9kdWxlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIG5nIG1vZHVsZSBmb3IgcmVhY3RpdmUgZm9ybXMuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFJlYWN0aXZlRm9ybXNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWFjdGl2ZUZvcm1zTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1JFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0Zvcm1CdWlsZGVyLCBSYWRpb0NvbnRyb2xSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gUmVhY3RpdmVGb3Jtc01vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgZXhwb3J0cy5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5BYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSA9IEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5Db250cm9sQ29udGFpbmVyID0gQ29udHJvbENvbnRhaW5lcjtcbiAgICBleHBvcnRzLk5HX1ZBTFVFX0FDQ0VTU09SID0gTkdfVkFMVUVfQUNDRVNTT1I7XG4gICAgZXhwb3J0cy5EZWZhdWx0VmFsdWVBY2Nlc3NvciA9IERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuTmdDb250cm9sID0gTmdDb250cm9sO1xuICAgIGV4cG9ydHMuTmdDb250cm9sU3RhdHVzID0gTmdDb250cm9sU3RhdHVzO1xuICAgIGV4cG9ydHMuTmdDb250cm9sU3RhdHVzR3JvdXAgPSBOZ0NvbnRyb2xTdGF0dXNHcm91cDtcbiAgICBleHBvcnRzLk5nRm9ybSA9IE5nRm9ybTtcbiAgICBleHBvcnRzLk5nTW9kZWwgPSBOZ01vZGVsO1xuICAgIGV4cG9ydHMuTmdNb2RlbEdyb3VwID0gTmdNb2RlbEdyb3VwO1xuICAgIGV4cG9ydHMuUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbERpcmVjdGl2ZSA9IEZvcm1Db250cm9sRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuRm9ybUNvbnRyb2xOYW1lID0gRm9ybUNvbnRyb2xOYW1lO1xuICAgIGV4cG9ydHMuRm9ybUdyb3VwRGlyZWN0aXZlID0gRm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuRm9ybUFycmF5TmFtZSA9IEZvcm1BcnJheU5hbWU7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXBOYW1lID0gRm9ybUdyb3VwTmFtZTtcbiAgICBleHBvcnRzLk5nU2VsZWN0T3B0aW9uID0gTmdTZWxlY3RPcHRpb247XG4gICAgZXhwb3J0cy5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciA9IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5DaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yID0gQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLk1heExlbmd0aFZhbGlkYXRvciA9IE1heExlbmd0aFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLk1pbkxlbmd0aFZhbGlkYXRvciA9IE1pbkxlbmd0aFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLlBhdHRlcm5WYWxpZGF0b3IgPSBQYXR0ZXJuVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuUmVxdWlyZWRWYWxpZGF0b3IgPSBSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLkZvcm1CdWlsZGVyID0gRm9ybUJ1aWxkZXI7XG4gICAgZXhwb3J0cy5BYnN0cmFjdENvbnRyb2wgPSBBYnN0cmFjdENvbnRyb2w7XG4gICAgZXhwb3J0cy5Gb3JtQXJyYXkgPSBGb3JtQXJyYXk7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbCA9IEZvcm1Db250cm9sO1xuICAgIGV4cG9ydHMuRm9ybUdyb3VwID0gRm9ybUdyb3VwO1xuICAgIGV4cG9ydHMuTkdfQVNZTkNfVkFMSURBVE9SUyA9IE5HX0FTWU5DX1ZBTElEQVRPUlM7XG4gICAgZXhwb3J0cy5OR19WQUxJREFUT1JTID0gTkdfVkFMSURBVE9SUztcbiAgICBleHBvcnRzLlZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzO1xuICAgIGV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG4gICAgZXhwb3J0cy5Gb3Jtc01vZHVsZSA9IEZvcm1zTW9kdWxlO1xuICAgIGV4cG9ydHMuUmVhY3RpdmVGb3Jtc01vZHVsZSA9IFJlYWN0aXZlRm9ybXNNb2R1bGU7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjIuNC44QEBhbmd1bGFyL2Zvcm1zL2J1bmRsZXMvZm9ybXMudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9ICAgICAgICAgICAgIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUsIFJvdXRlcyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcblxyXG5cclxuaW1wb3J0IHthcHBMb2dpbk1vZHVsZX0gZnJvbSAnLi4vYXBwTG9naW5Nb2R1bGUvbG9naW4ubW9kdWxlJztcclxuaW1wb3J0IHtMb2dpbjFDb21wb25lbnR9IGZyb20gJy4uL2FwcExvZ2luTW9kdWxlL2xvZ2luMS5jb21wb25lbnQnO1xyXG5pbXBvcnQge2FwcENvbnRlbnRNb2R1bGV9IGZyb20gJy4uL2FwcENvbnRlbnRNb2R1bGUvY29udGVudC5tb2R1bGUnO1xyXG5pbXBvcnQge2FwcENvbnRlbnRSb3V0ZXN9IGZyb20gJy4vYXBwQ29udGVudFJvdXRlci5tb2R1bGUnO1xyXG5cclxuY29uc3QgYXBwUm91dGVzOiBSb3V0ZXMgPSBbXHJcblxyXG4gICAgeyBwYXRoOiAnJywgcmVkaXJlY3RUbzogJ2xvZ2luJywgIHBhdGhNYXRjaDogJ2Z1bGwnfSxcclxuICAgIHsgcGF0aDogJ2xvZ2luJywgY29tcG9uZW50OiBMb2dpbjFDb21wb25lbnQgfSxcclxuICAgIC4uLmFwcENvbnRlbnRSb3V0ZXNcclxuICAgIFxyXG5dO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBpbXBvcnRzOiBbXHJcbiAgICBSb3V0ZXJNb2R1bGUuZm9yUm9vdChhcHBSb3V0ZXMseyB1c2VIYXNoOiB0cnVlIH0pLFxyXG4gICAgYXBwTG9naW5Nb2R1bGUsXHJcbiAgICBhcHBDb250ZW50TW9kdWxlLCBcclxuICBdLFxyXG4gIGRlY2xhcmF0aW9uczogW1xyXG4gIF0sXHJcbiAgZXhwb3J0czogW1xyXG4gICAgUm91dGVyTW9kdWxlXHJcbiAgXSxcclxuXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBSb3V0aW5nTW9kdWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwUm91dGVyTW9kdWxlL2FwcFJvdXRlci5tb2R1bGUudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge0xvZ2luMUNvbXBvbmVudH0gZnJvbSAnLi9sb2dpbjEuY29tcG9uZW50JztcclxuaW1wb3J0IHsgTWF0ZXJpYWxNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XHJcbmltcG9ydCB7IEZsZXhMYXlvdXRNb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvZmxleC1sYXlvdXRcIjtcclxuXHJcbkBOZ01vZHVsZSh7XHJcblx0aW1wb3J0czogW1xyXG5cdFx0TWF0ZXJpYWxNb2R1bGUuZm9yUm9vdCgpLFxyXG5cdFx0RmxleExheW91dE1vZHVsZS5mb3JSb290KCksXHJcblx0XSxcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIExvZ2luMUNvbXBvbmVudCxcclxuICAgICAgIFxyXG4gICAgXSxcclxuICAgIGV4cG9ydHM6W1xyXG4gICAgICAgIExvZ2luMUNvbXBvbmVudFxyXG4gICAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIGFwcExvZ2luTW9kdWxlIHt9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwTG9naW5Nb2R1bGUvbG9naW4ubW9kdWxlLnRzIiwiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2xvZ2luMS1mb3JtJyxcclxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9sb2dpbjEuaHRtbCcpLFxyXG4gIC8vIGRpcmVjdGl2ZXM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTG9naW4xQ29tcG9uZW50IHt9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwTG9naW5Nb2R1bGUvbG9naW4xLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJsb2dpbi1mb3JtLWNvbnRhaW5lclxcXCIgZnhMYXlvdXQ9XFxcImNvbHVtblxcXCIgZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCIgPlxcclxcblxcdDxmb3JtIGNsYXNzPVxcXCJmbGV4LWl0ZW0gbG9naW4tZm9ybVxcXCIgZnhMYXlvdXQ9XFxcImNvbHVtblxcXCIgZnhMYXlvdXRBbGlnbj1cXFwiY2VudGVyIGNlbnRlclxcXCI+XFxyXFxuXFx0XFx0PG1kLWlucHV0LWNvbnRhaW5lcj5cXHJcXG5cXHRcXHQgIDxpbnB1dCBtZElucHV0IHBsYWNlaG9sZGVyPVxcXCLotKYgIOaIt1xcXCIgdmFsdWU9XFxcIlN1c2hpXFxcIj5cXHJcXG5cXHRcXHQ8L21kLWlucHV0LWNvbnRhaW5lcj5cXHJcXG5cXHRcXHQ8bWQtaW5wdXQtY29udGFpbmVyPlxcclxcblxcdFxcdCAgPGlucHV0IG1kSW5wdXQgcGxhY2Vob2xkZXI9XFxcIuWvhiAg56CBXFxcIiB2YWx1ZT1cXFwiU3VzaGlcXFwiPlxcclxcblxcdFxcdDwvbWQtaW5wdXQtY29udGFpbmVyPlxcclxcblxcdFxcdDxkaXYgZnhMYXlvdXQ9XFxcInJvd1xcXCIgZnhMYXlvdXRBbGlnbj1cXFwic3BhY2UtYXJvdW5kIGNlbnRlclxcXCI+IFxcclxcblxcdFxcdCAgXFx0PGJ1dHRvbiBtZC1yYWlzZWQtYnV0dG9uPumHjSAg572uPC9idXR0b24+XFxyXFxuXFx0XFx0ICBcXHQ8YnV0dG9uIG1kLXJhaXNlZC1idXR0b24+55m7ICDpmYY8L2J1dHRvbj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L2Zvcm0+XFxyXFxuPC9kaXY+XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2FwcExvZ2luTW9kdWxlL2xvZ2luMS5odG1sXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAgKiBAbGljZW5zZSBBbmd1bGFyIE1hdGVyaWFsIHYyLjAuMC1iZXRhLjJcbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vbWF0ZXJpYWwuYW5ndWxhci5pby9cbiAgKiBMaWNlbnNlOiBNSVRcbiAgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyksIHJlcXVpcmUoJ3J4anMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50JyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL2F1ZGl0VGltZScpLCByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2Zvcm1zJyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL3N0YXJ0V2l0aCcpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9maXJzdCcpLCByZXF1aXJlKCdAYW5ndWxhci9odHRwJyksIHJlcXVpcmUoJ3J4anMvYWRkL29ic2VydmFibGUvZm9ya0pvaW4nKSwgcmVxdWlyZSgncnhqcy9hZGQvb2JzZXJ2YWJsZS9vZicpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9tYXAnKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyJyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL2RvJyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL3NoYXJlJyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL2ZpbmFsbHknKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnKSwgcmVxdWlyZSgncnhqcy9hZGQvb2JzZXJ2YWJsZS9tZXJnZScpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXAnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29yZScsICdAYW5ndWxhci9jb21tb24nLCAncnhqcy9TdWJqZWN0JywgJ3J4anMvT2JzZXJ2YWJsZScsICdyeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudCcsICdyeGpzL2FkZC9vcGVyYXRvci9hdWRpdFRpbWUnLCAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicsICdAYW5ndWxhci9mb3JtcycsICdyeGpzL2FkZC9vcGVyYXRvci9zdGFydFdpdGgnLCAncnhqcy9hZGQvb3BlcmF0b3IvZmlyc3QnLCAnQGFuZ3VsYXIvaHR0cCcsICdyeGpzL2FkZC9vYnNlcnZhYmxlL2ZvcmtKb2luJywgJ3J4anMvYWRkL29ic2VydmFibGUvb2YnLCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwJywgJ3J4anMvYWRkL29wZXJhdG9yL2ZpbHRlcicsICdyeGpzL2FkZC9vcGVyYXRvci9kbycsICdyeGpzL2FkZC9vcGVyYXRvci9zaGFyZScsICdyeGpzL2FkZC9vcGVyYXRvci9maW5hbGx5JywgJ3J4anMvYWRkL29wZXJhdG9yL2NhdGNoJywgJ3J4anMvYWRkL29ic2VydmFibGUvbWVyZ2UnLCAncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcubWF0ZXJpYWwgPSBnbG9iYWwubmcubWF0ZXJpYWwgfHwge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5uZy5jb21tb24sZ2xvYmFsLlJ4LGdsb2JhbC5SeCxnbG9iYWwuUnguT2JzZXJ2YWJsZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcixnbG9iYWwubmcuZm9ybXMsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwubmcuaHR0cCxnbG9iYWwuUnguT2JzZXJ2YWJsZSxnbG9iYWwuUnguT2JzZXJ2YWJsZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUsX2FuZ3VsYXJfY29tbW9uLHJ4anNfU3ViamVjdCxyeGpzX09ic2VydmFibGUscnhqc19hZGRfb2JzZXJ2YWJsZV9mcm9tRXZlbnQscnhqc19hZGRfb3BlcmF0b3JfYXVkaXRUaW1lLF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlcixfYW5ndWxhcl9mb3JtcyxyeGpzX2FkZF9vcGVyYXRvcl9zdGFydFdpdGgscnhqc19hZGRfb3BlcmF0b3JfZmlyc3QsX2FuZ3VsYXJfaHR0cCxyeGpzX2FkZF9vYnNlcnZhYmxlX2ZvcmtKb2luLHJ4anNfYWRkX29ic2VydmFibGVfb2Yscnhqc19hZGRfb3BlcmF0b3JfbWFwLHJ4anNfYWRkX29wZXJhdG9yX2ZpbHRlcixyeGpzX2FkZF9vcGVyYXRvcl9kbyxyeGpzX2FkZF9vcGVyYXRvcl9zaGFyZSxyeGpzX2FkZF9vcGVyYXRvcl9maW5hbGx5LHJ4anNfYWRkX29wZXJhdG9yX2NhdGNoLHJ4anNfYWRkX29ic2VydmFibGVfbWVyZ2Uscnhqc19hZGRfb3BlcmF0b3Jfc3dpdGNoTWFwKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIF9fZGVjb3JhdGUkMiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignbWQtY29tcGF0aWJpbGl0eS1tb2RlJyk7XG4vKiogU2VsZWN0b3IgdGhhdCBtYXRjaGVzIGFsbCBlbGVtZW50cyB0aGF0IG1heSBoYXZlIHN0eWxlIGNvbGxpc2lvbnMgd2l0aCBBbmd1bGFySlMgTWF0ZXJpYWwuICovXG52YXIgTUFUX0VMRU1FTlRTX1NFTEVDVE9SID0gXCJcXG4gIFttYXQtYnV0dG9uXSxcXG4gIFttYXQtZGlhbG9nLWFjdGlvbnNdLFxcbiAgW21hdC1kaWFsb2ctY2xvc2VdLFxcbiAgW21hdC1kaWFsb2ctY29udGVudF0sXFxuICBbbWF0LWRpYWxvZy10aXRsZV0sXFxuICBbbWF0LWZhYl0sXFxuICBbbWF0LWljb24tYnV0dG9uXSxcXG4gIFttYXQtbWVudS10cmlnZ2VyLWZvcl0sXFxuICBbbWF0LW1pbmktZmFiXSxcXG4gIFttYXQtcmFpc2VkLWJ1dHRvbl0sXFxuICBbbWF0LXRhYi1sYWJlbF0sXFxuICBbbWF0LXRhYi1saW5rXSxcXG4gIFttYXQtdGFiLW5hdi1iYXJdLFxcbiAgW21hdFRvb2x0aXBdLFxcbiAgbWF0LWF1dG9jb21wbGV0ZSxcXG4gIG1hdC1idXR0b24tdG9nZ2xlLFxcbiAgbWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXAsXFxuICBtYXQtYnV0dG9uLXRvZ2dsZSxcXG4gIG1hdC1jYXJkLFxcbiAgbWF0LWNhcmQtYWN0aW9ucyxcXG4gIG1hdC1jYXJkLWNvbnRlbnQsXFxuICBtYXQtY2FyZC1mb290ZXIsXFxuICBtYXQtY2FyZC1oZWFkZXIsXFxuICBtYXQtY2FyZC1zdWJ0aXRsZSxcXG4gIG1hdC1jYXJkLXRpdGxlLFxcbiAgbWF0LWNhcmQtdGl0bGUtZ3JvdXAsXFxuICBtYXQtY2hlY2tib3gsXFxuICBtYXQtY2hpcCxcXG4gIG1hdC1kaWFsb2ctYWN0aW9ucyxcXG4gIG1hdC1kaWFsb2ctY29udGFpbmVyLFxcbiAgbWF0LWRpYWxvZy1jb250ZW50LFxcbiAgbWF0LWRpdmlkZXIsXFxuICBtYXQtZ3JpZC1saXN0LFxcbiAgbWF0LWdyaWQtdGlsZSxcXG4gIG1hdC1ncmlkLXRpbGUtZm9vdGVyLFxcbiAgbWF0LWdyaWQtdGlsZS1oZWFkZXIsXFxuICBtYXQtaGludCxcXG4gIG1hdC1pY29uLFxcbiAgbWF0LWluay1iYXIsXFxuICBtYXQtbGlzdCxcXG4gIG1hdC1saXN0LWl0ZW0sXFxuICBtYXQtbWVudSxcXG4gIG1hdC1uYXYtbGlzdCxcXG4gIG1hdC1vcHRpb24sXFxuICBtYXQtcGxhY2Vob2xkZXIsXFxuICBtYXQtcHJvZ3Jlc3MtYmFyLFxcbiAgbWF0LXByb2dyZXNzLWNpcmNsZSxcXG4gIG1hdC1wc2V1ZG8tY2hlY2tib3gsXFxuICBtYXQtcmFkaW8tYnV0dG9uLFxcbiAgbWF0LXJhZGlvLWdyb3VwLFxcbiAgbWF0LXNlbGVjdCxcXG4gIG1hdC1zaWRlbmF2LFxcbiAgbWF0LXNpZGVuYXYtY29udGFpbmVyLFxcbiAgbWF0LXNsaWRlcixcXG4gIG1hdC1zcGlubmVyLFxcbiAgbWF0LXRhYixcXG4gIG1hdC10YWItYm9keSxcXG4gIG1hdC10YWItaGVhZGVyLFxcbiAgbWF0LXRhYi1ncm91cCxcXG4gIG1hdC10b29sYmFyXCI7XG4vKiogU2VsZWN0b3IgdGhhdCBtYXRjaGVzIGFsbCBlbGVtZW50cyB0aGF0IG1heSBoYXZlIHN0eWxlIGNvbGxpc2lvbnMgd2l0aCBBbmd1bGFySlMgTWF0ZXJpYWwuICovXG52YXIgTURfRUxFTUVOVFNfU0VMRUNUT1IgPSBcIiAgXFxuICBbbWQtYnV0dG9uXSxcXG4gIFttZC1kaWFsb2ctYWN0aW9uc10sXFxuICBbbWQtZGlhbG9nLWNsb3NlXSxcXG4gIFttZC1kaWFsb2ctY29udGVudF0sXFxuICBbbWQtZGlhbG9nLXRpdGxlXSxcXG4gIFttZC1mYWJdLFxcbiAgW21kLWljb24tYnV0dG9uXSxcXG4gIFttZC1tZW51LXRyaWdnZXItZm9yXSxcXG4gIFttZC1taW5pLWZhYl0sXFxuICBbbWQtcmFpc2VkLWJ1dHRvbl0sXFxuICBbbWQtdGFiLWxhYmVsXSxcXG4gIFttZC10YWItbGlua10sXFxuICBbbWQtdGFiLW5hdi1iYXJdLFxcbiAgW21kVG9vbHRpcF0sXFxuICBtZC1hdXRvY29tcGxldGUsXFxuICBtZC1idXR0b24tdG9nZ2xlLFxcbiAgbWQtYnV0dG9uLXRvZ2dsZS1ncm91cCxcXG4gIG1kLWJ1dHRvbi10b2dnbGUsXFxuICBtZC1jYXJkLFxcbiAgbWQtY2FyZC1hY3Rpb25zLFxcbiAgbWQtY2FyZC1jb250ZW50LFxcbiAgbWQtY2FyZC1mb290ZXIsXFxuICBtZC1jYXJkLWhlYWRlcixcXG4gIG1kLWNhcmQtc3VidGl0bGUsXFxuICBtZC1jYXJkLXRpdGxlLFxcbiAgbWQtY2FyZC10aXRsZS1ncm91cCxcXG4gIG1kLWNoZWNrYm94LFxcbiAgbWQtY2hpcCxcXG4gIG1kLWRpYWxvZy1hY3Rpb25zLFxcbiAgbWQtZGlhbG9nLWNvbnRhaW5lcixcXG4gIG1kLWRpYWxvZy1jb250ZW50LFxcbiAgbWQtZGl2aWRlcixcXG4gIG1kLWdyaWQtbGlzdCxcXG4gIG1kLWdyaWQtdGlsZSxcXG4gIG1kLWdyaWQtdGlsZS1mb290ZXIsXFxuICBtZC1ncmlkLXRpbGUtaGVhZGVyLFxcbiAgbWQtaGludCxcXG4gIG1kLWljb24sXFxuICBtZC1pbmstYmFyLFxcbiAgbWQtbGlzdCxcXG4gIG1kLWxpc3QtaXRlbSxcXG4gIG1kLW1lbnUsXFxuICBtZC1uYXYtbGlzdCxcXG4gIG1kLW9wdGlvbixcXG4gIG1kLXBsYWNlaG9sZGVyLFxcbiAgbWQtcHJvZ3Jlc3MtYmFyLFxcbiAgbWQtcHJvZ3Jlc3MtY2lyY2xlLFxcbiAgbWQtcHNldWRvLWNoZWNrYm94LFxcbiAgbWQtcmFkaW8tYnV0dG9uLFxcbiAgbWQtcmFkaW8tZ3JvdXAsXFxuICBtZC1zZWxlY3QsXFxuICBtZC1zaWRlbmF2LFxcbiAgbWQtc2lkZW5hdi1jb250YWluZXIsXFxuICBtZC1zbGlkZXIsXFxuICBtZC1zcGlubmVyLFxcbiAgbWQtdGFiLFxcbiAgbWQtdGFiLWJvZHksXFxuICBtZC10YWItaGVhZGVyLFxcbiAgbWQtdGFiLWdyb3VwLFxcbiAgbWQtdG9vbGJhclwiO1xuLyoqIERpcmVjdGl2ZSB0aGF0IGVuZm9yY2VzIHRoYXQgdGhlIGBtYXQtYCBwcmVmaXggY2Fubm90IGJlIHVzZWQuICovXG52YXIgTWF0UHJlZml4UmVqZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdFByZWZpeFJlamVjdG9yKGlzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgaWYgKCFpc0NvbXBhdGliaWxpdHlNb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIFwibWF0LVwiIHByZWZpeCBjYW5ub3QgYmUgdXNlZCBvdXQgb2YgbmctbWF0ZXJpYWwgdjEgY29tcGF0aWJpbGl0eSBtb2RlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hdFByZWZpeFJlamVjdG9yID0gX19kZWNvcmF0ZSQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogTUFUX0VMRU1FTlRTX1NFTEVDVE9SIH0pLFxuICAgICAgICBfX3BhcmFtKDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0oMCwgX2FuZ3VsYXJfY29yZS5JbmplY3QoTUFURVJJQUxfQ09NUEFUSUJJTElUWV9NT0RFKSksIFxuICAgICAgICBfX21ldGFkYXRhJDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0Jvb2xlYW5dKVxuICAgIF0sIE1hdFByZWZpeFJlamVjdG9yKTtcbiAgICByZXR1cm4gTWF0UHJlZml4UmVqZWN0b3I7XG59KCkpO1xuLyoqIERpcmVjdGl2ZSB0aGF0IGVuZm9yY2VzIHRoYXQgdGhlIGBtZC1gIHByZWZpeCBjYW5ub3QgYmUgdXNlZC4gKi9cbnZhciBNZFByZWZpeFJlamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByZWZpeFJlamVjdG9yKGlzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgaWYgKGlzQ29tcGF0aWJpbGl0eU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdUaGUgXCJtZC1cIiBwcmVmaXggY2Fubm90IGJlIHVzZWQgaW4gbmctbWF0ZXJpYWwgdjEgY29tcGF0aWJpbGl0eSBtb2RlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1kUHJlZml4UmVqZWN0b3IgPSBfX2RlY29yYXRlJDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiBNRF9FTEVNRU5UU19TRUxFQ1RPUiB9KSxcbiAgICAgICAgX19wYXJhbSgwLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtKDAsIF9hbmd1bGFyX2NvcmUuSW5qZWN0KE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtCb29sZWFuXSlcbiAgICBdLCBNZFByZWZpeFJlamVjdG9yKTtcbiAgICByZXR1cm4gTWRQcmVmaXhSZWplY3Rvcjtcbn0oKSk7XG4vKipcbiAqIE1vZHVsZSB0aGF0IGVuZm9yY2VzIHRoZSBkZWZhdWx0IGNvbXBhdGliaWxpdHkgbW9kZSBzZXR0aW5ncy4gV2hlbiB0aGlzIG1vZHVsZSBpcyBsb2FkZWRcbiAqIHdpdGhvdXQgTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUgYWxzbyBiZWluZyBpbXBvcnRlZCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZlxuICogdGhlcmUgYXJlIGFueSB1c2VzIG9mIHRoZSBgbWF0LWAgcHJlZml4LlxuICovXG52YXIgQ29tcGF0aWJpbGl0eU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGF0aWJpbGl0eU1vZHVsZSgpIHtcbiAgICB9XG4gICAgQ29tcGF0aWJpbGl0eU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IENvbXBhdGliaWxpdHlNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29tcGF0aWJpbGl0eU1vZHVsZSA9IF9fZGVjb3JhdGUkMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWF0UHJlZml4UmVqZWN0b3IsIE1kUHJlZml4UmVqZWN0b3JdLFxuICAgICAgICAgICAgZXhwb3J0czogW01hdFByZWZpeFJlamVjdG9yLCBNZFByZWZpeFJlamVjdG9yXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgQ29tcGF0aWJpbGl0eU1vZHVsZSk7XG4gICAgcmV0dXJuIENvbXBhdGliaWxpdHlNb2R1bGU7XG59KCkpO1xuLyoqXG4gKiBNb2R1bGUgdGhhdCBlbmZvcmNlcyBcIm5vLWNvbmZsaWN0XCIgY29tcGF0aWJpbGl0eSBtb2RlIHNldHRpbmdzLiBXaGVuIHRoaXMgbW9kdWxlIGlzIGxvYWRlZCxcbiAqIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSB1c2VzIG9mIHRoZSBgbWQtYCBwcmVmaXguXG4gKi9cbnZhciBOb0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gICAgfVxuICAgIE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlID0gX19kZWNvcmF0ZSQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSwgdXNlVmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlKTtcbiAgICByZXR1cm4gTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogU2hhcmVkIGRpcmVjdGl2ZSB0byBjb3VudCBsaW5lcyBpbnNpZGUgYSB0ZXh0IGFyZWEsIHN1Y2ggYXMgYSBsaXN0IGl0ZW0uXG4gKiBMaW5lIGVsZW1lbnRzIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBhIEBDb250ZW50Q2hpbGRyZW4oTWRMaW5lKSBxdWVyeSwgdGhlblxuICogY291bnRlZCBieSBjaGVja2luZyB0aGUgcXVlcnkgbGlzdCdzIGxlbmd0aC5cbiAqL1xudmFyIE1kTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaW5lKCkge1xuICAgIH1cbiAgICBNZExpbmUgPSBfX2RlY29yYXRlJDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1saW5lXSwgW21hdC1saW5lXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbGluZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaW5lKTtcbiAgICByZXR1cm4gTWRMaW5lO1xufSgpKTtcbi8qKlxuICogSGVscGVyIHRoYXQgdGFrZXMgYSBxdWVyeSBsaXN0IG9mIGxpbmVzIGFuZCBzZXRzIHRoZSBjb3JyZWN0IGNsYXNzIG9uIHRoZSBob3N0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRMaW5lU2V0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpbmVTZXR0ZXIoX2xpbmVzLCBfcmVuZGVyZXIsIF9lbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gX2xpbmVzO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9zZXRMaW5lQ2xhc3ModGhpcy5fbGluZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fbGluZXMuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3NldExpbmVDbGFzcyhfdGhpcy5fbGluZXMubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE1kTGluZVNldHRlci5wcm90b3R5cGUuX3NldExpbmVDbGFzcyA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICB0aGlzLl9yZXNldENsYXNzZXMoKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAyIHx8IGNvdW50ID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDbGFzcyhcIm1hdC1cIiArIGNvdW50ICsgXCItbGluZVwiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3VudCA+IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENsYXNzKFwibWF0LW11bHRpLWxpbmVcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kTGluZVNldHRlci5wcm90b3R5cGUuX3Jlc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0Q2xhc3MoJ21hdC0yLWxpbmUnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldENsYXNzKCdtYXQtMy1saW5lJywgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRDbGFzcygnbWF0LW11bHRpLWxpbmUnLCBmYWxzZSk7XG4gICAgfTtcbiAgICBNZExpbmVTZXR0ZXIucHJvdG90eXBlLl9zZXRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGJvb2wpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lLCBib29sKTtcbiAgICB9O1xuICAgIHJldHVybiBNZExpbmVTZXR0ZXI7XG59KCkpO1xudmFyIE1kTGluZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaW5lTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZExpbmVNb2R1bGUgPSBfX2RlY29yYXRlJDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZExpbmUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRMaW5lXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaW5lTW9kdWxlKTtcbiAgICByZXR1cm4gTWRMaW5lTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIERpcmVjdGl2ZSB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgb2YgZGlyZWN0aW9uIG9mIHBhcnQgb2YgdGhlIERPTS5cbiAqXG4gKiBBcHBsaWNhdGlvbnMgc2hvdWxkIHVzZSB0aGlzIGRpcmVjdGl2ZSBpbnN0ZWFkIG9mIHRoZSBuYXRpdmUgYXR0cmlidXRlIHNvIHRoYXQgTWF0ZXJpYWxcbiAqIGNvbXBvbmVudHMgY2FuIGxpc3RlbiBvbiBjaGFuZ2VzIG9mIGRpcmVjdGlvbi5cbiAqL1xudmFyIERpciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlyKCkge1xuICAgICAgICAvKiogTGF5b3V0IGRpcmVjdGlvbiBvZiB0aGUgZWxlbWVudC4gKi9cbiAgICAgICAgdGhpcy5fZGlyID0gJ2x0cic7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGRpcmVjdGlvbiBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLmRpckNoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyLnByb3RvdHlwZSwgXCJkaXJcIiwge1xuICAgICAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLl9kaXI7XG4gICAgICAgICAgICB0aGlzLl9kaXIgPSB2O1xuICAgICAgICAgICAgaWYgKG9sZCAhPSB0aGlzLl9kaXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpckNoYW5nZS5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqIEN1cnJlbnQgbGF5b3V0IGRpcmVjdGlvbiBvZiB0aGUgZWxlbWVudC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLmRpciA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2RpcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBEaXIucHJvdG90eXBlLCBcIl9kaXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBEaXIucHJvdG90eXBlLCBcImRpckNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksIFxuICAgICAgICBfX21ldGFkYXRhJDMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIERpci5wcm90b3R5cGUsIFwiZGlyXCIsIG51bGwpO1xuICAgIERpciA9IF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Rpcl0nLFxuICAgICAgICAgICAgLy8gVE9ETyhoYW5zbCk6IG1heWJlIGAkaW1wbGljaXRgIGlzbid0IHRoZSBiZXN0IG9wdGlvbiBoZXJlLCBidXQgZm9yIG5vdyB0aGF0J3MgdGhlIGJlc3Qgd2UgZ290LlxuICAgICAgICAgICAgZXhwb3J0QXM6ICckaW1wbGljaXQnXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIERpcik7XG4gICAgcmV0dXJuIERpcjtcbn0oKSk7XG52YXIgUnRsTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSdGxNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIFJ0bE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFJ0bE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFJ0bE1vZHVsZSA9IF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW0Rpcl0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtEaXJdXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIFJ0bE1vZHVsZSk7XG4gICAgcmV0dXJuIFJ0bE1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgdGhhdCB0cmlnZ2VycyBhIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBjb250ZW50IG9mXG4gKiBpdHMgYXNzb2NpYXRlZCBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG52YXIgT2JzZXJ2ZUNvbnRlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVDb250ZW50KF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgZm9yIGVhY2ggY2hhbmdlIGluIHRoZSBlbGVtZW50J3MgY29udGVudC4gKi9cbiAgICAgICAgdGhpcy5ldmVudCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYnNlcnZlQ29udGVudC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHsgcmV0dXJuIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmV2ZW50LmVtaXQoKTsgfSk7IH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwge1xuICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZlQ29udGVudC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgnY2RrT2JzZXJ2ZUNvbnRlbnQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgT2JzZXJ2ZUNvbnRlbnQucHJvdG90eXBlLCBcImV2ZW50XCIsIHZvaWQgMCk7XG4gICAgT2JzZXJ2ZUNvbnRlbnQgPSBfX2RlY29yYXRlJDQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtPYnNlcnZlQ29udGVudF0nXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE9ic2VydmVDb250ZW50KTtcbiAgICByZXR1cm4gT2JzZXJ2ZUNvbnRlbnQ7XG59KCkpO1xudmFyIE9ic2VydmVDb250ZW50TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlQ29udGVudE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgT2JzZXJ2ZUNvbnRlbnRNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBPYnNlcnZlQ29udGVudE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE9ic2VydmVDb250ZW50TW9kdWxlID0gX19kZWNvcmF0ZSQ0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBleHBvcnRzOiBbT2JzZXJ2ZUNvbnRlbnRdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbT2JzZXJ2ZUNvbnRlbnRdXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE9ic2VydmVDb250ZW50TW9kdWxlKTtcbiAgICByZXR1cm4gT2JzZXJ2ZUNvbnRlbnRNb2R1bGU7XG59KCkpO1xuXG4vLyBEdWUgdG8gYSBidWcgaW4gdGhlIENocm9tZURyaXZlciwgQW5ndWxhciBrZXlib2FyZCBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgYnkgYHNlbmRLZXlzYFxuLy8gZHVyaW5nIEUyRSB0ZXN0cyB3aGVuIHVzaW5nIGRvdCBub3RhdGlvbiBzdWNoIGFzIGAoa2V5ZG93bi5yaWdodEFycm93KWAuIFRvIGdldCBhcm91bmQgdGhpcyxcbi8vIHdlIGFyZSB0ZW1wb3JhcmlseSB1c2luZyBhIHNpbmdsZSAoa2V5ZG93bikgaGFuZGxlci5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvOTQxOVxudmFyIFVQX0FSUk9XID0gMzg7XG52YXIgRE9XTl9BUlJPVyA9IDQwO1xudmFyIFJJR0hUX0FSUk9XID0gMzk7XG52YXIgTEVGVF9BUlJPVyA9IDM3O1xudmFyIFBBR0VfVVAgPSAzMztcbnZhciBQQUdFX0RPV04gPSAzNDtcbnZhciBIT01FID0gMzY7XG52YXIgRU5EID0gMzU7XG52YXIgRU5URVIgPSAxMztcbnZhciBTUEFDRSA9IDMyO1xudmFyIFRBQiA9IDk7XG52YXIgRVNDQVBFID0gMjc7XG52YXIgQkFDS1NQQUNFID0gODtcbnZhciBERUxFVEUgPSA0NjtcblxuLyoqIENvZXJjZXMgYSBkYXRhLWJvdW5kIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcpIHRvIGEgYm9vbGVhbi4gKi9cbmZ1bmN0aW9uIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIFwiXCIgKyB2YWx1ZSAhPT0gJ2ZhbHNlJztcbn1cblxuLyoqIEZhZGUtaW4gc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQuIENhbiBiZSBtb2RpZmllZCB3aXRoIHRoZSBzcGVlZEZhY3RvciBvcHRpb24uICovXG52YXIgUklQUExFX1NQRUVEX1BYX1BFUl9TRUNPTkQgPSAxNzA7XG4vKiogRmFkZS1vdXQgc3BlZWQgZm9yIHRoZSByaXBwbGVzIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBjYW4ndCBiZSBtb2RpZmllZCBieSB0aGUgc3BlZWRGYWN0b3IuICovXG52YXIgUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OID0gNjAwO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCAoeCwgeSkgdG8gdGhlIGZ1cnRoZXN0IGNvcm5lciBvZiBhIHJlY3RhbmdsZS5cbiAqL1xudmFyIGRpc3RhbmNlVG9GdXJ0aGVzdENvcm5lciA9IGZ1bmN0aW9uICh4LCB5LCByZWN0KSB7XG4gICAgdmFyIGRpc3RYID0gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHJlY3QubGVmdCksIE1hdGguYWJzKHggLSByZWN0LnJpZ2h0KSk7XG4gICAgdmFyIGRpc3RZID0gTWF0aC5tYXgoTWF0aC5hYnMoeSAtIHJlY3QudG9wKSwgTWF0aC5hYnMoeSAtIHJlY3QuYm90dG9tKSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChkaXN0WCAqIGRpc3RYICsgZGlzdFkgKiBkaXN0WSk7XG59O1xuLyoqXG4gKiBIZWxwZXIgc2VydmljZSB0aGF0IHBlcmZvcm1zIERPTSBtYW5pcHVsYXRpb25zLiBOb3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuICogVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgZGlyZWN0aXZlJ3MgaG9zdCBlbGVtZW50IGFuZCBhIG1hcCBvZiBET01cbiAqIGV2ZW50IGhhbmRsZXJzIHRvIGJlIGluc3RhbGxlZCBvbiB0aGUgZWxlbWVudCB0aGF0IHRyaWdnZXJzIHJpcHBsZSBhbmltYXRpb25zLlxuICogVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGEgY3VzdG9tIHJlbmRlcmVyIG9uY2UgQW5ndWxhciBzdXBwb3J0IGV4aXN0cy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFJpcHBsZVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSaXBwbGVSZW5kZXJlcihfZWxlbWVudFJlZiwgX25nWm9uZSwgX3J1bGVyKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX3J1bGVyID0gX3J1bGVyO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IGRvd24gb3Igbm90LiAqL1xuICAgICAgICB0aGlzLl9pc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudGx5IGFjdGl2ZSByaXBwbGVzIHRoYXQgd2lsbCBiZSBjbG9zZWQgb24gbW91c2V1cC4gKi9cbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcyA9IFtdO1xuICAgICAgICAvKiogRXZlbnRzIHRvIGJlIHJlZ2lzdGVyZWQgb24gdGhlIHRyaWdnZXIgZWxlbWVudC4gKi9cbiAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIFJpcHBsZSBjb25maWcgZm9yIGFsbCByaXBwbGVzIGNyZWF0ZWQgYnkgZXZlbnRzLiAqL1xuICAgICAgICB0aGlzLnJpcHBsZUNvbmZpZyA9IHt9O1xuICAgICAgICAvKiogV2hldGhlciBtb3VzZSByaXBwbGVzIHNob3VsZCBiZSBjcmVhdGVkIG9yIG5vdC4gKi9cbiAgICAgICAgdGhpcy5yaXBwbGVEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gU3BlY2lmeSBldmVudHMgd2hpY2ggbmVlZCB0byBiZSByZWdpc3RlcmVkIG9uIHRoZSB0cmlnZ2VyLlxuICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnRzLnNldCgnbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cy5zZXQoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cy5zZXQoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCB1c2UgdGhlIGhvc3QgZWxlbWVudCBhcyB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuc2V0VHJpZ2dlckVsZW1lbnQodGhpcy5fY29udGFpbmVyRWxlbWVudCk7XG4gICAgfVxuICAgIC8qKiBGYWRlcyBpbiBhIHJpcHBsZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLmZhZGVJblJpcHBsZSA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVksIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSB0aGlzLl9jb250YWluZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoY29uZmlnLmNlbnRlcmVkKSB7XG4gICAgICAgICAgICBwYWdlWCA9IGNvbnRhaW5lclJlY3QubGVmdCArIGNvbnRhaW5lclJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgcGFnZVkgPSBjb250YWluZXJSZWN0LnRvcCArIGNvbnRhaW5lclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHNjcm9sbCB2YWx1ZXMgZnJvbSB0aGUgY29vcmRpbmF0ZXMgYmVjYXVzZSBjYWxjdWxhdGlvbnMgYmVsb3dcbiAgICAgICAgICAgIC8vIGFyZSBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IHJlY3RhbmdsZS5cbiAgICAgICAgICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3J1bGVyLmdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHBhZ2VYIC09IHNjcm9sbFBvc2l0aW9uLmxlZnQ7XG4gICAgICAgICAgICBwYWdlWSAtPSBzY3JvbGxQb3NpdGlvbi50b3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhZGl1cyA9IGNvbmZpZy5yYWRpdXMgfHwgZGlzdGFuY2VUb0Z1cnRoZXN0Q29ybmVyKHBhZ2VYLCBwYWdlWSwgY29udGFpbmVyUmVjdCk7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDEgLyAoY29uZmlnLnNwZWVkRmFjdG9yIHx8IDEpICogKHJhZGl1cyAvIFJJUFBMRV9TUEVFRF9QWF9QRVJfU0VDT05EKTtcbiAgICAgICAgdmFyIG9mZnNldFggPSBwYWdlWCAtIGNvbnRhaW5lclJlY3QubGVmdDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBwYWdlWSAtIGNvbnRhaW5lclJlY3QudG9wO1xuICAgICAgICB2YXIgcmlwcGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdtYXQtcmlwcGxlLWVsZW1lbnQnKTtcbiAgICAgICAgcmlwcGxlLnN0eWxlLmxlZnQgPSAob2Zmc2V0WCAtIHJhZGl1cykgKyBcInB4XCI7XG4gICAgICAgIHJpcHBsZS5zdHlsZS50b3AgPSAob2Zmc2V0WSAtIHJhZGl1cykgKyBcInB4XCI7XG4gICAgICAgIHJpcHBsZS5zdHlsZS5oZWlnaHQgPSByYWRpdXMgKiAyICsgXCJweFwiO1xuICAgICAgICByaXBwbGUuc3R5bGUud2lkdGggPSByYWRpdXMgKiAyICsgXCJweFwiO1xuICAgICAgICAvLyBJZiB0aGUgY29sb3IgaXMgbm90IHNldCwgdGhlIGRlZmF1bHQgQ1NTIGNvbG9yIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgcmlwcGxlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5jb2xvcjtcbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uICsgXCJzXCI7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQocmlwcGxlKTtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCB0aGUgYnJvd3NlciBkb2VzIG5vdCByZWNhbGN1bGF0ZSB0aGUgc3R5bGVzIG9mIGR5bmFtaWNhbGx5IGNyZWF0ZWRcbiAgICAgICAgLy8gcmlwcGxlIGVsZW1lbnRzLiBUaGlzIGlzIGNyaXRpY2FsIGJlY2F1c2UgdGhlbiB0aGUgYHNjYWxlYCB3b3VsZCBub3QgYW5pbWF0ZSBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5fZW5mb3JjZVN0eWxlUmVjYWxjdWxhdGlvbihyaXBwbGUpO1xuICAgICAgICByaXBwbGUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHJpcHBsZSB0byBiZSBmYWRlZCBpbi4gT25jZSBpdCdzIGZhZGVkIGluLCB0aGUgcmlwcGxlIGNhbiBiZSBoaWRkZW4gaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gaWYgdGhlIG1vdXNlIGlzIHJlbGVhc2VkLlxuICAgICAgICB0aGlzLnJ1blRpbWVvdXRPdXRzaWRlWm9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5faXNNb3VzZWRvd24gPyBfdGhpcy5fYWN0aXZlUmlwcGxlcy5wdXNoKHJpcHBsZSkgOiBfdGhpcy5mYWRlT3V0UmlwcGxlKHJpcHBsZSk7XG4gICAgICAgIH0sIGR1cmF0aW9uICogMTAwMCk7XG4gICAgfTtcbiAgICAvKiogRmFkZXMgb3V0IGEgcmlwcGxlIGVsZW1lbnQuICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLmZhZGVPdXRSaXBwbGUgPSBmdW5jdGlvbiAocmlwcGxlKSB7XG4gICAgICAgIHJpcHBsZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBSSVBQTEVfRkFERV9PVVRfRFVSQVRJT04gKyBcIm1zXCI7XG4gICAgICAgIHJpcHBsZS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAvLyBPbmNlIHRoZSByaXBwbGUgZmFkZWQgb3V0LCB0aGUgcmlwcGxlIGNhbiBiZSBzYWZlbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAgICAgIHRoaXMucnVuVGltZW91dE91dHNpZGVab25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJpcHBsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJpcHBsZSk7XG4gICAgICAgIH0sIFJJUFBMRV9GQURFX09VVF9EVVJBVElPTik7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgdHJpZ2dlciBlbGVtZW50IGFuZCByZWdpc3RlcnMgdGhlIG1vdXNlIGV2ZW50cy4gKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUuc2V0VHJpZ2dlckVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBSZW1vdmUgYWxsIHByZXZpb3VzbHkgcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIHRyaWdnZXIgZWxlbWVudC5cbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGZuLCB0eXBlKSB7IHJldHVybiBfdGhpcy5fdHJpZ2dlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgbnVsbCwgcmVnaXN0ZXIgYWxsIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmbiwgdHlwZSkgeyByZXR1cm4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqIExpc3RlbmVyIGJlaW5nIGNhbGxlZCBvbiBtb3VzZWRvd24gZXZlbnQuICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLm9uTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJpcHBsZURpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLmZhZGVJblJpcHBsZShldmVudC5wYWdlWCwgZXZlbnQucGFnZVksIHRoaXMucmlwcGxlQ29uZmlnKTtcbiAgICB9O1xuICAgIC8qKiBMaXN0ZW5lciBiZWluZyBjYWxsZWQgb24gbW91c2V1cCBldmVudC4gKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUub25Nb3VzZXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9pc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hY3RpdmVSaXBwbGVzLmZvckVhY2goZnVuY3Rpb24gKHJpcHBsZSkgeyByZXR1cm4gX3RoaXMuZmFkZU91dFJpcHBsZShyaXBwbGUpOyB9KTtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcyA9IFtdO1xuICAgIH07XG4gICAgLyoqIExpc3RlbmVyIGJlaW5nIGNhbGxlZCBvbiBtb3VzZWxlYXZlIGV2ZW50LiAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc01vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNldXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFJ1bnMgYSB0aW1lb3V0IG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZSB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uLiAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5ydW5UaW1lb3V0T3V0c2lkZVpvbmUgPSBmdW5jdGlvbiAoZm4sIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0VGltZW91dChmbiwgZGVsYXkpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBFbmZvcmNlcyBhIHN0eWxlIHJlY2FsY3VsYXRpb24gb2YgYSBET00gZWxlbWVudCBieSBjb21wdXRpbmcgaXRzIHN0eWxlcy4gKi9cbiAgICAvLyBUT0RPKGRldnZlcnNpb24pOiBNb3ZlIGludG8gZ2xvYmFsIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLl9lbmZvcmNlU3R5bGVSZWNhbGN1bGF0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gRW5mb3JjZSBhIHN0eWxlIHJlY2FsY3VsYXRpb24gYnkgY2FsbGluZyBgZ2V0Q29tcHV0ZWRTdHlsZWAgYW5kIGFjY2Vzc2luZyBhbnkgcHJvcGVydHkuXG4gICAgICAgIC8vIENhbGxpbmcgYGdldFByb3BlcnR5VmFsdWVgIGlzIGltcG9ydGFudCB0byBsZXQgb3B0aW1pemVycyBrbm93IHRoYXQgdGhpcyBpcyBub3QgYSBub29wLlxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYVxuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdvcGFjaXR5Jyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmlwcGxlUmVuZGVyZXI7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBUaW1lIGluIG1zIHRvIHRocm90dGxlIHRoZSBzY3JvbGxpbmcgZXZlbnRzIGJ5IGRlZmF1bHQuICovXG52YXIgREVGQVVMVF9TQ1JPTExfVElNRSA9IDIwO1xuLyoqXG4gKiBTZXJ2aWNlIGNvbnRhaW5lZCBhbGwgcmVnaXN0ZXJlZCBTY3JvbGxhYmxlIHJlZmVyZW5jZXMgYW5kIGVtaXRzIGFuIGV2ZW50IHdoZW4gYW55IG9uZSBvZiB0aGVcbiAqIFNjcm9sbGFibGUgcmVmZXJlbmNlcyBlbWl0IGEgc2Nyb2xsZWQgZXZlbnQuXG4gKi9cbnZhciBTY3JvbGxEaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxEaXNwYXRjaGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoYXQgYSByZWdpc3RlcmVkIHNjcm9sbGFibGUgcmVmZXJlbmNlIGVsZW1lbnQgaGFzIGJlZW4gc2Nyb2xsZWQuICovXG4gICAgICAgIHRoaXMuX3Njcm9sbGVkID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgYWxsIHRoZSBzY3JvbGxhYmxlIHJlZmVyZW5jZXMgdGhhdCBhcmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBzZXJ2aWNlIGFuZCB0aGVpclxuICAgICAgICAgKiBzY3JvbGwgZXZlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIG5vdGlmeSBhIHNjcm9sbCBldmVudCB3aGVuIHRoZSBkb2N1bWVudCBpcyBzY3JvbGxlZCBvciB0aGUgd2luZG93IGlzIHJlc2l6ZWQuXG4gICAgICAgIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3cuZG9jdW1lbnQsICdzY3JvbGwnKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX25vdGlmeSgpOyB9KTtcbiAgICAgICAgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUuZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbm90aWZ5KCk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBTY3JvbGxhYmxlIHdpdGggdGhlIHNlcnZpY2UgYW5kIGxpc3RlbnMgZm9yIGl0cyBzY3JvbGxlZCBldmVudHMuIFdoZW4gdGhlXG4gICAgICogc2Nyb2xsYWJsZSBpcyBzY3JvbGxlZCwgdGhlIHNlcnZpY2UgZW1pdHMgdGhlIGV2ZW50IGluIGl0cyBzY3JvbGxlZCBvYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjcm9sbGFibGUgU2Nyb2xsYWJsZSBpbnN0YW5jZSB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIFNjcm9sbERpc3BhdGNoZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHNjcm9sbGFibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNjcm9sbFN1YnNjcmlwdGlvbiA9IHNjcm9sbGFibGUuZWxlbWVudFNjcm9sbGVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9ub3RpZnkoKTsgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuc2V0KHNjcm9sbGFibGUsIHNjcm9sbFN1YnNjcmlwdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXJlZ2lzdGVycyBhIFNjcm9sbGFibGUgcmVmZXJlbmNlIGFuZCB1bnN1YnNjcmliZXMgZnJvbSBpdHMgc2Nyb2xsIGV2ZW50IG9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Nyb2xsYWJsZSBTY3JvbGxhYmxlIGluc3RhbmNlIHRvIGJlIGRlcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5kZXJlZ2lzdGVyID0gZnVuY3Rpb24gKHNjcm9sbGFibGUpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5nZXQoc2Nyb2xsYWJsZSkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5kZWxldGUoc2Nyb2xsYWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBldmVudCB3aGVuZXZlciBhbnkgb2YgdGhlIHJlZ2lzdGVyZWQgU2Nyb2xsYWJsZVxuICAgICAqIHJlZmVyZW5jZXMgKG9yIHdpbmRvdywgZG9jdW1lbnQsIG9yIGJvZHkpIGZpcmUgYSBzY3JvbGxlZCBldmVudC4gQ2FuIHByb3ZpZGUgYSB0aW1lIGluIG1zXG4gICAgICogdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgXCJ0aHJvdHRsZVwiIHRpbWUuXG4gICAgICovXG4gICAgU2Nyb2xsRGlzcGF0Y2hlci5wcm90b3R5cGUuc2Nyb2xsZWQgPSBmdW5jdGlvbiAoYXVkaXRUaW1lSW5Ncykge1xuICAgICAgICBpZiAoYXVkaXRUaW1lSW5NcyA9PT0gdm9pZCAwKSB7IGF1ZGl0VGltZUluTXMgPSBERUZBVUxUX1NDUk9MTF9USU1FOyB9XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgMG1zIGRlbGF5LCByZXR1cm4gdGhlIG9ic2VydmFibGUgd2l0aG91dCBhdWRpdFRpbWUgc2luY2UgaXQgZG9lcyBhZGRcbiAgICAgICAgLy8gYSBwZXJjZXB0aWJsZSBkZWxheSBpbiBwcm9jZXNzaW5nIG92ZXJoZWFkLlxuICAgICAgICBpZiAoYXVkaXRUaW1lSW5NcyA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsZWQuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbGVkLmFzT2JzZXJ2YWJsZSgpLmF1ZGl0VGltZShhdWRpdFRpbWVJbk1zKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFsbCByZWdpc3RlcmVkIFNjcm9sbGFibGVzIHRoYXQgY29udGFpbiB0aGUgcHJvdmlkZWQgZWxlbWVudC4gKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5nZXRTY3JvbGxDb250YWluZXJzID0gZnVuY3Rpb24gKGVsZW1lbnRSZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNjcm9sbGluZ0NvbnRhaW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlUmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpcHRpb24sIHNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY3JvbGxhYmxlQ29udGFpbnNFbGVtZW50KHNjcm9sbGFibGUsIGVsZW1lbnRSZWYpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsaW5nQ29udGFpbmVycy5wdXNoKHNjcm9sbGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbGluZ0NvbnRhaW5lcnM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIFNjcm9sbGFibGUuICovXG4gICAgU2Nyb2xsRGlzcGF0Y2hlci5wcm90b3R5cGUuc2Nyb2xsYWJsZUNvbnRhaW5zRWxlbWVudCA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgc2Nyb2xsYWJsZUVsZW1lbnQgPSBzY3JvbGxhYmxlLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBUcmF2ZXJzZSB0aHJvdWdoIHRoZSBlbGVtZW50IHBhcmVudHMgdW50aWwgd2UgcmVhY2ggbnVsbCwgY2hlY2tpbmcgaWYgYW55IG9mIHRoZSBlbGVtZW50c1xuICAgICAgICAvLyBhcmUgdGhlIHNjcm9sbGFibGUncyBlbGVtZW50LlxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PSBzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKiBTZW5kcyBhIG5vdGlmaWNhdGlvbiB0aGF0IGEgc2Nyb2xsIGV2ZW50IGhhcyBiZWVuIGZpcmVkLiAqL1xuICAgIFNjcm9sbERpc3BhdGNoZXIucHJvdG90eXBlLl9ub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbGVkLm5leHQoKTtcbiAgICB9O1xuICAgIFNjcm9sbERpc3BhdGNoZXIgPSBfX2RlY29yYXRlJDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBTY3JvbGxEaXNwYXRjaGVyKTtcbiAgICByZXR1cm4gU2Nyb2xsRGlzcGF0Y2hlcjtcbn0oKSk7XG5mdW5jdGlvbiBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIpIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgU2Nyb2xsRGlzcGF0Y2hlcigpO1xufVxudmFyIFNDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBTY3JvbGxEaXNwYXRjaGVyIGF2YWlsYWJsZSwgdXNlIHRoYXQuIE90aGVyd2lzZSwgcHJvdmlkZSBhIG5ldyBvbmUuXG4gICAgcHJvdmlkZTogU2Nyb2xsRGlzcGF0Y2hlcixcbiAgICBkZXBzOiBbW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLlNraXBTZWxmKCksIFNjcm9sbERpc3BhdGNoZXJdXSxcbiAgICB1c2VGYWN0b3J5OiBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuXG52YXIgX19kZWNvcmF0ZSQ3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogU2ltcGxlIHV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIGJvdW5kcyBvZiB0aGUgYnJvd3NlciB2aWV3cG9ydC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFZpZXdwb3J0UnVsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdwb3J0UnVsZXIoc2Nyb2xsRGlzcGF0Y2hlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJbml0aWFsbHkgY2FjaGUgdGhlIGRvY3VtZW50IHJlY3RhbmdsZS5cbiAgICAgICAgdGhpcy5fY2FjaGVWaWV3cG9ydEdlb21ldHJ5KCk7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgcmVjdGFuZ2xlIG9uIGNoYW5nZXMuXG4gICAgICAgIHNjcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NhY2hlVmlld3BvcnRHZW9tZXRyeSgpOyB9KTtcbiAgICB9XG4gICAgLyoqIEdldHMgYSBDbGllbnRSZWN0IGZvciB0aGUgdmlld3BvcnQncyBib3VuZHMuICovXG4gICAgVmlld3BvcnRSdWxlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRSZWN0ID0gZnVuY3Rpb24gKGRvY3VtZW50UmVjdCkge1xuICAgICAgICBpZiAoZG9jdW1lbnRSZWN0ID09PSB2b2lkIDApIHsgZG9jdW1lbnRSZWN0ID0gdGhpcy5fZG9jdW1lbnRSZWN0OyB9XG4gICAgICAgIC8vIFVzZSB0aGUgZG9jdW1lbnQgZWxlbWVudCdzIGJvdW5kaW5nIHJlY3QgcmF0aGVyIHRoYW4gdGhlIHdpbmRvdyBzY3JvbGwgcHJvcGVydGllc1xuICAgICAgICAvLyAoZS5nLiBwYWdlWU9mZnNldCwgc2Nyb2xsWSkgZHVlIHRvIGluIGlzc3VlIGluIENocm9tZSBhbmQgSUUgd2hlcmUgd2luZG93IHNjcm9sbFxuICAgICAgICAvLyBwcm9wZXJ0aWVzIGFuZCBjbGllbnQgY29vcmRpbmF0ZXMgKGJvdW5kaW5nQ2xpZW50UmVjdCwgY2xpZW50WC9ZLCBldGMuKSBhcmUgaW4gZGlmZmVyZW50XG4gICAgICAgIC8vIGNvbmNlcHR1YWwgdmlld3BvcnRzLiBVbmRlciBtb3N0IGNpcmN1bXN0YW5jZXMgdGhlc2Ugdmlld3BvcnRzIGFyZSBlcXVpdmFsZW50LCBidXQgdGhleVxuICAgICAgICAvLyBjYW4gZGlzYWdyZWUgd2hlbiB0aGUgcGFnZSBpcyBwaW5jaC16b29tZWQgKG9uIGRldmljZXMgdGhhdCBzdXBwb3J0IHRvdWNoKS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ4OTIwNiNjNFxuICAgICAgICAvLyBXZSB1c2UgdGhlIGRvY3VtZW50RWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBib2R5IGJlY2F1c2UsIGJ5IGRlZmF1bHQgKHdpdGhvdXQgYSBjc3MgcmVzZXQpXG4gICAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBnaXZlIHRoZSBkb2N1bWVudCBib2R5IGFuIDhweCBtYXJnaW4sIHdoaWNoIGlzIG5vdCBpbmNsdWRlZCBpblxuICAgICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5cbiAgICAgICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKGRvY3VtZW50UmVjdCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBzY3JvbGxQb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBsZWZ0OiBzY3JvbGxQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgYm90dG9tOiBzY3JvbGxQb3NpdGlvbi50b3AgKyBoZWlnaHQsXG4gICAgICAgICAgICByaWdodDogc2Nyb2xsUG9zaXRpb24ubGVmdCArIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSAodG9wLCBsZWZ0KSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlY3RcbiAgICAgKi9cbiAgICBWaWV3cG9ydFJ1bGVyLnByb3RvdHlwZS5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uID0gZnVuY3Rpb24gKGRvY3VtZW50UmVjdCkge1xuICAgICAgICBpZiAoZG9jdW1lbnRSZWN0ID09PSB2b2lkIDApIHsgZG9jdW1lbnRSZWN0ID0gdGhpcy5fZG9jdW1lbnRSZWN0OyB9XG4gICAgICAgIC8vIFRoZSB0b3AtbGVmdC1jb3JuZXIgb2YgdGhlIHZpZXdwb3J0IGlzIGRldGVybWluZWQgYnkgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgLy8gYm9keSwgbm9ybWFsbHkganVzdCAoc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKS4gSG93ZXZlciwgQ2hyb21lIGFuZCBGaXJlZm94IGRpc2FncmVlIGFib3V0XG4gICAgICAgIC8vIHdoZXRoZXIgYGRvY3VtZW50LmJvZHlgIG9yIGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRgIGlzIHRoZSBzY3JvbGxlZCBlbGVtZW50LCBzbyByZWFkaW5nXG4gICAgICAgIC8vIGBzY3JvbGxUb3BgIGFuZCBgc2Nyb2xsTGVmdGAgaXMgaW5jb25zaXN0ZW50LiBIb3dldmVyLCB1c2luZyB0aGUgYm91bmRpbmcgcmVjdCBvZlxuICAgICAgICAvLyBgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50YCB3b3JrcyBjb25zaXN0ZW50bHksIHdoZXJlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHZhbHVlcyB3aWxsXG4gICAgICAgIC8vIGVxdWFsIG5lZ2F0aXZlIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgIHZhciB0b3AgPSAtZG9jdW1lbnRSZWN0LnRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCB3aW5kb3cuc2Nyb2xsWSB8fCAwO1xuICAgICAgICB2YXIgbGVmdCA9IC1kb2N1bWVudFJlY3QubGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgd2luZG93LnNjcm9sbFggfHwgMDtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbiAgICB9O1xuICAgIC8qKiBDYWNoZXMgdGhlIGxhdGVzdCBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LiAqL1xuICAgIFZpZXdwb3J0UnVsZXIucHJvdG90eXBlLl9jYWNoZVZpZXdwb3J0R2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9O1xuICAgIFZpZXdwb3J0UnVsZXIgPSBfX2RlY29yYXRlJDcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbU2Nyb2xsRGlzcGF0Y2hlcl0pXG4gICAgXSwgVmlld3BvcnRSdWxlcik7XG4gICAgcmV0dXJuIFZpZXdwb3J0UnVsZXI7XG59KCkpO1xuZnVuY3Rpb24gVklFV1BPUlRfUlVMRVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnRSdWxlciwgc2Nyb2xsRGlzcGF0Y2hlcikge1xuICAgIHJldHVybiBwYXJlbnRSdWxlciB8fCBuZXcgVmlld3BvcnRSdWxlcihzY3JvbGxEaXNwYXRjaGVyKTtcbn1cbnZhciBWSUVXUE9SVF9SVUxFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgVmlld3BvcnRSdWxlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IFZpZXdwb3J0UnVsZXIsXG4gICAgZGVwczogW1tuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpLCBWaWV3cG9ydFJ1bGVyXSwgU2Nyb2xsRGlzcGF0Y2hlcl0sXG4gICAgdXNlRmFjdG9yeTogVklFV1BPUlRfUlVMRVJfUFJPVklERVJfRkFDVE9SWVxufTtcblxudmFyIF9fZGVjb3JhdGUkNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRSaXBwbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmlwcGxlKGVsZW1lbnRSZWYsIG5nWm9uZSwgcnVsZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCwgdGhlIHJhZGl1cyBpbiBwaXhlbHMgb2YgZm9yZWdyb3VuZCByaXBwbGVzIHdoZW4gZnVsbHkgZXhwYW5kZWQuIElmIHVuc2V0LCB0aGUgcmFkaXVzXG4gICAgICAgICAqIHdpbGwgYmUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgcmlwcGxlIHRvIHRoZSBmdXJ0aGVzdCBjb3JuZXIgb2YgdGhlIGhvc3QgZWxlbWVudCdzXG4gICAgICAgICAqIGJvdW5kaW5nIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFkaXVzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCwgdGhlIG5vcm1hbCBkdXJhdGlvbiBvZiByaXBwbGUgYW5pbWF0aW9ucyBpcyBkaXZpZGVkIGJ5IHRoaXMgdmFsdWUuIEZvciBleGFtcGxlLFxuICAgICAgICAgKiBzZXR0aW5nIGl0IHRvIDAuNSB3aWxsIGNhdXNlIHRoZSBhbmltYXRpb25zIHRvIHRha2UgdHdpY2UgYXMgbG9uZy5cbiAgICAgICAgICogQSBjaGFuZ2VkIHNwZWVkRmFjdG9yIHdpbGwgbm90IG1vZGlmeSB0aGUgZmFkZS1vdXQgZHVyYXRpb24gb2YgdGhlIHJpcHBsZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwZWVkRmFjdG9yID0gMTtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIgPSBuZXcgUmlwcGxlUmVuZGVyZXIoZWxlbWVudFJlZiwgbmdab25lLCBydWxlcik7XG4gICAgfVxuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWyd0cmlnZ2VyJ10gJiYgdGhpcy50cmlnZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5zZXRUcmlnZ2VyRWxlbWVudCh0aGlzLnRyaWdnZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLnJpcHBsZURpc2FibGVkID0gdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlQ29uZmlnKCk7XG4gICAgfTtcbiAgICBNZFJpcHBsZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdHJpZ2dlciBlbGVtZW50IHRvIG51bGwgdG8gY2xlYW51cCBhbGwgbGlzdGVuZXJzLlxuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5zZXRUcmlnZ2VyRWxlbWVudChudWxsKTtcbiAgICB9O1xuICAgIC8qKiBMYXVuY2hlcyBhIG1hbnVhbCByaXBwbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gKi9cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUubGF1bmNoID0gZnVuY3Rpb24gKHBhZ2VYLCBwYWdlWSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLmZhZGVJblJpcHBsZShwYWdlWCwgcGFnZVksIGNvbmZpZyk7XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgcmlwcGxlIGNvbmZpZ3VyYXRpb24gd2l0aCB0aGUgaW5wdXQgdmFsdWVzLiAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5fdXBkYXRlUmlwcGxlQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5yaXBwbGVDb25maWcgPSB7XG4gICAgICAgICAgICBjZW50ZXJlZDogdGhpcy5jZW50ZXJlZCxcbiAgICAgICAgICAgIHNwZWVkRmFjdG9yOiB0aGlzLnNwZWVkRmFjdG9yLFxuICAgICAgICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFJpcHBsZVRyaWdnZXInKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcInRyaWdnZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFJpcHBsZUNlbnRlcmVkJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFJpcHBsZS5wcm90b3R5cGUsIFwiY2VudGVyZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFJpcHBsZURpc2FibGVkJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFJpcHBsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFJpcHBsZVJhZGl1cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZFJpcHBsZS5wcm90b3R5cGUsIFwicmFkaXVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRSaXBwbGVTcGVlZEZhY3RvcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZFJpcHBsZS5wcm90b3R5cGUsIFwic3BlZWRGYWN0b3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFJpcHBsZUNvbG9yJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmlwcGxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kUmlwcGxlVW5ib3VuZGVkJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFJpcHBsZS5wcm90b3R5cGUsIFwidW5ib3VuZGVkXCIsIHZvaWQgMCk7XG4gICAgTWRSaXBwbGUgPSBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1yaXBwbGVdLCBbbWF0LXJpcHBsZV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJpcHBsZV0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcmlwcGxlLXVuYm91bmRlZF0nOiAndW5ib3VuZGVkJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLk5nWm9uZSwgVmlld3BvcnRSdWxlcl0pXG4gICAgXSwgTWRSaXBwbGUpO1xuICAgIHJldHVybiBNZFJpcHBsZTtcbn0oKSk7XG52YXIgTWRSaXBwbGVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmlwcGxlTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFJpcHBsZU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kUmlwcGxlTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRSaXBwbGVNb2R1bGUgPSBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFJpcHBsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFJpcHBsZV0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtWSUVXUE9SVF9SVUxFUl9QUk9WSURFUiwgU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFJpcHBsZU1vZHVsZSk7XG4gICAgcmV0dXJuIE1kUmlwcGxlTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIE9wdGlvbiBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG52YXIgX3VuaXF1ZUlkQ291bnRlciA9IDA7XG4vKiogRXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRPcHRpb24gd2hlbiBzZWxlY3RlZC4gKi9cbnZhciBNZE9wdGlvblNlbGVjdEV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE9wdGlvblNlbGVjdEV2ZW50KHNvdXJjZSwgaXNVc2VySW5wdXQpIHtcbiAgICAgICAgaWYgKGlzVXNlcklucHV0ID09PSB2b2lkIDApIHsgaXNVc2VySW5wdXQgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5pc1VzZXJJbnB1dCA9IGlzVXNlcklucHV0O1xuICAgIH1cbiAgICByZXR1cm4gTWRPcHRpb25TZWxlY3RFdmVudDtcbn0oKSk7XG4vKipcbiAqIFNpbmdsZSBvcHRpb24gaW5zaWRlIG9mIGEgYDxtZC1zZWxlY3Q+YCBlbGVtZW50LlxuICovXG52YXIgTWRPcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kT3B0aW9uKF9lbGVtZW50LCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBvcHRpb24gaXMgZGlzYWJsZWQuICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IFwibWQtb3B0aW9uLVwiICsgX3VuaXF1ZUlkQ291bnRlcisrO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBvcHRpb24gaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIHRoaXMub25TZWxlY3QgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKiBUaGUgdW5pcXVlIElEIG9mIHRoZSBvcHRpb24uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE9wdGlvbi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE9wdGlvbi5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIG9wdGlvbiBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRPcHRpb24ucHJvdG90eXBlLCBcImFjdGl2ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3B0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUgYW5kIHJlYWR5IHRvIGJlIHNlbGVjdGVkLlxuICAgICAgICAgKiBBbiBhY3RpdmUgb3B0aW9uIGRpc3BsYXlzIHN0eWxlcyBhcyBpZiBpdCBpcyBmb2N1c2VkLCBidXQgdGhlXG4gICAgICAgICAqIGZvY3VzIGlzIGFjdHVhbGx5IHJldGFpbmVkIHNvbWV3aGVyZSBlbHNlLiBUaGlzIGNvbWVzIGluIGhhbmR5XG4gICAgICAgICAqIGZvciBjb21wb25lbnRzIGxpa2UgYXV0b2NvbXBsZXRlIHdoZXJlIGZvY3VzIG11c3QgcmVtYWluIG9uIHRoZSBpbnB1dC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJ2aWV3VmFsdWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXllZCB2YWx1ZSBvZiB0aGUgb3B0aW9uLiBJdCBpcyBuZWNlc3NhcnkgdG8gc2hvdyB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluIHRoZVxuICAgICAgICAgKiBzZWxlY3QncyB0cmlnZ2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGthcmEpOiBBZGQgaW5wdXQgcHJvcGVydHkgYWx0ZXJuYXRpdmUgZm9yIG5vZGUgZW52cy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRIb3N0RWxlbWVudCgpLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFNlbGVjdHMgdGhlIG9wdGlvbi4gKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25TZWxlY3QuZW1pdChuZXcgTWRPcHRpb25TZWxlY3RFdmVudCh0aGlzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgLyoqIERlc2VsZWN0cyB0aGUgb3B0aW9uLiAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5kZXNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIGZvY3VzIG9udG8gdGhpcyBvcHRpb24uICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2dldEhvc3RFbGVtZW50KCksICdmb2N1cycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyBkaXNwbGF5IHN0eWxlcyBvbiB0aGUgb3B0aW9uIHRvIG1ha2UgaXQgYXBwZWFyXG4gICAgICogYWN0aXZlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIHNvIGtleVxuICAgICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgICAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5zZXRBY3RpdmVTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hY3RpdmUgPSB0cnVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgZGlzcGxheSBzdHlsZXMgb24gdGhlIG9wdGlvbiB0aGF0IG1hZGUgaXQgYXBwZWFyXG4gICAgICogYWN0aXZlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIHNvIGtleVxuICAgICAqIGV2ZW50cyB3aWxsIGRpc3BsYXkgdGhlIHByb3BlciBvcHRpb25zIGFzIGFjdGl2ZSBvbiBhcnJvdyBrZXkgZXZlbnRzLlxuICAgICAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5zZXRJbmFjdGl2ZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2FjdGl2ZSA9IGZhbHNlOyB9KTtcbiAgICB9O1xuICAgIC8qKiBFbnN1cmVzIHRoZSBvcHRpb24gaXMgc2VsZWN0ZWQgd2hlbiBhY3RpdmF0ZWQgZnJvbSB0aGUga2V5Ym9hcmQuICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLl9oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBTUEFDRSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0VmlhSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgb3B0aW9uIHdoaWxlIGluZGljYXRpbmcgdGhlIHNlbGVjdGlvbiBjYW1lIGZyb20gdGhlIHVzZXIuIFVzZWQgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCdzIHZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQuXG4gICAgICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLl9zZWxlY3RWaWFJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0LmVtaXQobmV3IE1kT3B0aW9uU2VsZWN0RXZlbnQodGhpcywgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgY29ycmVjdCB0YWJpbmRleCBmb3IgdGhlIG9wdGlvbiBkZXBlbmRpbmcgb24gZGlzYWJsZWQgc3RhdGUuICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLl9nZXRUYWJJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAnLTEnIDogJzAnO1xuICAgIH07XG4gICAgTWRPcHRpb24ucHJvdG90eXBlLl9nZXRIb3N0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRPcHRpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZE9wdGlvbi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRPcHRpb24ucHJvdG90eXBlLCBcIm9uU2VsZWN0XCIsIHZvaWQgMCk7XG4gICAgTWRPcHRpb24gPSBfX2RlY29yYXRlJDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1vcHRpb24sIG1hdC1vcHRpb24nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfZ2V0VGFiSW5kZXgoKScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgICAgICAgICAgICAgJ1tpZF0nOiAnaWQnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXNlbGVjdGVkXSc6ICdzZWxlY3RlZC50b1N0cmluZygpJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtb3B0aW9uLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJyhjbGljayknOiAnX3NlbGVjdFZpYUludGVyYWN0aW9uKCknLFxuICAgICAgICAgICAgICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtb3B0aW9uXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LW9wdGlvbi1yaXBwbGVcXFwiICpuZ0lmPVxcXCIhZGlzYWJsZWRcXFwiIG1kLXJpcHBsZSBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwiX2dldEhvc3RFbGVtZW50KClcXFwiPjwvZGl2PlwiLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kT3B0aW9uKTtcbiAgICByZXR1cm4gTWRPcHRpb247XG59KCkpO1xudmFyIE1kT3B0aW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE9wdGlvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRPcHRpb25Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZE9wdGlvbk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kT3B0aW9uTW9kdWxlID0gX19kZWNvcmF0ZSQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbTWRSaXBwbGVNb2R1bGUsIF9hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kT3B0aW9uXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kT3B0aW9uXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZE9wdGlvbk1vZHVsZSk7XG4gICAgcmV0dXJuIE1kT3B0aW9uTW9kdWxlO1xufSgpKTtcblxuLy8gVE9ETyhrYXJhKTogUmV2aXNpdCB3aHkgZXJyb3IgbWVzc2FnZXMgYXJlIG5vdCBiZWluZyBwcm9wZXJseSBzZXQuXG52YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBFcnJvciB0aGF0IHNldHMgdGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMyhNZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kRXJyb3IodmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTWRFcnJvcjtcbn0oRXJyb3IpKTtcblxudmFyIF9fZXh0ZW5kcyQyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgbnVsbCBwb3J0YWwgdG8gYSBob3N0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTnVsbFBvcnRhbEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihOdWxsUG9ydGFsRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTnVsbFBvcnRhbEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnTXVzdCBwcm92aWRlIGEgcG9ydGFsIHRvIGF0dGFjaCcpO1xuICAgIH1cbiAgICByZXR1cm4gTnVsbFBvcnRhbEVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIGhvc3QgdGhhdCBpcyBhbHJlYWR5IGF0dGFjaGVkLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgUG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyKFBvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnSG9zdCBhbHJlYWR5IGhhcyBhIHBvcnRhbCBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gUG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgcG9ydGFsIHRvIGFuIGFscmVhZHktZGlzcG9zZWQgaG9zdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFBvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIoUG9ydGFsSG9zdEFscmVhZHlEaXNwb3NlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ1RoaXMgUG9ydGFsSG9zdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBQb3J0YWxIb3N0QWxyZWFkeURpc3Bvc2VkRXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGFuIHVua25vd24gcG9ydGFsIHR5cGUuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBVbmtub3duUG9ydGFsVHlwZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihVbmtub3duUG9ydGFsVHlwZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVua25vd25Qb3J0YWxUeXBlRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdBdHRlbXB0aW5nIHRvIGF0dGFjaCBhbiB1bmtub3duIFBvcnRhbCB0eXBlLiAnICtcbiAgICAgICAgICAgICdCYXNlUG9ydGFsSG9zdCBhY2NlcHRzIGVpdGhlciBhIENvbXBvbmVudFBvcnRhbCBvciBhIFRlbXBsYXRlUG9ydGFsLicpO1xuICAgIH1cbiAgICByZXR1cm4gVW5rbm93blBvcnRhbFR5cGVFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhdHRhY2ggYSBwb3J0YWwgdG8gYSBudWxsIGhvc3QuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBOdWxsUG9ydGFsSG9zdEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihOdWxsUG9ydGFsSG9zdEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bGxQb3J0YWxIb3N0RXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdBdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIG51bGwgUG9ydGFsSG9zdCcpO1xuICAgIH1cbiAgICByZXR1cm4gTnVsbFBvcnRhbEhvc3RFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBkZXRhY2ggYSBwb3J0YWwgdGhhdCBpcyBub3QgYXR0YWNoZWQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBOb1BvcnRhbEF0dGFjaGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyKE5vUG9ydGFsQXR0YWNoZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb1BvcnRhbEF0dGFjaGVkRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdBdHRlbXB0aW5nIHRvIGRldGFjaCBhIHBvcnRhbCB0aGF0IGlzIG5vdCBhdHRhY2hlZCB0byBhIGhvc3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE5vUG9ydGFsQXR0YWNoZWRFcnJvcjtcbn0oTWRFcnJvcikpO1xuXG52YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBIGBQb3J0YWxgIGlzIHNvbWV0aGluZyB0aGF0IHlvdSB3YW50IHRvIHJlbmRlciBzb21ld2hlcmUgZWxzZS5cbiAqIEl0IGNhbiBiZSBhdHRhY2ggdG8gLyBkZXRhY2hlZCBmcm9tIGEgYFBvcnRhbEhvc3RgLlxuICovXG52YXIgUG9ydGFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3J0YWwoKSB7XG4gICAgfVxuICAgIC8qKiBBdHRhY2ggdGhpcyBwb3J0YWwgdG8gYSBob3N0LiAqL1xuICAgIFBvcnRhbC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgaWYgKGhvc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE51bGxQb3J0YWxIb3N0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gaG9zdC5hdHRhY2godGhpcyk7XG4gICAgfTtcbiAgICAvKiogRGV0YWNoIHRoaXMgcG9ydGFsIGZyb20gaXRzIGhvc3QgKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhvc3QgPSB0aGlzLl9hdHRhY2hlZEhvc3Q7XG4gICAgICAgIGlmIChob3N0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb1BvcnRhbEF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gaG9zdC5kZXRhY2goKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb3J0YWwucHJvdG90eXBlLCBcImlzQXR0YWNoZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGlzIHBvcnRhbCBpcyBhdHRhY2hlZCB0byBhIGhvc3QuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaGVkSG9zdCAhPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBQb3J0YWxIb3N0IHJlZmVyZW5jZSB3aXRob3V0IHBlcmZvcm1pbmcgYGF0dGFjaCgpYC4gVGhpcyBpcyB1c2VkIGRpcmVjdGx5IGJ5XG4gICAgICogdGhlIFBvcnRhbEhvc3Qgd2hlbiBpdCBpcyBwZXJmb3JtaW5nIGFuIGBhdHRhY2goKWAgb3IgYGRldGFjaCgpYC5cbiAgICAgKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLnNldEF0dGFjaGVkSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkSG9zdCA9IGhvc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gUG9ydGFsO1xufSgpKTtcbi8qKlxuICogQSBgQ29tcG9uZW50UG9ydGFsYCBpcyBhIHBvcnRhbCB0aGF0IGluc3RhbnRpYXRlcyBzb21lIENvbXBvbmVudCB1cG9uIGF0dGFjaG1lbnQuXG4gKi9cbnZhciBDb21wb25lbnRQb3J0YWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvbXBvbmVudFBvcnRhbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRQb3J0YWwoY29tcG9uZW50LCB2aWV3Q29udGFpbmVyUmVmLCBpbmplY3Rvcikge1xuICAgICAgICBpZiAodmlld0NvbnRhaW5lclJlZiA9PT0gdm9pZCAwKSB7IHZpZXdDb250YWluZXJSZWYgPSBudWxsOyB9XG4gICAgICAgIGlmIChpbmplY3RvciA9PT0gdm9pZCAwKSB7IGluamVjdG9yID0gbnVsbDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvbmVudFBvcnRhbDtcbn0oUG9ydGFsKSk7XG4vKipcbiAqIEEgYFRlbXBsYXRlUG9ydGFsYCBpcyBhIHBvcnRhbCB0aGF0IHJlcHJlc2VudHMgc29tZSBlbWJlZGRlZCB0ZW1wbGF0ZSAoVGVtcGxhdGVSZWYpLlxuICovXG52YXIgVGVtcGxhdGVQb3J0YWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRlbXBsYXRlUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUG9ydGFsKHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBsb2NhbHMgZm9yIHRoZSBpbnN0YW50aWF0ZWQgZW1iZWRkZWQgdmlldy5cbiAgICAgICAgICogVGhlc2UgbG9jYWxzIGNhbiBiZSBzZWVuIGFzIFwiZXhwb3J0c1wiIGZvciB0aGUgdGVtcGxhdGUsIHN1Y2ggYXMgaG93IG5nRm9yIGhhc1xuICAgICAgICAgKiBpbmRleCAvIGV2ZW50IC8gb2RkLlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2RvY3MvdHMvbGF0ZXN0L2FwaS9jb3JlL0VtYmVkZGVkVmlld1JlZi1jbGFzcy5odG1sXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvY2FscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVQb3J0YWwucHJvdG90eXBlLCBcIm9yaWdpblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVSZWYuZWxlbWVudFJlZjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGVtcGxhdGVQb3J0YWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChob3N0LCBsb2NhbHMpIHtcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBsb2NhbHMgPT0gbnVsbCA/IG5ldyBNYXAoKSA6IGxvY2FscztcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuYXR0YWNoLmNhbGwodGhpcywgaG9zdCk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBvcnRhbC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvY2FscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGV0YWNoLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQb3J0YWw7XG59KFBvcnRhbCkpO1xuLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIG9mIFBvcnRhbEhvc3QgdGhhdCBvbmx5IGRlYWxzIHdpdGggYXR0YWNoaW5nIGVpdGhlciBhXG4gKiBDb21wb25lbnRQb3J0YWwgb3IgYSBUZW1wbGF0ZVBvcnRhbC5cbiAqL1xudmFyIEJhc2VQb3J0YWxIb3N0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlUG9ydGFsSG9zdCgpIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyBob3N0IGhhcyBhbHJlYWR5IGJlZW4gcGVybWFuZW50bHkgZGlzcG9zZWQuICovXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqIFdoZXRoZXIgdGhpcyBob3N0IGhhcyBhbiBhdHRhY2hlZCBwb3J0YWwuICovXG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmhhc0F0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXR0YWNoZWRQb3J0YWwgIT0gbnVsbDtcbiAgICB9O1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmIChwb3J0YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE51bGxQb3J0YWxFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUG9ydGFsSG9zdEFscmVhZHlEaXNwb3NlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcnRhbCBpbnN0YW5jZW9mIENvbXBvbmVudFBvcnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwgPSBwb3J0YWw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3J0YWwgaW5zdGFuY2VvZiBUZW1wbGF0ZVBvcnRhbCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwgPSBwb3J0YWw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hUZW1wbGF0ZVBvcnRhbChwb3J0YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBVbmtub3duUG9ydGFsVHlwZUVycm9yKCk7XG4gICAgfTtcbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYXR0YWNoZWRQb3J0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsLnNldEF0dGFjaGVkSG9zdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hdHRhY2hlZFBvcnRhbCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlRm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUZuKCk7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlRm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5zZXREaXNwb3NlRm4gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZUZuID0gZm47XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZVBvcnRhbEhvc3Q7XG59KCkpO1xuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkOSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgdmVyc2lvbiBvZiBhIGBUZW1wbGF0ZVBvcnRhbGAuIEJlY2F1c2UgdGhlIGRpcmVjdGl2ZSAqaXMqIGEgVGVtcGxhdGVQb3J0YWwsXG4gKiB0aGUgZGlyZWN0aXZlIGluc3RhbmNlIGl0c2VsZiBjYW4gYmUgYXR0YWNoZWQgdG8gYSBob3N0LCBlbmFibGluZyBkZWNsYXJhdGl2ZSB1c2Ugb2YgcG9ydGFscy5cbiAqXG4gKiBVc2FnZTpcbiAqIDx0ZW1wbGF0ZSBwb3J0YWwgI2dyZWV0aW5nPlxuICogICA8cD4gSGVsbG8ge3tuYW1lfX0gPC9wPlxuICogPC90ZW1wbGF0ZT5cbiAqL1xudmFyIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cbiAgICBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nkay1wb3J0YWxdLCBbcG9ydGFsXScsXG4gICAgICAgICAgICBleHBvcnRBczogJ2Nka1BvcnRhbCcsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWZdKVxuICAgIF0sIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlKTtcbiAgICByZXR1cm4gVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmU7XG59KFRlbXBsYXRlUG9ydGFsKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB2ZXJzaW9uIG9mIGEgUG9ydGFsSG9zdC4gQmVjYXVzZSB0aGUgZGlyZWN0aXZlICppcyogYSBQb3J0YWxIb3N0LCBwb3J0YWxzIGNhbiBiZVxuICogZGlyZWN0bHkgYXR0YWNoZWQgdG8gaXQsIGVuYWJsaW5nIGRlY2xhcmF0aXZlIHVzZS5cbiAqXG4gKiBVc2FnZTpcbiAqIDx0ZW1wbGF0ZSBbY2RrUG9ydGFsSG9zdF09XCJncmVldGluZ1wiPjwvdGVtcGxhdGU+XG4gKi9cbnZhciBQb3J0YWxIb3N0RGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9ydGFsSG9zdERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3J0YWxIb3N0RGlyZWN0aXZlKF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF92aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb3J0YWxIb3N0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZFBvcnRhbFwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucG9ydGFsOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMucG9ydGFsID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLCBcInBvcnRhbFwiLCB7XG4gICAgICAgIC8qKiBQb3J0YWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBQb3J0YWwgaG9zdC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VBdHRhY2hlZFBvcnRhbChwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBDb21wb25lbnRQb3J0YWwgdG8gdGhpcyBQb3J0YWxIb3N0IHVzaW5nIHRoZSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZCB0byB0aGUgcG9ydGFsIGhvc3QuXG4gICAgICovXG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUuYXR0YWNoQ29tcG9uZW50UG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBwb3J0YWwuc2V0QXR0YWNoZWRIb3N0KHRoaXMpO1xuICAgICAgICAvLyBJZiB0aGUgcG9ydGFsIHNwZWNpZmllcyBhbiBvcmlnaW4sIHVzZSB0aGF0IGFzIHRoZSBsb2dpY2FsIGxvY2F0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaW4gdGhlIGFwcGxpY2F0aW9uIHRyZWUuIE90aGVyd2lzZSB1c2UgdGhlIGxvY2F0aW9uIG9mIHRoaXMgUG9ydGFsSG9zdC5cbiAgICAgICAgdmFyIHZpZXdDb250YWluZXJSZWYgPSBwb3J0YWwudmlld0NvbnRhaW5lclJlZiAhPSBudWxsID9cbiAgICAgICAgICAgIHBvcnRhbC52aWV3Q29udGFpbmVyUmVmIDpcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KHBvcnRhbC5jb21wb25lbnQpO1xuICAgICAgICB2YXIgcmVmID0gdmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSwgdmlld0NvbnRhaW5lclJlZi5sZW5ndGgsIHBvcnRhbC5pbmplY3RvciB8fCB2aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yKTtcbiAgICAgICAgdGhpcy5zZXREaXNwb3NlRm4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVmLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGdpdmVuIFRlbXBsYXRlUG9ydGFsIHRvIHRoaXMgUG9ydGxIb3N0IGFzIGFuIGVtYmVkZGVkIFZpZXcuXG4gICAgICogQHBhcmFtIHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQuXG4gICAgICovXG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUuYXR0YWNoVGVtcGxhdGVQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHBvcnRhbC5zZXRBdHRhY2hlZEhvc3QodGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHBvcnRhbC50ZW1wbGF0ZVJlZik7XG4gICAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH0pO1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogcmV0dXJuIGxvY2FscyBmcm9tIHZpZXdcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIC8qKiBEZXRhY2hlcyB0aGUgY3VycmVudGx5IGF0dGFjaGVkIFBvcnRhbCAoaWYgdGhlcmUgaXMgb25lKSBhbmQgYXR0YWNoZXMgdGhlIGdpdmVuIFBvcnRhbC4gKi9cbiAgICBQb3J0YWxIb3N0RGlyZWN0aXZlLnByb3RvdHlwZS5fcmVwbGFjZUF0dGFjaGVkUG9ydGFsID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2gocCk7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSBwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdwb3J0YWxIb3N0JyksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLCBcIl9kZXByZWNhdGVkUG9ydGFsXCIsIG51bGwpO1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUgPSBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtQb3J0YWxIb3N0XSwgW3BvcnRhbEhvc3RdJyxcbiAgICAgICAgICAgIGlucHV0czogWydwb3J0YWw6IGNka1BvcnRhbEhvc3QnXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZl0pXG4gICAgXSwgUG9ydGFsSG9zdERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIFBvcnRhbEhvc3REaXJlY3RpdmU7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG52YXIgUG9ydGFsTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3J0YWxNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIFBvcnRhbE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBvcnRhbE1vZHVsZSA9IF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW1RlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBQb3J0YWxIb3N0RGlyZWN0aXZlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1RlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBQb3J0YWxIb3N0RGlyZWN0aXZlXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgUG9ydGFsTW9kdWxlKTtcbiAgICByZXR1cm4gUG9ydGFsTW9kdWxlO1xufSgpKTtcblxuLyoqXG4gKiBPdmVybGF5U3RhdGUgaXMgYSBiYWcgb2YgdmFsdWVzIGZvciBlaXRoZXIgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBvciBjdXJyZW50IHN0YXRlIG9mIGFuXG4gKiBvdmVybGF5LlxuICovXG52YXIgT3ZlcmxheVN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5U3RhdGUoKSB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBvdmVybGF5IGhhcyBhIGJhY2tkcm9wLiAqL1xuICAgICAgICB0aGlzLmhhc0JhY2tkcm9wID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXN0b20gY2xhc3MgdG8gYWRkIHRvIHRoZSBiYWNrZHJvcCAqKi9cbiAgICAgICAgdGhpcy5iYWNrZHJvcENsYXNzID0gJ2Nkay1vdmVybGF5LWRhcmstYmFja2Ryb3AnO1xuICAgICAgICAvKiogVGhlIGRpcmVjdGlvbiBvZiB0aGUgdGV4dCBpbiB0aGUgb3ZlcmxheSBwYW5lbC4gKi9cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAnbHRyJztcbiAgICB9XG4gICAgcmV0dXJuIE92ZXJsYXlTdGF0ZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEEgUG9ydGFsSG9zdCBmb3IgYXR0YWNoaW5nIHBvcnRhbHMgdG8gYW4gYXJiaXRyYXJ5IERPTSBlbGVtZW50IG91dHNpZGUgb2YgdGhlIEFuZ3VsYXJcbiAqIGFwcGxpY2F0aW9uIGNvbnRleHQuXG4gKlxuICogVGhpcyBpcyB0aGUgb25seSBwYXJ0IG9mIHRoZSBwb3J0YWwgY29yZSB0aGF0IGRpcmVjdGx5IHRvdWNoZXMgdGhlIERPTS5cbiAqL1xudmFyIERvbVBvcnRhbEhvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ0KERvbVBvcnRhbEhvc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9tUG9ydGFsSG9zdChfaG9zdERvbUVsZW1lbnQsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9hcHBSZWYsIF9kZWZhdWx0SW5qZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2hvc3REb21FbGVtZW50ID0gX2hvc3REb21FbGVtZW50O1xuICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9hcHBSZWYgPSBfYXBwUmVmO1xuICAgICAgICB0aGlzLl9kZWZhdWx0SW5qZWN0b3IgPSBfZGVmYXVsdEluamVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGdpdmVuIENvbXBvbmVudFBvcnRhbCB0byBET00gZWxlbWVudCB1c2luZyB0aGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLlxuICAgICAqIEBwYXJhbSBwb3J0YWwgUG9ydGFsIHRvIGJlIGF0dGFjaGVkXG4gICAgICovXG4gICAgRG9tUG9ydGFsSG9zdC5wcm90b3R5cGUuYXR0YWNoQ29tcG9uZW50UG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShwb3J0YWwuY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGNvbXBvbmVudFJlZjtcbiAgICAgICAgLy8gSWYgdGhlIHBvcnRhbCBzcGVjaWZpZXMgYSBWaWV3Q29udGFpbmVyUmVmLCB3ZSB3aWxsIHVzZSB0aGF0IGFzIHRoZSBhdHRhY2htZW50IHBvaW50XG4gICAgICAgIC8vIGZvciB0aGUgY29tcG9uZW50IChpbiB0ZXJtcyBvZiBBbmd1bGFyJ3MgY29tcG9uZW50IHRyZWUsIG5vdCByZW5kZXJpbmcpLlxuICAgICAgICAvLyBXaGVuIHRoZSBWaWV3Q29udGFpbmVyUmVmIGlzIG1pc3NpbmcsIHdlIHVzZSB0aGUgZmFjdG9yeSB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCBkaXJlY3RseVxuICAgICAgICAvLyBhbmQgdGhlbiBtYW51YWxseSBhdHRhY2ggdGhlIHZpZXcgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAgICBpZiAocG9ydGFsLnZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZiA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5LCBwb3J0YWwudmlld0NvbnRhaW5lclJlZi5sZW5ndGgsIHBvcnRhbC5pbmplY3RvciB8fCBwb3J0YWwudmlld0NvbnRhaW5lclJlZi5wYXJlbnRJbmplY3Rvcik7XG4gICAgICAgICAgICB0aGlzLnNldERpc3Bvc2VGbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnRSZWYuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKHBvcnRhbC5pbmplY3RvciB8fCB0aGlzLl9kZWZhdWx0SW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5fYXBwUmVmLmF0dGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYXBwUmVmLmRldGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRSZWYuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGluc3RhbnRpYXRlZCwgc28gd2UgbW92ZSBpdCB0byB0aGUgbG9jYXRpb24gaW4gdGhlIERPTVxuICAgICAgICAvLyB3aGVyZSB3ZSB3YW50IGl0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICB0aGlzLl9ob3N0RG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9nZXRDb21wb25lbnRSb290Tm9kZShjb21wb25lbnRSZWYpKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgdGVtcGxhdGUgcG9ydGFsIHRvIHRoZSBET00gYXMgYW4gZW1iZWRkZWQgdmlldy5cbiAgICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBEb21Qb3J0YWxIb3N0LnByb3RvdHlwZS5hdHRhY2hUZW1wbGF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSBwb3J0YWwudmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdmFyIHZpZXdSZWYgPSB2aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhwb3J0YWwudGVtcGxhdGVSZWYpO1xuICAgICAgICAvLyBUaGUgbWV0aG9kIGBjcmVhdGVFbWJlZGRlZFZpZXdgIHdpbGwgYWRkIHRoZSB2aWV3IGFzIGEgY2hpbGQgb2YgdGhlIHZpZXdDb250YWluZXIuXG4gICAgICAgIC8vIEJ1dCBmb3IgdGhlIERvbVBvcnRhbEhvc3QgdGhlIHZpZXcgY2FuIGJlIGFkZGVkIGV2ZXJ5d2hlcmUgaW4gdGhlIERPTSAoZS5nIE92ZXJsYXkgQ29udGFpbmVyKVxuICAgICAgICAvLyBUbyBtb3ZlIHRoZSB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgaG9zdCBlbGVtZW50LiBXZSBqdXN0IHJlLWFwcGVuZCB0aGUgZXhpc3Rpbmcgcm9vdCBub2Rlcy5cbiAgICAgICAgdmlld1JlZi5yb290Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAocm9vdE5vZGUpIHsgcmV0dXJuIF90aGlzLl9ob3N0RG9tRWxlbWVudC5hcHBlbmRDaGlsZChyb290Tm9kZSk7IH0pO1xuICAgICAgICB0aGlzLnNldERpc3Bvc2VGbigoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdmlld0NvbnRhaW5lci5pbmRleE9mKHZpZXdSZWYpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZpZXdDb250YWluZXIucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogUmV0dXJuIGxvY2FscyBmcm9tIHZpZXcuXG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgb3V0IGEgcG9ydGFsIGZyb20gdGhlIERPTS5cbiAgICAgKi9cbiAgICBEb21Qb3J0YWxIb3N0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2hvc3REb21FbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faG9zdERvbUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ob3N0RG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBHZXRzIHRoZSByb290IEhUTUxFbGVtZW50IGZvciBhbiBpbnN0YW50aWF0ZWQgY29tcG9uZW50LiAqL1xuICAgIERvbVBvcnRhbEhvc3QucHJvdG90eXBlLl9nZXRDb21wb25lbnRSb290Tm9kZSA9IGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZi5ob3N0Vmlldy5yb290Tm9kZXNbMF07XG4gICAgfTtcbiAgICByZXR1cm4gRG9tUG9ydGFsSG9zdDtcbn0oQmFzZVBvcnRhbEhvc3QpKTtcblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gYW4gb3ZlcmxheSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCB0aGUgT3ZlcmxheSBzZXJ2aWNlLlxuICogVXNlZCB0byBtYW5pcHVsYXRlIG9yIGRpc3Bvc2Ugb2Ygc2FpZCBvdmVybGF5LlxuICovXG52YXIgT3ZlcmxheVJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheVJlZihfcG9ydGFsSG9zdCwgX3BhbmUsIF9zdGF0ZSwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9wb3J0YWxIb3N0ID0gX3BvcnRhbEhvc3Q7XG4gICAgICAgIHRoaXMuX3BhbmUgPSBfcGFuZTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBfc3RhdGU7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wQ2xpY2sgPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE92ZXJsYXlSZWYucHJvdG90eXBlLCBcIm92ZXJsYXlFbGVtZW50XCIsIHtcbiAgICAgICAgLyoqIFRoZSBvdmVybGF5J3MgSFRNTCBlbGVtZW50ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhbmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBvdmVybGF5IHRvIGEgcG9ydGFsIGluc3RhbmNlIGFuZCBhZGRzIHRoZSBiYWNrZHJvcC5cbiAgICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCBpbnN0YW5jZSB0byB3aGljaCB0byBhdHRhY2ggdGhlIG92ZXJsYXkuXG4gICAgICogQHJldHVybnMgVGhlIHBvcnRhbCBhdHRhY2htZW50IHJlc3VsdC5cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5oYXNCYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoQmFja2Ryb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoUmVzdWx0ID0gdGhpcy5fcG9ydGFsSG9zdC5hdHRhY2gocG9ydGFsKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwYW5lIGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gc3RhdGUgY29uZmlndXJhdGlvbi5cbiAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgLy8gRW5hYmxlIHBvaW50ZXIgZXZlbnRzIGZvciB0aGUgb3ZlcmxheSBwYW5lIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuX3RvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHJldHVybiBhdHRhY2hSZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyBhbiBvdmVybGF5IGZyb20gYSBwb3J0YWwuXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RldGFjaEJhY2tkcm9wKCk7XG4gICAgICAgIC8vIFdoZW4gdGhlIG92ZXJsYXkgaXMgZGV0YWNoZWQsIHRoZSBwYW5lIGVsZW1lbnQgc2hvdWxkIGRpc2FibGUgcG9pbnRlciBldmVudHMuXG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBwYW5lIGVsZW1lbnQgd2lsbCBjb3ZlciB0aGUgcGFnZSBhbmQgZGlzYWJsZVxuICAgICAgICAvLyBwb2ludGVyIGV2ZW50cyB0aGVyZWZvcmUuIERlcGVuZHMgb24gdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IGFuZCB0aGUgYXBwbGllZCBwYW5lIGJvdW5kYXJpZXMuXG4gICAgICAgIHRoaXMuX3RvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsSG9zdC5kZXRhY2goKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCB0aGUgb3ZlcmxheSBmcm9tIHRoZSBET00uXG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLnBvc2l0aW9uU3RyYXRlZ3kuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RldGFjaEJhY2tkcm9wKCk7XG4gICAgICAgIHRoaXMuX3BvcnRhbEhvc3QuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuXG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuaGFzQXR0YWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdGhhdCBlbWl0cyB3aGVuIHRoZSBiYWNrZHJvcCBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmJhY2tkcm9wQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNrZHJvcENsaWNrLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0ZSBjb25maWcgb2YgdGhlIG92ZXJsYXkuXG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9O1xuICAgIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBiYXNlZCBvbiB0aGUgcG9zaXRpb24gc3RyYXRlZ3kuICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUudXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5wb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5wb3NpdGlvblN0cmF0ZWd5LmFwcGx5KHRoaXMuX3BhbmUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIG92ZXJsYXkgcGFuZWwuICoqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLnVwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFuZS5zZXRBdHRyaWJ1dGUoJ2RpcicsIHRoaXMuX3N0YXRlLmRpcmVjdGlvbik7XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgc2l6ZSBvZiB0aGUgb3ZlcmxheSBiYXNlZCBvbiB0aGUgb3ZlcmxheSBjb25maWcuICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLndpZHRoIHx8IHRoaXMuX3N0YXRlLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLndpZHRoID0gZm9ybWF0Q3NzVW5pdCh0aGlzLl9zdGF0ZS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmhlaWdodCB8fCB0aGlzLl9zdGF0ZS5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbmUuc3R5bGUuaGVpZ2h0ID0gZm9ybWF0Q3NzVW5pdCh0aGlzLl9zdGF0ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5taW5XaWR0aCB8fCB0aGlzLl9zdGF0ZS5taW5XaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS5taW5XaWR0aCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUubWluV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5taW5IZWlnaHQgfHwgdGhpcy5fc3RhdGUubWluSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLm1pbkhlaWdodCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUubWluSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFRvZ2dsZXMgdGhlIHBvaW50ZXIgZXZlbnRzIGZvciB0aGUgb3ZlcmxheSBwYW5lIGVsZW1lbnQuICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuX3RvZ2dsZVBvaW50ZXJFdmVudHMgPSBmdW5jdGlvbiAoZW5hYmxlUG9pbnRlcikge1xuICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBlbmFibGVQb2ludGVyID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIH07XG4gICAgLyoqIEF0dGFjaGVzIGEgYmFja2Ryb3AgZm9yIHRoaXMgb3ZlcmxheS4gKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5fYXR0YWNoQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktYmFja2Ryb3AnKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5fc3RhdGUuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgIC8vIEluc2VydCB0aGUgYmFja2Ryb3AgYmVmb3JlIHRoZSBwYW5lIGluIHRoZSBET00gb3JkZXIsXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGhhbmRsZSBzdGFja2VkIG92ZXJsYXlzIHByb3Blcmx5LlxuICAgICAgICB0aGlzLl9wYW5lLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuX2JhY2tkcm9wRWxlbWVudCwgdGhpcy5fcGFuZSk7XG4gICAgICAgIC8vIEZvcndhcmQgYmFja2Ryb3AgY2xpY2tzIHN1Y2ggdGhhdCB0aGUgY29uc3VtZXIgb2YgdGhlIG92ZXJsYXkgY2FuIHBlcmZvcm0gd2hhdGV2ZXJcbiAgICAgICAgLy8gYWN0aW9uIGRlc2lyZWQgd2hlbiBzdWNoIGEgY2xpY2sgb2NjdXJzICh1c3VhbGx5IGNsb3NpbmcgdGhlIG92ZXJsYXkpLlxuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYmFja2Ryb3BDbGljay5uZXh0KG51bGwpOyB9KTtcbiAgICAgICAgLy8gQWRkIGNsYXNzIHRvIGZhZGUtaW4gdGhlIGJhY2tkcm9wIGFmdGVyIG9uZSBmcmFtZS5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fYmFja2Ryb3BFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tkcm9wRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjZGstb3ZlcmxheS1iYWNrZHJvcC1zaG93aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIERldGFjaGVzIHRoZSBiYWNrZHJvcCAoaWYgYW55KSBhc3NvY2lhdGVkIHdpdGggdGhlIG92ZXJsYXkuICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuX2RldGFjaEJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYmFja2Ryb3BUb0RldGFjaCA9IHRoaXMuX2JhY2tkcm9wRWxlbWVudDtcbiAgICAgICAgaWYgKGJhY2tkcm9wVG9EZXRhY2gpIHtcbiAgICAgICAgICAgIHZhciBmaW5pc2hEZXRhY2hfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCBtYXkgbm90IGJlIGF0dGFjaGVkIHRvIGFueXRoaW5nIGluIGNlcnRhaW4gY2FzZXMgKGUuZy4gdW5pdCB0ZXN0cykuXG4gICAgICAgICAgICAgICAgaWYgKGJhY2tkcm9wVG9EZXRhY2ggJiYgYmFja2Ryb3BUb0RldGFjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrZHJvcFRvRGV0YWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCBhIG5ldyBwb3J0YWwgaGFzIGJlZW4gYXR0YWNoZWQgdG8gdGhpcyBvdmVybGF5IHNpbmNlIHdlIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAvLyByZW1vdmluZyB0aGUgYmFja2Ryb3AuIElmIHRoYXQgaXMgdGhlIGNhc2UsIG9ubHkgY2xlYXIgdGhlIGJhY2tkcm9wIHJlZmVyZW5jZSBpZiBpdFxuICAgICAgICAgICAgICAgIC8vIGlzIHN0aWxsIHRoZSBzYW1lIGluc3RhbmNlIHRoYXQgd2Ugc3RhcnRlZCB0byByZW1vdmUuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9iYWNrZHJvcEVsZW1lbnQgPT0gYmFja2Ryb3BUb0RldGFjaCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYmFja2Ryb3BUb0RldGFjaC5jbGFzc0xpc3QucmVtb3ZlKCdjZGstb3ZlcmxheS1iYWNrZHJvcC1zaG93aW5nJyk7XG4gICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fc3RhdGUuYmFja2Ryb3BDbGFzcyk7XG4gICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmaW5pc2hEZXRhY2hfMSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYmFja2Ryb3AgZG9lc24ndCBoYXZlIGEgdHJhbnNpdGlvbiwgdGhlIGB0cmFuc2l0aW9uZW5kYCBldmVudCB3b24ndCBmaXJlLlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIG1ha2UgaXQgdW5jbGlja2FibGUgYW5kIHdlIHRyeSB0byByZW1vdmUgaXQgYWZ0ZXIgYSBkZWxheS5cbiAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2guc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIC8vIFJ1biB0aGlzIG91dHNpZGUgdGhlIEFuZ3VsYXIgem9uZSBiZWNhdXNlIHRoZXJlJ3Mgbm90aGluZyB0aGF0IEFuZ3VsYXIgY2FyZXMgYWJvdXQuXG4gICAgICAgICAgICAvLyBJZiBpdCB3ZXJlIHRvIHJ1biBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZSwgZXZlcnkgdGVzdCB0aGF0IHVzZWQgT3ZlcmxheSB3b3VsZCBoYXZlIHRvIGJlXG4gICAgICAgICAgICAvLyBlaXRoZXIgYXN5bmMgb3IgZmFrZUFzeW5jLlxuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZpbmlzaERldGFjaF8xLCA1MDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5UmVmO1xufSgpKTtcbmZ1bmN0aW9uIGZvcm1hdENzc1VuaXQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogdmFsdWUgKyBcInB4XCI7XG59XG5cbnZhciBfX2RlY29yYXRlJDEzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQyID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqIFRoZSBwb2ludHMgb2YgdGhlIG9yaWdpbiBlbGVtZW50IGFuZCB0aGUgb3ZlcmxheSBlbGVtZW50IHRvIGNvbm5lY3QuICovXG52YXIgQ29ubmVjdGlvblBvc2l0aW9uUGFpciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvblBvc2l0aW9uUGFpcihvcmlnaW4sIG92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3JpZ2luLm9yaWdpblg7XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IG9yaWdpbi5vcmlnaW5ZO1xuICAgICAgICB0aGlzLm92ZXJsYXlYID0gb3ZlcmxheS5vdmVybGF5WDtcbiAgICAgICAgdGhpcy5vdmVybGF5WSA9IG92ZXJsYXkub3ZlcmxheVk7XG4gICAgfVxuICAgIHJldHVybiBDb25uZWN0aW9uUG9zaXRpb25QYWlyO1xufSgpKTtcbi8qKlxuICogU2V0IG9mIHByb3BlcnRpZXMgcmVnYXJkaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3JpZ2luIGFuZCBvdmVybGF5IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICogd2l0aCByZXNwZWN0IHRvIHRoZSBjb250YWluaW5nIFNjcm9sbGFibGUgZWxlbWVudHMuXG4gKlxuICogVGhlIG92ZXJsYXkgYW5kIG9yaWdpbiBhcmUgY2xpcHBlZCBpZiBhbnkgcGFydCBvZiB0aGVpciBib3VuZGluZyBjbGllbnQgcmVjdGFuZ2xlIGV4Y2VlZHMgdGhlXG4gKiBib3VuZHMgb2YgYW55IG9uZSBvZiB0aGUgc3RyYXRlZ3kncyBTY3JvbGxhYmxlJ3MgYm91bmRpbmcgY2xpZW50IHJlY3RhbmdsZS5cbiAqXG4gKiBUaGUgb3ZlcmxheSBhbmQgb3JpZ2luIGFyZSBvdXRzaWRlIHZpZXcgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcCBiZXR3ZWVuIHRoZWlyIGJvdW5kaW5nIGNsaWVudFxuICogcmVjdGFuZ2xlIGFuZCBhbnkgb25lIG9mIHRoZSBzdHJhdGVneSdzIFNjcm9sbGFibGUncyBib3VuZGluZyBjbGllbnQgcmVjdGFuZ2xlLlxuICpcbiAqICAgICAgIC0tLS0tLS0tLS0tICAgICAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLVxuICogICAgICAgfCBvdXRzaWRlIHwgICAgICAgICAgICAgICAgICAgIHwgY2xpcHBlZCB8XG4gKiAgICAgICB8ICB2aWV3ICAgfCAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICAgICAgIHwgICAgICAgICB8ICAgICAgICAgICAgICB8ICAgICB8ICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgLS0tLS0tLS0tLSAgICAgICAgICAgICAgIHwgICAgIC0tLS0tLS0tLS0tICAgICAgICB8XG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8ICAgICAgU2Nyb2xsYWJsZSAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgfCAgICAgIFNjcm9sbGFibGUgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbnZhciBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbGFibGVWaWV3UHJvcGVydGllcygpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNjcm9sbGFibGVWaWV3UHJvcGVydGllcztcbn0oKSk7XG4vKiogVGhlIGNoYW5nZSBldmVudCBlbWl0dGVkIGJ5IHRoZSBzdHJhdGVneSB3aGVuIGEgZmFsbGJhY2sgcG9zaXRpb24gaXMgdXNlZC4gKi9cbnZhciBDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZShjb25uZWN0aW9uUGFpciwgc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBhaXIgPSBjb25uZWN0aW9uUGFpcjtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMgPSBzY3JvbGxhYmxlVmlld1Byb3BlcnRpZXM7XG4gICAgfVxuICAgIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZSA9IF9fZGVjb3JhdGUkMTMoW1xuICAgICAgICBfX3BhcmFtJDIoMSwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0Nvbm5lY3Rpb25Qb3NpdGlvblBhaXIsIFNjcm9sbGFibGVWaWV3UHJvcGVydGllc10pXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlKTtcbiAgICByZXR1cm4gQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlO1xufSgpKTtcblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBwb3NpdGlvbmluZyBvdmVybGF5cy4gVXNpbmcgdGhpcyBzdHJhdGVneSwgYW4gb3ZlcmxheSBpcyBnaXZlbiBhblxuICogaW1wbGljaXQgcG9zaXRpb24gcmVsYXRpdmUgc29tZSBvcmlnaW4gZWxlbWVudC4gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGRlZmluZWQgaW4gdGVybXMgb2ZcbiAqIGEgcG9pbnQgb24gdGhlIG9yaWdpbiBlbGVtZW50IHRoYXQgaXMgY29ubmVjdGVkIHRvIGEgcG9pbnQgb24gdGhlIG92ZXJsYXkgZWxlbWVudC4gRm9yIGV4YW1wbGUsXG4gKiBhIGJhc2ljIGRyb3Bkb3duIGlzIGNvbm5lY3RpbmcgdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0aGUgb3JpZ2luIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXJcbiAqIG9mIHRoZSBvdmVybGF5LlxuICovXG52YXIgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneShfY29ubmVjdGVkVG8sIF9vcmlnaW5Qb3MsIF9vdmVybGF5UG9zLCBfdmlld3BvcnRSdWxlcikge1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWRUbyA9IF9jb25uZWN0ZWRUbztcbiAgICAgICAgdGhpcy5fb3JpZ2luUG9zID0gX29yaWdpblBvcztcbiAgICAgICAgdGhpcy5fb3ZlcmxheVBvcyA9IF9vdmVybGF5UG9zO1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyID0gX3ZpZXdwb3J0UnVsZXI7XG4gICAgICAgIHRoaXMuX2RpciA9ICdsdHInO1xuICAgICAgICAvKiogVGhlIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBvdmVybGF5IGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHgtYXhpcyAqL1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gMDtcbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB5LWF4aXMgKi9cbiAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IDA7XG4gICAgICAgIC8qKiBUaGUgU2Nyb2xsYWJsZSBjb250YWluZXJzIHVzZWQgdG8gY2hlY2sgc2Nyb2xsYWJsZSB2aWV3IHByb3BlcnRpZXMgb24gcG9zaXRpb24gY2hhbmdlLiAqL1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVzID0gW107XG4gICAgICAgIC8qKiBPcmRlcmVkIGxpc3Qgb2YgcHJlZmVycmVkIHBvc2l0aW9ucywgZnJvbSBtb3N0IHRvIGxlYXN0IGRlc2lyYWJsZS4gKi9cbiAgICAgICAgdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zID0gW107XG4gICAgICAgIHRoaXMuX29uUG9zaXRpb25DaGFuZ2UgPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gdGhpcy5fY29ubmVjdGVkVG8ubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy53aXRoRmFsbGJhY2tQb3NpdGlvbihfb3JpZ2luUG9zLCBfb3ZlcmxheVBvcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZSwgXCJfaXNSdGxcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgd2UncmUgZGVhbGluZyB3aXRoIGFuIFJUTCBjb250ZXh0ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpciA9PT0gJ3J0bCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZSwgXCJvblBvc2l0aW9uQ2hhbmdlXCIsIHtcbiAgICAgICAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGNvbm5lY3Rpb24gcG9pbnQgY2hhbmdlcy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25Qb3NpdGlvbkNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLCBcInBvc2l0aW9uc1wiLCB7XG4gICAgICAgIC8qKiBPcmRlcmVkIGxpc3Qgb2YgcHJlZmVycmVkIHBvc2l0aW9ucywgZnJvbSBtb3N0IHRvIGxlYXN0IGRlc2lyYWJsZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUbyBiZSB1c2VkIHRvIGZvciBhbnkgY2xlYW51cCBhZnRlciB0aGUgZWxlbWVudCBnZXRzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IGVsZW1lbnQsIHVzaW5nIHdoaWNoZXZlciBwcmVmZXJyZWQgcG9zaXRpb24gcmVsYXRpdmVcbiAgICAgKiB0byB0aGUgb3JpZ2luIGZpdHMgb24tc2NyZWVuLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gd2hpY2ggdG8gYXBwbHkgdGhlIENTUyBzdHlsZXMuXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB0aGUgc3R5bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIG92ZXJsYXkgcGFuZSBlbGVtZW50IGluIGNhc2UgcmUtY2FsY3VsYXRpbmcgcG9zaXRpb24gaXMgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuX3BhbmUgPSBlbGVtZW50O1xuICAgICAgICAvLyBXZSBuZWVkIHRoZSBib3VuZGluZyByZWN0cyBmb3IgdGhlIG9yaWdpbiBhbmQgdGhlIG92ZXJsYXkgdG8gZGV0ZXJtaW5lIGhvdyB0byBwb3NpdGlvblxuICAgICAgICAvLyB0aGUgb3ZlcmxheSByZWxhdGl2ZSB0byB0aGUgb3JpZ2luLlxuICAgICAgICB2YXIgb3JpZ2luUmVjdCA9IHRoaXMuX29yaWdpbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG92ZXJsYXlSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gV2UgdXNlIHRoZSB2aWV3cG9ydCByZWN0IHRvIGRldGVybWluZSB3aGV0aGVyIGEgcG9zaXRpb24gd291bGQgZ28gb2ZmLXNjcmVlbi5cbiAgICAgICAgdmFyIHZpZXdwb3J0UmVjdCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG4gICAgICAgIC8vIEZhbGxiYWNrIHBvaW50IGlmIG5vbmUgb2YgdGhlIGZhbGxiYWNrcyBmaXQgaW50byB0aGUgdmlld3BvcnQuXG4gICAgICAgIHZhciBmYWxsYmFja1BvaW50ID0gbnVsbDtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBwbGFjZSB0aGUgb3ZlcmxheSBpbiB0aGUgZmlyc3Qgb2YgdGhlIHByZWZlcnJlZCBwb3NpdGlvbnMgc3VjaCB0aGF0IHRoZVxuICAgICAgICAvLyBvdmVybGF5IGZpdHMgb24tc2NyZWVuLlxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9hW19pXTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgKHgsIHkpIHBvaW50IG9mIGNvbm5lY3Rpb24gb24gdGhlIG9yaWdpbiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgLy8gKHRvcCwgbGVmdCkgY29vcmRpbmF0ZSBmb3IgdGhlIG92ZXJsYXkgYXQgYHBvc2AuXG4gICAgICAgICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLl9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQob3JpZ2luUmVjdCwgcG9zKTtcbiAgICAgICAgICAgIHZhciBvdmVybGF5UG9pbnQgPSB0aGlzLl9nZXRPdmVybGF5UG9pbnQob3JpZ2luUG9pbnQsIG92ZXJsYXlSZWN0LCB2aWV3cG9ydFJlY3QsIHBvcyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3ZlcmxheSBpbiB0aGUgY2FsY3VsYXRlZCBwb3NpdGlvbiBmaXRzIG9uLXNjcmVlbiwgcHV0IGl0IHRoZXJlIGFuZCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgaWYgKG92ZXJsYXlQb2ludC5maXRzSW5WaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBvdmVybGF5UG9pbnQpO1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgY29ubmVjdGVkIHBvc2l0aW9uIGluIGNhc2UgdGhlIHBvc2l0aW9uIG5lZWRzIHRvIGJlIHJlLWNhbGN1bGF0ZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdENvbm5lY3RlZFBvc2l0aW9uID0gcG9zO1xuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSB0aGF0IHRoZSBwb3NpdGlvbiBoYXMgYmVlbiBjaGFuZ2VkIGFsb25nIHdpdGggaXRzIGNoYW5nZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMgPSB0aGlzLmdldFNjcm9sbGFibGVWaWV3UHJvcGVydGllcyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25DaGFuZ2UgPSBuZXcgQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlKHBvcywgc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblBvc2l0aW9uQ2hhbmdlLm5leHQocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmFsbGJhY2tQb2ludCB8fCBmYWxsYmFja1BvaW50LnZpc2libGVBcmVhIDwgb3ZlcmxheVBvaW50LnZpc2libGVBcmVhKSB7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tQb2ludCA9IG92ZXJsYXlQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBwcmVmZXJyZWQgcG9zaXRpb25zIHdlcmUgaW4gdGhlIHZpZXdwb3J0LCB0YWtlIHRoZSBvbmVcbiAgICAgICAgLy8gd2l0aCB0aGUgbGFyZ2VzdCB2aXNpYmxlIGFyZWEuXG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBmYWxsYmFja1BvaW50KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgcmUtYWxpZ25zIHRoZSBvdmVybGF5IGVsZW1lbnQgd2l0aCB0aGUgdHJpZ2dlciBpbiBpdHMgbGFzdCBjYWxjdWxhdGVkIHBvc2l0aW9uLFxuICAgICAqIGV2ZW4gaWYgYSBwb3NpdGlvbiBoaWdoZXIgaW4gdGhlIFwicHJlZmVycmVkIHBvc2l0aW9uc1wiIGxpc3Qgd291bGQgbm93IGZpdC4gVGhpc1xuICAgICAqIGFsbG93cyBvbmUgdG8gcmUtYWxpZ24gdGhlIHBhbmVsIHdpdGhvdXQgY2hhbmdpbmcgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwYW5lbC5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5yZWNhbGN1bGF0ZUxhc3RQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yaWdpblJlY3QgPSB0aGlzLl9vcmlnaW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvdmVybGF5UmVjdCA9IHRoaXMuX3BhbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLl9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQob3JpZ2luUmVjdCwgdGhpcy5fbGFzdENvbm5lY3RlZFBvc2l0aW9uKTtcbiAgICAgICAgdmFyIG92ZXJsYXlQb2ludCA9IHRoaXMuX2dldE92ZXJsYXlQb2ludChvcmlnaW5Qb2ludCwgb3ZlcmxheVJlY3QsIHZpZXdwb3J0UmVjdCwgdGhpcy5fbGFzdENvbm5lY3RlZFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudFBvc2l0aW9uKHRoaXMuX3BhbmUsIG92ZXJsYXlQb2ludCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IG9mIFNjcm9sbGFibGUgY29udGFpbmVycyB0aGF0IGhvc3QgdGhlIG9yaWdpbiBlbGVtZW50IHNvIHRoYXRcbiAgICAgKiBvbiByZXBvc2l0aW9uIHdlIGNhbiBldmFsdWF0ZSBpZiBpdCBvciB0aGUgb3ZlcmxheSBoYXMgYmVlbiBjbGlwcGVkIG9yIG91dHNpZGUgdmlldy4gRXZlcnlcbiAgICAgKiBTY3JvbGxhYmxlIG11c3QgYmUgYW4gYW5jZXN0b3IgZWxlbWVudCBvZiB0aGUgc3RyYXRlZ3kncyBvcmlnaW4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aXRoU2Nyb2xsYWJsZUNvbnRhaW5lcnMgPSBmdW5jdGlvbiAoc2Nyb2xsYWJsZXMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlcyA9IHNjcm9sbGFibGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBwcmVmZXJyZWQgZmFsbGJhY2sgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIG9yaWdpblBvc1xuICAgICAqIEBwYXJhbSBvdmVybGF5UG9zXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2l0aEZhbGxiYWNrUG9zaXRpb24gPSBmdW5jdGlvbiAob3JpZ2luUG9zLCBvdmVybGF5UG9zKSB7XG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucy5wdXNoKG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKG9yaWdpblBvcywgb3ZlcmxheVBvcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxheW91dCBkaXJlY3Rpb24gc28gdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBjYW4gYmUgYWRqdXN0ZWQgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIGRpciBOZXcgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aXRoRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICB0aGlzLl9kaXIgPSBkaXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBvZmZzZXQgZm9yIHRoZSBvdmVybGF5J3MgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeC1heGlzXG4gICAgICogQHBhcmFtIG9mZnNldCBOZXcgb2Zmc2V0IGluIHRoZSBYIGF4aXMuXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2l0aE9mZnNldFggPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX29mZnNldFggPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBvZmZzZXQgZm9yIHRoZSBvdmVybGF5J3MgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeS1heGlzXG4gICAgICogQHBhcmFtICBvZmZzZXQgTmV3IG9mZnNldCBpbiB0aGUgWSBheGlzLlxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpdGhPZmZzZXRZID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhvcml6b250YWwgKHgpIFwic3RhcnRcIiBkaW1lbnNpb24gYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSBpcyBpbiBhbiBSVEwgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gcmVjdFxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRTdGFydFggPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSdGwgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaG9yaXpvbnRhbCAoeCkgXCJlbmRcIiBkaW1lbnNpb24gYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSBpcyBpbiBhbiBSVEwgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gcmVjdFxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRFbmRYID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnRsID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlICh4LCB5KSBjb29yZGluYXRlIG9mIGEgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgb3JpZ2luIGJhc2VkIG9uIGEgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIG9yaWdpblJlY3RcbiAgICAgKiBAcGFyYW0gcG9zXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuX2dldE9yaWdpbkNvbm5lY3Rpb25Qb2ludCA9IGZ1bmN0aW9uIChvcmlnaW5SZWN0LCBwb3MpIHtcbiAgICAgICAgdmFyIG9yaWdpblN0YXJ0WCA9IHRoaXMuX2dldFN0YXJ0WChvcmlnaW5SZWN0KTtcbiAgICAgICAgdmFyIG9yaWdpbkVuZFggPSB0aGlzLl9nZXRFbmRYKG9yaWdpblJlY3QpO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgaWYgKHBvcy5vcmlnaW5YID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB4ID0gb3JpZ2luU3RhcnRYICsgKG9yaWdpblJlY3Qud2lkdGggLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSBwb3Mub3JpZ2luWCA9PSAnc3RhcnQnID8gb3JpZ2luU3RhcnRYIDogb3JpZ2luRW5kWDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeTtcbiAgICAgICAgaWYgKHBvcy5vcmlnaW5ZID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB5ID0gb3JpZ2luUmVjdC50b3AgKyAob3JpZ2luUmVjdC5oZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHkgPSBwb3Mub3JpZ2luWSA9PSAndG9wJyA/IG9yaWdpblJlY3QudG9wIDogb3JpZ2luUmVjdC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgKHgsIHkpIGNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgb3ZlcmxheSBnaXZlbiBhIGdpdmVuIHBvc2l0aW9uIGFuZFxuICAgICAqIG9yaWdpbiBwb2ludCB0byB3aGljaCB0aGUgb3ZlcmxheSBzaG91bGQgYmUgY29ubmVjdGVkLCBhcyB3ZWxsIGFzIGhvdyBtdWNoIG9mIHRoZSBlbGVtZW50XG4gICAgICogd291bGQgYmUgaW5zaWRlIHRoZSB2aWV3cG9ydCBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRPdmVybGF5UG9pbnQgPSBmdW5jdGlvbiAob3JpZ2luUG9pbnQsIG92ZXJsYXlSZWN0LCB2aWV3cG9ydFJlY3QsIHBvcykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIChvdmVybGF5U3RhcnRYLCBvdmVybGF5U3RhcnRZKSwgdGhlIHN0YXJ0IG9mIHRoZSBwb3RlbnRpYWwgb3ZlcmxheSBwb3NpdGlvblxuICAgICAgICAvLyByZWxhdGl2ZSB0byB0aGUgb3JpZ2luIHBvaW50LlxuICAgICAgICB2YXIgb3ZlcmxheVN0YXJ0WDtcbiAgICAgICAgaWYgKHBvcy5vdmVybGF5WCA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WCA9IC1vdmVybGF5UmVjdC53aWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zLm92ZXJsYXlYID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICBvdmVybGF5U3RhcnRYID0gdGhpcy5faXNSdGwgPyAtb3ZlcmxheVJlY3Qud2lkdGggOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WCA9IHRoaXMuX2lzUnRsID8gMCA6IC1vdmVybGF5UmVjdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3ZlcmxheVN0YXJ0WTtcbiAgICAgICAgaWYgKHBvcy5vdmVybGF5WSA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WSA9IC1vdmVybGF5UmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WSA9IHBvcy5vdmVybGF5WSA9PSAndG9wJyA/IDAgOiAtb3ZlcmxheVJlY3QuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSAoeCwgeSkgY29vcmRpbmF0ZXMgb2YgdGhlIG92ZXJsYXkuXG4gICAgICAgIHZhciB4ID0gb3JpZ2luUG9pbnQueCArIG92ZXJsYXlTdGFydFggKyB0aGlzLl9vZmZzZXRYO1xuICAgICAgICB2YXIgeSA9IG9yaWdpblBvaW50LnkgKyBvdmVybGF5U3RhcnRZICsgdGhpcy5fb2Zmc2V0WTtcbiAgICAgICAgLy8gSG93IG11Y2ggdGhlIG92ZXJsYXkgd291bGQgb3ZlcmZsb3cgYXQgdGhpcyBwb3NpdGlvbiwgb24gZWFjaCBzaWRlLlxuICAgICAgICB2YXIgbGVmdE92ZXJmbG93ID0gMCAtIHg7XG4gICAgICAgIHZhciByaWdodE92ZXJmbG93ID0gKHggKyBvdmVybGF5UmVjdC53aWR0aCkgLSB2aWV3cG9ydFJlY3Qud2lkdGg7XG4gICAgICAgIHZhciB0b3BPdmVyZmxvdyA9IDAgLSB5O1xuICAgICAgICB2YXIgYm90dG9tT3ZlcmZsb3cgPSAoeSArIG92ZXJsYXlSZWN0LmhlaWdodCkgLSB2aWV3cG9ydFJlY3QuaGVpZ2h0O1xuICAgICAgICAvLyBWaXNpYmxlIHBhcnRzIG9mIHRoZSBlbGVtZW50IG9uIGVhY2ggYXhpcy5cbiAgICAgICAgdmFyIHZpc2libGVXaWR0aCA9IHRoaXMuX3N1YnRyYWN0T3ZlcmZsb3dzKG92ZXJsYXlSZWN0LndpZHRoLCBsZWZ0T3ZlcmZsb3csIHJpZ2h0T3ZlcmZsb3cpO1xuICAgICAgICB2YXIgdmlzaWJsZUhlaWdodCA9IHRoaXMuX3N1YnRyYWN0T3ZlcmZsb3dzKG92ZXJsYXlSZWN0LmhlaWdodCwgdG9wT3ZlcmZsb3csIGJvdHRvbU92ZXJmbG93KTtcbiAgICAgICAgLy8gVGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQgdGhhdCdzIHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gICAgICAgIHZhciB2aXNpYmxlQXJlYSA9IHZpc2libGVXaWR0aCAqIHZpc2libGVIZWlnaHQ7XG4gICAgICAgIHZhciBmaXRzSW5WaWV3cG9ydCA9IChvdmVybGF5UmVjdC53aWR0aCAqIG92ZXJsYXlSZWN0LmhlaWdodCkgPT09IHZpc2libGVBcmVhO1xuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCBmaXRzSW5WaWV3cG9ydDogZml0c0luVmlld3BvcnQsIHZpc2libGVBcmVhOiB2aXNpYmxlQXJlYSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldyBwcm9wZXJ0aWVzIG9mIHRoZSB0cmlnZ2VyIGFuZCBvdmVybGF5LCBpbmNsdWRpbmcgd2hldGhlciB0aGV5IGFyZSBjbGlwcGVkXG4gICAgICogb3IgY29tcGxldGVseSBvdXRzaWRlIHRoZSB2aWV3IG9mIGFueSBvZiB0aGUgc3RyYXRlZ3kncyBzY3JvbGxhYmxlcy5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5nZXRTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMgPSBmdW5jdGlvbiAob3ZlcmxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3JpZ2luQm91bmRzID0gdGhpcy5fZ2V0RWxlbWVudEJvdW5kcyh0aGlzLl9vcmlnaW4pO1xuICAgICAgICB2YXIgb3ZlcmxheUJvdW5kcyA9IHRoaXMuX2dldEVsZW1lbnRCb3VuZHMob3ZlcmxheSk7XG4gICAgICAgIHZhciBzY3JvbGxDb250YWluZXJCb3VuZHMgPSB0aGlzLnNjcm9sbGFibGVzLm1hcChmdW5jdGlvbiAoc2Nyb2xsYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRFbGVtZW50Qm91bmRzKHNjcm9sbGFibGUuZ2V0RWxlbWVudFJlZigpLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzT3JpZ2luQ2xpcHBlZDogdGhpcy5pc0VsZW1lbnRDbGlwcGVkKG9yaWdpbkJvdW5kcywgc2Nyb2xsQ29udGFpbmVyQm91bmRzKSxcbiAgICAgICAgICAgIGlzT3JpZ2luT3V0c2lkZVZpZXc6IHRoaXMuaXNFbGVtZW50T3V0c2lkZVZpZXcob3JpZ2luQm91bmRzLCBzY3JvbGxDb250YWluZXJCb3VuZHMpLFxuICAgICAgICAgICAgaXNPdmVybGF5Q2xpcHBlZDogdGhpcy5pc0VsZW1lbnRDbGlwcGVkKG92ZXJsYXlCb3VuZHMsIHNjcm9sbENvbnRhaW5lckJvdW5kcyksXG4gICAgICAgICAgICBpc092ZXJsYXlPdXRzaWRlVmlldzogdGhpcy5pc0VsZW1lbnRPdXRzaWRlVmlldyhvdmVybGF5Qm91bmRzLCBzY3JvbGxDb250YWluZXJCb3VuZHMpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY29tcGxldGVseSBvdXQgb2YgdGhlIHZpZXcgb2YgYW55IG9mIHRoZSBjb250YWluZXJzLiAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmlzRWxlbWVudE91dHNpZGVWaWV3ID0gZnVuY3Rpb24gKGVsZW1lbnRCb3VuZHMsIGNvbnRhaW5lcnNCb3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcnNCb3VuZHMuc29tZShmdW5jdGlvbiAoY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUFib3ZlID0gZWxlbWVudEJvdW5kcy5ib3R0b20gPCBjb250YWluZXJCb3VuZHMudG9wO1xuICAgICAgICAgICAgdmFyIG91dHNpZGVCZWxvdyA9IGVsZW1lbnRCb3VuZHMudG9wID4gY29udGFpbmVyQm91bmRzLmJvdHRvbTtcbiAgICAgICAgICAgIHZhciBvdXRzaWRlTGVmdCA9IGVsZW1lbnRCb3VuZHMucmlnaHQgPCBjb250YWluZXJCb3VuZHMubGVmdDtcbiAgICAgICAgICAgIHZhciBvdXRzaWRlUmlnaHQgPSBlbGVtZW50Qm91bmRzLmxlZnQgPiBjb250YWluZXJCb3VuZHMucmlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gb3V0c2lkZUFib3ZlIHx8IG91dHNpZGVCZWxvdyB8fCBvdXRzaWRlTGVmdCB8fCBvdXRzaWRlUmlnaHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY2xpcHBlZCBieSBhbnkgb2YgdGhlIGNvbnRhaW5lcnMuICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuaXNFbGVtZW50Q2xpcHBlZCA9IGZ1bmN0aW9uIChlbGVtZW50Qm91bmRzLCBjb250YWluZXJzQm91bmRzKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJzQm91bmRzLnNvbWUoZnVuY3Rpb24gKGNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgdmFyIGNsaXBwZWRBYm92ZSA9IGVsZW1lbnRCb3VuZHMudG9wIDwgY29udGFpbmVyQm91bmRzLnRvcDtcbiAgICAgICAgICAgIHZhciBjbGlwcGVkQmVsb3cgPSBlbGVtZW50Qm91bmRzLmJvdHRvbSA+IGNvbnRhaW5lckJvdW5kcy5ib3R0b207XG4gICAgICAgICAgICB2YXIgY2xpcHBlZExlZnQgPSBlbGVtZW50Qm91bmRzLmxlZnQgPCBjb250YWluZXJCb3VuZHMubGVmdDtcbiAgICAgICAgICAgIHZhciBjbGlwcGVkUmlnaHQgPSBlbGVtZW50Qm91bmRzLnJpZ2h0ID4gY29udGFpbmVyQm91bmRzLnJpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGNsaXBwZWRBYm92ZSB8fCBjbGlwcGVkQmVsb3cgfHwgY2xpcHBlZExlZnQgfHwgY2xpcHBlZFJpZ2h0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBoeXNpY2FsbHkgcG9zaXRpb25zIHRoZSBvdmVybGF5IGVsZW1lbnQgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gb3ZlcmxheVBvaW50XG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuX3NldEVsZW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBvdmVybGF5UG9pbnQpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gb3ZlcmxheVBvaW50LnggKyAncHgnO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IG92ZXJsYXlQb2ludC55ICsgJ3B4JztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBib3VuZGluZyBwb3NpdGlvbnMgb2YgdGhlIHByb3ZpZGVkIGVsZW1lbnQgd2l0aCByZXNwZWN0IHRvIHRoZSB2aWV3cG9ydC4gKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0RWxlbWVudEJvdW5kcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBib3VuZGluZ0NsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBib3VuZGluZ0NsaWVudFJlY3QudG9wLFxuICAgICAgICAgICAgcmlnaHQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0ICsgYm91bmRpbmdDbGllbnRSZWN0LndpZHRoLFxuICAgICAgICAgICAgYm90dG9tOiBib3VuZGluZ0NsaWVudFJlY3QudG9wICsgYm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGFtb3VudCB0aGF0IGFuIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgb24gYW4gYXhpcyBmcm9tIGl0J3MgbGVuZ3RoLlxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9zdWJ0cmFjdE92ZXJmbG93cyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIG92ZXJmbG93cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3ZlcmZsb3dzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVyZmxvd3MucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50VmFsdWUsIGN1cnJlbnRPdmVyZmxvdykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSAtIE1hdGgubWF4KGN1cnJlbnRPdmVyZmxvdywgMCk7XG4gICAgICAgIH0sIGxlbmd0aCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbn0oKSk7XG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgcG9zaXRpb25pbmcgb3ZlcmxheXMuIFVzaW5nIHRoaXMgc3RyYXRlZ3ksIGFuIG92ZXJsYXkgaXMgZ2l2ZW4gYW5cbiAqIGV4cGxpY2l0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBicm93c2VyJ3Mgdmlld3BvcnQuIFdlIHVzZSBmbGV4Ym94LCBpbnN0ZWFkIG9mXG4gKiB0cmFuc2Zvcm1zLCBpbiBvcmRlciB0byBhdm9pZCBpc3N1ZXMgd2l0aCBzdWJwaXhlbCByZW5kZXJpbmcgd2hpY2ggY2FuIGNhdXNlIHRoZVxuICogZWxlbWVudCB0byBiZWNvbWUgYmx1cnJ5LlxuICovXG52YXIgR2xvYmFsUG9zaXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2xvYmFsUG9zaXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgdGhpcy5fY3NzUG9zaXRpb24gPSAnc3RhdGljJztcbiAgICAgICAgdGhpcy5fdG9wT2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX2JvdHRvbU9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9sZWZ0T2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX3JpZ2h0T2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnJztcbiAgICAgICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5fd2lkdGggPSAnJztcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCB2ZXJ0aWNhbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHRvcCBvZmZzZXQuXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUudG9wID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2JvdHRvbU9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl90b3BPZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdmbGV4LXN0YXJ0JztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5LiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IGhvcml6b250YWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyBsZWZ0IG9mZnNldC5cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5sZWZ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JpZ2h0T2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX2xlZnRPZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSAnZmxleC1zdGFydCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYm90dG9tIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5LiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IHZlcnRpY2FsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgYm90dG9tIG9mZnNldC5cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5ib3R0b20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdG9wT2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX2JvdHRvbU9mZnNldCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9hbGlnbkl0ZW1zID0gJ2ZsZXgtZW5kJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByaWdodCBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCBob3Jpem9udGFsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgcmlnaHQgb2Zmc2V0LlxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJpZ2h0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xlZnRPZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fcmlnaHRPZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG92ZXJsYXkgd2lkdGggYW5kIGNsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgd2lkdGguXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB3aWR0aCBmb3IgdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICAvLyBXaGVuIHRoZSB3aWR0aCBpcyAxMDAlLCB3ZSBzaG91bGQgcmVzZXQgdGhlIGBsZWZ0YCBhbmQgdGhlIG9mZnNldCxcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgdGhlIGVsZW1lbnQgaXMgZmx1c2ggYWdhaW5zdCB0aGUgdmlld3BvcnQgZWRnZS5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnMTAwJScpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdCgnMHB4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvdmVybGF5IGhlaWdodCBhbmQgY2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCBoZWlnaHQuXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyBoZWlnaHQgZm9yIHRoZSBvdmVybGF5XG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICAvLyBXaGVuIHRoZSBoZWlnaHQgaXMgMTAwJSwgd2Ugc2hvdWxkIHJlc2V0IHRoZSBgdG9wYCBhbmQgdGhlIG9mZnNldCxcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgdGhlIGVsZW1lbnQgaXMgZmx1c2ggYWdhaW5zdCB0aGUgdmlld3BvcnQgZWRnZS5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnMTAwJScpIHtcbiAgICAgICAgICAgIHRoaXMudG9wKCcwcHgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENlbnRlcnMgdGhlIG92ZXJsYXkgaG9yaXpvbnRhbGx5IHdpdGggYW4gb3B0aW9uYWwgb2Zmc2V0LlxuICAgICAqIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgT3ZlcmxheSBvZmZzZXQgZnJvbSB0aGUgaG9yaXpvbnRhbCBjZW50ZXIuXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuY2VudGVySG9yaXpvbnRhbGx5ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gJyc7IH1cbiAgICAgICAgdGhpcy5sZWZ0KG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2NlbnRlcic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2VudGVycyB0aGUgb3ZlcmxheSB2ZXJ0aWNhbGx5IHdpdGggYW4gb3B0aW9uYWwgb2Zmc2V0LlxuICAgICAqIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE92ZXJsYXkgb2Zmc2V0IGZyb20gdGhlIHZlcnRpY2FsIGNlbnRlci5cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5jZW50ZXJWZXJ0aWNhbGx5ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gJyc7IH1cbiAgICAgICAgdGhpcy50b3Aob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgZWxlbWVudC5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRvIGFwcGx5IHRoZSBDU1MuXG4gICAgICogQHJldHVybnMgUmVzb2x2ZWQgd2hlbiB0aGUgc3R5bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93cmFwcGVyKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2Nkay1nbG9iYWwtb3ZlcmxheS13cmFwcGVyJyk7XG4gICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX3dyYXBwZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGVzID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgdmFyIHBhcmVudFN0eWxlcyA9IGVsZW1lbnQucGFyZW50Tm9kZS5zdHlsZTtcbiAgICAgICAgc3R5bGVzLnBvc2l0aW9uID0gdGhpcy5fY3NzUG9zaXRpb247XG4gICAgICAgIHN0eWxlcy5tYXJnaW5Ub3AgPSB0aGlzLl90b3BPZmZzZXQ7XG4gICAgICAgIHN0eWxlcy5tYXJnaW5MZWZ0ID0gdGhpcy5fbGVmdE9mZnNldDtcbiAgICAgICAgc3R5bGVzLm1hcmdpbkJvdHRvbSA9IHRoaXMuX2JvdHRvbU9mZnNldDtcbiAgICAgICAgc3R5bGVzLm1hcmdpblJpZ2h0ID0gdGhpcy5fcmlnaHRPZmZzZXQ7XG4gICAgICAgIHN0eWxlcy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBzdHlsZXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBwYXJlbnRTdHlsZXMuanVzdGlmeUNvbnRlbnQgPSB0aGlzLl9qdXN0aWZ5Q29udGVudDtcbiAgICAgICAgcGFyZW50U3R5bGVzLmFsaWduSXRlbXMgPSB0aGlzLl9hbGlnbkl0ZW1zO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgd3JhcHBlciBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fd3JhcHBlciAmJiB0aGlzLl93cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl93cmFwcGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR2xvYmFsUG9zaXRpb25TdHJhdGVneTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDEyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogQnVpbGRlciBmb3Igb3ZlcmxheSBwb3NpdGlvbiBzdHJhdGVneS4gKi9cbnZhciBPdmVybGF5UG9zaXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5UG9zaXRpb25CdWlsZGVyKF92aWV3cG9ydFJ1bGVyKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0UnVsZXIgPSBfdmlld3BvcnRSdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdsb2JhbCBwb3NpdGlvbiBzdHJhdGVneS5cbiAgICAgKi9cbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2xvYmFsUG9zaXRpb25TdHJhdGVneSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlbGF0aXZlIHBvc2l0aW9uIHN0cmF0ZWd5LlxuICAgICAqIEBwYXJhbSBlbGVtZW50UmVmXG4gICAgICogQHBhcmFtIG9yaWdpblBvc1xuICAgICAqIEBwYXJhbSBvdmVybGF5UG9zXG4gICAgICovXG4gICAgT3ZlcmxheVBvc2l0aW9uQnVpbGRlci5wcm90b3R5cGUuY29ubmVjdGVkVG8gPSBmdW5jdGlvbiAoZWxlbWVudFJlZiwgb3JpZ2luUG9zLCBvdmVybGF5UG9zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneShlbGVtZW50UmVmLCBvcmlnaW5Qb3MsIG92ZXJsYXlQb3MsIHRoaXMuX3ZpZXdwb3J0UnVsZXIpO1xuICAgIH07XG4gICAgT3ZlcmxheVBvc2l0aW9uQnVpbGRlciA9IF9fZGVjb3JhdGUkMTIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1ZpZXdwb3J0UnVsZXJdKVxuICAgIF0sIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIpO1xuICAgIHJldHVybiBPdmVybGF5UG9zaXRpb25CdWlsZGVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVGhlIE92ZXJsYXlDb250YWluZXIgaXMgdGhlIGNvbnRhaW5lciBpbiB3aGljaCBhbGwgb3ZlcmxheXMgd2lsbCBsb2FkLlxuICogSXQgc2hvdWxkIGJlIHByb3ZpZGVkIGluIHRoZSByb290IGNvbXBvbmVudCB0byBlbnN1cmUgaXQgaXMgcHJvcGVybHkgc2hhcmVkLlxuICovXG52YXIgT3ZlcmxheUNvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheUNvbnRhaW5lcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgb3ZlcmxheSBjb250YWluZXIgZWxlbWVudC4gIEl0IHdpbGwgbGF6aWx5XG4gICAgICogY3JlYXRlIHRoZSBlbGVtZW50IHRoZSBmaXJzdCB0aW1lICBpdCBpcyBjYWxsZWQgdG8gZmFjaWxpdGF0ZSB1c2luZ1xuICAgICAqIHRoZSBjb250YWluZXIgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICAgICAqIEByZXR1cm5zIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgICAqL1xuICAgIE92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLmdldENvbnRhaW5lckVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIG92ZXJsYXkgY29udGFpbmVyIGVsZW1lbnQsIHdoaWNoIGlzIHNpbXBseSBhIGRpdlxuICAgICAqIHdpdGggdGhlICdjZGstb3ZlcmxheS1jb250YWluZXInIGNsYXNzIG9uIHRoZSBkb2N1bWVudCBib2R5LlxuICAgICAqL1xuICAgIE92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LWNvbnRhaW5lcicpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXI7XG4gICAgfTtcbiAgICBPdmVybGF5Q29udGFpbmVyID0gX19kZWNvcmF0ZSQxNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBPdmVybGF5Q29udGFpbmVyKTtcbiAgICByZXR1cm4gT3ZlcmxheUNvbnRhaW5lcjtcbn0oKSk7XG5mdW5jdGlvbiBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudENvbnRhaW5lcikge1xuICAgIHJldHVybiBwYXJlbnRDb250YWluZXIgfHwgbmV3IE92ZXJsYXlDb250YWluZXIoKTtcbn1cblxudmFyIE9WRVJMQVlfQ09OVEFJTkVSX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gT3ZlcmxheUNvbnRhaW5lciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IE92ZXJsYXlDb250YWluZXIsXG4gICAgZGVwczogW1tuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpLCBPdmVybGF5Q29udGFpbmVyXV0sXG4gICAgdXNlRmFjdG9yeTogT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVJfRkFDVE9SWVxufTtcblxudmFyIF9fZGVjb3JhdGUkMTEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBOZXh0IG92ZXJsYXkgdW5pcXVlIElELiAqL1xudmFyIG5leHRVbmlxdWVJZCA9IDA7XG4vKiogVGhlIGRlZmF1bHQgc3RhdGUgZm9yIG5ld2x5IGNyZWF0ZWQgb3ZlcmxheXMuICovXG52YXIgZGVmYXVsdFN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGNyZWF0ZSBPdmVybGF5cy4gT3ZlcmxheXMgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHBpZWNlcyBvZiBmbG9hdGluZyBVSSwgbWVhbnQgdG8gYmVcbiAqIHVzZWQgYXMgYSBsb3ctbGV2ZWwgYnVpbGRpbmcgYnVpbGRpbmcgYmxvY2sgZm9yIG90aGVyIGNvbXBvbmVudHMuIERpYWxvZ3MsIHRvb2x0aXBzLCBtZW51cyxcbiAqIHNlbGVjdHMsIGV0Yy4gY2FuIGFsbCBiZSBidWlsdCB1c2luZyBvdmVybGF5cy4gVGhlIHNlcnZpY2Ugc2hvdWxkIHByaW1hcmlseSBiZSB1c2VkIGJ5IGF1dGhvcnNcbiAqIG9mIHJlLXVzYWJsZSBjb21wb25lbnRzIHJhdGhlciB0aGFuIGRldmVsb3BlcnMgYnVpbGRpbmcgZW5kLXVzZXIgYXBwbGljYXRpb25zLlxuICpcbiAqIEFuIG92ZXJsYXkgKmlzKiBhIFBvcnRhbEhvc3QsIHNvIGFueSBraW5kIG9mIFBvcnRhbCBjYW4gYmUgbG9hZGVkIGludG8gb25lLlxuICovXG52YXIgT3ZlcmxheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheShfb3ZlcmxheUNvbnRhaW5lciwgX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgX3Bvc2l0aW9uQnVpbGRlciwgX2FwcFJlZiwgX2luamVjdG9yLCBfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlDb250YWluZXIgPSBfb3ZlcmxheUNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25CdWlsZGVyID0gX3Bvc2l0aW9uQnVpbGRlcjtcbiAgICAgICAgdGhpcy5fYXBwUmVmID0gX2FwcFJlZjtcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gc3RhdGUgU3RhdGUgdG8gYXBwbHkgdG8gdGhlIG92ZXJsYXkuXG4gICAgICogQHJldHVybnMgUmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIG92ZXJsYXkuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG4gICAgICAgIGlmIChzdGF0ZSQkMSA9PT0gdm9pZCAwKSB7IHN0YXRlJCQxID0gZGVmYXVsdFN0YXRlOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVPdmVybGF5UmVmKHRoaXMuX2NyZWF0ZVBhbmVFbGVtZW50KCksIHN0YXRlJCQxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb3NpdGlvbiBidWlsZGVyIHRoYXQgY2FuIGJlIHVzZWQsIHZpYSBmbHVlbnQgQVBJLFxuICAgICAqIHRvIGNvbnN0cnVjdCBhbmQgY29uZmlndXJlIGEgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbkJ1aWxkZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBET00gZWxlbWVudCBmb3IgYW4gb3ZlcmxheSBhbmQgYXBwZW5kcyBpdCB0byB0aGUgb3ZlcmxheSBjb250YWluZXIuXG4gICAgICogQHJldHVybnMgTmV3bHktY3JlYXRlZCBwYW5lIGVsZW1lbnRcbiAgICAgKi9cbiAgICBPdmVybGF5LnByb3RvdHlwZS5fY3JlYXRlUGFuZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHBhbmUuaWQgPSBcImNkay1vdmVybGF5LVwiICsgbmV4dFVuaXF1ZUlkKys7XG4gICAgICAgIHBhbmUuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktcGFuZScpO1xuICAgICAgICB0aGlzLl9vdmVybGF5Q29udGFpbmVyLmdldENvbnRhaW5lckVsZW1lbnQoKS5hcHBlbmRDaGlsZChwYW5lKTtcbiAgICAgICAgcmV0dXJuIHBhbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBEb21Qb3J0YWxIb3N0IGludG8gd2hpY2ggdGhlIG92ZXJsYXkgY29udGVudCBjYW4gYmUgbG9hZGVkLlxuICAgICAqIEBwYXJhbSBwYW5lIFRoZSBET00gZWxlbWVudCB0byB0dXJuIGludG8gYSBwb3J0YWwgaG9zdC5cbiAgICAgKiBAcmV0dXJucyBBIHBvcnRhbCBob3N0IGZvciB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuX2NyZWF0ZVBvcnRhbEhvc3QgPSBmdW5jdGlvbiAocGFuZSkge1xuICAgICAgICByZXR1cm4gbmV3IERvbVBvcnRhbEhvc3QocGFuZSwgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCB0aGlzLl9hcHBSZWYsIHRoaXMuX2luamVjdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT3ZlcmxheVJlZiBmb3IgYW4gb3ZlcmxheSBpbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHBhbmUgRE9NIGVsZW1lbnQgZm9yIHRoZSBvdmVybGF5XG4gICAgICogQHBhcmFtIHN0YXRlXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXlSZWYgPSBmdW5jdGlvbiAocGFuZSwgc3RhdGUkJDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybGF5UmVmKHRoaXMuX2NyZWF0ZVBvcnRhbEhvc3QocGFuZSksIHBhbmUsIHN0YXRlJCQxLCB0aGlzLl9uZ1pvbmUpO1xuICAgIH07XG4gICAgT3ZlcmxheSA9IF9fZGVjb3JhdGUkMTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXlDb250YWluZXIsIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBPdmVybGF5UG9zaXRpb25CdWlsZGVyLCBfYW5ndWxhcl9jb3JlLkFwcGxpY2F0aW9uUmVmLCBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCBfYW5ndWxhcl9jb3JlLk5nWm9uZV0pXG4gICAgXSwgT3ZlcmxheSk7XG4gICAgcmV0dXJuIE92ZXJsYXk7XG59KCkpO1xuLyoqIFByb3ZpZGVycyBmb3IgT3ZlcmxheSBhbmQgaXRzIHJlbGF0ZWQgaW5qZWN0YWJsZXMuICovXG52YXIgT1ZFUkxBWV9QUk9WSURFUlMgPSBbXG4gICAgT3ZlcmxheSxcbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLFxuICAgIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSLFxuICAgIFNDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSLFxuICAgIE9WRVJMQVlfQ09OVEFJTkVSX1BST1ZJREVSLFxuXTtcblxudmFyIF9fZGVjb3JhdGUkMTUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogU2VuZHMgYW4gZXZlbnQgd2hlbiB0aGUgZGlyZWN0aXZlJ3MgZWxlbWVudCBpcyBzY3JvbGxlZC4gUmVnaXN0ZXJzIGl0c2VsZiB3aXRoIHRoZVxuICogU2Nyb2xsRGlzcGF0Y2hlciBzZXJ2aWNlIHRvIGluY2x1ZGUgaXRzZWxmIGFzIHBhcnQgb2YgaXRzIGNvbGxlY3Rpb24gb2Ygc2Nyb2xsaW5nIGV2ZW50cyB0aGF0IGl0XG4gKiBjYW4gYmUgbGlzdGVuZWQgdG8gdGhyb3VnaCB0aGUgc2VydmljZS5cbiAqL1xudmFyIFNjcm9sbGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbGFibGUoX2VsZW1lbnRSZWYsIF9zY3JvbGwpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9zY3JvbGwgPSBfc2Nyb2xsO1xuICAgIH1cbiAgICBTY3JvbGxhYmxlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsLnJlZ2lzdGVyKHRoaXMpO1xuICAgIH07XG4gICAgU2Nyb2xsYWJsZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbC5kZXJlZ2lzdGVyKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiBhIHNjcm9sbCBldmVudCBpcyBmaXJlZCBvbiB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqL1xuICAgIFNjcm9sbGFibGUucHJvdG90eXBlLmVsZW1lbnRTY3JvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLmZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdzY3JvbGwnKTtcbiAgICB9O1xuICAgIFNjcm9sbGFibGUucHJvdG90eXBlLmdldEVsZW1lbnRSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmO1xuICAgIH07XG4gICAgU2Nyb2xsYWJsZSA9IF9fZGVjb3JhdGUkMTUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstc2Nyb2xsYWJsZV0nXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBTY3JvbGxEaXNwYXRjaGVyXSlcbiAgICBdLCBTY3JvbGxhYmxlKTtcbiAgICByZXR1cm4gU2Nyb2xsYWJsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDEwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqIERlZmF1bHQgc2V0IG9mIHBvc2l0aW9ucyBmb3IgdGhlIG92ZXJsYXkuIEZvbGxvd3MgdGhlIGJlaGF2aW9yIG9mIGEgZHJvcGRvd24uICovXG52YXIgZGVmYXVsdFBvc2l0aW9uTGlzdCA9IFtcbiAgICBuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcih7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAndG9wJyB9KSxcbiAgICBuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcih7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICd0b3AnIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9KSxcbl07XG4vKipcbiAqIERpcmVjdGl2ZSBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgdG8gbWFrZSBpdCB1c2FibGUgYXMgYW4gb3JpZ2luIGZvciBhbiBPdmVybGF5IHVzaW5nIGFcbiAqIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kuXG4gKi9cbnZhciBPdmVybGF5T3JpZ2luID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5T3JpZ2luKGVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICB9XG4gICAgT3ZlcmxheU9yaWdpbiA9IF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstb3ZlcmxheS1vcmlnaW5dLCBbb3ZlcmxheS1vcmlnaW5dJyxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrT3ZlcmxheU9yaWdpbicsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBPdmVybGF5T3JpZ2luKTtcbiAgICByZXR1cm4gT3ZlcmxheU9yaWdpbjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB0byBmYWNpbGl0YXRlIGRlY2xhcmF0aXZlIGNyZWF0aW9uIG9mIGFuIE92ZXJsYXkgdXNpbmcgYSBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LlxuICovXG52YXIgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyhqZWxib3Vybik6IGlucHV0cyBmb3Igc2l6ZSwgc2Nyb2xsIGJlaGF2aW9yLCBhbmltYXRpb24sIGV0Yy5cbiAgICBmdW5jdGlvbiBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlKF9vdmVybGF5LCB0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZiwgX2Rpcikge1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFzQmFja2Ryb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IDA7XG4gICAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBiYWNrZHJvcCBpcyBjbGlja2VkLiAqL1xuICAgICAgICB0aGlzLmJhY2tkcm9wQ2xpY2sgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWQuICovXG4gICAgICAgIHRoaXMucG9zaXRpb25DaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBhdHRhY2hlZC4gKi9cbiAgICAgICAgdGhpcy5hdHRhY2ggPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3ZlcmxheSBoYXMgYmVlbiBkZXRhY2hlZC4gKi9cbiAgICAgICAgdGhpcy5kZXRhY2ggPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVQb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0WFwiLCB7XG4gICAgICAgIC8qKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeC1heGlzICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldFgpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFggPSBvZmZzZXRYO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24ud2l0aE9mZnNldFgob2Zmc2V0WCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRZXCIsIHtcbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB5LWF4aXMgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob2Zmc2V0WSkge1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbi53aXRoT2Zmc2V0WShvZmZzZXRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcImhhc0JhY2tkcm9wXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHNob3VsZCBhdHRhY2ggYSBiYWNrZHJvcC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzQmFja2Ryb3A7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNCYWNrZHJvcCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcGVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID8gdGhpcy5fYXR0YWNoT3ZlcmxheSgpIDogdGhpcy5fZGV0YWNoT3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5fb3BlbiA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3ZlcmxheVJlZlwiLCB7XG4gICAgICAgIC8qKiBUaGUgYXNzb2NpYXRlZCBvdmVybGF5IHJlZmVyZW5jZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgICAgIC8qKiBUaGUgZWxlbWVudCdzIGxheW91dCBkaXJlY3Rpb24uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA6ICdsdHInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveU92ZXJsYXkoKTtcbiAgICB9O1xuICAgIC8qKiBDcmVhdGVzIGFuIG92ZXJsYXkgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvc2l0aW9ucyB8fCAhdGhpcy5wb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IGRlZmF1bHRQb3NpdGlvbkxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKHRoaXMuX2J1aWxkQ29uZmlnKCkpO1xuICAgIH07XG4gICAgLyoqIEJ1aWxkcyB0aGUgb3ZlcmxheSBjb25maWcgYmFzZWQgb24gdGhlIGRpcmVjdGl2ZSdzIGlucHV0cyAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9idWlsZENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG92ZXJsYXlDb25maWcgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIGlmICh0aGlzLndpZHRoIHx8IHRoaXMud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCB8fCB0aGlzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgb3ZlcmxheUNvbmZpZy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCB8fCB0aGlzLm1pbldpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5IZWlnaHQgfHwgdGhpcy5taW5IZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcubWluSGVpZ2h0ID0gdGhpcy5taW5IZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgb3ZlcmxheUNvbmZpZy5oYXNCYWNrZHJvcCA9IHRoaXMuaGFzQmFja2Ryb3A7XG4gICAgICAgIGlmICh0aGlzLmJhY2tkcm9wQ2xhc3MpIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcuYmFja2Ryb3BDbGFzcyA9IHRoaXMuYmFja2Ryb3BDbGFzcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2NyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICAgICAgb3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fcG9zaXRpb247XG4gICAgICAgIG92ZXJsYXlDb25maWcuZGlyZWN0aW9uID0gdGhpcy5kaXI7XG4gICAgICAgIHJldHVybiBvdmVybGF5Q29uZmlnO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IG9mIHRoZSBvdmVybGF5IHRvIGJlIHNldCBvbiB0aGUgb3ZlcmxheSBjb25maWcgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fY3JlYXRlUG9zaXRpb25TdHJhdGVneSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb25zWzBdO1xuICAgICAgICB2YXIgb3JpZ2luUG9pbnQgPSB7IG9yaWdpblg6IHBvcy5vcmlnaW5YLCBvcmlnaW5ZOiBwb3Mub3JpZ2luWSB9O1xuICAgICAgICB2YXIgb3ZlcmxheVBvaW50ID0geyBvdmVybGF5WDogcG9zLm92ZXJsYXlYLCBvdmVybGF5WTogcG9zLm92ZXJsYXlZIH07XG4gICAgICAgIHZhciBzdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMub3JpZ2luLmVsZW1lbnRSZWYsIG9yaWdpblBvaW50LCBvdmVybGF5UG9pbnQpXG4gICAgICAgICAgICAud2l0aERpcmVjdGlvbih0aGlzLmRpcilcbiAgICAgICAgICAgIC53aXRoT2Zmc2V0WCh0aGlzLm9mZnNldFgpXG4gICAgICAgICAgICAud2l0aE9mZnNldFkodGhpcy5vZmZzZXRZKTtcbiAgICAgICAgdGhpcy5faGFuZGxlUG9zaXRpb25DaGFuZ2VzKHN0cmF0ZWd5KTtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgIH07XG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2hhbmRsZVBvc2l0aW9uQ2hhbmdlcyA9IGZ1bmN0aW9uIChzdHJhdGVneSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHJhdGVneS53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6IHRoaXMucG9zaXRpb25zW2ldLm9yaWdpblgsIG9yaWdpblk6IHRoaXMucG9zaXRpb25zW2ldLm9yaWdpblkgfSwgeyBvdmVybGF5WDogdGhpcy5wb3NpdGlvbnNbaV0ub3ZlcmxheVgsIG92ZXJsYXlZOiB0aGlzLnBvc2l0aW9uc1tpXS5vdmVybGF5WSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICBzdHJhdGVneS5vblBvc2l0aW9uQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAocG9zKSB7IHJldHVybiBfdGhpcy5wb3NpdGlvbkNoYW5nZS5lbWl0KHBvcyk7IH0pO1xuICAgIH07XG4gICAgLyoqIEF0dGFjaGVzIHRoZSBvdmVybGF5IGFuZCBzdWJzY3JpYmVzIHRvIGJhY2tkcm9wIGNsaWNrcyBpZiBiYWNrZHJvcCBleGlzdHMgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fYXR0YWNoT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3RlbXBsYXRlUG9ydGFsKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoLmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNCYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24gPSB0aGlzLl9vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmJhY2tkcm9wQ2xpY2suZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEZXRhY2hlcyB0aGUgb3ZlcmxheSBhbmQgdW5zdWJzY3JpYmVzIHRvIGJhY2tkcm9wIGNsaWNrcyBpZiBiYWNrZHJvcCBleGlzdHMgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fZGV0YWNoT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLmRldGFjaC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRGVzdHJveXMgdGhlIG92ZXJsYXkgY3JlYXRlZCBieSB0aGlzIGRpcmVjdGl2ZS4gKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fZGVzdHJveU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPdmVybGF5T3JpZ2luKVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9yaWdpblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIEFycmF5KVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcInBvc2l0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRYXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRZXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwibWluV2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwibWluSGVpZ2h0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcImJhY2tkcm9wQ2xhc3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGFzQmFja2Ryb3BcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9wZW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJiYWNrZHJvcENsaWNrXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwb3NpdGlvbkNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXR0YWNoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkZXRhY2hcIiwgdm9pZCAwKTtcbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nkay1jb25uZWN0ZWQtb3ZlcmxheV0sIFtjb25uZWN0ZWQtb3ZlcmxheV0nLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdjZGtDb25uZWN0ZWRPdmVybGF5J1xuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQxKDMsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPdmVybGF5LCBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIERpcl0pXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmU7XG59KCkpO1xudmFyIE92ZXJsYXlNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE92ZXJsYXlNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlNb2R1bGUgPSBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbUG9ydGFsTW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLCBPdmVybGF5T3JpZ2luLCBTY3JvbGxhYmxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0Nvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUsIE92ZXJsYXlPcmlnaW4sIFNjcm9sbGFibGVdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbT1ZFUkxBWV9QUk9WSURFUlNdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgT3ZlcmxheU1vZHVsZSk7XG4gICAgcmV0dXJuIE92ZXJsYXlNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQxOSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxOSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLy8gV2hldGhlciB0aGUgY3VycmVudCBwbGF0Zm9ybSBzdXBwb3J0cyB0aGUgVjggQnJlYWsgSXRlcmF0b3IuIFRoZSBWOCBjaGVja1xuLy8gaXMgbmVjZXNzYXJ5IHRvIGRldGVjdCBhbGwgQmxpbmsgYmFzZWQgYnJvd3NlcnMuXG52YXIgaGFzVjhCcmVha0l0ZXJhdG9yID0gdHlwZW9mICh3aW5kb3cpICE9PSAndW5kZWZpbmVkJyA/XG4gICAgKHdpbmRvdy5JbnRsICYmIHdpbmRvdy5JbnRsLnY4QnJlYWtJdGVyYXRvcikgOlxuICAgICh0eXBlb2YgKEludGwpICE9PSAndW5kZWZpbmVkJyAmJiBJbnRsLnY4QnJlYWtJdGVyYXRvcik7XG4vKipcbiAqIFNlcnZpY2UgdG8gZGV0ZWN0IHRoZSBjdXJyZW50IHBsYXRmb3JtIGJ5IGNvbXBhcmluZyB0aGUgdXNlckFnZW50IHN0cmluZ3MgYW5kXG4gKiBjaGVja2luZyBicm93c2VyLXNwZWNpZmljIGdsb2JhbCBwcm9wZXJ0aWVzLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgUGxhdGZvcm0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYXRmb3JtKCkge1xuICAgICAgICAvKiogTGF5b3V0IEVuZ2luZXMgKi9cbiAgICAgICAgdGhpcy5FREdFID0gLyhlZGdlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHRoaXMuVFJJREVOVCA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIC8vIEVkZ2VIVE1MIGFuZCBUcmlkZW50IG1vY2sgQmxpbmsgc3BlY2lmaWMgdGhpbmdzIGFuZCBuZWVkIHRvIGV4Y2x1ZGVkIGZyb20gdGhpcyBjaGVjay5cbiAgICAgICAgdGhpcy5CTElOSyA9ICEhKHdpbmRvdy5jaHJvbWUgfHwgaGFzVjhCcmVha0l0ZXJhdG9yKSAmJiAhIUNTUyAmJiAhdGhpcy5FREdFICYmICF0aGlzLlRSSURFTlQ7XG4gICAgICAgIC8vIFdlYmtpdCBpcyBwYXJ0IG9mIHRoZSB1c2VyQWdlbnQgaW4gRWRnZUhUTUwgQmxpbmsgYW5kIFRyaWRlbnQsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgV2Via2l0IHJ1bnMgc3RhbmRhbG9uZSBhbmQgaXMgbm90IHVzZSBhcyBhbm90aGVyIGVuZ2luZXMgYmFzZS5cbiAgICAgICAgdGhpcy5XRUJLSVQgPSAvQXBwbGVXZWJLaXQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLkJMSU5LICYmICF0aGlzLkVER0UgJiYgIXRoaXMuVFJJREVOVDtcbiAgICAgICAgLyoqIEJyb3dzZXJzIGFuZCBQbGF0Zm9ybSBUeXBlcyAqL1xuICAgICAgICB0aGlzLklPUyA9IC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG4gICAgICAgIC8vIEl0J3MgZGlmZmljdWx0IHRvIGRldGVjdCB0aGUgcGxhaW4gR2Vja28gZW5naW5lLCBiZWNhdXNlIG1vc3Qgb2YgdGhlIGJyb3dzZXJzIGlkZW50aWZ5XG4gICAgICAgIC8vIHRoZW0gc2VsZiBhcyBHZWNrby1saWtlIGJyb3dzZXJzIGFuZCBtb2RpZnkgdGhlIHVzZXJBZ2VudCdzIGFjY29yZGluZyB0byB0aGF0LlxuICAgICAgICAvLyBTaW5jZSB3ZSBvbmx5IGNvdmVyIG9uZSBleHBsaWNpdCBGaXJlZm94IGNhc2UsIHdlIGNhbiBzaW1wbHkgY2hlY2sgZm9yIEZpcmVmb3hcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBoYXZpbmcgYW4gdW5zdGFibGUgY2hlY2sgZm9yIEdlY2tvLlxuICAgICAgICB0aGlzLkZJUkVGT1ggPSAvKGZpcmVmb3h8bWluZWZpZWxkKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIC8vIFRyaWRlbnQgb24gbW9iaWxlIGFkZHMgdGhlIGFuZHJvaWQgcGxhdGZvcm0gdG8gdGhlIHVzZXJBZ2VudCB0byB0cmljayBkZXRlY3Rpb25zLlxuICAgICAgICB0aGlzLkFORFJPSUQgPSAvYW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXRoaXMuVFJJREVOVDtcbiAgICB9XG4gICAgUGxhdGZvcm0gPSBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDE5KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIFBsYXRmb3JtKTtcbiAgICByZXR1cm4gUGxhdGZvcm07XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQxOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxOCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBUaGUgSW50ZXJhY3Rpdml0eUNoZWNrZXIgbGVhbnMgaGVhdmlseSBvbiB0aGUgYWxseS5qcyBhY2Nlc3NpYmlsaXR5IHV0aWxpdGllcy5cbiAqIE1ldGhvZHMgbGlrZSBgaXNUYWJiYWJsZWAgYXJlIG9ubHkgY292ZXJpbmcgc3BlY2lmaWMgZWRnZS1jYXNlcyBmb3IgdGhlIGJyb3dzZXJzIHdoaWNoIGFyZVxuICogc3VwcG9ydGVkLlxuICovXG4vKipcbiAqIFV0aWxpdHkgZm9yIGNoZWNraW5nIHRoZSBpbnRlcmFjdGl2aXR5IG9mIGFuIGVsZW1lbnQsIHN1Y2ggYXMgd2hldGhlciBpcyBpcyBmb2N1c2FibGUgb3JcbiAqIHRhYmJhYmxlLlxuICovXG52YXIgSW50ZXJhY3Rpdml0eUNoZWNrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVyYWN0aXZpdHlDaGVja2VyKF9wbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgZGlzYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBJbnRlcmFjdGl2aXR5Q2hlY2tlci5wcm90b3R5cGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIFRoaXMgZG9lcyBub3QgY2FwdHVyZSBzb21lIGNhc2VzLCBzdWNoIGFzIGEgbm9uLWZvcm0gY29udHJvbCB3aXRoIGEgZGlzYWJsZWQgYXR0cmlidXRlIG9yXG4gICAgICAgIC8vIGEgZm9ybSBjb250cm9sIGluc2lkZSBvZiBhIGRpc2FibGVkIGZvcm0sIGJ1dCBzaG91bGQgY2FwdHVyZSB0aGUgbW9zdCBjb21tb24gY2FzZXMuXG4gICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIHZpc2libGUgZm9yIHRoZSBwdXJwb3NlcyBvZiBpbnRlcmFjdGl2aXR5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNhcHR1cmUgc3RhdGVzIGxpa2UgYGRpc3BsYXk6IG5vbmVgIGFuZCBgdmlzaWJpbGl0eTogaGlkZGVuYCwgYnV0IG5vdCB0aGluZ3MgbGlrZVxuICAgICAqIGJlaW5nIGNsaXBwZWQgYnkgYW4gYG92ZXJmbG93OiBoaWRkZW5gIHBhcmVudCBvciBiZWluZyBvdXRzaWRlIHRoZSB2aWV3cG9ydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBJbnRlcmFjdGl2aXR5Q2hlY2tlci5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhc0dlb21ldHJ5KGVsZW1lbnQpICYmIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgY2FuIGJlIHJlYWNoZWQgdmlhIFRhYiBrZXkuXG4gICAgICogQXNzdW1lcyB0aGF0IHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZCB3aXRoIGlzRm9jdXNhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGFiYmFibGUuXG4gICAgICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzVGFiYmFibGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgZnJhbWVFbGVtZW50ID0gZ2V0V2luZG93KGVsZW1lbnQpLmZyYW1lRWxlbWVudDtcbiAgICAgICAgaWYgKGZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGZyYW1lVHlwZSA9IGZyYW1lRWxlbWVudCAmJiBmcmFtZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIC8vIEZyYW1lIGVsZW1lbnRzIGluaGVyaXQgdGhlaXIgdGFiaW5kZXggb250byBhbGwgY2hpbGQgZWxlbWVudHMuXG4gICAgICAgICAgICBpZiAoZ2V0VGFiSW5kZXhWYWx1ZShmcmFtZUVsZW1lbnQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlYmtpdCBhbmQgQmxpbmsgY29uc2lkZXIgYW55dGhpbmcgaW5zaWRlIG9mIGFuIDxvYmplY3Q+IGVsZW1lbnQgYXMgbm9uLXRhYmJhYmxlLlxuICAgICAgICAgICAgaWYgKCh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5XRUJLSVQpICYmIGZyYW1lVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZWJraXQgYW5kIEJsaW5rIGRpc2FibGUgdGFiYmluZyB0byBhbiBlbGVtZW50IGluc2lkZSBvZiBhbiBpbnZpc2libGUgZnJhbWUuXG4gICAgICAgICAgICBpZiAoKHRoaXMuX3BsYXRmb3JtLkJMSU5LIHx8IHRoaXMuX3BsYXRmb3JtLldFQktJVCkgJiYgIXRoaXMuaXNWaXNpYmxlKGZyYW1lRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgdGFiSW5kZXhWYWx1ZSA9IGdldFRhYkluZGV4VmFsdWUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWJJbmRleFZhbHVlICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdpZnJhbWUnKSB7XG4gICAgICAgICAgICAvLyBUaGUgZnJhbWVzIG1heSBiZSB0YWJiYWJsZSBkZXBlbmRpbmcgb24gY29udGVudCwgYnV0IGl0J3Mgbm90IHBvc3NpYmx5IHRvIHJlbGlhYmx5XG4gICAgICAgICAgICAvLyBpbnZlc3RpZ2F0ZSB0aGUgY29udGVudCBvZiB0aGUgZnJhbWVzLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xuICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQgYW4gPGF1ZGlvPiBlbGVtZW50IHdpdGhvdXQgdGhlIGNvbnRyb2xzIGVuYWJsZWQgaXMgbm90IHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BsYXRmb3JtLkJMSU5LKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gQmxpbmsgPGF1ZGlvIGNvbnRyb2xzPiBlbGVtZW50cyBhcmUgYWx3YXlzIHRhYmJhYmxlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSAmJiB0aGlzLl9wbGF0Zm9ybS5UUklERU5UKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gVHJpZGVudCBhIDx2aWRlbz4gZWxlbWVudCB3aXRob3V0IHRoZSBjb250cm9scyBlbmFibGVkIGlzIG5vdCB0YWJiYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5GSVJFRk9YKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gQ2hyb21lIGFuZCBGaXJlZm94IDx2aWRlbyBjb250cm9scz4gZWxlbWVudHMgYXJlIGFsd2F5cyB0YWJiYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdvYmplY3QnICYmICh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5XRUJLSVQpKSB7XG4gICAgICAgICAgICAvLyBJbiBhbGwgQmxpbmsgYW5kIFdlYktpdCBiYXNlZCBicm93c2VycyA8b2JqZWN0PiBlbGVtZW50cyBhcmUgbmV2ZXIgdGFiYmFibGUuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gaU9TIHRoZSBicm93c2VyIG9ubHkgY29uc2lkZXJzIHNvbWUgc3BlY2lmaWMgZWxlbWVudHMgYXMgdGFiYmFibGUuXG4gICAgICAgIGlmICh0aGlzLl9wbGF0Zm9ybS5XRUJLSVQgJiYgdGhpcy5fcGxhdGZvcm0uSU9TICYmICFpc1BvdGVudGlhbGx5VGFiYmFibGVJT1MoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudC50YWJJbmRleCA+PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgY2FuIGJlIGZvY3VzZWQgYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZWxlbWVudCBpcyBmb2N1c2FibGUuXG4gICAgICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzRm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBjaGVja3MgaW4gb3JkZXIgb2YgbGVmdCB0byBtb3N0IGV4cGVuc2l2ZS5cbiAgICAgICAgLy8gQWdhaW4sIG5haXZlIGFwcHJvYWNoIHRoYXQgZG9lcyBub3QgY2FwdHVyZSBtYW55IGVkZ2UgY2FzZXMgYW5kIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgICByZXR1cm4gaXNQb3RlbnRpYWxseUZvY3VzYWJsZShlbGVtZW50KSAmJiAhdGhpcy5pc0Rpc2FibGVkKGVsZW1lbnQpICYmIHRoaXMuaXNWaXNpYmxlKGVsZW1lbnQpO1xuICAgIH07XG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIgPSBfX2RlY29yYXRlJDE4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDE4KCdkZXNpZ246cGFyYW10eXBlcycsIFtQbGF0Zm9ybV0pXG4gICAgXSwgSW50ZXJhY3Rpdml0eUNoZWNrZXIpO1xuICAgIHJldHVybiBJbnRlcmFjdGl2aXR5Q2hlY2tlcjtcbn0oKSk7XG4vKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBlbGVtZW50IGhhcyBhbnkgZ2VvbWV0cnkgLyByZWN0YW5nbGVzLiAqL1xuZnVuY3Rpb24gaGFzR2VvbWV0cnkoZWxlbWVudCkge1xuICAgIC8vIFVzZSBsb2dpYyBmcm9tIGpRdWVyeSB0byBjaGVjayBmb3IgYW4gaW52aXNpYmxlIGVsZW1lbnQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9jc3MvaGlkZGVuVmlzaWJsZVNlbGVjdG9ycy5qcyNMMTJcbiAgICByZXR1cm4gISEoZWxlbWVudC5vZmZzZXRXaWR0aCB8fCBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCdzICAqL1xuZnVuY3Rpb24gaXNOYXRpdmVGb3JtRWxlbWVudChlbGVtZW50KSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSA9PT0gJ2lucHV0JyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICdidXR0b24nIHx8XG4gICAgICAgIG5vZGVOYW1lID09PSAndGV4dGFyZWEnO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+LiAqL1xuZnVuY3Rpb24gaXNIaWRkZW5JbnB1dChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQudHlwZSA9PSAnaGlkZGVuJztcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiBhbmNob3IgdGhhdCBoYXMgYW4gaHJlZiBhdHRyaWJ1dGUuICovXG5mdW5jdGlvbiBpc0FuY2hvcldpdGhIcmVmKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNBbmNob3JFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdocmVmJyk7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gaW5wdXQgZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZSA9PSAnaW5wdXQnO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGFuY2hvciBlbGVtZW50LiAqL1xuZnVuY3Rpb24gaXNBbmNob3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdhJztcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBoYXMgYSB2YWxpZCB0YWJpbmRleC4gKi9cbmZ1bmN0aW9uIGhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgZWxlbWVudC50YWJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRhYkluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgLy8gSUUxMSBwYXJzZXMgdGFiaW5kZXg9XCJcIiBhcyB0aGUgdmFsdWUgXCItMzI3NjhcIlxuICAgIGlmICh0YWJJbmRleCA9PSAnLTMyNzY4Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhISh0YWJJbmRleCAmJiAhaXNOYU4ocGFyc2VJbnQodGFiSW5kZXgsIDEwKSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJzZWQgdGFiaW5kZXggZnJvbSB0aGUgZWxlbWVudCBhdHRyaWJ1dGVzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZVxuICogZXZhbHVhdGVkIHRhYmluZGV4IGZyb20gdGhlIGJyb3dzZXJzIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBnZXRUYWJJbmRleFZhbHVlKGVsZW1lbnQpIHtcbiAgICBpZiAoIWhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNlZSBicm93c2VyIGlzc3VlIGluIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbiAgICB2YXIgdGFiSW5kZXggPSBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICAgIHJldHVybiBpc05hTih0YWJJbmRleCkgPyAtMSA6IHRhYkluZGV4O1xufVxuLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBpcyBwb3RlbnRpYWxseSB0YWJiYWJsZSBvbiBpT1MgKi9cbmZ1bmN0aW9uIGlzUG90ZW50aWFsbHlUYWJiYWJsZUlPUyhlbGVtZW50KSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBpbnB1dFR5cGUgPSBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGU7XG4gICAgcmV0dXJuIGlucHV0VHlwZSA9PT0gJ3RleHQnXG4gICAgICAgIHx8IGlucHV0VHlwZSA9PT0gJ3Bhc3N3b3JkJ1xuICAgICAgICB8fCBub2RlTmFtZSA9PT0gJ3NlbGVjdCdcbiAgICAgICAgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYSc7XG59XG4vKipcbiAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIHBvdGVudGlhbGx5IGZvY3VzYWJsZSB3aXRob3V0IHRha2luZyBjdXJyZW50IHZpc2libGUvZGlzYWJsZWQgc3RhdGVcbiAqIGludG8gYWNjb3VudC5cbiAqL1xuZnVuY3Rpb24gaXNQb3RlbnRpYWxseUZvY3VzYWJsZShlbGVtZW50KSB7XG4gICAgLy8gSW5wdXRzIGFyZSBwb3RlbnRpYWxseSBmb2N1c2FibGUgKnVubGVzcyogdGhleSdyZSB0eXBlPVwiaGlkZGVuXCIuXG4gICAgaWYgKGlzSGlkZGVuSW5wdXQoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNOYXRpdmVGb3JtRWxlbWVudChlbGVtZW50KSB8fFxuICAgICAgICBpc0FuY2hvcldpdGhIcmVmKGVsZW1lbnQpIHx8XG4gICAgICAgIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSB8fFxuICAgICAgICBoYXNWYWxpZFRhYkluZGV4KGVsZW1lbnQpO1xufVxuLyoqIEdldHMgdGhlIHBhcmVudCB3aW5kb3cgb2YgYSBET00gbm9kZSB3aXRoIHJlZ2FyZHMgb2YgYmVpbmcgaW5zaWRlIG9mIGFuIGlmcmFtZS4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59XG5cbnZhciBfX2RlY29yYXRlJDE3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIERpcmVjdGl2ZSBmb3IgdHJhcHBpbmcgZm9jdXMgd2l0aGluIGEgcmVnaW9uLlxuICpcbiAqIE5PVEU6IFRoaXMgZGlyZWN0aXZlIGN1cnJlbnRseSB1c2VzIGEgdmVyeSBzaW1wbGUgKG5haXZlKSBhcHByb2FjaCB0byBmb2N1cyB0cmFwcGluZy5cbiAqIEl0IGFzc3VtZXMgdGhhdCB0aGUgdGFiIG9yZGVyIGlzIHRoZSBzYW1lIGFzIERPTSBvcmRlciwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRydWUuXG4gKiBUaGluZ3MgbGlrZSB0YWJJbmRleCA+IDAsIGZsZXggYG9yZGVyYCwgYW5kIHNoYWRvdyByb290cyBjYW4gY2F1c2UgdG8gdHdvIHRvIG1pc2FsaWduLlxuICogVGhpcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYSBtb3JlIGludGVsbGlnZW50IHNvbHV0aW9uIGJlZm9yZSB0aGUgbGlicmFyeSBpcyBjb25zaWRlcmVkIHN0YWJsZS5cbiAqL1xudmFyIEZvY3VzVHJhcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9jdXNUcmFwKF9jaGVja2VyLCBfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrZXIgPSBfY2hlY2tlcjtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvY3VzVHJhcC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgZm9jdXMgdHJhcCBpcyBhY3RpdmUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgbWljcm90YXNrIHF1ZXVlIHRvIGVtcHR5LCB0aGVuIGZvY3VzZXMgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1c1xuICAgICAqIHRyYXAgcmVnaW9uLlxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudFdoZW5SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciBtaWNyb3Rhc2sgcXVldWUgdG8gZW1wdHksIHRoZW4gZm9jdXNlcyB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXNcbiAgICAgKiB0cmFwIHJlZ2lvbi5cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudFdoZW5SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCB3aXRoaW4gdGhlIGZvY3VzIHRyYXAgcmVnaW9uLlxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy50cmFwcGVkQ29udGVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgcmVkaXJlY3RUb0VsZW1lbnQgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdbY2RrLWZvY3VzLXN0YXJ0XScpIHx8XG4gICAgICAgICAgICB0aGlzLl9nZXRGaXJzdFRhYmJhYmxlRWxlbWVudChyb290RWxlbWVudCk7XG4gICAgICAgIGlmIChyZWRpcmVjdFRvRWxlbWVudCkge1xuICAgICAgICAgICAgcmVkaXJlY3RUb0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5mb2N1c0xhc3RUYWJiYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMudHJhcHBlZENvbnRlbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIGZvY3VzVGFyZ2V0cyA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjZGstZm9jdXMtZW5kXScpO1xuICAgICAgICB2YXIgcmVkaXJlY3RUb0VsZW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoZm9jdXNUYXJnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVkaXJlY3RUb0VsZW1lbnQgPSBmb2N1c1RhcmdldHNbZm9jdXNUYXJnZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVkaXJlY3RUb0VsZW1lbnQgPSB0aGlzLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVkaXJlY3RUb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBHZXQgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgZnJvbSBhIERPTSBzdWJ0cmVlIChpbmNsdXNpdmUpLiAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuX2dldEZpcnN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIGluIERPTSBvcmRlci5cbiAgICAgICAgdmFyIGNoaWxkQ291bnQgPSByb290LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0YWJiYWJsZUNoaWxkID0gdGhpcy5fZ2V0Rmlyc3RUYWJiYWJsZUVsZW1lbnQocm9vdC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpZiAodGFiYmFibGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWJiYWJsZUNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqIEdldCB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IGZyb20gYSBET00gc3VidHJlZSAoaW5jbHVzaXZlKS4gKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgRE9NIG9yZGVyLlxuICAgICAgICBmb3IgKHZhciBpID0gcm9vdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHRhYmJhYmxlQ2hpbGQgPSB0aGlzLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50KHJvb3QuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiYmFibGVDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgndHJhcHBlZENvbnRlbnQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIEZvY3VzVHJhcC5wcm90b3R5cGUsIFwidHJhcHBlZENvbnRlbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIEZvY3VzVHJhcC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgRm9jdXNUcmFwID0gX19kZWNvcmF0ZSQxNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ2Nkay1mb2N1cy10cmFwLCBmb2N1cy10cmFwJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgKm5nSWY9XFxcIiFkaXNhYmxlZFxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIChmb2N1cyk9XFxcImZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudCgpXFxcIj48L2Rpdj48ZGl2ICN0cmFwcGVkQ29udGVudCBjbGFzcz1cXFwiY2RrLWZvY3VzLXRyYXAtY29udGVudFxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PjxkaXYgKm5nSWY9XFxcIiFkaXNhYmxlZFxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIChmb2N1cyk9XFxcImZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKVxcXCI+PC9kaXY+XCIsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbSW50ZXJhY3Rpdml0eUNoZWNrZXIsIF9hbmd1bGFyX2NvcmUuTmdab25lXSlcbiAgICBdLCBGb2N1c1RyYXApO1xuICAgIHJldHVybiBGb2N1c1RyYXA7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQyMCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyMCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMyA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ2xpdmVBbm5vdW5jZXJFbGVtZW50Jyk7XG52YXIgTGl2ZUFubm91bmNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGl2ZUFubm91bmNlcihlbGVtZW50VG9rZW4pIHtcbiAgICAgICAgLy8gV2UgaW5qZWN0IHRoZSBsaXZlIGVsZW1lbnQgYXMgYGFueWAgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlIGNhbm5vdCByZWZlcmVuY2VcbiAgICAgICAgLy8gYnJvd3NlciBnbG9iYWxzIChIVE1MRWxlbWVudCkgb24gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLCBzaW5jZSBoYXZpbmcgYSBjbGFzcyBkZWNvcmF0b3JcbiAgICAgICAgLy8gY2F1c2VzIFR5cGVTY3JpcHQgdG8gcHJlc2VydmUgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSB0eXBlcy5cbiAgICAgICAgdGhpcy5fbGl2ZUVsZW1lbnQgPSBlbGVtZW50VG9rZW4gfHwgdGhpcy5fY3JlYXRlTGl2ZUVsZW1lbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW5ub3VuY2VzIGEgbWVzc2FnZSB0byBzY3JlZW5yZWFkZXJzLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgdG8gYmUgYW5ub3VuY2VkIHRvIHRoZSBzY3JlZW5yZWFkZXJcbiAgICAgKiBAcGFyYW0gcG9saXRlbmVzcyBUaGUgcG9saXRlbmVzcyBvZiB0aGUgYW5ub3VuY2VyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBMaXZlQW5ub3VuY2VyLnByb3RvdHlwZS5hbm5vdW5jZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwb2xpdGVuZXNzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChwb2xpdGVuZXNzID09PSB2b2lkIDApIHsgcG9saXRlbmVzcyA9ICdwb2xpdGUnOyB9XG4gICAgICAgIHRoaXMuX2xpdmVFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIC8vIFRPRE86IGVuc3VyZSBjaGFuZ2luZyB0aGUgcG9saXRlbmVzcyB3b3JrcyBvbiBhbGwgZW52aXJvbm1lbnRzIHdlIHN1cHBvcnQuXG4gICAgICAgIHRoaXMuX2xpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgcG9saXRlbmVzcyk7XG4gICAgICAgIC8vIFRoaXMgMTAwbXMgdGltZW91dCBpcyBuZWNlc3NhcnkgZm9yIHNvbWUgYnJvd3NlciArIHNjcmVlbi1yZWFkZXIgY29tYmluYXRpb25zOlxuICAgICAgICAvLyAtIEJvdGggSkFXUyBhbmQgTlZEQSBvdmVyIElFMTEgd2lsbCBub3QgYW5ub3VuY2UgYW55dGhpbmcgd2l0aG91dCBhIG5vbi16ZXJvIHRpbWVvdXQuXG4gICAgICAgIC8vIC0gV2l0aCBDaHJvbWUgYW5kIElFMTEgd2l0aCBOVkRBIG9yIEpBV1MsIGEgcmVwZWF0ZWQgKGlkZW50aWNhbCkgbWVzc2FnZSB3b24ndCBiZSByZWFkIGFcbiAgICAgICAgLy8gICBzZWNvbmQgdGltZSB3aXRob3V0IGNsZWFyaW5nIGFuZCB0aGVuIHVzaW5nIGEgbm9uLXplcm8gZGVsYXkuXG4gICAgICAgIC8vICh1c2luZyBKQVdTIDE3IGF0IHRpbWUgb2YgdGhpcyB3cml0aW5nKS5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbGl2ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlOyB9LCAxMDApO1xuICAgIH07XG4gICAgLyoqIFJlbW92ZXMgdGhlIGFyaWEtbGl2ZSBlbGVtZW50IGZyb20gdGhlIERPTS4gKi9cbiAgICBMaXZlQW5ub3VuY2VyLnByb3RvdHlwZS5fcmVtb3ZlTGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXZlRWxlbWVudCAmJiB0aGlzLl9saXZlRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXZlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2xpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGl2ZUFubm91bmNlci5wcm90b3R5cGUuX2NyZWF0ZUxpdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGl2ZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGxpdmVFbC5jbGFzc0xpc3QuYWRkKCdjZGstdmlzdWFsbHktaGlkZGVuJyk7XG4gICAgICAgIGxpdmVFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXRvbWljJywgJ3RydWUnKTtcbiAgICAgICAgbGl2ZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpdmVFbCk7XG4gICAgICAgIHJldHVybiBsaXZlRWw7XG4gICAgfTtcbiAgICBMaXZlQW5ub3VuY2VyID0gX19kZWNvcmF0ZSQyMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX3BhcmFtJDMoMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSQzKDAsIF9hbmd1bGFyX2NvcmUuSW5qZWN0KExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4pKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGl2ZUFubm91bmNlcik7XG4gICAgcmV0dXJuIExpdmVBbm5vdW5jZXI7XG59KCkpO1xuZnVuY3Rpb24gTElWRV9BTk5PVU5DRVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyLCBsaXZlRWxlbWVudCkge1xuICAgIHJldHVybiBwYXJlbnREaXNwYXRjaGVyIHx8IG5ldyBMaXZlQW5ub3VuY2VyKGxpdmVFbGVtZW50KTtcbn1cblxudmFyIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBMaXZlQW5ub3VuY2VyIGF2YWlsYWJsZSwgdXNlIHRoYXQuIE90aGVyd2lzZSwgcHJvdmlkZSBhIG5ldyBvbmUuXG4gICAgcHJvdmlkZTogTGl2ZUFubm91bmNlcixcbiAgICBkZXBzOiBbXG4gICAgICAgIFtuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpLCBMaXZlQW5ub3VuY2VyXSxcbiAgICAgICAgW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdChMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOKV1cbiAgICBdLFxuICAgIHVzZUZhY3Rvcnk6IExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSX0ZBQ1RPUllcbn07XG5cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xuLyoqIEByZXR1cm5zIFRoZSBpbnB1dCB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcygpIHtcbiAgICBpZiAoIXN1cHBvcnRlZElucHV0VHlwZXMpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVUZXN0SW5wdXRfMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHN1cHBvcnRlZElucHV0VHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgICAgIC8vIGBjb2xvcmAgbXVzdCBjb21lIGZpcnN0LiBDaHJvbWUgNTYgc2hvd3MgYSB3YXJuaW5nIGlmIHdlIGNoYW5nZSB0aGUgdHlwZSB0byBgY29sb3JgIGFmdGVyXG4gICAgICAgICAgICAvLyBmaXJzdCBjaGFuZ2luZyBpdCB0byBzb21ldGhpbmcgZWxzZTpcbiAgICAgICAgICAgIC8vIFRoZSBzcGVjaWZpZWQgdmFsdWUgXCJcIiBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSByZXF1aXJlZCBmb3JtYXQuXG4gICAgICAgICAgICAvLyBUaGUgZm9ybWF0IGlzIFwiI3JyZ2diYlwiIHdoZXJlIHJyLCBnZywgYmIgYXJlIHR3by1kaWdpdCBoZXhhZGVjaW1hbCBudW1iZXJzLlxuICAgICAgICAgICAgJ2NvbG9yJyxcbiAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAgJ2NoZWNrYm94JyxcbiAgICAgICAgICAgICdkYXRlJyxcbiAgICAgICAgICAgICdkYXRldGltZS1sb2NhbCcsXG4gICAgICAgICAgICAnZW1haWwnLFxuICAgICAgICAgICAgJ2ZpbGUnLFxuICAgICAgICAgICAgJ2hpZGRlbicsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICdyYWRpbycsXG4gICAgICAgICAgICAncmFuZ2UnLFxuICAgICAgICAgICAgJ3Jlc2V0JyxcbiAgICAgICAgICAgICdzZWFyY2gnLFxuICAgICAgICAgICAgJ3N1Ym1pdCcsXG4gICAgICAgICAgICAndGVsJyxcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICd0aW1lJyxcbiAgICAgICAgICAgICd1cmwnLFxuICAgICAgICAgICAgJ3dlZWsnLFxuICAgICAgICBdLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZlYXR1cmVUZXN0SW5wdXRfMS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZVRlc3RJbnB1dF8xLnR5cGUgPT09IHZhbHVlO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xufVxuXG52YXIgX19kZWNvcmF0ZSQyMSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyMSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIFBsYXRmb3JtTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgUGxhdGZvcm1Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBQbGF0Zm9ybU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQbGF0Zm9ybU1vZHVsZSA9IF9fZGVjb3JhdGUkMjEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1BsYXRmb3JtXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgUGxhdGZvcm1Nb2R1bGUpO1xuICAgIHJldHVybiBQbGF0Zm9ybU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDE2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgQTExeU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQTExeU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgQTExeU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEExMXlNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQTExeU1vZHVsZSA9IF9fZGVjb3JhdGUkMTYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBQbGF0Zm9ybU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtGb2N1c1RyYXBdLFxuICAgICAgICAgICAgZXhwb3J0czogW0ZvY3VzVHJhcF0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtJbnRlcmFjdGl2aXR5Q2hlY2tlciwgTElWRV9BTk5PVU5DRVJfUFJPVklERVJdXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBBMTF5TW9kdWxlKTtcbiAgICByZXR1cm4gQTExeU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDIzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDIzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IHNob3dzIGEgc2ltcGxpZmllZCBjaGVja2JveCB3aXRob3V0IGluY2x1ZGluZyBhbnkga2luZCBvZiBcInJlYWxcIiBjaGVja2JveC5cbiAqIE1lYW50IHRvIGJlIHVzZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgcHVyZWx5IGRlY29yYXRpdmUgYW5kIGEgbGFyZ2UgbnVtYmVyIG9mIHRoZW0gd2lsbCBiZVxuICogaW5jbHVkZWQsIHN1Y2ggYXMgZm9yIHRoZSBvcHRpb25zIGluIGEgbXVsdGktc2VsZWN0LiBVc2VzIG5vIFNWR3Mgb3IgY29tcGxleCBhbmltYXRpb25zLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGNvbXBvbmVudCB3aWxsIGJlIGNvbXBsZXRlbHkgaW52aXNpYmxlIHRvIHNjcmVlbi1yZWFkZXIgdXNlcnMuIFRoaXMgaXMgKm5vdCpcbiAqIGludGVyY2hhbmdlYWJsZSB3aXRoIDxtZC1jaGVja2JveD4gYW5kIHNob3VsZCAqbm90KiBiZSB1c2VkIGlmIHRoZSB1c2VyIHdvdWxkIGRpcmVjdGx5IGludGVyYWN0XG4gKiB3aXRoIHRoZSBjaGVja2JveC4gVGhlIHBzZXVkby1jaGVja2JveCBzaG91bGQgb25seSBiZSB1c2VkIGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZlxuICogbW9yZSBjb21wbGV4IGNvbXBvbmVudHMgdGhhdCBhcHByb3ByaWF0ZWx5IGhhbmRsZSBzZWxlY3RlZCAvIGNoZWNrZWQgc3RhdGUuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFBzZXVkb0NoZWNrYm94ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFBzZXVkb0NoZWNrYm94KF9lbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgLyoqIERpc3BsYXkgc3RhdGUgb2YgdGhlIGNoZWNrYm94LiAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3VuY2hlY2tlZCc7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjaGVja2JveCBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbG9yID0gJ2FjY2VudCc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFBzZXVkb0NoZWNrYm94LnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKiBDb2xvciBvZiB0aGUgY2hlY2tib3guICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sb3I7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MobmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyB0aGlzLmNvbG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKG5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgdmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIF9fZGVjb3JhdGUkMjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDIzKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFBzZXVkb0NoZWNrYm94LnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDIzKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRQc2V1ZG9DaGVja2JveC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRQc2V1ZG9DaGVja2JveC5wcm90b3R5cGUsIFwiY29sb3JcIiwgbnVsbCk7XG4gICAgTWRQc2V1ZG9DaGVja2JveCA9IF9fZGVjb3JhdGUkMjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7ZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1wc2V1ZG8tY2hlY2tib3gsIG1hdC1wc2V1ZG8tY2hlY2tib3gnLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXBzZXVkby1jaGVja2JveHt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JvcmRlcjoycHggc29saWQ7Ym9yZGVyLXJhZGl1czoycHg7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOmJvcmRlci1jb2xvciA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpLGJhY2tncm91bmQtY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKX0ubWF0LXBzZXVkby1jaGVja2JveDo6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7b3BhY2l0eTowO2NvbnRlbnQ6Jyc7Ym9yZGVyLWJvdHRvbToycHggc29saWQgY3VycmVudENvbG9yO3RyYW5zaXRpb246b3BhY2l0eSA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpfS5tYXQtcHNldWRvLWNoZWNrYm94LWRpc2FibGVke2N1cnNvcjpkZWZhdWx0fS5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGU6OmFmdGVye3RvcDo5cHg7bGVmdDoycHg7d2lkdGg6MTZweDtvcGFjaXR5OjF9Lm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZDo6YWZ0ZXJ7dG9wOjVweDtsZWZ0OjNweDt3aWR0aDoxMnB4O2hlaWdodDo1cHg7Ym9yZGVyLWxlZnQ6MnB4IHNvbGlkIGN1cnJlbnRDb2xvcjt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7b3BhY2l0eToxfVwiXSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3hdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1pbmRldGVybWluYXRlXSc6ICdzdGF0ZSA9PT0gXCJpbmRldGVybWluYXRlXCInLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkXSc6ICdzdGF0ZSA9PT0gXCJjaGVja2VkXCInLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDIzKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kUHNldWRvQ2hlY2tib3gpO1xuICAgIHJldHVybiBNZFBzZXVkb0NoZWNrYm94O1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMjIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZFNlbGVjdGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTZWxlY3Rpb25Nb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kU2VsZWN0aW9uTW9kdWxlID0gX19kZWNvcmF0ZSQyMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW01kUHNldWRvQ2hlY2tib3hdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRQc2V1ZG9DaGVja2JveF1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDIyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2VsZWN0aW9uTW9kdWxlKTtcbiAgICByZXR1cm4gTWRTZWxlY3Rpb25Nb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQyNCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyNCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLy8gXCJQb2x5ZmlsbFwiIGZvciBgTm9kZS5yZXBsYWNlV2l0aCgpYC5cbi8vIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2hpbGROb2RlL3JlcGxhY2VXaXRoXG5mdW5jdGlvbiBfcmVwbGFjZVdpdGgodG9SZXBsYWNlRWwsIG90aGVyRWwpIHtcbiAgICB0b1JlcGxhY2VFbC5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChvdGhlckVsLCB0b1JlcGxhY2VFbCk7XG59XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIERvbVByb2plY3Rpb25Ib3N0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb21Qcm9qZWN0aW9uSG9zdChyZWYpIHtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgfVxuICAgIERvbVByb2plY3Rpb25Ib3N0ID0gX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLWRvbS1wcm9qZWN0aW9uLWhvc3QnXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBEb21Qcm9qZWN0aW9uSG9zdCk7XG4gICAgcmV0dXJuIERvbVByb2plY3Rpb25Ib3N0O1xufSgpKTtcbi8qKiBAZG9jcy1wcml2YXRlICovXG52YXIgRG9tUHJvamVjdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9tUHJvamVjdGlvbigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdCBhbiBlbGVtZW50IGludG8gYSBob3N0IGVsZW1lbnQuXG4gICAgICogUmVwbGFjZSBhIGhvc3QgZWxlbWVudCBieSBhbm90aGVyIGVsZW1lbnQuIFRoaXMgYWxzbyByZXBsYWNlcyB0aGUgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBieSB0aGUgY2hpbGRyZW4gb2YgdGhlIGhvc3QuXG4gICAgICpcbiAgICAgKiBJdCBzaG91bGQgYmUgdXNlZCBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgIEBDb21wb25lbnQoe1xuICAgICAqICAgICB0ZW1wbGF0ZTogYDxkaXY+XG4gICAgICogICAgICAgPGNkay1kb20tcHJvamVjdGlvbi1ob3N0PlxuICAgICAqICAgICAgICAgPGRpdj5vdGhlcjwvZGl2PlxuICAgICAqICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAqICAgICAgIDwvY2RrLWRvbS1wcm9qZWN0aW9uLWhvc3Q+XG4gICAgICogICAgIDwvZGl2PmBcbiAgICAgKiAgIH0pXG4gICAgICogICBjbGFzcyBDbXB0IHtcbiAgICAgKiAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcHJvamVjdG9yOiBEb21Qcm9qZWN0aW9uLCBwcml2YXRlIF9lbDogRWxlbWVudFJlZikge31cbiAgICAgKiAgICAgbmdPbkluaXQoKSB7IHRoaXMuX3Byb2plY3Rvci5wcm9qZWN0KHRoaXMuX2VsLCB0aGlzLl9wcm9qZWN0b3IpOyB9XG4gICAgICogICB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbXBvbmVudCB3aWxsIG1vdmUgdGhlIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQgaXQncyBhcHBsaWVkIHRvIGluIHRoZSBvdXRlciBkaXYuIEJlY2F1c2VcbiAgICAgKiBgcHJvamVjdCgpYCBhbHNvIG1vdmUgdGhlIGNoaWxkcmVuIG9mIHRoZSBob3N0IGluc2lkZSB0aGUgcHJvamVjdGVkIGVsZW1lbnQsIHRoZSBlbGVtZW50IHdpbGxcbiAgICAgKiBjb250YWluIHRoZSBgPGRpdj5vdGhlcjwvZGl2PmAgSFRNTCBhcyB3ZWxsIGFzIGl0cyBvd24gY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBOb3RlOiB3aXRob3V0IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCB0aGUgcHJvamVjdGlvbiB3aWxsIHByb2plY3QgYW4gZW1wdHkgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWYgRWxlbWVudFJlZiB0byBiZSBwcm9qZWN0ZWQuXG4gICAgICogQHBhcmFtIGhvc3QgUHJvamVjdGlvbiBob3N0IGludG8gd2hpY2ggdG8gcHJvamVjdCB0aGUgYEVsZW1lbnRSZWZgLlxuICAgICAqL1xuICAgIERvbVByb2plY3Rpb24ucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiAocmVmLCBob3N0KSB7XG4gICAgICAgIHZhciBwcm9qZWN0ZWRFbCA9IHJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgaG9zdEVsID0gaG9zdC5yZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBwcm9qZWN0ZWRFbC5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzWzBdO1xuICAgICAgICAvLyBXZSBob2lzdCBhbGwgb2YgdGhlIHByb2plY3RlZCBlbGVtZW50J3MgY2hpbGRyZW4gb3V0IGludG8gdGhlIHByb2plY3RlZCBlbGVtZW50cyBwb3NpdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHdlICpvbmx5KiB3YW50IHRvIG1vdmUgdGhlIHByb2plY3RlZCBlbGVtZW50IGFuZCBub3QgaXRzIGNoaWxkcmVuLlxuICAgICAgICBfcmVwbGFjZVdpdGgocHJvamVjdGVkRWwsIGNoaWxkKTtcbiAgICAgICAgdmFyIGwgPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2Rlc1swXSwgY2hpbGQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZzsgLy8gbmV4dFNpYmxpbmcgaXMgbm93IHRoZSBjaGlsZE5vZGVzWzBdLlxuICAgICAgICB9XG4gICAgICAgIC8vIEluc2VydCBhbGwgaG9zdCBjaGlsZHJlbiB1bmRlciB0aGUgcHJvamVjdGVkRWwsIHRoZW4gcmVwbGFjZSBob3N0IGJ5IGNvbXBvbmVudC5cbiAgICAgICAgbCA9IGhvc3RFbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgcHJvamVjdGVkRWwuYXBwZW5kQ2hpbGQoaG9zdEVsLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIF9yZXBsYWNlV2l0aChob3N0RWwsIHByb2plY3RlZEVsKTtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgaG9zdCBpcyByZXBsYWNlZCBieSB0aGUgY29tcG9uZW50LiBOb3RoaW5nIGVsc2UgdG8gYmUgZG9uZS5cbiAgICB9O1xuICAgIERvbVByb2plY3Rpb24gPSBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDI0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIERvbVByb2plY3Rpb24pO1xuICAgIHJldHVybiBEb21Qcm9qZWN0aW9uO1xufSgpKTtcbi8qKiBAZG9jcy1wcml2YXRlICovXG52YXIgUHJvamVjdGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvamVjdGlvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgUHJvamVjdGlvbk1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFByb2plY3Rpb25Nb2R1bGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQcm9qZWN0aW9uTW9kdWxlID0gX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW0RvbVByb2plY3Rpb25Ib3N0XSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0RvbVByb2plY3Rpb25Ib3N0XSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW0RvbVByb2plY3Rpb25dLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgUHJvamVjdGlvbk1vZHVsZSk7XG4gICAgcmV0dXJuIFByb2plY3Rpb25Nb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkMjUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVGhlIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyIGlzIHRoZSBhbHRlcm5hdGl2ZSB0byBPdmVybGF5Q29udGFpbmVyXG4gKiB0aGF0IHN1cHBvcnRzIGNvcnJlY3QgZGlzcGxheWluZyBvZiBvdmVybGF5IGVsZW1lbnRzIGluIEZ1bGxzY3JlZW4gbW9kZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVxdWVzdEZ1bGxTY3JlZW5cbiAqIEl0IHNob3VsZCBiZSBwcm92aWRlZCBpbiB0aGUgcm9vdCBjb21wb25lbnQgdGhhdCB3YXk6XG4gKiBwcm92aWRlcnM6IFtcbiAqICAge3Byb3ZpZGU6IE92ZXJsYXlDb250YWluZXIsIHVzZUNsYXNzOiBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lcn1cbiAqIF0sXG4gKi9cbnZhciBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDUoRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEZvckZ1bGxzY3JlZW5DaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fYWRkRnVsbHNjcmVlbkNoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hZGp1c3RQYXJlbnRGb3JGdWxsc2NyZWVuQ2hhbmdlKCk7IH0pO1xuICAgIH07XG4gICAgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLl9hZGp1c3RQYXJlbnRGb3JGdWxsc2NyZWVuQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVsbHNjcmVlbkVsZW1lbnQgPSB0aGlzLmdldEZ1bGxzY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBmdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyRWxlbWVudCk7XG4gICAgfTtcbiAgICBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lci5wcm90b3R5cGUuX2FkZEZ1bGxzY3JlZW5DaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQubW96RnVsbFNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQubXNGdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNGdWxsc2NyZWVuQ2hhbmdlJywgZm4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBwYWdlIGlzIHB1dCBpbnRvIGZ1bGxzY3JlZW4gbW9kZSwgYSBzcGVjaWZpYyBlbGVtZW50IGlzIHNwZWNpZmllZC5cbiAgICAgKiBPbmx5IHRoYXQgZWxlbWVudCBhbmQgaXRzIGNoaWxkcmVuIGFyZSB2aXNpYmxlIHdoZW4gaW4gZnVsbHNjcmVlbiBtb2RlLlxuICAgICovXG4gICAgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLmdldEZ1bGxzY3JlZW5FbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xuICAgIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyID0gX19kZWNvcmF0ZSQyNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lcik7XG4gICAgcmV0dXJuIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyO1xufShPdmVybGF5Q29udGFpbmVyKSk7XG5cbnZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQyNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyNiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyogQWRqdXN0cyBjb25maWd1cmF0aW9uIG9mIG91ciBnZXN0dXJlIGxpYnJhcnksIEhhbW1lci4gKi9cbnZhciBHZXN0dXJlQ29uZmlnID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkNihHZXN0dXJlQ29uZmlnLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdlc3R1cmVDb25maWcoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW1tZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5IYW1tZXIgOiBudWxsO1xuICAgICAgICAvKiBMaXN0IG9mIG5ldyBldmVudCBuYW1lcyB0byBhZGQgdG8gdGhlIGdlc3R1cmUgc3VwcG9ydCBsaXN0ICovXG4gICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5faGFtbWVyID8gW1xuICAgICAgICAgICAgJ2xvbmdwcmVzcycsXG4gICAgICAgICAgICAnc2xpZGUnLFxuICAgICAgICAgICAgJ3NsaWRlc3RhcnQnLFxuICAgICAgICAgICAgJ3NsaWRlZW5kJyxcbiAgICAgICAgICAgICdzbGlkZXJpZ2h0JyxcbiAgICAgICAgICAgICdzbGlkZWxlZnQnXG4gICAgICAgIF0gOiBbXTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYW1tZXIgJiYgX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBIYW1tZXJKUy4gQ2VydGFpbiBBbmd1bGFyIE1hdGVyaWFsICcgK1xuICAgICAgICAgICAgICAgICdjb21wb25lbnRzIG1heSBub3Qgd29yayBjb3JyZWN0bHkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIEhhbW1lciBpbnN0YW5jZSBtYW51YWxseSB0byBhZGQgY3VzdG9tIHJlY29nbml6ZXJzIHRoYXQgbWF0Y2ggdGhlIE1hdGVyaWFsIERlc2lnbiBzcGVjLlxuICAgICAqXG4gICAgICogT3VyIGdlc3R1cmUgbmFtZXMgY29tZSBmcm9tIHRoZSBNYXRlcmlhbCBEZXNpZ24gZ2VzdHVyZXMgc3BlYzpcbiAgICAgKiBodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL3BhdHRlcm5zL2dlc3R1cmVzLmh0bWwjZ2VzdHVyZXMtdG91Y2gtbWVjaGFuaWNzXG4gICAgICpcbiAgICAgKiBNb3JlIGluZm9ybWF0aW9uIG9uIGRlZmF1bHQgcmVjb2duaXplcnMgY2FuIGJlIGZvdW5kIGluIEhhbW1lciBkb2NzOlxuICAgICAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVjb2duaXplci1wYW4vXG4gICAgICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXByZXNzL1xuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0byBhc3NpZ24gdGhlIG5ldyBIYW1tZXJKUyBnZXN0dXJlcy5cbiAgICAgKiBAcmV0dXJucyBOZXdseS1jcmVhdGVkIEhhbW1lckpTIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEdlc3R1cmVDb25maWcucHJvdG90eXBlLmJ1aWxkSGFtbWVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG1jID0gbmV3IHRoaXMuX2hhbW1lcihlbGVtZW50KTtcbiAgICAgICAgLy8gRGVmYXVsdCBIYW1tZXIgUmVjb2duaXplcnMuXG4gICAgICAgIHZhciBwYW4gPSBuZXcgdGhpcy5faGFtbWVyLlBhbigpO1xuICAgICAgICB2YXIgc3dpcGUgPSBuZXcgdGhpcy5faGFtbWVyLlN3aXBlKCk7XG4gICAgICAgIHZhciBwcmVzcyA9IG5ldyB0aGlzLl9oYW1tZXIuUHJlc3MoKTtcbiAgICAgICAgLy8gTm90aWNlIHRoYXQgYSBIYW1tZXJKUyByZWNvZ25pemVyIGNhbiBvbmx5IGRlcGVuZCBvbiBvbmUgb3RoZXIgcmVjb2duaXplciBvbmNlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHByZXZpb3VzIGByZWNvZ25pemVXaXRoYCB3aWxsIGJlIGRyb3BwZWQuXG4gICAgICAgIC8vIFRPRE86IENvbmZpcm0gdGhyZXNob2xkIG51bWJlcnMgd2l0aCBNYXRlcmlhbCBEZXNpZ24gVVggVGVhbVxuICAgICAgICB2YXIgc2xpZGUgPSB0aGlzLl9jcmVhdGVSZWNvZ25pemVyKHBhbiwgeyBldmVudDogJ3NsaWRlJywgdGhyZXNob2xkOiAwIH0sIHN3aXBlKTtcbiAgICAgICAgdmFyIGxvbmdwcmVzcyA9IHRoaXMuX2NyZWF0ZVJlY29nbml6ZXIocHJlc3MsIHsgZXZlbnQ6ICdsb25ncHJlc3MnLCB0aW1lOiA1MDAgfSk7XG4gICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBgcGFuYCBldmVudCB0byB1c2UgdGhlIHN3aXBlIGV2ZW50LlxuICAgICAgICBwYW4ucmVjb2duaXplV2l0aChzd2lwZSk7XG4gICAgICAgIC8vIEFkZCBjdXN0b21pemVkIGdlc3R1cmVzIHRvIEhhbW1lciBtYW5hZ2VyXG4gICAgICAgIG1jLmFkZChbc3dpcGUsIHByZXNzLCBwYW4sIHNsaWRlLCBsb25ncHJlc3NdKTtcbiAgICAgICAgcmV0dXJuIG1jO1xuICAgIH07XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgcmVjb2duaXplciwgd2l0aG91dCBhZmZlY3RpbmcgdGhlIGRlZmF1bHQgcmVjb2duaXplcnMgb2YgSGFtbWVySlMgKi9cbiAgICBHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5fY3JlYXRlUmVjb2duaXplciA9IGZ1bmN0aW9uIChiYXNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpbmhlcml0YW5jZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGluaGVyaXRhbmNlc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjb2duaXplciA9IG5ldyBiYXNlLmNvbnN0cnVjdG9yKG9wdGlvbnMpO1xuICAgICAgICBpbmhlcml0YW5jZXMucHVzaChiYXNlKTtcbiAgICAgICAgaW5oZXJpdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtKTsgfSk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH07XG4gICAgR2VzdHVyZUNvbmZpZyA9IF9fZGVjb3JhdGUkMjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgR2VzdHVyZUNvbmZpZyk7XG4gICAgcmV0dXJuIEdlc3R1cmVDb25maWc7XG59KF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5IYW1tZXJHZXN0dXJlQ29uZmlnKSk7XG5cbi8qKlxuICogQ2xhc3MgdG8gYmUgdXNlZCB0byBwb3dlciBzZWxlY3Rpbmcgb25lIG9yIG1vcmUgb3B0aW9ucyBmcm9tIGEgbGlzdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFNlbGVjdGlvbk1vZGVsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25Nb2RlbChfaXNNdWx0aSwgaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKF9pc011bHRpID09PSB2b2lkIDApIHsgX2lzTXVsdGkgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLl9pc011bHRpID0gX2lzTXVsdGk7XG4gICAgICAgIC8qKiBDdXJyZW50bHktc2VsZWN0ZWQgdmFsdWVzLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgZGVzZWxlY3RlZCBvcHRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGVtaXR0ZWQgYnkgdGhlIGNoYW5nZSBldmVudC4gKi9cbiAgICAgICAgdGhpcy5fZGVzZWxlY3RlZFRvRW1pdCA9IFtdO1xuICAgICAgICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbiB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkIGJ5IHRoZSBjaGFuZ2UgZXZlbnQuICovXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0ID0gW107XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLiAqL1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIGlmIChpbml0aWFsbHlTZWxlY3RlZFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKF9pc011bHRpKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl9tYXJrU2VsZWN0ZWQodmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtTZWxlY3RlZChpbml0aWFsbHlTZWxlY3RlZFZhbHVlc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgYXJyYXkgaW4gb3JkZXIgdG8gYXZvaWQgZmlyaW5nIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHByZXNlbGVjdGVkIHZhbHVlcy5cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0Lmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKiBTZWxlY3RlZCB2YWx1ZShzKS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBBcnJheS5mcm9tKHRoaXMuX3NlbGVjdGlvbi52YWx1ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXJrU2VsZWN0ZWQodmFsdWUpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyBhIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdW5tYXJrU2VsZWN0ZWQodmFsdWUpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgb2YgdGhlIHNlbGVjdGVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VubWFya0FsbCgpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb24uaGFzKHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbW9kZWwgaGFzIGEgdmFsdWUuXG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb24uc2l6ZSA9PT0gMDtcbiAgICB9O1xuICAgIC8qKiBFbWl0cyBhIGNoYW5nZSBldmVudCBhbmQgY2xlYXJzIHRoZSByZWNvcmRzIG9mIHNlbGVjdGVkIGFuZCBkZXNlbGVjdGVkIHZhbHVlcy4gKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkVG9FbWl0Lmxlbmd0aCB8fCB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50RGF0YSA9IG5ldyBTZWxlY3Rpb25DaGFuZ2UodGhpcy5fc2VsZWN0ZWRUb0VtaXQsIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZS5uZXh0KGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0ID0gW107XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFRvRW1pdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogU2VsZWN0cyBhIHZhbHVlLiAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5fbWFya1NlbGVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc011bHRpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5tYXJrQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24uYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRGVzZWxlY3RzIGEgdmFsdWUuICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLl91bm1hcmtTZWxlY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQ2xlYXJzIG91dCB0aGUgc2VsZWN0ZWQgdmFsdWVzLiAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5fdW5tYXJrQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLl91bm1hcmtTZWxlY3RlZCh2YWx1ZSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0aW9uTW9kZWw7XG59KCkpO1xuLyoqXG4gKiBEZXNjcmliZXMgYW4gZXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB2YWx1ZSBvZiBhIE1kU2VsZWN0aW9uTW9kZWwgaGFzIGNoYW5nZWQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBTZWxlY3Rpb25DaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbkNoYW5nZShhZGRlZCwgcmVtb3ZlZCkge1xuICAgICAgICB0aGlzLmFkZGVkID0gYWRkZWQ7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuICAgIHJldHVybiBTZWxlY3Rpb25DaGFuZ2U7XG59KCkpO1xuXG4vKipcbiAqIFNjcmVlbnJlYWRlcnMgd2lsbCBvZnRlbiBmaXJlIGZha2UgbW91c2Vkb3duIGV2ZW50cyB3aGVuIGEgZm9jdXNhYmxlIGVsZW1lbnRcbiAqIGlzIGFjdGl2YXRlZCB1c2luZyB0aGUga2V5Ym9hcmQuIFdlIGNhbiB0eXBpY2FsbHkgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVzZSBmYWtlZFxuICogbW91c2Vkb3duIGV2ZW50cyBhbmQgcmVhbCBtb3VzZWRvd24gZXZlbnRzIHVzaW5nIHRoZSBcImJ1dHRvbnNcIiBwcm9wZXJ0eS4gV2hpbGVcbiAqIHJlYWwgbW91c2Vkb3ducyB3aWxsIGluZGljYXRlIHRoZSBtb3VzZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCAoZS5nLiBcIjFcIiBmb3JcbiAqIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiksIGZha2VkIG1vdXNlZG93bnMgd2lsbCB1c3VhbGx5IHNldCB0aGUgcHJvcGVydHkgdmFsdWUgdG8gMC5cbiAqL1xuZnVuY3Rpb24gaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlcihldmVudCkge1xuICAgIHJldHVybiBldmVudC5idXR0b25zID09PSAwO1xufVxuXG52YXIgX19kZWNvcmF0ZSQyNyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyNyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDbGFzcyB0byBjb29yZGluYXRlIHVuaXF1ZSBzZWxlY3Rpb24gYmFzZWQgb24gbmFtZS5cbiAqIEludGVuZGVkIHRvIGJlIGNvbnN1bWVkIGFzIGFuIEFuZ3VsYXIgc2VydmljZS5cbiAqIFRoaXMgc2VydmljZSBpcyBuZWVkZWQgYmVjYXVzZSBuYXRpdmUgcmFkaW8gY2hhbmdlIGV2ZW50cyBhcmUgb25seSBmaXJlZCBvbiB0aGUgaXRlbSBjdXJyZW50bHlcbiAqIGJlaW5nIHNlbGVjdGVkLCBhbmQgd2Ugc3RpbGwgbmVlZCB0byB1bmNoZWNrIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gKlxuICogVGhpcyBzZXJ2aWNlIGRvZXMgbm90ICpzdG9yZSogYW55IElEcyBhbmQgbmFtZXMgYmVjYXVzZSB0aGV5IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUsIHNvIGl0IGlzXG4gKiBsZXNzIGVycm9yLXByb25lIGlmIHRoZXkgYXJlIHNpbXBseSBwYXNzZWQgdGhyb3VnaCB3aGVuIHRoZSBldmVudHMgb2NjdXIuXG4gKi9cbnZhciBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90aWZ5IG90aGVyIGl0ZW1zIHRoYXQgc2VsZWN0aW9uIGZvciB0aGUgZ2l2ZW4gbmFtZSBoYXMgYmVlbiBzZXQuXG4gICAgICogQHBhcmFtIGlkIElEIG9mIHRoZSBpdGVtLlxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGl0ZW0uXG4gICAgICovXG4gICAgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGlkLCBuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9saXN0ZW5lcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBsaXN0ZW5lcihpZCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBMaXN0ZW4gZm9yIGZ1dHVyZSBjaGFuZ2VzIHRvIGl0ZW0gc2VsZWN0aW9uLiAqL1xuICAgIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyID0gX19kZWNvcmF0ZSQyNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyKTtcbiAgICByZXR1cm4gVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcjtcbn0oKSk7XG5mdW5jdGlvbiBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyKSB7XG4gICAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIoKTtcbn1cbnZhciBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVIgPSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGRpc3BhdGNoZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLFxuICAgIGRlcHM6IFtbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYoKSwgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcl1dLFxuICAgIHVzZUZhY3Rvcnk6IFVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuXG52YXIgX19kZWNvcmF0ZSQyOSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyOSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLy8gVGhpcyBpcyB0aGUgdmFsdWUgdXNlZCBieSBBbmd1bGFySlMgTWF0ZXJpYWwuIFRocm91Z2ggdHJpYWwgYW5kIGVycm9yIChvbiBpUGhvbmUgNlMpIHRoZXkgZm91bmRcbi8vIHRoYXQgYSB2YWx1ZSBvZiBhcm91bmQgNjUwbXMgc2VlbXMgYXBwcm9wcmlhdGUuXG52YXIgVE9VQ0hfQlVGRkVSX01TID0gNjUwO1xuLyoqIE1vbml0b3JzIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHMgdG8gZGV0ZXJtaW5lIHRoZSBjYXVzZSBvZiBmb2N1cyBldmVudHMuICovXG52YXIgRm9jdXNPcmlnaW5Nb25pdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb2N1c09yaWdpbk1vbml0b3IoKSB7XG4gICAgICAgIC8vIE5vdGU6IHdlIGxpc3RlbiB0byBldmVudHMgaW4gdGhlIGNhcHR1cmUgcGhhc2Ugc28gd2UgY2FuIGRldGVjdCB0aGVtIGV2ZW4gaWYgdGhlIHVzZXIgc3RvcHNcbiAgICAgICAgLy8gcHJvcGFnYXRpb24uXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBUaGUgZm9jdXMgb3JpZ2luIHRoYXQgdGhlIG5leHQgZm9jdXMgZXZlbnQgaXMgYSByZXN1bHQgb2YuICovXG4gICAgICAgIHRoaXMuX29yaWdpbiA9IG51bGw7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB3aW5kb3cgaGFzIGp1c3QgYmVlbiBmb2N1c2VkLiAqL1xuICAgICAgICB0aGlzLl93aW5kb3dGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE9uIGtleWRvd24gcmVjb3JkIHRoZSBvcmlnaW4gYW5kIGNsZWFyIGFueSB0b3VjaCBldmVudCB0aGF0IG1heSBiZSBpbiBwcm9ncmVzcy5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9sYXN0VG91Y2hUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlKCdrZXlib2FyZCcpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgLy8gT24gbW91c2Vkb3duIHJlY29yZCB0aGUgb3JpZ2luIG9ubHkgaWYgdGhlcmUgaXMgbm90IHRvdWNoIHRhcmdldCwgc2luY2UgYSBtb3VzZWRvd24gY2FuXG4gICAgICAgIC8vIGhhcHBlbiBhcyBhIHJlc3VsdCBvZiBhIHRvdWNoIGV2ZW50LlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9sYXN0VG91Y2hUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0T3JpZ2luRm9yQ3VycmVudEV2ZW50UXVldWUoJ21vdXNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICAvLyBXaGVuIHRoZSB0b3VjaHN0YXJ0IGV2ZW50IGZpcmVzIHRoZSBmb2N1cyBldmVudCBpcyBub3QgeWV0IGluIHRoZSBldmVudCBxdWV1ZS4gVGhpcyBtZWFucyB3ZVxuICAgICAgICAvLyBjYW4ndCByZWx5IG9uIHRoZSB0cmljayB1c2VkIGFib3ZlIChzZXR0aW5nIHRpbWVvdXQgb2YgMG1zKS4gSW5zdGVhZCB3ZSB3YWl0IDY1MG1zIHRvIHNlZSBpZlxuICAgICAgICAvLyBhIGZvY3VzIGhhcHBlbnMuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fdG91Y2hUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3RvdWNoVGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fbGFzdFRvdWNoVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgX3RoaXMuX3RvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2xhc3RUb3VjaFRhcmdldCA9IG51bGw7IH0sIFRPVUNIX0JVRkZFUl9NUyk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICAvLyBNYWtlIGEgbm90ZSBvZiB3aGVuIHRoZSB3aW5kb3cgcmVnYWlucyBmb2N1cywgc28gd2UgY2FuIHJlc3RvcmUgdGhlIG9yaWdpbiBpbmZvIGZvciB0aGVcbiAgICAgICAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fd2luZG93Rm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl93aW5kb3dGb2N1c2VkID0gZmFsc2U7IH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGFuIGVsZW1lbnQgdG8gcmVjZWl2ZSBmb2N1cyBjbGFzc2VzLiAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUucmVnaXN0ZXJFbGVtZW50Rm9yRm9jdXNDbGFzc2VzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIHJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCAnZm9jdXMnLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLl9vbkZvY3VzKGV2ZW50LCBlbGVtZW50LCByZW5kZXJlciwgc3ViamVjdCk7IH0pO1xuICAgICAgICByZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2JsdXInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25CbHVyKGVsZW1lbnQsIHJlbmRlcmVyLCBzdWJqZWN0KTsgfSk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIGVsZW1lbnQgdmlhIHRoZSBzcGVjaWZpZWQgZm9jdXMgb3JpZ2luLiAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuZm9jdXNWaWEgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyZXIsIG9yaWdpbikge1xuICAgICAgICB0aGlzLl9zZXRPcmlnaW5Gb3JDdXJyZW50RXZlbnRRdWV1ZShvcmlnaW4pO1xuICAgICAgICByZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKGVsZW1lbnQsICdmb2N1cycpO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIG9yaWdpbiBhbmQgc2NoZWR1bGVzIGFuIGFzeW5jIGZ1bmN0aW9uIHRvIGNsZWFyIGl0IGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IHF1ZXVlLiAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlID0gZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29yaWdpbiA9IG51bGw7IH0sIDApO1xuICAgIH07XG4gICAgLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBmb2N1cyBldmVudCB3YXMgY2F1c2VkIGJ5IGEgdG91Y2hzdGFydCBldmVudC4gKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLl93YXNDYXVzZWRCeVRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIE5vdGUobW1hbGVyYmEpOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCBxdWl0ZSBwZXJmZWN0LCB0aGVyZSBpcyBhIHNtYWxsIGVkZ2UgY2FzZS5cbiAgICAgICAgLy8gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBkb20gc3RydWN0dXJlOlxuICAgICAgICAvL1xuICAgICAgICAvLyA8ZGl2ICNwYXJlbnQgdGFiaW5kZXg9XCIwXCIgY2RrRm9jdXNDbGFzc2VzPlxuICAgICAgICAvLyAgIDxkaXYgI2NoaWxkIChjbGljayk9XCIjcGFyZW50LmZvY3VzKClcIj48L2Rpdj5cbiAgICAgICAgLy8gPC9kaXY+XG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHRvdWNoZXMgdGhlICNjaGlsZCBlbGVtZW50IGFuZCB0aGUgI3BhcmVudCBpcyBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzZWQgYXMgYVxuICAgICAgICAvLyByZXN1bHQsIHRoaXMgY29kZSB3aWxsIHN0aWxsIGNvbnNpZGVyIGl0IHRvIGhhdmUgYmVlbiBjYXVzZWQgYnkgdGhlIHRvdWNoIGV2ZW50IGFuZCB3aWxsXG4gICAgICAgIC8vIGFwcGx5IHRoZSBjZGstdG91Y2gtZm9jdXNlZCBjbGFzcyByYXRoZXIgdGhhbiB0aGUgY2RrLXByb2dyYW0tZm9jdXNlZCBjbGFzcy4gVGhpcyBpcyBhXG4gICAgICAgIC8vIHJlbGF0aXZlbHkgc21hbGwgZWRnZS1jYXNlIHRoYXQgY2FuIGJlIHdvcmtlZCBhcm91bmQgYnkgdXNpbmdcbiAgICAgICAgLy8gZm9jdXNWaWEocGFyZW50RWwsIHJlbmRlcmVyLCAgJ3Byb2dyYW0nKSB0byBmb2N1cyB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGRlY2lkZSB0aGF0IHdlIGFic29sdXRlbHkgbXVzdCBoYW5kbGUgdGhpcyBjYXNlIGNvcnJlY3RseSwgd2UgY2FuIGRvIHNvIGJ5IGxpc3RlbmluZ1xuICAgICAgICAvLyBmb3IgdGhlIGZpcnN0IGZvY3VzIGV2ZW50IGFmdGVyIHRoZSB0b3VjaHN0YXJ0LCBhbmQgdGhlbiB0aGUgZmlyc3QgYmx1ciBldmVudCBhZnRlciB0aGF0XG4gICAgICAgIC8vIGZvY3VzIGV2ZW50LiBXaGVuIHRoYXQgYmx1ciBldmVudCBmaXJlcyB3ZSBrbm93IHRoYXQgd2hhdGV2ZXIgZm9sbG93cyBpcyBub3QgYSByZXN1bHQgb2YgdGhlXG4gICAgICAgIC8vIHRvdWNoc3RhcnQuXG4gICAgICAgIHZhciBmb2N1c1RhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RUb3VjaFRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiYgZm9jdXNUYXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmXG4gICAgICAgICAgICAoZm9jdXNUYXJnZXQgPT0gdGhpcy5fbGFzdFRvdWNoVGFyZ2V0IHx8IGZvY3VzVGFyZ2V0LmNvbnRhaW5zKHRoaXMuX2xhc3RUb3VjaFRhcmdldCkpO1xuICAgIH07XG4gICAgLyoqIEhhbmRsZXMgZm9jdXMgZXZlbnRzIG9uIGEgcmVnaXN0ZXJlZCBlbGVtZW50LiAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQsIGVsZW1lbnQsIHJlbmRlcmVyLCBzdWJqZWN0KSB7XG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGRldGVjdCBhIGNhdXNlIGZvciB0aGUgZm9jdXMgZXZlbnQsIGl0J3MgZHVlIHRvIG9uZSBvZiB0d28gcmVhc29uczpcbiAgICAgICAgLy8gMSkgVGhlIHdpbmRvdyBoYXMganVzdCByZWdhaW5lZCBmb2N1cywgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIHJlc3RvcmUgdGhlIGZvY3VzZWQgc3RhdGUgb2ZcbiAgICAgICAgLy8gICAgdGhlIGVsZW1lbnQgZnJvbSBiZWZvcmUgdGhlIHdpbmRvdyBibHVycmVkLlxuICAgICAgICAvLyAyKSBJdCB3YXMgY2F1c2VkIGJ5IGEgdG91Y2ggZXZlbnQsIGluIHdoaWNoIGNhc2Ugd2UgbWFyayB0aGUgb3JpZ2luIGFzICd0b3VjaCcuXG4gICAgICAgIC8vIDMpIFRoZSBlbGVtZW50IHdhcyBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzZWQsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIG1hcmsgdGhlIG9yaWdpbiBhc1xuICAgICAgICAvLyAgICAncHJvZ3JhbScuXG4gICAgICAgIGlmICghdGhpcy5fb3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd2luZG93Rm9jdXNlZCAmJiB0aGlzLl9sYXN0Rm9jdXNPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSB0aGlzLl9sYXN0Rm9jdXNPcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl93YXNDYXVzZWRCeVRvdWNoKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9ICd0b3VjaCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSAncHJvZ3JhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstZm9jdXNlZCcsIHRydWUpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay10b3VjaC1mb2N1c2VkJywgdGhpcy5fb3JpZ2luID09ICd0b3VjaCcpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay1rZXlib2FyZC1mb2N1c2VkJywgdGhpcy5fb3JpZ2luID09ICdrZXlib2FyZCcpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay1tb3VzZS1mb2N1c2VkJywgdGhpcy5fb3JpZ2luID09ICdtb3VzZScpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay1wcm9ncmFtLWZvY3VzZWQnLCB0aGlzLl9vcmlnaW4gPT0gJ3Byb2dyYW0nKTtcbiAgICAgICAgc3ViamVjdC5uZXh0KHRoaXMuX29yaWdpbik7XG4gICAgICAgIHRoaXMuX2xhc3RGb2N1c09yaWdpbiA9IHRoaXMuX29yaWdpbjtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBIYW5kbGVzIGJsdXIgZXZlbnRzIG9uIGEgcmVnaXN0ZXJlZCBlbGVtZW50LiAqL1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvci5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uIChlbGVtZW50LCByZW5kZXJlciwgc3ViamVjdCkge1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay1mb2N1c2VkJywgZmFsc2UpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay10b3VjaC1mb2N1c2VkJywgZmFsc2UpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay1rZXlib2FyZC1mb2N1c2VkJywgZmFsc2UpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay1tb3VzZS1mb2N1c2VkJywgZmFsc2UpO1xuICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgJ2Nkay1wcm9ncmFtLWZvY3VzZWQnLCBmYWxzZSk7XG4gICAgICAgIHN1YmplY3QubmV4dChudWxsKTtcbiAgICB9O1xuICAgIEZvY3VzT3JpZ2luTW9uaXRvciA9IF9fZGVjb3JhdGUkMjkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgRm9jdXNPcmlnaW5Nb25pdG9yKTtcbiAgICByZXR1cm4gRm9jdXNPcmlnaW5Nb25pdG9yO1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgZGV0ZXJtaW5lcyBob3cgYSBwYXJ0aWN1bGFyIGVsZW1lbnQgd2FzIGZvY3VzZWQgKHZpYSBrZXlib2FyZCwgbW91c2UsIG9yXG4gKiBwcm9ncmFtbWF0aWNhbGx5KSBhbmQgYWRkcyBjb3JyZXNwb25kaW5nIGNsYXNzZXMgdG8gdGhlIGVsZW1lbnQuXG4gKi9cbnZhciBDZGtGb2N1c0NsYXNzZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENka0ZvY3VzQ2xhc3NlcyhlbGVtZW50UmVmLCBmb2N1c09yaWdpbk1vbml0b3IsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9XG4gICAgICAgICAgICBmb2N1c09yaWdpbk1vbml0b3IucmVnaXN0ZXJFbGVtZW50Rm9yRm9jdXNDbGFzc2VzKGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgcmVuZGVyZXIpO1xuICAgIH1cbiAgICBDZGtGb2N1c0NsYXNzZXMgPSBfX2RlY29yYXRlJDI5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrRm9jdXNDbGFzc2VzXScsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBGb2N1c09yaWdpbk1vbml0b3IsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIENka0ZvY3VzQ2xhc3Nlcyk7XG4gICAgcmV0dXJuIENka0ZvY3VzQ2xhc3Nlcztcbn0oKSk7XG5mdW5jdGlvbiBGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUl9GQUNUT1JZKHBhcmVudERpc3BhdGNoZXIpIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgRm9jdXNPcmlnaW5Nb25pdG9yKCk7XG59XG52YXIgRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVIgPSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIEZvY3VzT3JpZ2luTW9uaXRvciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IEZvY3VzT3JpZ2luTW9uaXRvcixcbiAgICBkZXBzOiBbW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLlNraXBTZWxmKCksIEZvY3VzT3JpZ2luTW9uaXRvcl1dLFxuICAgIHVzZUZhY3Rvcnk6IEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSX0ZBQ1RPUllcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIENTUyB0cmFuc2Zvcm0gdG8gYW4gZWxlbWVudCwgaW5jbHVkaW5nIGJyb3dzZXItcHJlZml4ZWQgcHJvcGVydGllcy5cbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcGFyYW0gdHJhbnNmb3JtVmFsdWVcbiAqL1xuZnVuY3Rpb24gYXBwbHlDc3NUcmFuc2Zvcm0oZWxlbWVudCwgdHJhbnNmb3JtVmFsdWUpIHtcbiAgICAvLyBJdCdzIGltcG9ydGFudCB0byB0cmltIHRoZSByZXN1bHQsIGJlY2F1c2UgdGhlIGJyb3dzZXIgd2lsbCBpZ25vcmUgdGhlIHNldCBvcGVyYXRpb25cbiAgICAvLyBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZS5cbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1WYWx1ZS50cmltKCk7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHZhbHVlO1xufVxuXG52YXIgX19kZWNvcmF0ZSQyOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyOCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIFN0eWxlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgU3R5bGVNb2R1bGUgPSBfX2RlY29yYXRlJDI4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDZGtGb2N1c0NsYXNzZXNdLFxuICAgICAgICAgICAgZXhwb3J0czogW0Nka0ZvY3VzQ2xhc3Nlc10sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBTdHlsZU1vZHVsZSk7XG4gICAgcmV0dXJuIFN0eWxlTW9kdWxlO1xufSgpKTtcblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbnZhciBBbmltYXRpb25DdXJ2ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkN1cnZlcygpIHtcbiAgICB9XG4gICAgQW5pbWF0aW9uQ3VydmVzLlNUQU5EQVJEX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuMiwxKSc7XG4gICAgQW5pbWF0aW9uQ3VydmVzLkRFQ0VMRVJBVElPTl9DVVJWRSA9ICdjdWJpYy1iZXppZXIoMC4wLDAuMCwwLjIsMSknO1xuICAgIEFuaW1hdGlvbkN1cnZlcy5BQ0NFTEVSQVRJT05fQ1VSVkUgPSAnY3ViaWMtYmV6aWVyKDAuNCwwLjAsMSwxKSc7XG4gICAgQW5pbWF0aW9uQ3VydmVzLlNIQVJQX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuNiwxKSc7XG4gICAgcmV0dXJuIEFuaW1hdGlvbkN1cnZlcztcbn0oKSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIEFuaW1hdGlvbkR1cmF0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uRHVyYXRpb25zKCkge1xuICAgIH1cbiAgICBBbmltYXRpb25EdXJhdGlvbnMuQ09NUExFWCA9ICczNzVtcyc7XG4gICAgQW5pbWF0aW9uRHVyYXRpb25zLkVOVEVSSU5HID0gJzIyNW1zJztcbiAgICBBbmltYXRpb25EdXJhdGlvbnMuRVhJVElORyA9ICcxOTVtcyc7XG4gICAgcmV0dXJuIEFuaW1hdGlvbkR1cmF0aW9ucztcbn0oKSk7XG5cbi8qKiBDb2VyY2VzIGEgZGF0YS1ib3VuZCB2YWx1ZSAodHlwaWNhbGx5IGEgc3RyaW5nKSB0byBhIG51bWJlci4gKi9cbmZ1bmN0aW9uIGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlLCBmYWxsYmFja1ZhbHVlKSB7XG4gICAgaWYgKGZhbGxiYWNrVmFsdWUgPT09IHZvaWQgMCkgeyBmYWxsYmFja1ZhbHVlID0gMDsgfVxuICAgIC8vIHBhcnNlRmxvYXQodmFsdWUpIGhhbmRsZXMgbW9zdCBvZiB0aGUgY2FzZXMgd2UncmUgaW50ZXJlc3RlZCBpbiAoaXQgdHJlYXRzIG51bGwsIGVtcHR5IHN0cmluZyxcbiAgICAvLyBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMgYXMgTmFOLCB3aGVyZSBOdW1iZXIganVzdCB1c2VzIDApIGJ1dCBpdCBjb25zaWRlcnMgdGhlIHN0cmluZ1xuICAgIC8vICcxMjNoZWxsbycgdG8gYmUgYSB2YWxpZCBudW1iZXIuIFRoZXJlZm9yZSB3ZSBhbHNvIGNoZWNrIGlmIE51bWJlcih2YWx1ZSkgaXMgTmFOLlxuICAgIHJldHVybiBpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgfHwgaXNOYU4oTnVtYmVyKHZhbHVlKSkgPyBmYWxsYmFja1ZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbn1cblxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZENvcmVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ29yZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRDb3JlTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRDb3JlTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kQ29yZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICBNZExpbmVNb2R1bGUsXG4gICAgICAgICAgICAgICAgUnRsTW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kUmlwcGxlTW9kdWxlLFxuICAgICAgICAgICAgICAgIE9ic2VydmVDb250ZW50TW9kdWxlLFxuICAgICAgICAgICAgICAgIFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgICAgICBPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgTWRPcHRpb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgTWRTZWxlY3Rpb25Nb2R1bGUsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kTGluZU1vZHVsZSxcbiAgICAgICAgICAgICAgICBSdGxNb2R1bGUsXG4gICAgICAgICAgICAgICAgTWRSaXBwbGVNb2R1bGUsXG4gICAgICAgICAgICAgICAgT2JzZXJ2ZUNvbnRlbnRNb2R1bGUsXG4gICAgICAgICAgICAgICAgUG9ydGFsTW9kdWxlLFxuICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgQTExeU1vZHVsZSxcbiAgICAgICAgICAgICAgICBNZE9wdGlvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBNZFNlbGVjdGlvbk1vZHVsZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENvcmVNb2R1bGUpO1xuICAgIHJldHVybiBNZENvcmVNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQzMSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzMSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1idXR0b24tdG9nZ2xlLWdyb3VwIHRvIHJlZ2lzdGVyIGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gKiBUaGlzIGFsbG93cyBpdCB0byBzdXBwb3J0IFsobmdNb2RlbCldLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTURfQlVUVE9OX1RPR0dMRV9HUk9VUF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBfYW5ndWxhcl9mb3Jtcy5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlR3JvdXA7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIF91bmlxdWVJZENvdW50ZXIkMSA9IDA7XG4vKiogQ2hhbmdlIGV2ZW50IG9iamVjdCBlbWl0dGVkIGJ5IE1kQnV0dG9uVG9nZ2xlLiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlQ2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvblRvZ2dsZUNoYW5nZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlQ2hhbmdlO1xufSgpKTtcbi8qKiBFeGNsdXNpdmUgc2VsZWN0aW9uIGJ1dHRvbiB0b2dnbGUgZ3JvdXAgdGhhdCBiZWhhdmVzIGxpa2UgYSByYWRpby1idXR0b24gZ3JvdXAuICovXG52YXIgTWRCdXR0b25Ub2dnbGVHcm91cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVHcm91cCgpIHtcbiAgICAgICAgLyoqIFRoZSB2YWx1ZSBmb3IgdGhlIGJ1dHRvbiB0b2dnbGUgZ3JvdXAuIFNob3VsZCBtYXRjaCBjdXJyZW50bHkgc2VsZWN0ZWQgYnV0dG9uIHRvZ2dsZS4gKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKiogVGhlIEhUTUwgbmFtZSBhdHRyaWJ1dGUgYXBwbGllZCB0byB0b2dnbGVzIGluIHRoaXMgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX25hbWUgPSBcIm1kLWJ1dHRvbi10b2dnbGUtZ3JvdXAtXCIgKyBfdW5pcXVlSWRDb3VudGVyJDErKztcbiAgICAgICAgLyoqIERpc2FibGVzIGFsbCB0b2dnbGVzIGluIHRoZSBncm91cC4gKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgYnV0dG9uIHRvZ2dsZSBncm91cCBzaG91bGQgYmUgdmVydGljYWwuICovXG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGJ1dHRvbiB0b2dnbGUsIHNob3VsZCBtYXRjaCB0aGUgdmFsdWUuICovXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJ1dHRvbiB0b2dnbGUgZ3JvdXAgaXMgaW5pdGlhbGl6ZWQgb3Igbm90LiAqL1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHRvIGJlIGNhbGxlZCBpbiBvcmRlciB0byB1cGRhdGUgbmdNb2RlbC5cbiAgICAgICAgICogTm93IGBuZ01vZGVsYCBiaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIC8qKiBvblRvdWNoIGZ1bmN0aW9uIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyT25Ub3VjaCAoQ29udHJvbFZhbHVlQWNjZXNzb3IpLiAqL1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZ3JvdXAncyB2YWx1ZSBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIENoaWxkIGJ1dHRvbiB0b2dnbGUgYnV0dG9ucy4gKi9cbiAgICAgICAgdGhpcy5fYnV0dG9uVG9nZ2xlcyA9IG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIC8qKiBgbmFtZWAgYXR0cmlidXRlIGZvciB0aGUgdW5kZXJseWluZyBgaW5wdXRgIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCdXR0b25Ub2dnbGVOYW1lcygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgdG9nZ2xlIGdyb3VwIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHRvZ2dsZSBncm91cCBpcyB2ZXJ0aWNhbC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVydGljYWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBWYWx1ZSBvZiB0aGUgdG9nZ2xlIGdyb3VwLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWRCdXR0b25Ub2dnbGVGcm9tVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGVtaXQgYSBjaGFuZ2UgZXZlbnQgaWYgdGhlIHZpZXcgaXMgY29tcGxldGVseSBpbml0aWFsaXplZC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGVtaXQgYSBjaGFuZ2UgZXZlbnQgZm9yIHRoZSBpbml0aWFsIHZhbHVlcy5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0b2dnbGUgZ3JvdXAgaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBzZWxlY3RlZCA/IHNlbGVjdGVkLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAhc2VsZWN0ZWQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlQnV0dG9uVG9nZ2xlTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9idXR0b25Ub2dnbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9idXR0b25Ub2dnbGVzLmZvckVhY2goZnVuY3Rpb24gKHRvZ2dsZSkge1xuICAgICAgICAgICAgICAgIHRvZ2dsZS5uYW1lID0gX3RoaXMuX25hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVE9ETzogUmVmYWN0b3IgaW50byBzaGFyZWQgY29kZSB3aXRoIHJhZGlvLlxuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLl91cGRhdGVTZWxlY3RlZEJ1dHRvblRvZ2dsZUZyb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlzQWxyZWFkeVNlbGVjdGVkID0gdGhpcy5fc2VsZWN0ZWQgIT0gbnVsbCAmJiB0aGlzLl9zZWxlY3RlZC52YWx1ZSA9PSB0aGlzLl92YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2J1dHRvblRvZ2dsZXMgIT0gbnVsbCAmJiAhaXNBbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0J1dHRvblRvZ2dsZSA9IHRoaXMuX2J1dHRvblRvZ2dsZXMuZmlsdGVyKGZ1bmN0aW9uIChidXR0b25Ub2dnbGUpIHsgcmV0dXJuIGJ1dHRvblRvZ2dsZS52YWx1ZSA9PSBfdGhpcy5fdmFsdWU7IH0pWzBdO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nQnV0dG9uVG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG1hdGNoaW5nQnV0dG9uVG9nZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uVG9nZ2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChidXR0b25Ub2dnbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uVG9nZ2xlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIERpc3BhdGNoIGNoYW5nZSBldmVudCB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCBncm91cCB2YWx1ZS4gKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTWRCdXR0b25Ub2dnbGVDaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4oZXZlbnQudmFsdWUpO1xuICAgICAgICB0aGlzLl9jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb2RlbCB2YWx1ZS4gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgc2V0IHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gZm4gT24gY2hhbmdlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250cm9sIGhhcyBiZWVuIHRvdWNoZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gZm4gT24gdG91Y2ggY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWQgV2hldGhlciB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRCdXR0b25Ub2dnbGU7IH0pKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwiX2J1dHRvblRvZ2dsZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwibmFtZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwidmVydGljYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwID0gX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtYnV0dG9uLXRvZ2dsZS1ncm91cDpub3QoW211bHRpcGxlXSksIG1hdC1idXR0b24tdG9nZ2xlLWdyb3VwOm5vdChbbXVsdGlwbGVdKScsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLWdyb3VwXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdyYWRpb2dyb3VwJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLXZlcnRpY2FsXSc6ICd2ZXJ0aWNhbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHBvcnRBczogJ21kQnV0dG9uVG9nZ2xlR3JvdXAnLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cCk7XG4gICAgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlR3JvdXA7XG59KCkpO1xuLyoqIE11bHRpcGxlIHNlbGVjdGlvbiBidXR0b24tdG9nZ2xlIGdyb3VwLiBgbmdNb2RlbGAgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG1vZGUuICovXG52YXIgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUoKSB7XG4gICAgICAgIC8qKiBEaXNhYmxlcyBhbGwgdG9nZ2xlcyBpbiB0aGUgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJ1dHRvbiB0b2dnbGUgZ3JvdXAgc2hvdWxkIGJlIHZlcnRpY2FsLiAqL1xuICAgICAgICB0aGlzLl92ZXJ0aWNhbCA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0b2dnbGUgZ3JvdXAgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHRvZ2dsZSBncm91cCBpcyB2ZXJ0aWNhbC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVydGljYWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5wcm90b3R5cGUsIFwidmVydGljYWxcIiwgbnVsbCk7XG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtYnV0dG9uLXRvZ2dsZS1ncm91cFttdWx0aXBsZV0sIG1hdC1idXR0b24tdG9nZ2xlLWdyb3VwW211bHRpcGxlXScsXG4gICAgICAgICAgICBleHBvcnRBczogJ21kQnV0dG9uVG9nZ2xlR3JvdXAnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXBdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtdmVydGljYWxdJzogJ3ZlcnRpY2FsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlKTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlO1xufSgpKTtcbi8qKiBTaW5nbGUgYnV0dG9uIGluc2lkZSBvZiBhIHRvZ2dsZSBncm91cC4gKi9cbnZhciBNZEJ1dHRvblRvZ2dsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGUodG9nZ2xlR3JvdXAsIHRvZ2dsZUdyb3VwTXVsdGlwbGUsIGJ1dHRvblRvZ2dsZURpc3BhdGNoZXIsIF9yZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZURpc3BhdGNoZXIgPSBidXR0b25Ub2dnbGVEaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgYnV0dG9uIHRvZ2dsZSBpcyBjaGVja2VkLiAqL1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGJ1dHRvbiB0b2dnbGUgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICAgICAgLyoqIFZhbHVlIGFzc2lnbmVkIHRvIHRoaXMgYnV0dG9uIHRvZ2dsZS4gKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIGJ1dHRvbiB0b2dnbGUgaXMgYSBzaW5nbGUgc2VsZWN0aW9uLiAqL1xuICAgICAgICB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZ3JvdXAgdmFsdWUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5fY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgPSB0b2dnbGVHcm91cDtcbiAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gdG9nZ2xlR3JvdXBNdWx0aXBsZTtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXApIHtcbiAgICAgICAgICAgIGJ1dHRvblRvZ2dsZURpc3BhdGNoZXIubGlzdGVuKGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBfdGhpcy5pZCAmJiBuYW1lID09IF90aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICdyYWRpbyc7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLm5hbWU7XG4gICAgICAgICAgICB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlcmUgaXMgbm8gZ3JvdXAgYXQgYWxsLCB0cmVhdCB0aGUgYnV0dG9uIHRvZ2dsZSBhcyBhIGNoZWNrYm94IHNvIGl0IGNhbiBiZVxuICAgICAgICAgICAgLy8gdG9nZ2xlZCBvbiBvciBvZmYuXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgIHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImNoYW5nZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gXCJtZC1idXR0b24tdG9nZ2xlLVwiICsgX3VuaXF1ZUlkQ291bnRlciQxKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgJiYgdGhpcy5fdmFsdWUgPT0gdGhpcy5idXR0b25Ub2dnbGVHcm91cC52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIC8qKiBVbmlxdWUgSUQgZm9yIHRoZSB1bmRlcmx5aW5nIGBpbnB1dGAgZWxlbWVudC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZCArIFwiLWlucHV0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBidXR0b24gaXMgY2hlY2tlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaW5nbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBidXR0b24gdG9nZ2xlcyB3aXRoIHRoZSBzYW1lIG5hbWUgKGluIHRoZSBzYW1lIGdyb3VwKSB0byB1bi1jaGVjay5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVEaXNwYXRjaGVyLm5vdGlmeSh0aGlzLmlkLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBuZXdDaGVja2VkU3RhdGU7XG4gICAgICAgICAgICBpZiAobmV3Q2hlY2tlZFN0YXRlICYmIHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IgJiYgdGhpcy5idXR0b25Ub2dnbGVHcm91cC52YWx1ZSAhPSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cC5zZWxlY3RlZCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogTWRCdXR0b25Ub2dnbGVHcm91cCByZWFkcyB0aGlzIHRvIGFzc2lnbiBpdHMgb3duIHZhbHVlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwICE9IG51bGwgJiYgdGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIERpc3BhdGNoIGNoYW5nZSBldmVudCB3aXRoIGN1cnJlbnQgdmFsdWUuICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBNZEJ1dHRvblRvZ2dsZUNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl9jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgfHwgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgIT0gbnVsbCAmJiB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLmRpc2FibGVkKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUgIT0gbnVsbCAmJiB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUuZGlzYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBUb2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGJ1dHRvbiB0b2dnbGUuICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLl90b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgfTtcbiAgICAvKiogQ2hlY2tzIHRoZSBidXR0b24gdG9nZ2xlIGR1ZSB0byBhbiBpbnRlcmFjdGlvbiB3aXRoIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBpbnB1dC4gKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NpbmdsZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBQcm9wYWdhdGUgdGhlIGNoYW5nZSBvbmUtd2F5IHZpYSB0aGUgZ3JvdXAsIHdoaWNoIHdpbGwgaW4gdHVybiBtYXJrIHRoaXNcbiAgICAgICAgICAgIC8vIGJ1dHRvbiB0b2dnbGUgYXMgY2hlY2tlZC5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnNlbGVjdGVkID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlIG5hdGl2ZSBpbnB1dCBkb2VzLlxuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZGlzcGF0Y2hlZCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBTaW5jZSB3ZSBhcmUgdXNpbmcgYSBsYWJlbCBlbGVtZW50IGFzIG91clxuICAgICAgICAvLyByb290IGNvbnRhaW5lciwgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBgc2xpZGUtdG9nZ2xlYCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIGJ1dHRvbi4gKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKCdpbnB1dCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcIl9pbnB1dEVsZW1lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtY2hlY2tlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWF0LWJ1dHRvbi10b2dnbGUtZGlzYWJsZWQnKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBNZEJ1dHRvblRvZ2dsZSA9IF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1idXR0b24tdG9nZ2xlLCBtYXQtYnV0dG9uLXRvZ2dsZScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGFiZWwgW2F0dHIuZm9yXT1cXFwiaW5wdXRJZFxcXCIgY2xhc3M9XFxcIm1hdC1idXR0b24tdG9nZ2xlLWxhYmVsXFxcIj48aW5wdXQgI2lucHV0IGNsYXNzPVxcXCJtYXQtYnV0dG9uLXRvZ2dsZS1pbnB1dCBjZGstdmlzdWFsbHktaGlkZGVuXFxcIiBbdHlwZV09XFxcIl90eXBlXFxcIiBbaWRdPVxcXCJpbnB1dElkXFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIChjaGFuZ2UpPVxcXCJfb25JbnB1dENoYW5nZSgkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1idXR0b24tdG9nZ2xlLWxhYmVsLWNvbnRlbnRcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48L2xhYmVsPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXB7Ym94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2JvcmRlci1yYWRpdXM6MnB4O2N1cnNvcjpwb2ludGVyO3doaXRlLXNwYWNlOm5vd3JhcH0ubWF0LWJ1dHRvbi10b2dnbGUtdmVydGljYWx7ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5tYXQtYnV0dG9uLXRvZ2dsZS12ZXJ0aWNhbCAubWF0LWJ1dHRvbi10b2dnbGUtbGFiZWwtY29udGVudHtkaXNwbGF5OmJsb2NrfS5tYXQtYnV0dG9uLXRvZ2dsZS1kaXNhYmxlZCAubWF0LWJ1dHRvbi10b2dnbGUtbGFiZWwtY29udGVudHtjdXJzb3I6ZGVmYXVsdH0ubWF0LWJ1dHRvbi10b2dnbGV7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWZ9Lm1hdC1idXR0b24tdG9nZ2xlLWxhYmVsLWNvbnRlbnR7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGluZS1oZWlnaHQ6MzZweDtwYWRkaW5nOjAgMTZweDtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9Lm1hdC1idXR0b24tdG9nZ2xlLWxhYmVsLWNvbnRlbnQ+Knt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJ1dHRvbi10b2dnbGVdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDQoMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSQ0KDEsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246cGFyYW10eXBlcycsIFtNZEJ1dHRvblRvZ2dsZUdyb3VwLCBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlKTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGU7XG59KCkpO1xudmFyIE1kQnV0dG9uVG9nZ2xlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvblRvZ2dsZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRCdXR0b25Ub2dnbGVNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZEJ1dHRvblRvZ2dsZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kQnV0dG9uVG9nZ2xlTW9kdWxlID0gX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2Zvcm1zLkZvcm1zTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLFxuICAgICAgICAgICAgICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSxcbiAgICAgICAgICAgICAgICBNZEJ1dHRvblRvZ2dsZSxcbiAgICAgICAgICAgICAgICBDb21wYXRpYmlsaXR5TW9kdWxlLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kQnV0dG9uVG9nZ2xlR3JvdXAsIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSwgTWRCdXR0b25Ub2dnbGVdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVNb2R1bGUpO1xuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQzMiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzMiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLy8gVE9ETyhqZWxib3Vybik6IE1ha2UgdGhlIGBpc01vdXNlRG93bmAgc3R1ZmYgZG9uZSB3aXRoIG9uZSBnbG9iYWwgbGlzdGVuZXIuXG4vLyBUT0RPKGthcmEpOiBDb252ZXJ0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgdG8gY2xhc3NlcyB3aGVuIGF0dHIgbWFwcyBiZWNvbWUgYXZhaWxhYmxlXG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRCdXR0b25Dc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZEJ1dHRvbkNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1idXR0b25dLCBidXR0b25bbWF0LWJ1dHRvbl0sIGFbbWQtYnV0dG9uXSwgYVttYXQtYnV0dG9uXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRCdXR0b25Dc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZEJ1dHRvbkNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1yYWlzZWQtYnV0dG9uXSwgYnV0dG9uW21hdC1yYWlzZWQtYnV0dG9uXSwgJyArXG4gICAgICAgICAgICAgICAgJ2FbbWQtcmFpc2VkLWJ1dHRvbl0sIGFbbWF0LXJhaXNlZC1idXR0b25dJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yYWlzZWQtYnV0dG9uXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1pY29uLWJ1dHRvbl0sIGJ1dHRvblttYXQtaWNvbi1idXR0b25dLCBhW21kLWljb24tYnV0dG9uXSwgYVttYXQtaWNvbi1idXR0b25dJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1pY29uLWJ1dHRvbl0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kRmFiQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEZhYkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRGYWJDc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtZmFiXSwgYnV0dG9uW21hdC1mYWJdLCBhW21kLWZhYl0sIGFbbWF0LWZhYl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWZhYl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kRmFiQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRGYWJDc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kTWluaUZhYkNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRNaW5pRmFiQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZE1pbmlGYWJDc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtbWluaS1mYWJdLCBidXR0b25bbWF0LW1pbmktZmFiXSwgYVttZC1taW5pLWZhYl0sIGFbbWF0LW1pbmktZmFiXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbWluaS1mYWJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZE1pbmlGYWJDc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZE1pbmlGYWJDc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBNYXRlcmlhbCBkZXNpZ24gYnV0dG9uLlxuICovXG52YXIgTWRCdXR0b24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uKF9lbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJ1dHRvbiBoYXMgZm9jdXMgZnJvbSB0aGUga2V5Ym9hcmQgKG5vdCB0aGUgbW91c2UpLiBVc2VkIGZvciBjbGFzcyBiaW5kaW5nLiAqL1xuICAgICAgICB0aGlzLl9pc0tleWJvYXJkRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciBhIG1vdXNlZG93biBoYXMgb2NjdXJyZWQgb24gdGhpcyBlbGVtZW50IGluIHRoZSBsYXN0IDEwMG1zLiAqL1xuICAgICAgICB0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcmlwcGxlIGVmZmVjdCBvbiBjbGljayBzaG91bGQgYmUgZGlzYWJsZWQuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcmlwcGxlIGVmZmVjdCBmb3IgdGhpcyBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl9kaXNhYmxlUmlwcGxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHYpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpID8gdHJ1ZSA6IG51bGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvbi5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBidXR0b24uIENhbiBiZSBgcHJpbWFyeWAsIGBhY2NlbnRgLCBvciBgd2FybmAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sb3I7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9zZXRNb3VzZWRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdlIG9ubHkgKnNob3cqIHRoZSBmb2N1cyBzdHlsZSB3aGVuIGZvY3VzIGhhcyBjb21lIHRvIHRoZSBidXR0b24gdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgICAgLy8gVGhlIE1hdGVyaWFsIERlc2lnbiBzcGVjIGlzIHNpbGVudCBvbiB0aGlzIHRvcGljLCBhbmQgd2l0aG91dCBkb2luZyB0aGlzLCB0aGVcbiAgICAgICAgLy8gYnV0dG9uIGNvbnRpbnVlcyB0byBsb29rIDphY3RpdmUgYWZ0ZXIgY2xpY2tpbmcuXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL21hcmN5c3V0dG9uLmNvbS9idXR0b24tZm9jdXMtaGVsbC9cbiAgICAgICAgdGhpcy5faXNNb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgX3RoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7IH0sIDEwMCk7XG4gICAgfTtcbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yID0gZnVuY3Rpb24gKG5ld0NvbG9yKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcih0aGlzLl9jb2xvciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IobmV3Q29sb3IsIHRydWUpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld0NvbG9yO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZ2V0SG9zdEVsZW1lbnQoKSwgXCJtYXQtXCIgKyBjb2xvciwgaXNBZGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX3NldEtleWJvYXJkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzS2V5Ym9hcmRGb2N1c2VkID0gIXRoaXMuX2lzTW91c2VEb3duO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9yZW1vdmVLZXlib2FyZEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0tleWJvYXJkRm9jdXNlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIGJ1dHRvbi4gKi9cbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5fZ2V0SG9zdEVsZW1lbnQoKSwgJ2ZvY3VzJyk7XG4gICAgfTtcbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX2dldEhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9pc1JvdW5kQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLl9nZXRIb3N0RWxlbWVudCgpO1xuICAgICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKCdtZC1pY29uLWJ1dHRvbicpIHx8XG4gICAgICAgICAgICBlbC5oYXNBdHRyaWJ1dGUoJ21kLWZhYicpIHx8XG4gICAgICAgICAgICBlbC5oYXNBdHRyaWJ1dGUoJ21kLW1pbmktZmFiJyk7XG4gICAgfTtcbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX2lzUmlwcGxlRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVSaXBwbGUgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEJ1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRCdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEJ1dHRvbi5wcm90b3R5cGUsIFwiY29sb3JcIiwgbnVsbCk7XG4gICAgTWRCdXR0b24gPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnYnV0dG9uW21kLWJ1dHRvbl0sIGJ1dHRvblttZC1yYWlzZWQtYnV0dG9uXSwgYnV0dG9uW21kLWljb24tYnV0dG9uXSwnICtcbiAgICAgICAgICAgICAgICAnYnV0dG9uW21kLWZhYl0sIGJ1dHRvblttZC1taW5pLWZhYl0sJyArXG4gICAgICAgICAgICAgICAgJ2J1dHRvblttYXQtYnV0dG9uXSwgYnV0dG9uW21hdC1yYWlzZWQtYnV0dG9uXSwgYnV0dG9uW21hdC1pY29uLWJ1dHRvbl0sJyArXG4gICAgICAgICAgICAgICAgJ2J1dHRvblttYXQtZmFiXSwgYnV0dG9uW21hdC1taW5pLWZhYl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tZm9jdXNdJzogJ19pc0tleWJvYXJkRm9jdXNlZCcsXG4gICAgICAgICAgICAgICAgJyhtb3VzZWRvd24pJzogJ19zZXRNb3VzZWRvd24oKScsXG4gICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnX3NldEtleWJvYXJkRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfcmVtb3ZlS2V5Ym9hcmRGb2N1cygpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3BhbiBjbGFzcz1cXFwibWF0LWJ1dHRvbi13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjxkaXYgbWQtcmlwcGxlICpuZ0lmPVxcXCIhX2lzUmlwcGxlRGlzYWJsZWQoKVxcXCIgY2xhc3M9XFxcIm1hdC1idXR0b24tcmlwcGxlXFxcIiBbY2xhc3MubWF0LWJ1dHRvbi1yaXBwbGUtcm91bmRdPVxcXCJfaXNSb3VuZEJ1dHRvbigpXFxcIiBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwiX2dldEhvc3RFbGVtZW50KClcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheVxcXCIgKHRvdWNoc3RhcnQpPVxcXCIkZXZlbnQucHJldmVudERlZmF1bHQoKVxcXCI+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYnV0dG9uLWZvY3VzLm1hdC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWJ1dHRvbi1mb2N1cy5tYXQtZmFiIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LW1pbmktZmFiIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWJ1dHRvbjpob3ZlciAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtaWNvbi1idXR0b246aG92ZXIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtvcGFjaXR5OjF9Lm1hdC1idXR0b24sLm1hdC1mYWIsLm1hdC1pY29uLWJ1dHRvbiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO291dGxpbmU6MDtib3JkZXI6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dmVydGljYWwtYWxpZ246YmFzZWxpbmU7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luOjA7bWluLXdpZHRoOjg4cHg7bGluZS1oZWlnaHQ6MzZweDtwYWRkaW5nOjAgMTZweDtib3JkZXItcmFkaXVzOjJweH1bZGlzYWJsZWRdLm1hdC1idXR0b24sW2Rpc2FibGVkXS5tYXQtZmFiLFtkaXNhYmxlZF0ubWF0LWljb24tYnV0dG9uLFtkaXNhYmxlZF0ubWF0LW1pbmktZmFiLFtkaXNhYmxlZF0ubWF0LXJhaXNlZC1idXR0b257Y3Vyc29yOmRlZmF1bHR9Lm1hdC1mYWIsLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllciguNCwwLC4yLDEpfS5tYXQtZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmUsLm1hdC1taW5pLWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZlLC5tYXQtcmFpc2VkLWJ1dHRvbjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA1cHggNXB4IC0zcHggcmdiYSgwLDAsMCwuMiksMCA4cHggMTBweCAxcHggcmdiYSgwLDAsMCwuMTQpLDAgM3B4IDE0cHggMnB4IHJnYmEoMCwwLDAsLjEyKX1bZGlzYWJsZWRdLm1hdC1mYWIsW2Rpc2FibGVkXS5tYXQtbWluaS1mYWIsW2Rpc2FibGVkXS5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2hhZG93Om5vbmV9Lm1hdC1idXR0b25bZGlzYWJsZWRdOmhvdmVyIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1hY2NlbnQsLm1hdC1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1wcmltYXJ5LC5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtd2FybiwubWF0LWljb24tYnV0dG9uW2Rpc2FibGVkXTpob3ZlciAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtaWNvbi1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1hY2NlbnQsLm1hdC1pY29uLWJ1dHRvbltkaXNhYmxlZF06aG92ZXIubWF0LXByaW1hcnksLm1hdC1pY29uLWJ1dHRvbltkaXNhYmxlZF06aG92ZXIubWF0LXdhcm57YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0ubWF0LWZhYntib3gtc2hhZG93OjAgM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsLjIpLDAgNnB4IDEwcHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggMThweCAwIHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MDtib3JkZXItcmFkaXVzOjUwJTt3aWR0aDo1NnB4O2hlaWdodDo1NnB4O3BhZGRpbmc6MDtmbGV4LXNocmluazowfS5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYnttaW4td2lkdGg6MDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmV7Ym94LXNoYWRvdzowIDdweCA4cHggLTRweCByZ2JhKDAsMCwwLC4yKSwwIDEycHggMTdweCAycHggcmdiYSgwLDAsMCwuMTQpLDAgNXB4IDIycHggNHB4IHJnYmEoMCwwLDAsLjEyKX0ubWF0LWZhYiAubWF0LWljb24sLm1hdC1mYWIgaXtwYWRkaW5nOjE2cHggMDtsaW5lLWhlaWdodDoyNHB4fS5tYXQtbWluaS1mYWJ7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7cGFkZGluZzowO2ZsZXgtc2hyaW5rOjB9Lm1hdC1taW5pLWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA3cHggOHB4IC00cHggcmdiYSgwLDAsMCwuMiksMCAxMnB4IDE3cHggMnB4IHJnYmEoMCwwLDAsLjE0KSwwIDVweCAyMnB4IDRweCByZ2JhKDAsMCwwLC4xMil9Lm1hdC1taW5pLWZhYiAubWF0LWljb24sLm1hdC1taW5pLWZhYiBpe3BhZGRpbmc6OHB4IDA7bGluZS1oZWlnaHQ6MjRweH0ubWF0LWljb24tYnV0dG9ue3BhZGRpbmc6MDtmbGV4LXNocmluazowO2xpbmUtaGVpZ2h0OjQwcHh9Lm1hdC1pY29uLWJ1dHRvbiAubWF0LWljb24sLm1hdC1pY29uLWJ1dHRvbiBpe2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1idXR0b24sLm1hdC1pY29uLWJ1dHRvbiwubWF0LXJhaXNlZC1idXR0b257Y29sb3I6Y3VycmVudENvbG9yfS5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24td3JhcHBlcj4qe3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MH0ubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMTIpO2JvcmRlci1yYWRpdXM6aW5oZXJpdDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MH0ubWF0LWJ1dHRvbi1yaXBwbGUtcm91bmR7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI1NSwyNTUsMjU1LC41KX0ubWF0LWJ1dHRvbiwubWF0LWZhYiwubWF0LWljb24tYnV0dG9uLC5tYXQtbWluaS1mYWIsLm1hdC1yYWlzZWQtYnV0dG9ue291dGxpbmU6c29saWQgMXB4fX1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlcl0pXG4gICAgXSwgTWRCdXR0b24pO1xuICAgIHJldHVybiBNZEJ1dHRvbjtcbn0oKSk7XG4vKipcbiAqIFJhaXNlZCBNYXRlcmlhbCBkZXNpZ24gYnV0dG9uLlxuICovXG52YXIgTWRBbmNob3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ3KE1kQW5jaG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kQW5jaG9yKGVsZW1lbnRSZWYsIHJlbmRlcmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnRSZWYsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQW5jaG9yLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCB7XG4gICAgICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEFuY2hvci5wcm90b3R5cGUsIFwiX2lzQXJpYURpc2FibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQW5jaG9yLnByb3RvdHlwZS5faGFsdERpc2FibGVkRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEEgZGlzYWJsZWQgYnV0dG9uIHNob3VsZG4ndCBhcHBseSBhbnkgYWN0aW9uc1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygndGFiSW5kZXgnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kQW5jaG9yLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbiAgICBNZEFuY2hvciA9IF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6IFwiYVttZC1idXR0b25dLCBhW21kLXJhaXNlZC1idXR0b25dLCBhW21kLWljb24tYnV0dG9uXSwgYVttZC1mYWJdLCBhW21kLW1pbmktZmFiXSxcXG4gICAgICAgICAgICAgYVttYXQtYnV0dG9uXSwgYVttYXQtcmFpc2VkLWJ1dHRvbl0sIGFbbWF0LWljb24tYnV0dG9uXSwgYVttYXQtZmFiXSwgYVttYXQtbWluaS1mYWJdXCIsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1thdHRyLmRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ19pc0FyaWFEaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLWZvY3VzXSc6ICdfaXNLZXlib2FyZEZvY3VzZWQnLFxuICAgICAgICAgICAgICAgICcobW91c2Vkb3duKSc6ICdfc2V0TW91c2Vkb3duKCknLFxuICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ19zZXRLZXlib2FyZEZvY3VzKCknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX3JlbW92ZUtleWJvYXJkRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgJyhjbGljayknOiAnX2hhbHREaXNhYmxlZEV2ZW50cygkZXZlbnQpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3BhbiBjbGFzcz1cXFwibWF0LWJ1dHRvbi13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjxkaXYgbWQtcmlwcGxlICpuZ0lmPVxcXCIhX2lzUmlwcGxlRGlzYWJsZWQoKVxcXCIgY2xhc3M9XFxcIm1hdC1idXR0b24tcmlwcGxlXFxcIiBbY2xhc3MubWF0LWJ1dHRvbi1yaXBwbGUtcm91bmRdPVxcXCJfaXNSb3VuZEJ1dHRvbigpXFxcIiBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwiX2dldEhvc3RFbGVtZW50KClcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheVxcXCIgKHRvdWNoc3RhcnQpPVxcXCIkZXZlbnQucHJldmVudERlZmF1bHQoKVxcXCI+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtYnV0dG9uLWZvY3VzLm1hdC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWJ1dHRvbi1mb2N1cy5tYXQtZmFiIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LW1pbmktZmFiIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWJ1dHRvbjpob3ZlciAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtaWNvbi1idXR0b246aG92ZXIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtvcGFjaXR5OjF9Lm1hdC1idXR0b24sLm1hdC1mYWIsLm1hdC1pY29uLWJ1dHRvbiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO291dGxpbmU6MDtib3JkZXI6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dmVydGljYWwtYWxpZ246YmFzZWxpbmU7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7dGV4dC1hbGlnbjpjZW50ZXI7bWFyZ2luOjA7bWluLXdpZHRoOjg4cHg7bGluZS1oZWlnaHQ6MzZweDtwYWRkaW5nOjAgMTZweDtib3JkZXItcmFkaXVzOjJweH1bZGlzYWJsZWRdLm1hdC1idXR0b24sW2Rpc2FibGVkXS5tYXQtZmFiLFtkaXNhYmxlZF0ubWF0LWljb24tYnV0dG9uLFtkaXNhYmxlZF0ubWF0LW1pbmktZmFiLFtkaXNhYmxlZF0ubWF0LXJhaXNlZC1idXR0b257Y3Vyc29yOmRlZmF1bHR9Lm1hdC1mYWIsLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllciguNCwwLC4yLDEpfS5tYXQtZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmUsLm1hdC1taW5pLWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZlLC5tYXQtcmFpc2VkLWJ1dHRvbjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA1cHggNXB4IC0zcHggcmdiYSgwLDAsMCwuMiksMCA4cHggMTBweCAxcHggcmdiYSgwLDAsMCwuMTQpLDAgM3B4IDE0cHggMnB4IHJnYmEoMCwwLDAsLjEyKX1bZGlzYWJsZWRdLm1hdC1mYWIsW2Rpc2FibGVkXS5tYXQtbWluaS1mYWIsW2Rpc2FibGVkXS5tYXQtcmFpc2VkLWJ1dHRvbntib3gtc2hhZG93Om5vbmV9Lm1hdC1idXR0b25bZGlzYWJsZWRdOmhvdmVyIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1hY2NlbnQsLm1hdC1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1wcmltYXJ5LC5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtd2FybiwubWF0LWljb24tYnV0dG9uW2Rpc2FibGVkXTpob3ZlciAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtaWNvbi1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1hY2NlbnQsLm1hdC1pY29uLWJ1dHRvbltkaXNhYmxlZF06aG92ZXIubWF0LXByaW1hcnksLm1hdC1pY29uLWJ1dHRvbltkaXNhYmxlZF06aG92ZXIubWF0LXdhcm57YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0ubWF0LWZhYntib3gtc2hhZG93OjAgM3B4IDVweCAtMXB4IHJnYmEoMCwwLDAsLjIpLDAgNnB4IDEwcHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggMThweCAwIHJnYmEoMCwwLDAsLjEyKTttaW4td2lkdGg6MDtib3JkZXItcmFkaXVzOjUwJTt3aWR0aDo1NnB4O2hlaWdodDo1NnB4O3BhZGRpbmc6MDtmbGV4LXNocmluazowfS5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYnttaW4td2lkdGg6MDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtZmFiOm5vdChbZGlzYWJsZWRdKTphY3RpdmV7Ym94LXNoYWRvdzowIDdweCA4cHggLTRweCByZ2JhKDAsMCwwLC4yKSwwIDEycHggMTdweCAycHggcmdiYSgwLDAsMCwuMTQpLDAgNXB4IDIycHggNHB4IHJnYmEoMCwwLDAsLjEyKX0ubWF0LWZhYiAubWF0LWljb24sLm1hdC1mYWIgaXtwYWRkaW5nOjE2cHggMDtsaW5lLWhlaWdodDoyNHB4fS5tYXQtbWluaS1mYWJ7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7cGFkZGluZzowO2ZsZXgtc2hyaW5rOjB9Lm1hdC1taW5pLWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA3cHggOHB4IC00cHggcmdiYSgwLDAsMCwuMiksMCAxMnB4IDE3cHggMnB4IHJnYmEoMCwwLDAsLjE0KSwwIDVweCAyMnB4IDRweCByZ2JhKDAsMCwwLC4xMil9Lm1hdC1taW5pLWZhYiAubWF0LWljb24sLm1hdC1taW5pLWZhYiBpe3BhZGRpbmc6OHB4IDA7bGluZS1oZWlnaHQ6MjRweH0ubWF0LWljb24tYnV0dG9ue3BhZGRpbmc6MDtmbGV4LXNocmluazowO2xpbmUtaGVpZ2h0OjQwcHh9Lm1hdC1pY29uLWJ1dHRvbiAubWF0LWljb24sLm1hdC1pY29uLWJ1dHRvbiBpe2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1idXR0b24sLm1hdC1pY29uLWJ1dHRvbiwubWF0LXJhaXNlZC1idXR0b257Y29sb3I6Y3VycmVudENvbG9yfS5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LWljb24tYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+KiwubWF0LXJhaXNlZC1idXR0b24gLm1hdC1idXR0b24td3JhcHBlcj4qe3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MH0ubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMTIpO2JvcmRlci1yYWRpdXM6aW5oZXJpdDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MH0ubWF0LWJ1dHRvbi1yaXBwbGUtcm91bmR7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI1NSwyNTUsMjU1LC41KX0ubWF0LWJ1dHRvbiwubWF0LWZhYiwubWF0LWljb24tYnV0dG9uLC5tYXQtbWluaS1mYWIsLm1hdC1yYWlzZWQtYnV0dG9ue291dGxpbmU6c29saWQgMXB4fX1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kQW5jaG9yKTtcbiAgICByZXR1cm4gTWRBbmNob3I7XG59KE1kQnV0dG9uKSk7XG52YXIgTWRCdXR0b25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZEJ1dHRvbk1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kQnV0dG9uTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRCdXR0b25Nb2R1bGUgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZSwgTWRSaXBwbGVNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kQnV0dG9uLCBNZEFuY2hvcixcbiAgICAgICAgICAgICAgICBDb21wYXRpYmlsaXR5TW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kQnV0dG9uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZEZhYkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZE1pbmlGYWJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBNZEJ1dHRvbixcbiAgICAgICAgICAgICAgICBNZEFuY2hvcixcbiAgICAgICAgICAgICAgICBNZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRGYWJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRNaW5pRmFiQ3NzTWF0U3R5bGVyXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRCdXR0b25Nb2R1bGUpO1xuICAgIHJldHVybiBNZEJ1dHRvbk1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDMzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDMzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIGludGVnZXIgdXNlZCB0byBhdXRvLWdlbmVyYXRlIHVuaXF1ZSBpZHMgZm9yIGNoZWNrYm94IGNvbXBvbmVudHMuICovXG52YXIgbmV4dElkID0gMDtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1jaGVja2JveCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogVGhpcyBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1EX0NIRUNLQk9YX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogX2FuZ3VsYXJfZm9ybXMuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZENoZWNrYm94OyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlmZmVyZW50IHN0YXRlcyB0aGF0IHJlcXVpcmUgY3VzdG9tIHRyYW5zaXRpb25zIGJldHdlZW4gdGhlbS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuXG4oZnVuY3Rpb24gKFRyYW5zaXRpb25DaGVja1N0YXRlKSB7XG4gICAgLyoqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgYmVmb3JlIGFueSB1c2VyIGludGVyYWN0aW9uLiAqL1xuICAgIFRyYW5zaXRpb25DaGVja1N0YXRlW1RyYW5zaXRpb25DaGVja1N0YXRlW1wiSW5pdFwiXSA9IDBdID0gXCJJbml0XCI7XG4gICAgLyoqIFRoZSBzdGF0ZSByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudCB3aGVuIGl0J3MgYmVjb21pbmcgY2hlY2tlZC4gKi9cbiAgICBUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtcIkNoZWNrZWRcIl0gPSAxXSA9IFwiQ2hlY2tlZFwiO1xuICAgIC8qKiBUaGUgc3RhdGUgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQgd2hlbiBpdCdzIGJlY29taW5nIHVuY2hlY2tlZC4gKi9cbiAgICBUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtcIlVuY2hlY2tlZFwiXSA9IDJdID0gXCJVbmNoZWNrZWRcIjtcbiAgICAvKiogVGhlIHN0YXRlIHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50IHdoZW4gaXQncyBiZWNvbWluZyBpbmRldGVybWluYXRlLiAqL1xuICAgIFRyYW5zaXRpb25DaGVja1N0YXRlW1RyYW5zaXRpb25DaGVja1N0YXRlW1wiSW5kZXRlcm1pbmF0ZVwiXSA9IDNdID0gXCJJbmRldGVybWluYXRlXCI7XG59KShleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlIHx8IChleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlID0ge30pKTtcbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRDaGVja2JveC4gKi9cbnZhciBNZENoZWNrYm94Q2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoZWNrYm94Q2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRDaGVja2JveENoYW5nZTtcbn0oKSk7XG4vKipcbiAqIEEgbWF0ZXJpYWwgZGVzaWduIGNoZWNrYm94IGNvbXBvbmVudC4gU3VwcG9ydHMgYWxsIG9mIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIEhUTUw1IGNoZWNrYm94LFxuICogYW5kIGV4cG9zZXMgYSBzaW1pbGFyIEFQSS4gQSBNZENoZWNrYm94IGNhbiBiZSBlaXRoZXIgY2hlY2tlZCwgdW5jaGVja2VkLCBpbmRldGVybWluYXRlLCBvclxuICogZGlzYWJsZWQuIE5vdGUgdGhhdCBhbGwgYWRkaXRpb25hbCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXMgYXJlIHRha2VuIGNhcmUgb2YgYnkgdGhlIGNvbXBvbmVudCxcbiAqIHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gcHJvdmlkZSB0aGVtIHlvdXJzZWxmLiBIb3dldmVyLCBpZiB5b3Ugd2FudCB0byBvbWl0IGEgbGFiZWwgYW5kIHN0aWxsXG4gKiBoYXZlIHRoZSBjaGVja2JveCBiZSBhY2Nlc3NpYmxlLCB5b3UgbWF5IHN1cHBseSBhbiBbYXJpYS1sYWJlbF0gaW5wdXQuXG4gKiBTZWU6IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9zZWxlY3Rpb24tY29udHJvbHMuaHRtbFxuICovXG52YXIgTWRDaGVja2JveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGVja2JveChfcmVuZGVyZXIsIF9lbGVtZW50UmVmLCBfY2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlZCB0byB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgZWxlbWVudC4gSW4gbW9zdCBjYXNlcywgYXJpYWwtbGFiZWxsZWRieSB3aWxsXG4gICAgICAgICAqIHRha2UgcHJlY2VkZW5jZSBzbyB0aGlzIG1heSBiZSBvbWl0dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZXJzIGNhbiBzcGVjaWZ5IHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBhdHRyaWJ1dGUgd2hpY2ggd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJpYUxhYmVsbGVkYnkgPSBudWxsO1xuICAgICAgICAvKiogQSB1bmlxdWUgaWQgZm9yIHRoZSBjaGVja2JveC4gSWYgb25lIGlzIG5vdCBzdXBwbGllZCwgaXQgaXMgYXV0by1nZW5lcmF0ZWQuICovXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLWNoZWNrYm94LVwiICsgKytuZXh0SWQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYXBwZWFyIGFmdGVyIG9yIGJlZm9yZSB0aGUgY2hlY2tib3guIERlZmF1bHRzIHRvICdhZnRlcicgKi9cbiAgICAgICAgdGhpcy5sYWJlbFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRhYmluZGV4IHZhbHVlIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVsZW1lbnQuICovXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAwO1xuICAgICAgICAvKiogTmFtZSB2YWx1ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQgaWYgcHJlc2VudCAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjaGVja2JveCdzIGBjaGVja2VkYCB2YWx1ZSBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjaGVja2JveCdzIGBpbmRldGVybWluYXRlYCB2YWx1ZSBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBjaGVja2JveCBpcyBibHVycmVkLiBOZWVkZWQgdG8gcHJvcGVybHkgaW1wbGVtZW50IENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgdGhpcy5fY3VycmVudEFuaW1hdGlvbkNsYXNzID0gJyc7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaGVja1N0YXRlID0gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5Jbml0O1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgICAgICB0aGlzLl9oYXNGb2N1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbG9yID0gJ2FjY2VudCc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHJpcHBsZSBlZmZlY3QgZm9yIHRoaXMgY2hlY2tib3ggaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHtcbiAgICAgICAgLyoqIElEIG9mIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBpbnNpZGUgYDxtZC1jaGVja2JveD5gICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXQtXCIgKyB0aGlzLmlkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgcmVxdWlyZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImFsaWduXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjaGVja2JveCBzaG91bGQgYXBwZWFyIGJlZm9yZSBvciBhZnRlciB0aGUgbGFiZWwuXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGFsaWduIHJlZmVycyB0byB0aGUgY2hlY2tib3ggcmVsYXRpdmUgdG8gdGhlIGxhYmVsLCB3aGlsZSBsYWJlbFBvc2l0aW9uIHJlZmVycyB0byB0aGVcbiAgICAgICAgICAgIC8vIGxhYmVsIHJlbGF0aXZlIHRvIHRoZSBjaGVja2JveC4gQXMgc3VjaCwgdGhleSBhcmUgaW52ZXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09ICdhZnRlcicgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICh2ID09ICdzdGFydCcpID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZC4gTm90ZSB0aGF0IHNldHRpbmcgYGNoZWNrZWRgIHdpbGwgaW1tZWRpYXRlbHkgc2V0XG4gICAgICAgICAqIGBpbmRldGVybWluYXRlYCB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNoZWNrZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VkICE9IHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRldGVybWluYXRlQ2hhbmdlLmVtaXQodGhpcy5faW5kZXRlcm1pbmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25DaGVja1N0YXRlKHRoaXMuX2NoZWNrZWQgPyBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgOiBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJpbmRldGVybWluYXRlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGluZGV0ZXJtaW5hdGUuIFRoaXMgaXMgYWxzbyBrbm93biBhcyBcIm1peGVkXCIgbW9kZSBhbmQgY2FuIGJlIHVzZWQgdG9cbiAgICAgICAgICogcmVwcmVzZW50IGEgY2hlY2tib3ggd2l0aCB0aHJlZSBzdGF0ZXMsIGUuZy4gYSBjaGVja2JveCB0aGF0IHJlcHJlc2VudHMgYSBuZXN0ZWQgbGlzdCBvZlxuICAgICAgICAgKiBjaGVja2FibGUgaXRlbXMuIE5vdGUgdGhhdCB3aGVuZXZlciBgY2hlY2tlZGAgaXMgc2V0LCBpbmRldGVybWluYXRlIGlzIGltbWVkaWF0ZWx5IHNldCB0b1xuICAgICAgICAgKiBmYWxzZS4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHdlYiBwbGF0Zm9ybSBpbiB0aGF0IGluZGV0ZXJtaW5hdGUgc3RhdGUgb24gbmF0aXZlXG4gICAgICAgICAqIGNoZWNrYm94ZXMgaXMgb25seSByZW1vdmUgd2hlbiB0aGUgdXNlciBtYW51YWxseSBjaGVja3MgdGhlIGNoZWNrYm94IChyYXRoZXIgdGhhbiBzZXR0aW5nIHRoZVxuICAgICAgICAgKiBgY2hlY2tlZGAgcHJvcGVydHkgcHJvZ3JhbW1hdGljYWxseSkuIEhvd2V2ZXIsIHdlIGZlZWwgdGhhdCB0aGlzIGJlaGF2aW9yIGlzIG1vcmUgYWNjb21tb2RhdGluZ1xuICAgICAgICAgKiB0byB0aGUgd2F5IGNvbnN1bWVycyB3b3VsZCBlbnZpc2lvbiB1c2luZyB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV0ZXJtaW5hdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gaW5kZXRlcm1pbmF0ZSAhPSB0aGlzLl9pbmRldGVybWluYXRlO1xuICAgICAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25DaGVja1N0YXRlKGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5kZXRlcm1pbmF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSh0aGlzLmNoZWNrZWQgPyBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgOiBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KHRoaXMuX2luZGV0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBidXR0b24uIENhbiBiZSBgcHJpbWFyeWAsIGBhY2NlbnRgLCBvciBgd2FybmAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sb3I7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yID0gZnVuY3Rpb24gKG5ld0NvbG9yKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcih0aGlzLl9jb2xvciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IobmV3Q29sb3IsIHRydWUpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld0NvbG9yO1xuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX3NldEVsZW1lbnRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwgJiYgY29sb3IgIT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgY29sb3IsIGlzQWRkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2lzUmlwcGxlRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVSaXBwbGUgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vZGVsIHZhbHVlLiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiZSBzZXQgdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gISF2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY2hhbmdlLlxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRyb2wgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBmbiBDYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgdG91Y2hlZC5cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2hlY2tib3gncyBkaXNhYmxlZCBzdGF0ZS4gSW1wbGVtZW50ZWQgYXMgYSBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkIFdoZXRoZXIgdGhlIGNoZWNrYm94IHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fdHJhbnNpdGlvbkNoZWNrU3RhdGUgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5fY3VycmVudENoZWNrU3RhdGU7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgICB2YXIgZWxlbWVudFJlZiA9IHRoaXMuX2VsZW1lbnRSZWY7XG4gICAgICAgIGlmIChvbGRTdGF0ZSA9PT0gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEFuaW1hdGlvbkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcyA9IHRoaXMuX2dldEFuaW1hdGlvbkNsYXNzRm9yQ2hlY2tTdGF0ZVRyYW5zaXRpb24ob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5fY3VycmVudENoZWNrU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTWRDaGVja2JveENoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC5jaGVja2VkID0gdGhpcy5jaGVja2VkO1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKHRoaXMuY2hlY2tlZCk7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqIEluZm9ybXMgdGhlIGNvbXBvbmVudCB3aGVuIHRoZSBpbnB1dCBoYXMgZm9jdXMgc28gdGhhdCB3ZSBjYW4gc3R5bGUgYWNjb3JkaW5nbHkgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fb25JbnB1dEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9oYXNGb2N1cyA9IHRydWU7XG4gICAgfTtcbiAgICAvKiogSW5mb3JtcyB0aGUgY29tcG9uZW50IHdoZW4gd2UgbG9zZSBmb2N1cyBpbiBvcmRlciB0byBzdHlsZSBhY2NvcmRpbmdseSAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9vbklucHV0Qmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICB9O1xuICAgIC8qKiBUb2dnbGVzIHRoZSBgY2hlY2tlZGAgc3RhdGUgb2YgdGhlIGNoZWNrYm94LiAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNoZWNrYm94IGlucHV0IGVsZW1lbnQuXG4gICAgICogVG9nZ2xlcyBjaGVja2VkIHN0YXRlIGlmIGVsZW1lbnQgaXMgbm90IGRpc2FibGVkLlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9vbkludGVyYWN0aW9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGNoYW5nZSBldmVudCwgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCwgd2lsbCBidWJibGUgdXAgYW5kXG4gICAgICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0LlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgLy8gRW1pdCBvdXIgY3VzdG9tIGNoYW5nZSBldmVudCBpZiB0aGUgbmF0aXZlIGlucHV0IGVtaXR0ZWQgb25lLlxuICAgICAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIG9ubHkgZW1pdCBpdCwgaWYgdGhlIG5hdGl2ZSBpbnB1dCB0cmlnZ2VyZWQgb25lLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIHdoZW4gdGhlIGBjaGVja2VkYCB2YXJpYWJsZSBjaGFuZ2VzIGZvciBleGFtcGxlLlxuICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBjaGVja2JveC4gKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgICAgIHRoaXMuX29uSW5wdXRGb2N1cygpO1xuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX29uSW5wdXRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gZm9yIGNsaWNrIGV2ZW50cyBvbiB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB3aGVuIGEgdXNlciBjbGlja3Mgb24gYSBsYWJlbCBlbGVtZW50LCBhIGdlbmVyYXRlZCBjbGljayBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGRpc3BhdGNoZWQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gU2luY2Ugd2UgYXJlIHVzaW5nIGEgbGFiZWwgZWxlbWVudCBhcyBvdXJcbiAgICAgICAgLy8gcm9vdCBjb250YWluZXIsIHRoZSBjbGljayBldmVudCBvbiB0aGUgYGNoZWNrYm94YCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2dldEFuaW1hdGlvbkNsYXNzRm9yQ2hlY2tTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciBhbmltU3VmZml4O1xuICAgICAgICBzd2l0Y2ggKG9sZFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdDpcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlIHdoZXJlIHVzZXIgaW50ZXJhY3RzIHdpdGggY2hlY2tib3ggdGhhdCBkb2VzIG5vdCBoYXZlIFsobmdNb2RlbCldIG9yXG4gICAgICAgICAgICAgICAgLy8gW2NoZWNrZWRdIGJvdW5kIHRvIGl0LlxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1TdWZmaXggPSAndW5jaGVja2VkLWNoZWNrZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQ6XG4gICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9IG5ld1N0YXRlID09PSBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAndW5jaGVja2VkLWNoZWNrZWQnIDogJ3VuY2hlY2tlZC1pbmRldGVybWluYXRlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkOlxuICAgICAgICAgICAgICAgIGFuaW1TdWZmaXggPSBuZXdTdGF0ZSA9PT0gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAnY2hlY2tlZC11bmNoZWNrZWQnIDogJ2NoZWNrZWQtaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5kZXRlcm1pbmF0ZTpcbiAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gbmV3U3RhdGUgPT09IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCA/XG4gICAgICAgICAgICAgICAgICAgICdpbmRldGVybWluYXRlLWNoZWNrZWQnIDogJ2luZGV0ZXJtaW5hdGUtdW5jaGVja2VkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJtYXQtY2hlY2tib3gtYW5pbS1cIiArIGFuaW1TdWZmaXg7XG4gICAgfTtcbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fZ2V0SG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiYXJpYUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiYXJpYUxhYmVsbGVkYnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImxhYmVsUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcilcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJpbmRldGVybWluYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKCdpbnB1dCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiX2lucHV0RWxlbWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJpbmRldGVybWluYXRlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBNZENoZWNrYm94ID0gX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWNoZWNrYm94LCBtYXQtY2hlY2tib3gnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtbGF5b3V0XFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtaW5uZXItY29udGFpbmVyXFxcIj48aW5wdXQgI2lucHV0IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtaW5wdXQgY2RrLXZpc3VhbGx5LWhpZGRlblxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIFtpZF09XFxcImlucHV0SWRcXFwiIFtyZXF1aXJlZF09XFxcInJlcXVpcmVkXFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFt0YWJJbmRleF09XFxcInRhYkluZGV4XFxcIiBbaW5kZXRlcm1pbmF0ZV09XFxcImluZGV0ZXJtaW5hdGVcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJhcmlhTGFiZWxcXFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcImFyaWFMYWJlbGxlZGJ5XFxcIiAoZm9jdXMpPVxcXCJfb25JbnB1dEZvY3VzKClcXFwiIChibHVyKT1cXFwiX29uSW5wdXRCbHVyKClcXFwiIChjaGFuZ2UpPVxcXCJfb25JbnRlcmFjdGlvbkV2ZW50KCRldmVudClcXFwiIChjbGljayk9XFxcIl9vbklucHV0Q2xpY2soJGV2ZW50KVxcXCI+PGRpdiBtZC1yaXBwbGUgKm5nSWY9XFxcIiFfaXNSaXBwbGVEaXNhYmxlZCgpXFxcIiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LXJpcHBsZVxcXCIgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIiBbbWRSaXBwbGVDZW50ZXJlZF09XFxcInRydWVcXFwiIFttZFJpcHBsZVNwZWVkRmFjdG9yXT1cXFwiMC4zXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtZnJhbWVcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1iYWNrZ3JvdW5kXFxcIj48c3ZnIHZlcnNpb249XFxcIjEuMVxcXCIgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1jaGVja21hcmtcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB4bWw6c3BhY2U9XFxcInByZXNlcnZlXFxcIj48cGF0aCBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWNoZWNrbWFyay1wYXRoXFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIndoaXRlXFxcIiBkPVxcXCJNNC4xLDEyLjcgOSwxNy42IDIwLjMsNi4zXFxcIi8+PC9zdmc+PGRpdiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LW1peGVkbWFya1xcXCI+PC9kaXY+PC9kaXY+PC9kaXY+PHNwYW4gY2xhc3M9XFxcIm1hdC1jaGVja2JveC1sYWJlbFxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj48L2xhYmVsPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWNoZWNrYm94LWZyYW1lLC5tYXQtY2hlY2tib3gtdW5jaGVja2VkIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fUBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWZhZGUtaW4tYmFja2dyb3VuZHswJXtvcGFjaXR5OjB9NTAle29wYWNpdHk6MX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtZmFkZS1vdXQtYmFja2dyb3VuZHswJSw1MCV7b3BhY2l0eToxfTEwMCV7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtY2hlY2tlZC1jaGVja21hcmstcGF0aHswJSw1MCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MjIuOTEwMjZ9NTAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAsMCwuMiwuMSl9MTAwJXtzdHJva2UtZGFzaG9mZnNldDowfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcmt7MCUsNjguMiV7dHJhbnNmb3JtOnNjYWxlWCgwKX02OC4yJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLDAsMCwxKX0xMDAle3RyYW5zZm9ybTpzY2FsZVgoMSl9fUBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWNoZWNrZWQtdW5jaGVja2VkLWNoZWNrbWFyay1wYXRoe2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsMCwxLDEpO3N0cm9rZS1kYXNob2Zmc2V0OjB9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6LTIyLjkxMDI2fX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtY2hlY2ttYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMCwwLC4yLC4xKTtvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3tvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9fUBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUtY2hlY2tlZC1jaGVja21hcmt7ZnJvbXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMTQsMCwwLDEpO29wYWNpdHk6MDt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX10b3tvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMCwwLC4yLC4xKTtvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfXRve29wYWNpdHk6MTt0cmFuc2Zvcm06cm90YXRlKDApfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtbWl4ZWRtYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE0LDAsMCwxKTtvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3tvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSgzMTVkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLXVuY2hlY2tlZC1taXhlZG1hcmt7MCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpsaW5lYXI7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZVgoMSl9MTAwJSwzMi44JXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlWCgwKX19Lm1hdC1jaGVja2JveC1iYWNrZ3JvdW5kLC5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLC5tYXQtY2hlY2tib3gtZnJhbWV7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9Lm1hdC1jaGVja2JveC1jaGVja21hcmssLm1hdC1jaGVja2JveC1taXhlZG1hcmt7d2lkdGg6Y2FsYygxMDAlIC0gNHB4KX0ubWF0LWNoZWNrYm94LWJhY2tncm91bmQsLm1hdC1jaGVja2JveC1mcmFtZXtib3JkZXItcmFkaXVzOjJweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9pbnRlci1ldmVudHM6bm9uZX0ubWF0LWNoZWNrYm94e2N1cnNvcjpwb2ludGVyO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllciguNCwwLC4yLDEpfS5tYXQtY2hlY2tib3gtbGF5b3V0e2N1cnNvcjppbmhlcml0O2FsaWduLWl0ZW1zOmJhc2VsaW5lO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtkaXNwbGF5OmlubGluZS1mbGV4fS5tYXQtY2hlY2tib3gtaW5uZXItY29udGFpbmVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoyMHB4O2xpbmUtaGVpZ2h0OjA7bWFyZ2luOmF1dG8gOHB4IGF1dG8gYXV0bztvcmRlcjowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MjBweDtmbGV4LXNocmluazowfVtkaXI9cnRsXSAubWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lcnttYXJnaW4tbGVmdDo4cHg7bWFyZ2luLXJpZ2h0OmF1dG99Lm1hdC1jaGVja2JveC1sYXlvdXQgLm1hdC1jaGVja2JveC1sYWJlbHtsaW5lLWhlaWdodDoyNHB4fS5tYXQtY2hlY2tib3gtZnJhbWV7dHJhbnNpdGlvbjpib3JkZXItY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKTtib3JkZXItd2lkdGg6MnB4O2JvcmRlci1zdHlsZTpzb2xpZH0ubWF0LWNoZWNrYm94LWJhY2tncm91bmR7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6aW5saW5lLWZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKSxvcGFjaXR5IDkwbXMgY3ViaWMtYmV6aWVyKDAsMCwuMiwuMSl9Lm1hdC1jaGVja2JveC1jaGVja21hcmt7d2lkdGg6MTAwJX0ubWF0LWNoZWNrYm94LWNoZWNrbWFyay1wYXRoe3N0cm9rZS1kYXNob2Zmc2V0OjIyLjkxMDI2O3N0cm9rZS1kYXNoYXJyYXk6MjIuOTEwMjY7c3Ryb2tlLXdpZHRoOjIuNjdweH0ubWF0LWNoZWNrYm94LWNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aCwubWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHtzdHJva2UtZGFzaG9mZnNldDowfS5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2hlaWdodDoycHg7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZVgoMCkgcm90YXRlKDApfS5tYXQtY2hlY2tib3gtbGFiZWwtYmVmb3JlIC5tYXQtY2hlY2tib3gtaW5uZXItY29udGFpbmVye29yZGVyOjE7bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDphdXRvfVtkaXI9cnRsXSAubWF0LWNoZWNrYm94LWxhYmVsLWJlZm9yZSAubWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lcnttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDo4cHh9Lm1hdC1jaGVja2JveC1jaGVja2VkIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJre29wYWNpdHk6MX0ubWF0LWNoZWNrYm94LWNoZWNrZWQgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7dHJhbnNmb3JtOnNjYWxlWCgxKSByb3RhdGUoLTQ1ZGVnKX0ubWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1jaGVja21hcmt7b3BhY2l0eTowO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSAubWF0LWNoZWNrYm94LW1peGVkbWFya3tvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlWCgxKSByb3RhdGUoMCl9Lm1hdC1jaGVja2JveC1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWNoZWNrZWQgLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FuaW1hdGlvbjoxODBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWZhZGUtaW4tYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtY2hlY2tlZC1jaGVja21hcmstcGF0aH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FuaW1hdGlvbjoxODBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWZhZGUtaW4tYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7YW5pbWF0aW9uOjkwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcmt9Lm1hdC1jaGVja2JveC1hbmltLWNoZWNrZWQtdW5jaGVja2VkIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1mYWRlLW91dC1iYWNrZ3JvdW5kfS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLXVuY2hlY2tlZCAubWF0LWNoZWNrYm94LWNoZWNrbWFyay1wYXRoe2FuaW1hdGlvbjo5MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtY2hlY2tlZC11bmNoZWNrZWQtY2hlY2ttYXJrLXBhdGh9Lm1hdC1jaGVja2JveC1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZSAubWF0LWNoZWNrYm94LWNoZWNrbWFya3thbmltYXRpb246OTBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1jaGVja21hcmt9Lm1hdC1jaGVja2JveC1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZSAubWF0LWNoZWNrYm94LW1peGVkbWFya3thbmltYXRpb246OTBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcmt9Lm1hdC1jaGVja2JveC1hbmltLWluZGV0ZXJtaW5hdGUtY2hlY2tlZCAubWF0LWNoZWNrYm94LWNoZWNrbWFya3thbmltYXRpb246LjVzIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLWNoZWNrbWFya30ubWF0LWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS1jaGVja2VkIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2FuaW1hdGlvbjouNXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtbWl4ZWRtYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1pbmRldGVybWluYXRlLXVuY2hlY2tlZCAubWF0LWNoZWNrYm94LWJhY2tncm91bmR7YW5pbWF0aW9uOjE4MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtZmFkZS1vdXQtYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7YW5pbWF0aW9uOi4zcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkLW1peGVkbWFya30ubWF0LWNoZWNrYm94LWlucHV0e2JvdHRvbTowO2xlZnQ6NTAlfS5tYXQtY2hlY2tib3gtcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTE1cHg7dG9wOi0xNXB4O3JpZ2h0Oi0xNXB4O2JvdHRvbTotMTVweDtib3JkZXItcmFkaXVzOjUwJTt6LWluZGV4OjE7cG9pbnRlci1ldmVudHM6bm9uZX1cIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hlY2tib3hdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGVdJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94LWNoZWNrZWRdJzogJ2NoZWNrZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94LWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hlY2tib3gtbGFiZWwtYmVmb3JlXSc6ICdsYWJlbFBvc2l0aW9uID09IFwiYmVmb3JlXCInLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94LWZvY3VzZWRdJzogJ19oYXNGb2N1cycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfQ0hFQ0tCT1hfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdG9yUmVmXSlcbiAgICBdLCBNZENoZWNrYm94KTtcbiAgICByZXR1cm4gTWRDaGVja2JveDtcbn0oKSk7XG52YXIgTWRDaGVja2JveE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGVja2JveE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRDaGVja2JveE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kQ2hlY2tib3hNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZENoZWNrYm94TW9kdWxlID0gX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIE1kUmlwcGxlTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZENoZWNrYm94LCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kQ2hlY2tib3hdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDaGVja2JveE1vZHVsZSk7XG4gICAgcmV0dXJuIE1kQ2hlY2tib3hNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQzNCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzNCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1yYWRpby1ncm91cCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiBUaGlzXG4gKiBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXSBhbmQgbmdDb250cm9sLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTURfUkFESU9fR1JPVVBfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBfYW5ndWxhcl9mb3Jtcy5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kUmFkaW9Hcm91cDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgX3VuaXF1ZUlkQ291bnRlciQyID0gMDtcbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWRSYWRpbyBhbmQgTWRSYWRpb0dyb3VwLiAqL1xudmFyIE1kUmFkaW9DaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmFkaW9DaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFJhZGlvQ2hhbmdlO1xufSgpKTtcbi8qKlxuICogQSBncm91cCBvZiByYWRpbyBidXR0b25zLiBNYXkgY29udGFpbiBvbmUgb3IgbW9yZSBgPG1kLXJhZGlvLWJ1dHRvbj5gIGVsZW1lbnRzLlxuICovXG52YXIgTWRSYWRpb0dyb3VwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhZGlvR3JvdXAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RlZCB2YWx1ZSBmb3IgZ3JvdXAuIFNob3VsZCBlcXVhbCB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIHJhZGlvIGJ1dHRvbiBpZiB0aGVyZSAqaXMqXG4gICAgICAgICAqIGEgY29ycmVzcG9uZGluZyByYWRpbyBidXR0b24gd2l0aCBhIG1hdGNoaW5nIHZhbHVlLiBJZiB0aGVyZSBpcyAqbm90KiBzdWNoIGEgY29ycmVzcG9uZGluZ1xuICAgICAgICAgKiByYWRpbyBidXR0b24sIHRoaXMgdmFsdWUgcGVyc2lzdHMgdG8gYmUgYXBwbGllZCBpbiBjYXNlIGEgbmV3IHJhZGlvIGJ1dHRvbiBpcyBhZGRlZCB3aXRoIGFcbiAgICAgICAgICogbWF0Y2hpbmcgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgSFRNTCBuYW1lIGF0dHJpYnV0ZSBhcHBsaWVkIHRvIHJhZGlvIGJ1dHRvbnMgaW4gdGhpcyBncm91cC4gKi9cbiAgICAgICAgdGhpcy5fbmFtZSA9IFwibWQtcmFkaW8tZ3JvdXAtXCIgKyBfdW5pcXVlSWRDb3VudGVyJDIrKztcbiAgICAgICAgLyoqIERpc2FibGVzIGFsbCBpbmRpdmlkdWFsIHJhZGlvIGJ1dHRvbnMgYXNzaWduZWQgdG8gdGhpcyBncm91cC4gKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcmFkaW8gYnV0dG9uLiBTaG91bGQgbWF0Y2ggdmFsdWUuICovXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGB2YWx1ZWAgaGFzIGJlZW4gc2V0IHRvIGl0cyBpbml0aWFsIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgbWV0aG9kIHRvIGJlIGNhbGxlZCBpbiBvcmRlciB0byB1cGRhdGUgbmdNb2RlbCAqL1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvblRvdWNoIGZ1bmN0aW9uIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyT25Ub3VjaCAoQ29udHJvbFZhbHVlQWNjZXNzb3IpLlxuICAgICAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZ3JvdXAgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgICogQ2hhbmdlIGV2ZW50cyBhcmUgb25seSBlbWl0dGVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24gd2l0aFxuICAgICAgICAgKiBhIHJhZGlvIGJ1dHRvbiAodGhlIHNhbWUgYmVoYXZpb3IgYXMgYDxpbnB1dCB0eXBlLVwicmFkaW9cIj5gKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBDaGlsZCByYWRpbyBidXR0b25zLiAqL1xuICAgICAgICB0aGlzLl9yYWRpb3MgPSBudWxsO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgbGFiZWxzIHNob3VsZCBhcHBlYXIgYWZ0ZXIgb3IgYmVmb3JlIHRoZSByYWRpby1idXR0b25zLiBEZWZhdWx0cyB0byAnYWZ0ZXInICovXG4gICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKiogTmFtZSBvZiB0aGUgcmFkaW8gYnV0dG9uIGdyb3VwLiBBbGwgcmFkaW8gYnV0dG9ucyBpbnNpZGUgdGhpcyBncm91cCB3aWxsIHVzZSB0aGlzIG5hbWUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmFtZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJhZGlvQnV0dG9uTmFtZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiYWxpZ25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxpZ25tZW50IG9mIHRoZSByYWRpby1idXR0b25zIHJlbGF0aXZlIHRvIHRoZWlyIGxhYmVscy4gQ2FuIGJlICdiZWZvcmUnIG9yICdhZnRlcicuXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGFsaWduIHJlZmVycyB0byB0aGUgY2hlY2tib3ggcmVsYXRpdmUgdG8gdGhlIGxhYmVsLCB3aGlsZSBsYWJlbFBvc2l0aW9uIHJlZmVycyB0byB0aGVcbiAgICAgICAgICAgIC8vIGxhYmVsIHJlbGF0aXZlIHRvIHRoZSBjaGVja2JveC4gQXMgc3VjaCwgdGhleSBhcmUgaW52ZXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09ICdhZnRlcicgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICh2ID09ICdzdGFydCcpID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJlc2VuY2Ugb2YgKmFueSogZGlzYWJsZWQgdmFsdWUgbWFrZXMgdGhlIGNvbXBvbmVudCBkaXNhYmxlZCwgKmV4Y2VwdCogZm9yIGZhbHNlLlxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqIFZhbHVlIG9mIHRoZSByYWRpbyBidXR0b24uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhpcyBiZWZvcmUgcHJvY2VlZGluZyB0byBlbnN1cmUgbm8gY2lyY3VsYXIgbG9vcCBvY2N1cnMgd2l0aCBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZFJhZGlvRnJvbVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tTZWxlY3RlZFJhZGlvQnV0dG9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX2NoZWNrU2VsZWN0ZWRSYWRpb0J1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgJiYgIXRoaXMuX3NlbGVjdGVkLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNlbGVjdGVkID8gc2VsZWN0ZWQudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tTZWxlY3RlZFJhZGlvQnV0dG9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcHJvcGVydGllcyBvbmNlIGNvbnRlbnQgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZS5cbiAgICAgKiBUaGlzIGFsbG93cyB1cyB0byBwcm9wYWdhdGUgcmVsZXZhbnQgYXR0cmlidXRlcyB0byBhc3NvY2lhdGVkIGJ1dHRvbnMuXG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE1hcmsgdGhpcyBjb21wb25lbnQgYXMgaW5pdGlhbGl6ZWQgaW4gQWZ0ZXJDb250ZW50SW5pdCBiZWNhdXNlIHRoZSBpbml0aWFsIHZhbHVlIGNhblxuICAgICAgICAvLyBwb3NzaWJseSBiZSBzZXQgYnkgTmdNb2RlbCBvbiBNZFJhZGlvR3JvdXAsIGFuZCBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBPbkluaXQgb2YgdGhlXG4gICAgICAgIC8vIE5nTW9kZWwgb2NjdXJzICphZnRlciogdGhlIE9uSW5pdCBvZiB0aGUgTWRSYWRpb0dyb3VwLlxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmsgdGhpcyBncm91cCBhcyBiZWluZyBcInRvdWNoZWRcIiAoZm9yIG5nTW9kZWwpLiBNZWFudCB0byBiZSBjYWxsZWQgYnkgdGhlIGNvbnRhaW5lZFxuICAgICAqIHJhZGlvIGJ1dHRvbnMgdXBvbiB0aGVpciBibHVyLlxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3RvdWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vblRvdWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVJhZGlvQnV0dG9uTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgICAgIHJhZGlvLm5hbWUgPSBfdGhpcy5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBVcGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHJhZGlvIGJ1dHRvbiBmcm9tIHRoZSBpbnRlcm5hbCBfdmFsdWUgc3RhdGUuICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0ZWRSYWRpb0Zyb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGFscmVhZHkgbWF0Y2hlcyB0aGUgc2VsZWN0ZWQgcmFkaW8sIGRvIG5vdGhpbmcuXG4gICAgICAgIHZhciBpc0FscmVhZHlTZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkICE9IG51bGwgJiYgdGhpcy5fc2VsZWN0ZWQudmFsdWUgPT0gdGhpcy5fdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MgIT0gbnVsbCAmJiAhaXNBbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgICAgIHJhZGlvLmNoZWNrZWQgPSBfdGhpcy52YWx1ZSA9PSByYWRpby52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmFkaW8uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZWN0ZWQgPSByYWRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIERpc3BhdGNoIGNoYW5nZSBldmVudCB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCBncm91cCB2YWx1ZS4gKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IG5ldyBNZFJhZGlvQ2hhbmdlKCk7XG4gICAgICAgICAgICBldmVudF8xLnNvdXJjZSA9IHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICAgICAgZXZlbnRfMS52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudF8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9kZWwgdmFsdWUuIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBtb2RlbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250cm9sIGlzIHRvdWNoZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgY29udHJvbC4gSW1wbGVtZW50ZWQgYXMgYSBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkIFdoZXRoZXIgdGhlIGNvbnRyb2wgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZFJhZGlvQnV0dG9uOyB9KSksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiX3JhZGlvc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcIm5hbWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwibGFiZWxQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcbiAgICBNZFJhZGlvR3JvdXAgPSBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1yYWRpby1ncm91cCwgbWF0LXJhZGlvLWdyb3VwJyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ3JhZGlvZ3JvdXAnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJhZGlvLWdyb3VwXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFJhZGlvR3JvdXApO1xuICAgIHJldHVybiBNZFJhZGlvR3JvdXA7XG59KCkpO1xuLyoqXG4gKiBBIHJhZGlvLWJ1dHRvbi4gTWF5IGJlIGluc2lkZSBvZlxuICovXG52YXIgTWRSYWRpb0J1dHRvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSYWRpb0J1dHRvbihyYWRpb0dyb3VwLCBfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCByYWRpb0Rpc3BhdGNoZXIpIHtcbiAgICAgICAgLy8gQXNzZXJ0aW9ucy4gSWRlYWxseSB0aGVzZSBzaG91bGQgYmUgc3RyaXBwZWQgb3V0IGJ5IHRoZSBjb21waWxlci5cbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IEFzc2VydCB0aGF0IHRoZXJlJ3Mgbm8gbmFtZSBiaW5kaW5nIEFORCBhIHBhcmVudCByYWRpbyBncm91cC5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yYWRpb0Rpc3BhdGNoZXIgPSByYWRpb0Rpc3BhdGNoZXI7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoaXMgcmFkaW8gaXMgY2hlY2tlZC4gKi9cbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAvKiogVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIHJhZGlvIGJ1dHRvbi4gKi9cbiAgICAgICAgdGhpcy5pZCA9IFwibWQtcmFkaW8tXCIgKyBfdW5pcXVlSWRDb3VudGVyJDIrKztcbiAgICAgICAgLyoqIFZhbHVlIGFzc2lnbmVkIHRvIHRoaXMgcmFkaW8uKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIG9mIHRoaXMgcmFkaW8gYnV0dG9uIGNoYW5nZXMuXG4gICAgICAgICAqIENoYW5nZSBldmVudHMgYXJlIG9ubHkgZW1pdHRlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uIHdpdGhcbiAgICAgICAgICogdGhlIHJhZGlvIGJ1dHRvbiAodGhlIHNhbWUgYmVoYXZpb3IgYXMgYDxpbnB1dCB0eXBlLVwicmFkaW9cIj5gKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucmFkaW9Hcm91cCA9IHJhZGlvR3JvdXA7XG4gICAgICAgIHJhZGlvRGlzcGF0Y2hlci5saXN0ZW4oZnVuY3Rpb24gKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAoaWQgIT0gX3RoaXMuaWQgJiYgbmFtZSA9PSBfdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcmlwcGxlIGVmZmVjdCBmb3IgdGhpcyByYWRpbyBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHtcbiAgICAgICAgLyoqIElEIG9mIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudCBpbnNpZGUgYDxtZC1yYWRpby1idXR0b24+YCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkICsgXCItaW5wdXRcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGlzIHJhZGlvIGJ1dHRvbiBpcyBjaGVja2VkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja2VkICE9IG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBuZXdDaGVja2VkU3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrZWRTdGF0ZSAmJiB0aGlzLnJhZGlvR3JvdXAgJiYgdGhpcy5yYWRpb0dyb3VwLnZhbHVlICE9IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLnNlbGVjdGVkID0gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW5ld0NoZWNrZWRTdGF0ZSAmJiB0aGlzLnJhZGlvR3JvdXAgJiYgdGhpcy5yYWRpb0dyb3VwLnZhbHVlID09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bmNoZWNraW5nIHRoZSBzZWxlY3RlZCByYWRpbyBidXR0b24sIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgcmFkaW9cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgb24gdGhlIGdyb3VwLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgcmFkaW8gYnV0dG9ucyB3aXRoIHRoZSBzYW1lIG5hbWUgdG8gdW4tY2hlY2suXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFkaW9EaXNwYXRjaGVyLm5vdGlmeSh0aGlzLmlkLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGlzIHJhZGlvIGJ1dHRvbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNoZWNrZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlZCB0byBtYXRjaCB0aGUgcmFkaW8gZ3JvdXAncyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy5yYWRpb0dyb3VwLnZhbHVlID09IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5zZWxlY3RlZCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJhbGlnblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgcmFkaW8tYnV0dG9uIHNob3VsZCBhcHBlYXIgYmVmb3JlIG9yIGFmdGVyIHRoZSBsYWJlbC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gYWxpZ24gcmVmZXJzIHRvIHRoZSBjaGVja2JveCByZWxhdGl2ZSB0byB0aGUgbGFiZWwsIHdoaWxlIGxhYmVsUG9zaXRpb24gcmVmZXJzIHRvIHRoZVxuICAgICAgICAgICAgLy8gbGFiZWwgcmVsYXRpdmUgdG8gdGhlIGNoZWNrYm94LiBBcyBzdWNoLCB0aGV5IGFyZSBpbnZlcnRlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT0gJ2FmdGVyJyA/ICdzdGFydCcgOiAnZW5kJztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5sYWJlbFBvc2l0aW9uID0gKHYgPT0gJ3N0YXJ0JykgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJsYWJlbFBvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBhcHBlYXIgYWZ0ZXIgb3IgYmVmb3JlIHRoZSByYWRpbyBidXR0b24uIERlZmF1bHRzIHRvICdhZnRlcicgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFiZWxQb3NpdGlvbiB8fCAodGhpcy5yYWRpb0dyb3VwICYmIHRoaXMucmFkaW9Hcm91cC5sYWJlbFBvc2l0aW9uKSB8fCAnYWZ0ZXInO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcmFkaW8gYnV0dG9uIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZCB8fCAodGhpcy5yYWRpb0dyb3VwICE9IG51bGwgJiYgdGhpcy5yYWRpb0dyb3VwLmRpc2FibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmVzZW5jZSBvZiAqYW55KiBkaXNhYmxlZCB2YWx1ZSBtYWtlcyB0aGUgY29tcG9uZW50IGRpc2FibGVkLCAqZXhjZXB0KiBmb3IgZmFsc2UuXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9ICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkgPyB0cnVlIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGlvR3JvdXApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSByYWRpbyBpcyBpbnNpZGUgYSByYWRpbyBncm91cCwgZGV0ZXJtaW5lIGlmIGl0IHNob3VsZCBiZSBjaGVja2VkXG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLnJhZGlvR3JvdXAudmFsdWUgPT09IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgLy8gQ29weSBuYW1lIGZyb20gcGFyZW50IHJhZGlvIGdyb3VwXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnJhZGlvR3JvdXAubmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIERpc3BhdGNoIGNoYW5nZSBldmVudCB3aXRoIGN1cnJlbnQgdmFsdWUuICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kUmFkaW9DaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5faXNSaXBwbGVEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZVJpcHBsZSB8fCB0aGlzLmRpc2FibGVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2UgdXNlIGEgaGlkZGVuIG5hdGl2ZSBpbnB1dCBmaWVsZCB0byBoYW5kbGUgY2hhbmdlcyB0byBmb2N1cyBzdGF0ZSB2aWEga2V5Ym9hcmQgbmF2aWdhdGlvbixcbiAgICAgKiB3aXRoIHZpc3VhbCByZW5kZXJpbmcgZG9uZSBzZXBhcmF0ZWx5LiBUaGUgbmF0aXZlIGVsZW1lbnQgaXMga2VwdCBpbiBzeW5jIHdpdGggdGhlIG92ZXJhbGxcbiAgICAgKiBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLl9vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKiogRm9jdXNlcyB0aGUgcmFkaW8gYnV0dG9uLiAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKTtcbiAgICAgICAgdGhpcy5fb25JbnB1dEZvY3VzKCk7XG4gICAgfTtcbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5yYWRpb0dyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX3RvdWNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBkaXNwYXRjaGVkIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuIFNpbmNlIHdlIGFyZSB1c2luZyBhIGxhYmVsIGVsZW1lbnQgYXMgb3VyXG4gICAgICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGByYWRpby1idXR0b25gIHdpbGwgYmUgZXhlY3V0ZWQgdHdpY2UuXG4gICAgICAgIC8vIFRoZSByZWFsIGNsaWNrIGV2ZW50IHdpbGwgYnViYmxlIHVwLCBhbmQgdGhlIGdlbmVyYXRlZCBjbGljayBldmVudCBhbHNvIHRyaWVzIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGxlYWQgdG8gbXVsdGlwbGUgY2xpY2sgZXZlbnRzLlxuICAgICAgICAvLyBQcmV2ZW50aW5nIGJ1YmJsaW5nIGZvciB0aGUgc2Vjb25kIGV2ZW50IHdpbGwgc29sdmUgdGhhdCBpc3N1ZS5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgcmFkaW8gYnV0dG9uIHJlY2VpdmVkIGEgY2xpY2sgb3IgdGhlIGlucHV0IHJlY29nbml6ZWQgYW55IGNoYW5nZS5cbiAgICAgKiBDbGlja2luZyBvbiBhIGxhYmVsIGVsZW1lbnQsIHdpbGwgdHJpZ2dlciBhIGNoYW5nZSBldmVudCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dC5cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIG9uIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY2hhbmdlIGV2ZW50LCBmcm9tIHRoZSBpbnB1dCBlbGVtZW50LCB3aWxsIGJ1YmJsZSB1cCBhbmRcbiAgICAgICAgLy8gZW1pdCBpdHMgZXZlbnQgb2JqZWN0IHRvIHRoZSBgY2hhbmdlYCBvdXRwdXQuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgZ3JvdXBWYWx1ZUNoYW5nZWQgPSB0aGlzLnJhZGlvR3JvdXAgJiYgdGhpcy52YWx1ZSAhPSB0aGlzLnJhZGlvR3JvdXAudmFsdWU7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICBpZiAodGhpcy5yYWRpb0dyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4odGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX3RvdWNoKCk7XG4gICAgICAgICAgICBpZiAoZ3JvdXBWYWx1ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWF0LXJhZGlvLWZvY3VzZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJfaXNGb2N1c2VkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2lkJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiYXJpYUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiYXJpYUxhYmVsbGVkYnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgnaW5wdXQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcIl9pbnB1dEVsZW1lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWF0LXJhZGlvLWNoZWNrZWQnKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJhbGlnblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwibGFiZWxQb3NpdGlvblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWF0LXJhZGlvLWRpc2FibGVkJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBNZFJhZGlvQnV0dG9uID0gX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXJhZGlvLWJ1dHRvbiwgbWF0LXJhZGlvLWJ1dHRvbicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGFiZWwgW2F0dHIuZm9yXT1cXFwiaW5wdXRJZFxcXCIgY2xhc3M9XFxcIm1hdC1yYWRpby1sYWJlbFxcXCIgI2xhYmVsPjxkaXYgY2xhc3M9XFxcIm1hdC1yYWRpby1jb250YWluZXJcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1yYWRpby1vdXRlci1jaXJjbGVcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1yYWRpby1pbm5lci1jaXJjbGVcXFwiPjwvZGl2PjxkaXYgbWQtcmlwcGxlICpuZ0lmPVxcXCIhX2lzUmlwcGxlRGlzYWJsZWQoKVxcXCIgY2xhc3M9XFxcIm1hdC1yYWRpby1yaXBwbGVcXFwiIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJsYWJlbFxcXCIgW21kUmlwcGxlQ2VudGVyZWRdPVxcXCJ0cnVlXFxcIiBbbWRSaXBwbGVTcGVlZEZhY3Rvcl09XFxcIjAuM1xcXCI+PC9kaXY+PC9kaXY+PGlucHV0ICNpbnB1dCBjbGFzcz1cXFwibWF0LXJhZGlvLWlucHV0IGNkay12aXN1YWxseS1oaWRkZW5cXFwiIHR5cGU9XFxcInJhZGlvXFxcIiBbaWRdPVxcXCJpbnB1dElkXFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJhcmlhTGFiZWxcXFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcImFyaWFMYWJlbGxlZGJ5XFxcIiAoY2hhbmdlKT1cXFwiX29uSW5wdXRDaGFuZ2UoJGV2ZW50KVxcXCIgKGZvY3VzKT1cXFwiX29uSW5wdXRGb2N1cygpXFxcIiAoYmx1cik9XFxcIl9vbklucHV0Qmx1cigpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1yYWRpby1sYWJlbC1jb250ZW50XFxcIiBbY2xhc3MubWF0LXJhZGlvLWxhYmVsLWJlZm9yZV09XFxcImxhYmVsUG9zaXRpb24gPT0gJ2JlZm9yZSdcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48L2xhYmVsPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXJhZGlvLWJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmfS5tYXQtcmFkaW8tbGFiZWx7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTppbmxpbmUtZmxleDthbGlnbi1pdGVtczpiYXNlbGluZTt3aGl0ZS1zcGFjZTpub3dyYXB9Lm1hdC1yYWRpby1jb250YWluZXJ7Ym94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoyMHB4O3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjIwcHg7dG9wOjJweH0ubWF0LXJhZGlvLWlubmVyLWNpcmNsZSwubWF0LXJhZGlvLW91dGVyLWNpcmNsZXtib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjIwcHg7bGVmdDowO3RvcDowO3dpZHRoOjIwcHg7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1yYWRpby1vdXRlci1jaXJjbGV7dHJhbnNpdGlvbjpib3JkZXItY29sb3IgZWFzZSAyODBtcztib3JkZXItd2lkdGg6MnB4O2JvcmRlci1zdHlsZTpzb2xpZH0ubWF0LXJhZGlvLWlubmVyLWNpcmNsZXt0cmFuc2l0aW9uOnRyYW5zZm9ybSBlYXNlIDI4MG1zLGJhY2tncm91bmQtY29sb3IgZWFzZSAyODBtczt0cmFuc2Zvcm06c2NhbGUoMCl9Lm1hdC1yYWRpby1jaGVja2VkIC5tYXQtcmFkaW8taW5uZXItY2lyY2xle3RyYW5zZm9ybTpzY2FsZSguNSl9Lm1hdC1yYWRpby1sYWJlbC1jb250ZW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO29yZGVyOjA7bGluZS1oZWlnaHQ6aW5oZXJpdDtwYWRkaW5nLWxlZnQ6OHB4O3BhZGRpbmctcmlnaHQ6MH1bZGlyPXJ0bF0gLm1hdC1yYWRpby1sYWJlbC1jb250ZW50e3BhZGRpbmctcmlnaHQ6OHB4O3BhZGRpbmctbGVmdDowfS5tYXQtcmFkaW8tbGFiZWwtY29udGVudC5tYXQtcmFkaW8tbGFiZWwtYmVmb3Jle29yZGVyOi0xO3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6OHB4fVtkaXI9cnRsXSAubWF0LXJhZGlvLWxhYmVsLWNvbnRlbnQubWF0LXJhZGlvLWxhYmVsLWJlZm9yZXtwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjhweH0ubWF0LXJhZGlvLWRpc2FibGVkLC5tYXQtcmFkaW8tZGlzYWJsZWQgLm1hdC1yYWRpby1sYWJlbHtjdXJzb3I6ZGVmYXVsdH0ubWF0LXJhZGlvLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xNXB4O3RvcDotMTVweDtyaWdodDotMTVweDtib3R0b206LTE1cHg7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxO3BvaW50ZXItZXZlbnRzOm5vbmV9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJhZGlvLWJ1dHRvbl0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDUoMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW01kUmFkaW9Hcm91cCwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyXSlcbiAgICBdLCBNZFJhZGlvQnV0dG9uKTtcbiAgICByZXR1cm4gTWRSYWRpb0J1dHRvbjtcbn0oKSk7XG52YXIgTWRSYWRpb01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSYWRpb01vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRSYWRpb01vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kUmFkaW9Nb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRSYWRpb01vZHVsZSA9IF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRSYWRpb0dyb3VwLCBNZFJhZGlvQnV0dG9uLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1VOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUiwgVklFV1BPUlRfUlVMRVJfUFJPVklERVJdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRSYWRpb0dyb3VwLCBNZFJhZGlvQnV0dG9uXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUmFkaW9Nb2R1bGUpO1xuICAgIHJldHVybiBNZFJhZGlvTW9kdWxlO1xufSgpKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMga2V5Ym9hcmQgZXZlbnRzIGZvciBzZWxlY3RhYmxlIGxpc3RzLiBJZiB5b3UgcGFzcyBpdCBhIHF1ZXJ5IGxpc3RcbiAqIG9mIGl0ZW1zLCBpdCB3aWxsIHNldCB0aGUgYWN0aXZlIGl0ZW0gY29ycmVjdGx5IHdoZW4gYXJyb3cgZXZlbnRzIG9jY3VyLlxuICovXG52YXIgTGlzdEtleU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpc3RLZXlNYW5hZ2VyKF9pdGVtcykge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IF9pdGVtcztcbiAgICAgICAgdGhpcy5fdGFiT3V0ID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX3dyYXAgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHVybnMgb24gd3JhcHBpbmcgbW9kZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZSBhY3RpdmUgaXRlbSB3aWxsIHdyYXAgdG9cbiAgICAgKiB0aGUgb3RoZXIgZW5kIG9mIGxpc3Qgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBpdGVtcyBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIExpc3RLZXlNYW5hZ2VyIHRoYXQgdGhlIG1ldGhvZCB3YXMgY2FsbGVkIG9uLlxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS53aXRoV3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fd3JhcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGl0ZW0gYXQgdGhlIGluZGV4IHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gYmUgc2V0IGFzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbSA9IHRoaXMuX2l0ZW1zLnRvQXJyYXkoKVtpbmRleF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBkZXBlbmRpbmcgb24gdGhlIGtleSBldmVudCBwYXNzZWQgaW4uXG4gICAgICogQHBhcmFtIGV2ZW50IEtleWJvYXJkIGV2ZW50IHRvIGJlIHVzZWQgZm9yIGRldGVybWluaW5nIHdoaWNoIGVsZW1lbnQgc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUub25LZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV4dEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcmV2aW91c0l0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSE9NRTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMYXN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUQUI6XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIHNob3VsZG4ndCBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiBvbiB0YWIuXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFiT3V0Lm5leHQobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUsIFwiYWN0aXZlSXRlbUluZGV4XCIsIHtcbiAgICAgICAgLyoqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZSwgXCJhY3RpdmVJdGVtXCIsIHtcbiAgICAgICAgLyoqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgaXRlbS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlSXRlbTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBmaXJzdCBlbmFibGVkIGl0ZW0gaW4gdGhlIGxpc3QuICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLnNldEZpcnN0SXRlbUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSXRlbUJ5SW5kZXgoMCwgMSk7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGxhc3QgZW5hYmxlZCBpdGVtIGluIHRoZSBsaXN0LiAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5zZXRMYXN0SXRlbUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSXRlbUJ5SW5kZXgodGhpcy5faXRlbXMubGVuZ3RoIC0gMSwgLTEpO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBuZXh0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0TmV4dEl0ZW1BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9PT0gbnVsbCA/IHRoaXMuc2V0Rmlyc3RJdGVtQWN0aXZlKCkgOiB0aGlzLl9zZXRBY3RpdmVJdGVtQnlEZWx0YSgxKTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byBhIHByZXZpb3VzIGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0UHJldmlvdXNJdGVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPT09IG51bGwgJiYgdGhpcy5fd3JhcCA/IHRoaXMuc2V0TGFzdEl0ZW1BY3RpdmUoKVxuICAgICAgICAgICAgOiB0aGlzLl9zZXRBY3RpdmVJdGVtQnlEZWx0YSgtMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc2V0dGluZyBvZiB0aGUgYWN0aXZlSXRlbUluZGV4IHdpdGhvdXQgYW55IG90aGVyIGVmZmVjdHMuXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBuZXcgYWN0aXZlSXRlbUluZGV4LlxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVBY3RpdmVJdGVtSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLCBcInRhYk91dFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYW55IHRpbWUgdGhlIFRBQiBrZXkgaXMgcHJlc3NlZCwgc28gY29tcG9uZW50cyBjYW4gcmVhY3RcbiAgICAgICAgICogd2hlbiBmb2N1cyBpcyBzaGlmdGVkIG9mZiBvZiB0aGUgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhYk91dC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgYWN0aXZlIGl0ZW0sIGdpdmVuIGEgbGlzdCBvZiBpdGVtcyBhbmQgdGhlIGRlbHRhIGJldHdlZW4gdGhlXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBpdGVtIGFuZCB0aGUgbmV3IGFjdGl2ZSBpdGVtLiBJdCB3aWxsIGNhbGN1bGF0ZSBkaWZmZXJlbnRseVxuICAgICAqIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdyYXAgbW9kZSBpcyB0dXJuZWQgb24uXG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJdGVtQnlEZWx0YSA9IGZ1bmN0aW9uIChkZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSB0aGlzLl9pdGVtcy50b0FycmF5KCk7IH1cbiAgICAgICAgdGhpcy5fd3JhcCA/IHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEsIGl0ZW1zKVxuICAgICAgICAgICAgOiB0aGlzLl9zZXRBY3RpdmVJbkRlZmF1bHRNb2RlKGRlbHRhLCBpdGVtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBwcm9wZXJseSBnaXZlbiBcIndyYXBcIiBtb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgd2lsbCBjb250aW51ZSB0byBtb3ZlXG4gICAgICogZG93biB0aGUgbGlzdCB1bnRpbCBpdCBmaW5kcyBhbiBpdGVtIHRoYXQgaXMgbm90IGRpc2FibGVkLCBhbmQgaXQgd2lsbCB3cmFwIGlmIGl0XG4gICAgICogZW5jb3VudGVycyBlaXRoZXIgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5fc2V0QWN0aXZlSW5XcmFwTW9kZSA9IGZ1bmN0aW9uIChkZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgLy8gd2hlbiBhY3RpdmUgaXRlbSB3b3VsZCBsZWF2ZSBtZW51LCB3cmFwIHRvIGJlZ2lubmluZyBvciBlbmRcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID1cbiAgICAgICAgICAgICh0aGlzLl9hY3RpdmVJdGVtSW5kZXggKyBkZWx0YSArIGl0ZW1zLmxlbmd0aCkgJSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIC8vIHNraXAgYWxsIGRpc2FibGVkIG1lbnUgaXRlbXMgcmVjdXJzaXZlbHkgdW50aWwgYW4gZW5hYmxlZCBvbmUgaXMgcmVhY2hlZFxuICAgICAgICBpZiAoaXRlbXNbdGhpcy5fYWN0aXZlSXRlbUluZGV4XS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QWN0aXZlSW5XcmFwTW9kZShkZWx0YSwgaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtKHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHByb3Blcmx5IGdpdmVuIHRoZSBkZWZhdWx0IG1vZGUuIEluIG90aGVyIHdvcmRzLCBpdCB3aWxsXG4gICAgICogY29udGludWUgdG8gbW92ZSBkb3duIHRoZSBsaXN0IHVudGlsIGl0IGZpbmRzIGFuIGl0ZW0gdGhhdCBpcyBub3QgZGlzYWJsZWQuIElmXG4gICAgICogaXQgZW5jb3VudGVycyBlaXRoZXIgZW5kIG9mIHRoZSBsaXN0LCBpdCB3aWxsIHN0b3AgYW5kIG5vdCB3cmFwLlxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5fc2V0QWN0aXZlSW5EZWZhdWx0TW9kZSA9IGZ1bmN0aW9uIChkZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSXRlbUJ5SW5kZXgodGhpcy5fYWN0aXZlSXRlbUluZGV4ICsgZGVsdGEsIGRlbHRhLCBpdGVtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgZmlyc3QgZW5hYmxlZCBpdGVtIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBzcGVjaWZpZWQuIElmIHRoZVxuICAgICAqIGl0ZW0gaXMgZGlzYWJsZWQsIGl0IHdpbGwgbW92ZSBpbiB0aGUgZmFsbGJhY2tEZWx0YSBkaXJlY3Rpb24gdW50aWwgaXQgZWl0aGVyXG4gICAgICogZmluZHMgYW4gZW5hYmxlZCBpdGVtIG9yIGVuY291bnRlcnMgdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuX3NldEFjdGl2ZUl0ZW1CeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBmYWxsYmFja0RlbHRhLCBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMgPT09IHZvaWQgMCkgeyBpdGVtcyA9IHRoaXMuX2l0ZW1zLnRvQXJyYXkoKTsgfVxuICAgICAgICBpZiAoIWl0ZW1zW2luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpdGVtc1tpbmRleF0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IGZhbGxiYWNrRGVsdGE7XG4gICAgICAgICAgICBpZiAoIWl0ZW1zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEFjdGl2ZUl0ZW0oaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIExpc3RLZXlNYW5hZ2VyO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBGb2N1c0tleU1hbmFnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ4KEZvY3VzS2V5TWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGb2N1c0tleU1hbmFnZXIoaXRlbXMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaXRlbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEl0IGFsc28gYWRkcyBmb2N1c2VzIHRoZSBuZXdseSBhY3RpdmUgaXRlbS5cbiAgICAgKi9cbiAgICBGb2N1c0tleU1hbmFnZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRBY3RpdmVJdGVtLmNhbGwodGhpcywgaW5kZXgpO1xuICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0uZm9jdXMoKTtcbiAgICB9O1xuICAgIHJldHVybiBGb2N1c0tleU1hbmFnZXI7XG59KExpc3RLZXlNYW5hZ2VyKSk7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBhcmUgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgbWQtc2VsZWN0IGNvbXBvbmVudCwgd2l0aCBlYWNoXG4gKiBjb25zdCBjb250YWluaW5nIHRoZSBtZXRhZGF0YSBmb3Igb25lIGFuaW1hdGlvbi5cbiAqXG4gKiBUaGUgdmFsdWVzIGJlbG93IG1hdGNoIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQW5ndWxhckpTIE1hdGVyaWFsIG1kLXNlbGVjdCBhbmltYXRpb24uXG4gKi9cbi8qKlxuICogVGhpcyBhbmltYXRpb24gc2hyaW5rcyB0aGUgcGxhY2Vob2xkZXIgdGV4dCB0byA3NSUgb2YgaXRzIG5vcm1hbCBzaXplIGFuZCB0cmFuc2xhdGVzXG4gKiBpdCB0byBlaXRoZXIgdGhlIHRvcCBsZWZ0IGNvcm5lciAobHRyKSBvciB0b3AgcmlnaHQgY29ybmVyIChydGwpIG9mIHRoZSB0cmlnZ2VyLFxuICogZGVwZW5kaW5nIG9uIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYXBwbGljYXRpb24uXG4gKi9cbnZhciB0cmFuc2Zvcm1QbGFjZWhvbGRlciA9IF9hbmd1bGFyX2NvcmUudHJpZ2dlcigndHJhbnNmb3JtUGxhY2Vob2xkZXInLCBbXG4gICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnZmxvYXRpbmctbHRyJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7XG4gICAgICAgIHRvcDogJy0yMnB4JyxcbiAgICAgICAgbGVmdDogJy0ycHgnLFxuICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMC43NSlcIlxuICAgIH0pKSxcbiAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdmbG9hdGluZy1ydGwnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHtcbiAgICAgICAgdG9wOiAnLTIycHgnLFxuICAgICAgICBsZWZ0OiAnMnB4JyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDAuNzUpXCJcbiAgICB9KSksXG4gICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCcqID0+IConLCBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoXCI0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKVwiKSlcbl0pO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiB0cmFuc2Zvcm1zIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsIG9uIGFuZCBvZmYgdGhlIHBhZ2UuXG4gKlxuICogV2hlbiB0aGUgcGFuZWwgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSwgaXQgZXhwYW5kcyBpdHMgd2lkdGggMzJweCwgc2NhbGVzIGl0IHVwIHRvXG4gKiAxMDAlIG9uIHRoZSBZIGF4aXMsIGZhZGVzIGluIGl0cyBib3JkZXIsIGFuZCB0cmFuc2xhdGVzIHNsaWdodGx5IHVwIGFuZCB0byB0aGVcbiAqIHNpZGUgdG8gZW5zdXJlIHRoZSBvcHRpb24gdGV4dCBjb3JyZWN0bHkgb3ZlcmxhcHMgdGhlIHRyaWdnZXIgdGV4dC5cbiAqXG4gKiBXaGVuIHRoZSBwYW5lbCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSwgaXQgc2ltcGx5IGZhZGVzIG91dCBsaW5lYXJseS5cbiAqL1xudmFyIHRyYW5zZm9ybVBhbmVsID0gX2FuZ3VsYXJfY29yZS50cmlnZ2VyKCd0cmFuc2Zvcm1QYW5lbCcsIFtcbiAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdzaG93aW5nJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIG1pbldpZHRoOiAnY2FsYygxMDAlICsgMzJweCknLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlWSgxKVwiXG4gICAgfSkpLFxuICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLnN0eWxlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBtaW5XaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDAsIDAsIDApIHNjYWxlWSgwKVwiXG4gICAgICAgIH0pLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoXCIxNTBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKVwiKVxuICAgIF0pLFxuICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoJzI1MG1zIDEwMG1zIGxpbmVhcicsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxuICAgIF0pXG5dKTtcbi8qKlxuICogVGhpcyBhbmltYXRpb24gZmFkZXMgaW4gdGhlIGJhY2tncm91bmQgY29sb3IgYW5kIHRleHQgY29udGVudCBvZiB0aGVcbiAqIHNlbGVjdCdzIG9wdGlvbnMuIEl0IGlzIHRpbWUgZGVsYXllZCB0byBvY2N1ciAxMDBtcyBhZnRlciB0aGUgb3ZlcmxheVxuICogcGFuZWwgaGFzIHRyYW5zZm9ybWVkIGluLlxuICovXG52YXIgZmFkZUluQ29udGVudCA9IF9hbmd1bGFyX2NvcmUudHJpZ2dlcignZmFkZUluQ29udGVudCcsIFtcbiAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdzaG93aW5nJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IG9wYWNpdHk6IDEgfSkpLFxuICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbigndm9pZCA9PiBzaG93aW5nJywgW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgb3BhY2l0eTogMCB9KSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5hbmltYXRlKFwiMTUwbXMgMTAwbXMgY3ViaWMtYmV6aWVyKDAuNTUsIDAsIDAuNTUsIDAuMilcIilcbiAgICBdKVxuXSk7XG5cbnZhciBfX2RlY29yYXRlJDM2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQ2ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHN0eWxlIGNvbnN0YW50cyBhcmUgbmVjZXNzYXJ5IHRvIHNhdmUgaGVyZSBpbiBvcmRlclxuICogdG8gcHJvcGVybHkgY2FsY3VsYXRlIHRoZSBhbGlnbm1lbnQgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbiBvdmVyXG4gKiB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICovXG4vKiogVGhlIGZpeGVkIGhlaWdodCBvZiBldmVyeSBvcHRpb24gZWxlbWVudC4gKi9cbnZhciBTRUxFQ1RfT1BUSU9OX0hFSUdIVCA9IDQ4O1xuLyoqIFRoZSBtYXggaGVpZ2h0IG9mIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsICovXG52YXIgU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQgPSAyNTY7XG4vKiogVGhlIG1heCBudW1iZXIgb2Ygb3B0aW9ucyB2aXNpYmxlIGF0IG9uY2UgaW4gdGhlIHNlbGVjdCBwYW5lbC4gKi9cbnZhciBTRUxFQ1RfTUFYX09QVElPTlNfRElTUExBWUVEID0gNTtcbi8qKiBUaGUgZml4ZWQgaGVpZ2h0IG9mIHRoZSBzZWxlY3QncyB0cmlnZ2VyIGVsZW1lbnQuICovXG52YXIgU0VMRUNUX1RSSUdHRVJfSEVJR0hUID0gMzA7XG4vKipcbiAqIE11c3QgYWRqdXN0IGZvciB0aGUgZGlmZmVyZW5jZSBpbiBoZWlnaHQgYmV0d2VlbiB0aGUgb3B0aW9uIGFuZCB0aGUgdHJpZ2dlcixcbiAqIHNvIHRoZSB0ZXh0IHdpbGwgYWxpZ24gb24gdGhlIHkgYXhpcy5cbiAqIChTRUxFQ1RfT1BUSU9OX0hFSUdIVCAoNDgpIC0gU0VMRUNUX1RSSUdHRVJfSEVJR0hUICgzMCkpIC8gMiA9IDlcbiAqL1xudmFyIFNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQgPSA5O1xuLyoqIFRoZSBwYW5lbCdzIHBhZGRpbmcgb24gdGhlIHgtYXhpcyAqL1xudmFyIFNFTEVDVF9QQU5FTF9QQURESU5HX1ggPSAxNjtcbi8qKlxuICogVGhlIHBhbmVsJ3MgcGFkZGluZyBvbiB0aGUgeS1heGlzLiBUaGlzIHBhZGRpbmcgaW5kaWNhdGVzIHRoZXJlIGFyZSBtb3JlXG4gKiBvcHRpb25zIGF2YWlsYWJsZSBpZiB5b3Ugc2Nyb2xsLlxuICovXG52YXIgU0VMRUNUX1BBTkVMX1BBRERJTkdfWSA9IDE2O1xuLyoqXG4gKiBUaGUgc2VsZWN0IHBhbmVsIHdpbGwgb25seSBcImZpdFwiIGluc2lkZSB0aGUgdmlld3BvcnQgaWYgaXQgaXMgcG9zaXRpb25lZCBhdFxuICogdGhpcyB2YWx1ZSBvciBtb3JlIGF3YXkgZnJvbSB0aGUgdmlld3BvcnQgYm91bmRhcnkuXG4gKi9cbnZhciBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORyA9IDg7XG4vKiogQ2hhbmdlIGV2ZW50IG9iamVjdCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IHZhbHVlIGhhcyBjaGFuZ2VkLiAqL1xudmFyIE1kU2VsZWN0Q2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNlbGVjdENoYW5nZShzb3VyY2UsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBNZFNlbGVjdENoYW5nZTtcbn0oKSk7XG52YXIgTWRTZWxlY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2VsZWN0KF9lbGVtZW50LCBfcmVuZGVyZXIsIF92aWV3cG9ydFJ1bGVyLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIF9kaXIsIF9jb250cm9sKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0UnVsZXIgPSBfdmlld3BvcnRSdWxlcjtcbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYgPSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX2NvbnRyb2wgPSBfY29udHJvbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvdmVybGF5IHBhbmVsIGlzIG9wZW4uICovXG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICAvKiogU3Vic2NyaXB0aW9ucyB0byBvcHRpb24gZXZlbnRzLiAqL1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIC8qKiBXaGV0aGVyIGZpbGxpbmcgb3V0IHRoZSBzZWxlY3QgaXMgcmVxdWlyZWQgaW4gdGhlIGZvcm0uICAqL1xuICAgICAgICB0aGlzLl9yZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgc2VsZWN0IGlzIGRpc2FibGVkLiAgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgcGFuZWwsIGNhbGN1bGF0ZWQgdG8gY2VudGVyIHRoZSBzZWxlY3RlZCBvcHRpb24uICovXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IDA7XG4gICAgICAgIC8qKiBUaGUgYW5pbWF0aW9uIHN0YXRlIG9mIHRoZSBwbGFjZWhvbGRlci4gKi9cbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZSA9ICcnO1xuICAgICAgICAvKiogVmlldyAtPiBtb2RlbCBjYWxsYmFjayBjYWxsZWQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIC8qKiBWaWV3IC0+IG1vZGVsIGNhbGxiYWNrIGNhbGxlZCB3aGVuIHNlbGVjdCBoYXMgYmVlbiB0b3VjaGVkICovXG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqIFRoZSBJRHMgb2YgY2hpbGQgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGFyaWEtb3ducyBhdHRyaWJ1dGUuICovXG4gICAgICAgIHRoaXMuX29wdGlvbklkcyA9ICcnO1xuICAgICAgICAvKiogVGhlIHZhbHVlIG9mIHRoZSBzZWxlY3QgcGFuZWwncyB0cmFuc2Zvcm0tb3JpZ2luIHByb3BlcnR5LiAqL1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSAndG9wJztcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHBhbmVsJ3MgYW5pbWF0aW9uIGlzIGRvbmUuICovXG4gICAgICAgIHRoaXMuX3BhbmVsRG9uZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHgtb2Zmc2V0IG9mIHRoZSBvdmVybGF5IHBhbmVsIGluIHJlbGF0aW9uIHRvIHRoZSB0cmlnZ2VyJ3MgdG9wIHN0YXJ0IGNvcm5lci5cbiAgICAgICAgICogVGhpcyBtdXN0IGJlIGFkanVzdGVkIHRvIGFsaWduIHRoZSBzZWxlY3RlZCBvcHRpb24gdGV4dCBvdmVyIHRoZSB0cmlnZ2VyIHRleHQgd2hlblxuICAgICAgICAgKiB0aGUgcGFuZWwgb3BlbnMuIFdpbGwgY2hhbmdlIGJhc2VkIG9uIExUUiBvciBSVEwgdGV4dCBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB5LW9mZnNldCBvZiB0aGUgb3ZlcmxheSBwYW5lbCBpbiByZWxhdGlvbiB0byB0aGUgdHJpZ2dlcidzIHRvcCBzdGFydCBjb3JuZXIuXG4gICAgICAgICAqIFRoaXMgbXVzdCBiZSBhZGp1c3RlZCB0byBhbGlnbiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRleHQgb3ZlciB0aGUgdHJpZ2dlciB0ZXh0LlxuICAgICAgICAgKiB3aGVuIHRoZSBwYW5lbCBvcGVucy4gV2lsbCBjaGFuZ2UgYmFzZWQgb24gdGhlIHktcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIG9wdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBwb3NpdGlvbiBjb25maWcgZW5zdXJlcyB0aGF0IHRoZSB0b3AgXCJzdGFydFwiIGNvcm5lciBvZiB0aGUgb3ZlcmxheVxuICAgICAgICAgKiBpcyBhbGlnbmVkIHdpdGggd2l0aCB0aGUgdG9wIFwic3RhcnRcIiBvZiB0aGUgb3JpZ2luIGJ5IGRlZmF1bHQgKG92ZXJsYXBwaW5nXG4gICAgICAgICAqIHRoZSB0cmlnZ2VyIGNvbXBsZXRlbHkpLiBJZiB0aGUgcGFuZWwgY2Fubm90IGZpdCBiZWxvdyB0aGUgdHJpZ2dlciwgaXRcbiAgICAgICAgICogd2lsbCBmYWxsIGJhY2sgdG8gYSBwb3NpdGlvbiBhYm92ZSB0aGUgdHJpZ2dlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBvcmlnaW5ZOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBvdmVybGF5WTogJ2JvdHRvbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgaGFzIGJlZW4gb3BlbmVkLiAqL1xuICAgICAgICB0aGlzLm9uT3BlbiA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3QgaGFzIGJlZW4gY2xvc2VkLiAqL1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCBieSB0aGUgdXNlci4gKi9cbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wudmFsdWVBY2Nlc3NvciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB7XG4gICAgICAgIC8qKiBQbGFjZWhvbGRlciB0byBiZSBzaG93biBpZiBubyB2YWx1ZSBoYXMgYmVlbiBzZWxlY3RlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGFjZWhvbGRlcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gTXVzdCB3YWl0IHRvIHJlY29yZCB0aGUgdHJpZ2dlciB3aWR0aCB0byBlbnN1cmUgcGxhY2Vob2xkZXIgd2lkdGggaXMgaW5jbHVkZWQuXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdHJpZ2dlcldpZHRoID0gX3RoaXMuX2dldFdpZHRoKCk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjb21wb25lbnQgaXMgcmVxdWlyZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRTZWxlY3QucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faW5pdEtleU1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlU3Vic2NyaXB0aW9uID0gdGhpcy5vcHRpb25zLmNoYW5nZXMuc3RhcnRXaXRoKG51bGwpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRPcHRpb25zKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2NvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZlciBzZXR0aW5nIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCB0aGUgXCJFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gaGFzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWRcIiBlcnJvcnMgZnJvbSBBbmd1bGFyLlxuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zZXRTZWxlY3Rpb25CeVZhbHVlKF90aGlzLl9jb250cm9sLnZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWRTZWxlY3QucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kcm9wU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5fY2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdGFiU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFRvZ2dsZXMgdGhlIG92ZXJsYXkgcGFuZWwgb3BlbiBvciBjbG9zZWQuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYW5lbE9wZW4gPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgICB9O1xuICAgIC8qKiBPcGVucyB0aGUgb3ZlcmxheSBwYW5lbC4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVPdmVybGF5UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJTdGF0ZSA9IHRoaXMuX2lzUnRsKCkgPyAnZmxvYXRpbmctcnRsJyA6ICdmbG9hdGluZy1sdHInO1xuICAgICAgICB0aGlzLl9wYW5lbE9wZW4gPSB0cnVlO1xuICAgIH07XG4gICAgLyoqIENsb3NlcyB0aGUgb3ZlcmxheSBwYW5lbCBhbmQgZm9jdXNlcyB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb2N1c0hvc3QoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdCdzIHZhbHVlLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICAgKiByZXF1aXJlZCB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbkJ5VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QncyB2YWx1ZVxuICAgICAqIGNoYW5nZXMgZnJvbSB1c2VyIGlucHV0LiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICAgKiByZXF1aXJlZCB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBzZWxlY3QgaXMgYmx1cnJlZFxuICAgICAqIGJ5IHRoZSB1c2VyLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgcmVxdWlyZWRcbiAgICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB0b3VjaGVkLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBzZWxlY3QuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkIFNldHMgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInBhbmVsT3BlblwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBwYW5lbCBpcyBvcGVuLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYW5lbE9wZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2lzUnRsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA6IGZhbHNlO1xuICAgIH07XG4gICAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgdHJpZ2dlciBlbGVtZW50LiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBtYXRjaFxuICAgICAqIHRoZSBvdmVybGF5IHdpZHRoIHRvIHRoZSB0cmlnZ2VyIHdpZHRoLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmlnZ2VyUmVjdCgpLndpZHRoO1xuICAgIH07XG4gICAgLyoqIEVuc3VyZXMgdGhlIHBhbmVsIG9wZW5zIGlmIGFjdGl2YXRlZCBieSB0aGUga2V5Ym9hcmQuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBTUEFDRSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHBhbmVsIGVsZW1lbnQgaXMgZmluaXNoZWQgdHJhbnNmb3JtaW5nIGluICh0aG91Z2ggbm90IGZhZGluZyBpbiksIGl0XG4gICAgICogZW1pdHMgYW4gZXZlbnQgYW5kIGZvY3VzZXMgYW4gb3B0aW9uIGlmIHRoZSBwYW5lbCBpcyBvcGVuLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fb25QYW5lbERvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhbmVsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNDb3JyZWN0T3B0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBwYW5lbCBjb250ZW50IGlzIGRvbmUgZmFkaW5nIGluLCB0aGUgX3BhbmVsRG9uZUFuaW1hdGluZyBwcm9wZXJ0eSBpc1xuICAgICAqIHNldCBzbyB0aGUgcHJvcGVyIGNsYXNzIGNhbiBiZSBhZGRlZCB0byB0aGUgcGFuZWwuXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9vbkZhZGVJbkRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhbmVsRG9uZUFuaW1hdGluZyA9IHRoaXMucGFuZWxPcGVuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIHRvdWNoZWQgY2FsbGJhY2sgb25seSBpZiB0aGUgcGFuZWwgaXMgY2xvc2VkLiBPdGhlcndpc2UsIHRoZSB0cmlnZ2VyIHdpbGxcbiAgICAgKiBcImJsdXJcIiB0byB0aGUgcGFuZWwgd2hlbiBpdCBvcGVucywgY2F1c2luZyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFuZWxPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIGNvcnJlY3QgdGFiaW5kZXggZm9yIHRoZSBzZWxlY3QgZGVwZW5kaW5nIG9uIGRpc2FibGVkIHN0YXRlLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZ2V0VGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gJy0xJyA6ICcwJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lci4gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlclxuICAgICAqIHRoZSBvdmVybGF5IHBhbmUgaXMgYXR0YWNoZWQgb3IgdGhlIHNjcm9sbCBjb250YWluZXIgZWxlbWVudCB3aWxsIG5vdCB5ZXQgYmVcbiAgICAgKiBwcmVzZW50IGluIHRoZSBET00uXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxDb250YWluZXIgPSB0aGlzLm92ZXJsYXlEaXIub3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LXNlbGVjdC1wYW5lbCcpO1xuICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5fc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0ZWQgb3B0aW9uIGJhc2VkIG9uIGEgdmFsdWUuIElmIG5vIG9wdGlvbiBjYW4gYmVcbiAgICAgKiBmb3VuZCB3aXRoIHRoZSBkZXNpZ25hdGVkIHZhbHVlLCB0aGUgc2VsZWN0IHRyaWdnZXIgaXMgY2xlYXJlZC5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldFNlbGVjdGlvbkJ5VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgc2VsZWN0aW9uIGlmIG5vIGl0ZW0gd2FzIHNlbGVjdGVkLlxuICAgICAgICB0aGlzLl9jbGVhclNlbGVjdGlvbigpO1xuICAgIH07XG4gICAgLyoqIENsZWFycyB0aGUgc2VsZWN0IHRyaWdnZXIgYW5kIGRlc2VsZWN0cyBldmVyeSBvcHRpb24gaW4gdGhlIGxpc3QuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9jbGVhclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICB0aGlzLl91cGRhdGVPcHRpb25zKCk7XG4gICAgfTtcbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldFRyaWdnZXJSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICAvKiogU2V0cyB1cCBhIGtleSBtYW5hZ2VyIHRvIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24gdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9pbml0S2V5TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIodGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdGFiU3Vic2NyaXB0aW9uID0gdGhpcy5fa2V5TWFuYWdlci50YWJPdXQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIERyb3BzIGN1cnJlbnQgb3B0aW9uIHN1YnNjcmlwdGlvbnMgYW5kIElEcyBhbmQgcmVzZXRzIGZyb20gc2NyYXRjaC4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3Jlc2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuVG9PcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbklkcygpO1xuICAgIH07XG4gICAgLyoqIExpc3RlbnMgdG8gc2VsZWN0aW9uIGV2ZW50cyBvbiBlYWNoIG9wdGlvbi4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2xpc3RlblRvT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgdmFyIHN1YiA9IG9wdGlvbi5vblNlbGVjdC5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmlzVXNlcklucHV0ICYmIF90aGlzLl9zZWxlY3RlZCAhPT0gb3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0Q2hhbmdlRXZlbnQob3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX29uU2VsZWN0KG9wdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goc3ViKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogVW5zdWJzY3JpYmVzIGZyb20gYWxsIG9wdGlvbiBzdWJzY3JpcHRpb25zLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZHJvcFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9O1xuICAgIC8qKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYW4gb3B0aW9uLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZShvcHRpb24udmFsdWUpO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KG5ldyBNZFNlbGVjdENoYW5nZSh0aGlzLCBvcHRpb24udmFsdWUpKTtcbiAgICB9O1xuICAgIC8qKiBSZWNvcmRzIG9wdGlvbiBJRHMgdG8gcGFzcyB0byB0aGUgYXJpYS1vd25zIHByb3BlcnR5LiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fc2V0T3B0aW9uSWRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vcHRpb25JZHMgPSB0aGlzLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbi5pZDsgfSkuam9pbignICcpO1xuICAgIH07XG4gICAgLyoqIFdoZW4gYSBuZXcgb3B0aW9uIGlzIHNlbGVjdGVkLCBkZXNlbGVjdHMgdGhlIG90aGVycyBhbmQgY2xvc2VzIHRoZSBwYW5lbC4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uU2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG9wdGlvbjtcbiAgICAgICAgdGhpcy5fdXBkYXRlT3B0aW9ucygpO1xuICAgICAgICB0aGlzLl9zZXRWYWx1ZVdpZHRoKCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcbiAgICAgICAgaWYgKHRoaXMucGFuZWxPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEZXNlbGVjdCBlYWNoIG9wdGlvbiB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fdXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbiAhPT0gX3RoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uZGVzZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNdXN0IHNldCB0aGUgd2lkdGggb2YgdGhlIHNlbGVjdGVkIG9wdGlvbidzIHZhbHVlIHByb2dyYW1tYXRpY2FsbHlcbiAgICAgKiBiZWNhdXNlIGl0IGlzIGFic29sdXRlbHkgcG9zaXRpb25lZCBhbmQgb3RoZXJ3aXNlIHdpbGwgbm90IGNsaXBcbiAgICAgKiBvdmVyZmxvdy4gVGhlIHNlbGVjdGlvbiBhcnJvdyBpcyA5cHggd2lkZSwgYWRkIDRweCBvZiBwYWRkaW5nID0gMTNcbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldFZhbHVlV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkVmFsdWVXaWR0aCA9IHRoaXMuX3RyaWdnZXJXaWR0aCAtIDEzO1xuICAgIH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIHNlbGVjdGVkIGl0ZW0uIElmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZCwgaXQgd2lsbCBmb2N1c1xuICAgICAqIHRoZSBmaXJzdCBpdGVtIGluc3RlYWQuXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9mb2N1c0NvcnJlY3RPcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0odGhpcy5fZ2V0T3B0aW9uSW5kZXgodGhpcy5zZWxlY3RlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIGhvc3QgZWxlbWVudCB3aGVuIHRoZSBwYW5lbCBjbG9zZXMuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9mb2N1c0hvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKTtcbiAgICB9O1xuICAgIC8qKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcHJvdmlkZWQgb3B0aW9uIGluIHRoZSBvcHRpb24gbGlzdC4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldE9wdGlvbkluZGV4ID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gKG9wdGlvbiA9PT0gY3VycmVudCA/IGluZGV4IDogdW5kZWZpbmVkKSA6IHJlc3VsdDtcbiAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIC8qKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgcG9zaXRpb24gYW5kIHgtIGFuZCB5LW9mZnNldHMgb2YgdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9jYWxjdWxhdGVPdmVybGF5UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29mZnNldFggPSB0aGlzLl9pc1J0bCgpID8gU0VMRUNUX1BBTkVMX1BBRERJTkdfWCA6IC1TRUxFQ1RfUEFORUxfUEFERElOR19YO1xuICAgICAgICB2YXIgcGFuZWxIZWlnaHQgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMubGVuZ3RoICogU0VMRUNUX09QVElPTl9IRUlHSFQsIFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUKTtcbiAgICAgICAgdmFyIHNjcm9sbENvbnRhaW5lckhlaWdodCA9IHRoaXMub3B0aW9ucy5sZW5ndGggKiBTRUxFQ1RfT1BUSU9OX0hFSUdIVDtcbiAgICAgICAgLy8gVGhlIGZhcnRoZXN0IHRoZSBwYW5lbCBjYW4gYmUgc2Nyb2xsZWQgYmVmb3JlIGl0IGhpdHMgdGhlIGJvdHRvbVxuICAgICAgICB2YXIgbWF4U2Nyb2xsID0gc2Nyb2xsQ29udGFpbmVySGVpZ2h0IC0gcGFuZWxIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IHRoaXMuX2dldE9wdGlvbkluZGV4KHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgLy8gV2UgbXVzdCBtYWludGFpbiBhIHNjcm9sbCBidWZmZXIgc28gdGhlIHNlbGVjdGVkIG9wdGlvbiB3aWxsIGJlIHNjcm9sbGVkIHRvIHRoZVxuICAgICAgICAgICAgLy8gY2VudGVyIG9mIHRoZSBvdmVybGF5IHBhbmVsIHJhdGhlciB0aGFuIHRoZSB0b3AuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsQnVmZmVyID0gcGFuZWxIZWlnaHQgLyAyO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9wID0gdGhpcy5fY2FsY3VsYXRlT3ZlcmxheVNjcm9sbChzZWxlY3RlZEluZGV4LCBzY3JvbGxCdWZmZXIsIG1heFNjcm9sbCk7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRZID0gdGhpcy5fY2FsY3VsYXRlT3ZlcmxheU9mZnNldChzZWxlY3RlZEluZGV4LCBzY3JvbGxCdWZmZXIsIG1heFNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBvcHRpb24gaXMgc2VsZWN0ZWQsIHRoZSBwYW5lbCBjZW50ZXJzIG9uIHRoZSBmaXJzdCBvcHRpb24uIEluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgIC8vIHdlIG11c3Qgb25seSBhZGp1c3QgZm9yIHRoZSBoZWlnaHQgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBvcHRpb24gZWxlbWVudFxuICAgICAgICAgICAgLy8gYW5kIHRoZSB0cmlnZ2VyIGVsZW1lbnQsIHRoZW4gbXVsdGlwbHkgaXQgYnkgLTEgdG8gZW5zdXJlIHRoZSBwYW5lbCBtb3Zlc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uIHVwIHRoZSBwYWdlLlxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IChTRUxFQ1RfT1BUSU9OX0hFSUdIVCAtIFNFTEVDVF9UUklHR0VSX0hFSUdIVCkgLyAyICogLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tPdmVybGF5V2l0aGluVmlld3BvcnQobWF4U2Nyb2xsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbC5cbiAgICAgKlxuICAgICAqIEF0dGVtcHRzIHRvIGNlbnRlciB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluIHRoZSBwYW5lbC4gSWYgdGhlIG9wdGlvbiBpc1xuICAgICAqIHRvbyBoaWdoIG9yIHRvbyBsb3cgaW4gdGhlIHBhbmVsIHRvIGJlIHNjcm9sbGVkIHRvIHRoZSBjZW50ZXIsIGl0IGNsYW1wcyB0aGVcbiAgICAgKiBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIG1pbiBvciBtYXggc2Nyb2xsIHBvc2l0aW9ucyByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9jYWxjdWxhdGVPdmVybGF5U2Nyb2xsID0gZnVuY3Rpb24gKHNlbGVjdGVkSW5kZXgsIHNjcm9sbEJ1ZmZlciwgbWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciBvcHRpb25PZmZzZXRGcm9tU2Nyb2xsVG9wID0gU0VMRUNUX09QVElPTl9IRUlHSFQgKiBzZWxlY3RlZEluZGV4O1xuICAgICAgICB2YXIgaGFsZk9wdGlvbkhlaWdodCA9IFNFTEVDVF9PUFRJT05fSEVJR0hUIC8gMjtcbiAgICAgICAgLy8gU3RhcnRzIGF0IHRoZSBvcHRpb25PZmZzZXRGcm9tU2Nyb2xsVG9wLCB3aGljaCBzY3JvbGxzIHRoZSBvcHRpb24gdG8gdGhlIHRvcCBvZiB0aGVcbiAgICAgICAgLy8gc2Nyb2xsIGNvbnRhaW5lciwgdGhlbiBzdWJ0cmFjdHMgdGhlIHNjcm9sbCBidWZmZXIgdG8gc2Nyb2xsIHRoZSBvcHRpb24gZG93biB0b1xuICAgICAgICAvLyB0aGUgY2VudGVyIG9mIHRoZSBvdmVybGF5IHBhbmVsLiBIYWxmIHRoZSBvcHRpb24gaGVpZ2h0IG11c3QgYmUgcmUtYWRkZWQgdG8gdGhlXG4gICAgICAgIC8vIHNjcm9sbFRvcCBzbyB0aGUgb3B0aW9uIGlzIGNlbnRlcmVkIGJhc2VkIG9uIGl0cyBtaWRkbGUsIG5vdCBpdHMgdG9wIGVkZ2UuXG4gICAgICAgIHZhciBvcHRpbWFsU2Nyb2xsUG9zaXRpb24gPSBvcHRpb25PZmZzZXRGcm9tU2Nyb2xsVG9wIC0gc2Nyb2xsQnVmZmVyICsgaGFsZk9wdGlvbkhlaWdodDtcbiAgICAgICAgcmV0dXJuIGNsYW1wVmFsdWUoMCwgb3B0aW1hbFNjcm9sbFBvc2l0aW9uLCBtYXhTY3JvbGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgeS1vZmZzZXQgb2YgdGhlIHNlbGVjdCdzIG92ZXJsYXkgcGFuZWwgaW4gcmVsYXRpb24gdG8gdGhlXG4gICAgICogdG9wIHN0YXJ0IGNvcm5lciBvZiB0aGUgdHJpZ2dlci4gSXQgaGFzIHRvIGJlIGFkanVzdGVkIGluIG9yZGVyIGZvciB0aGVcbiAgICAgKiBzZWxlY3RlZCBvcHRpb24gdG8gYmUgYWxpZ25lZCBvdmVyIHRoZSB0cmlnZ2VyIHdoZW4gdGhlIHBhbmVsIG9wZW5zLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheU9mZnNldCA9IGZ1bmN0aW9uIChzZWxlY3RlZEluZGV4LCBzY3JvbGxCdWZmZXIsIG1heFNjcm9sbCkge1xuICAgICAgICB2YXIgb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wO1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVG9wID09PSAwKSB7XG4gICAgICAgICAgICBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgPSBzZWxlY3RlZEluZGV4ICogU0VMRUNUX09QVElPTl9IRUlHSFQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2Nyb2xsVG9wID09PSBtYXhTY3JvbGwpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdERpc3BsYXllZEluZGV4ID0gdGhpcy5vcHRpb25zLmxlbmd0aCAtIFNFTEVDVF9NQVhfT1BUSU9OU19ESVNQTEFZRUQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWREaXNwbGF5SW5kZXggPSBzZWxlY3RlZEluZGV4IC0gZmlyc3REaXNwbGF5ZWRJbmRleDtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIHBhbmVsIGhlaWdodCBpcyBsb25nZXIgdGhhbiB0aGUgaGVpZ2h0IG9mIHRoZSBvcHRpb25zIGFsb25lLFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYWx3YXlzIGV4dHJhIHBhZGRpbmcgYXQgdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHBhbmVsLiBXaGVuXG4gICAgICAgICAgICAvLyBzY3JvbGxlZCB0byB0aGUgdmVyeSBib3R0b20sIHRoaXMgcGFkZGluZyBpcyBhdCB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmRcbiAgICAgICAgICAgIC8vIG11c3QgYmUgYWRkZWQgdG8gdGhlIG9mZnNldC5cbiAgICAgICAgICAgIG9wdGlvbk9mZnNldEZyb21QYW5lbFRvcCA9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREaXNwbGF5SW5kZXggKiBTRUxFQ1RfT1BUSU9OX0hFSUdIVCArIFNFTEVDVF9QQU5FTF9QQURESU5HX1k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW9uIHdhcyBzY3JvbGxlZCB0byB0aGUgbWlkZGxlIG9mIHRoZSBwYW5lbCB1c2luZyBhIHNjcm9sbCBidWZmZXIsXG4gICAgICAgICAgICAvLyBpdHMgb2Zmc2V0IHdpbGwgYmUgdGhlIHNjcm9sbCBidWZmZXIgbWludXMgdGhlIGhhbGYgaGVpZ2h0IHRoYXQgd2FzIGFkZGVkIHRvXG4gICAgICAgICAgICAvLyBjZW50ZXIgaXQuXG4gICAgICAgICAgICBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgPSBzY3JvbGxCdWZmZXIgLSBTRUxFQ1RfT1BUSU9OX0hFSUdIVCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZpbmFsIG9mZnNldCBpcyB0aGUgb3B0aW9uJ3Mgb2Zmc2V0IGZyb20gdGhlIHRvcCwgYWRqdXN0ZWQgZm9yIHRoZSBoZWlnaHRcbiAgICAgICAgLy8gZGlmZmVyZW5jZSwgbXVsdGlwbGllZCBieSAtMSB0byBlbnN1cmUgdGhhdCB0aGUgb3ZlcmxheSBtb3ZlcyBpbiB0aGUgY29ycmVjdFxuICAgICAgICAvLyBkaXJlY3Rpb24gdXAgdGhlIHBhZ2UuXG4gICAgICAgIHJldHVybiBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgKiAtMSAtIFNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhhdCB0aGUgYXR0ZW1wdGVkIG92ZXJsYXkgcG9zaXRpb24gd2lsbCBmaXQgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBJZiBpdCB3aWxsIG5vdCBmaXQsIHRyaWVzIHRvIGFkanVzdCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGUgYXNzb2NpYXRlZFxuICAgICAqIHktb2Zmc2V0IHNvIHRoZSBwYW5lbCBjYW4gb3BlbiBmdWxseSBvbi1zY3JlZW4uIElmIGl0IHN0aWxsIHdvbid0IGZpdCxcbiAgICAgKiBzZXRzIHRoZSBvZmZzZXQgYmFjayB0byAwIHRvIGFsbG93IHRoZSBmYWxsYmFjayBwb3NpdGlvbiB0byB0YWtlIG92ZXIuXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9jaGVja092ZXJsYXlXaXRoaW5WaWV3cG9ydCA9IGZ1bmN0aW9uIChtYXhTY3JvbGwpIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0UmVjdCA9IHRoaXMuX3ZpZXdwb3J0UnVsZXIuZ2V0Vmlld3BvcnRSZWN0KCk7XG4gICAgICAgIHZhciB0cmlnZ2VyUmVjdCA9IHRoaXMuX2dldFRyaWdnZXJSZWN0KCk7XG4gICAgICAgIHZhciB0b3BTcGFjZUF2YWlsYWJsZSA9IHRyaWdnZXJSZWN0LnRvcCAtIFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HO1xuICAgICAgICB2YXIgYm90dG9tU3BhY2VBdmFpbGFibGUgPSB2aWV3cG9ydFJlY3QuaGVpZ2h0IC0gdHJpZ2dlclJlY3QuYm90dG9tIC0gU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG4gICAgICAgIHZhciBwYW5lbEhlaWdodFRvcCA9IE1hdGguYWJzKHRoaXMuX29mZnNldFkpO1xuICAgICAgICB2YXIgdG90YWxQYW5lbEhlaWdodCA9IE1hdGgubWluKHRoaXMub3B0aW9ucy5sZW5ndGggKiBTRUxFQ1RfT1BUSU9OX0hFSUdIVCwgU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQpO1xuICAgICAgICB2YXIgcGFuZWxIZWlnaHRCb3R0b20gPSB0b3RhbFBhbmVsSGVpZ2h0IC0gcGFuZWxIZWlnaHRUb3AgLSB0cmlnZ2VyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmIChwYW5lbEhlaWdodEJvdHRvbSA+IGJvdHRvbVNwYWNlQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RQYW5lbFVwKHBhbmVsSGVpZ2h0Qm90dG9tLCBib3R0b21TcGFjZUF2YWlsYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFuZWxIZWlnaHRUb3AgPiB0b3BTcGFjZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0UGFuZWxEb3duKHBhbmVsSGVpZ2h0VG9wLCB0b3BTcGFjZUF2YWlsYWJsZSwgbWF4U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkJhc2VkT25PcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEFkanVzdHMgdGhlIG92ZXJsYXkgcGFuZWwgdXAgdG8gZml0IGluIHRoZSB2aWV3cG9ydC4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2FkanVzdFBhbmVsVXAgPSBmdW5jdGlvbiAocGFuZWxIZWlnaHRCb3R0b20sIGJvdHRvbVNwYWNlQXZhaWxhYmxlKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZUJlbG93Vmlld3BvcnQgPSBwYW5lbEhlaWdodEJvdHRvbSAtIGJvdHRvbVNwYWNlQXZhaWxhYmxlO1xuICAgICAgICAvLyBTY3JvbGxzIHRoZSBwYW5lbCB1cCBieSB0aGUgZGlzdGFuY2UgaXQgd2FzIGV4dGVuZGluZyBwYXN0IHRoZSBib3VuZGFyeSwgdGhlblxuICAgICAgICAvLyBhZGp1c3RzIHRoZSBvZmZzZXQgYnkgdGhhdCBhbW91bnQgdG8gbW92ZSB0aGUgcGFuZWwgdXAgaW50byB0aGUgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvcCAtPSBkaXN0YW5jZUJlbG93Vmlld3BvcnQ7XG4gICAgICAgIHRoaXMuX29mZnNldFkgLT0gZGlzdGFuY2VCZWxvd1ZpZXdwb3J0O1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uKCk7XG4gICAgICAgIC8vIElmIHRoZSBwYW5lbCBpcyBzY3JvbGxlZCB0byB0aGUgdmVyeSB0b3AsIGl0IHdvbid0IGJlIGFibGUgdG8gZml0IHRoZSBwYW5lbFxuICAgICAgICAvLyBieSBzY3JvbGxpbmcsIHNvIHNldCB0aGUgb2Zmc2V0IHRvIDAgdG8gYWxsb3cgdGhlIGZhbGxiYWNrIHBvc2l0aW9uIHRvIHRha2VcbiAgICAgICAgLy8gZWZmZWN0LlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVG9wIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IFwiNTAlIGJvdHRvbSAwcHhcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEFkanVzdHMgdGhlIG92ZXJsYXkgcGFuZWwgZG93biB0byBmaXQgaW4gdGhlIHZpZXdwb3J0LiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fYWRqdXN0UGFuZWxEb3duID0gZnVuY3Rpb24gKHBhbmVsSGVpZ2h0VG9wLCB0b3BTcGFjZUF2YWlsYWJsZSwgbWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZUFib3ZlVmlld3BvcnQgPSBwYW5lbEhlaWdodFRvcCAtIHRvcFNwYWNlQXZhaWxhYmxlO1xuICAgICAgICAvLyBTY3JvbGxzIHRoZSBwYW5lbCBkb3duIGJ5IHRoZSBkaXN0YW5jZSBpdCB3YXMgZXh0ZW5kaW5nIHBhc3QgdGhlIGJvdW5kYXJ5LCB0aGVuXG4gICAgICAgIC8vIGFkanVzdHMgdGhlIG9mZnNldCBieSB0aGF0IGFtb3VudCB0byBtb3ZlIHRoZSBwYW5lbCBkb3duIGludG8gdGhlIHZpZXdwb3J0LlxuICAgICAgICB0aGlzLl9zY3JvbGxUb3AgKz0gZGlzdGFuY2VBYm92ZVZpZXdwb3J0O1xuICAgICAgICB0aGlzLl9vZmZzZXRZICs9IGRpc3RhbmNlQWJvdmVWaWV3cG9ydDtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luQmFzZWRPbk9wdGlvbigpO1xuICAgICAgICAvLyBJZiB0aGUgcGFuZWwgaXMgc2Nyb2xsZWQgdG8gdGhlIHZlcnkgYm90dG9tLCBpdCB3b24ndCBiZSBhYmxlIHRvIGZpdCB0aGVcbiAgICAgICAgLy8gcGFuZWwgYnkgc2Nyb2xsaW5nLCBzbyBzZXQgdGhlIG9mZnNldCB0byAwIHRvIGFsbG93IHRoZSBmYWxsYmFjayBwb3NpdGlvblxuICAgICAgICAvLyB0byB0YWtlIGVmZmVjdC5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IG1heFNjcm9sbDtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gXCI1MCUgdG9wIDBweFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgdHJhbnNmb3JtIG9yaWdpbiBwb2ludCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgb3B0aW9uLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZ2V0T3JpZ2luQmFzZWRPbk9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9yaWdpblkgPSBNYXRoLmFicyh0aGlzLl9vZmZzZXRZKSAtIFNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQgKyBTRUxFQ1RfT1BUSU9OX0hFSUdIVCAvIDI7XG4gICAgICAgIHJldHVybiBcIjUwJSBcIiArIG9yaWdpblkgKyBcInB4IDBweFwiO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKCd0cmlnZ2VyJyksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZilcbiAgICBdLCBNZFNlbGVjdC5wcm90b3R5cGUsIFwidHJpZ2dlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZChDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzYoJ2Rlc2lnbjp0eXBlJywgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSlcbiAgICBdLCBNZFNlbGVjdC5wcm90b3R5cGUsIFwib3ZlcmxheURpclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZE9wdGlvbiksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kU2VsZWN0LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2VsZWN0LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTZWxlY3QucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNlbGVjdC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKVxuICAgIF0sIE1kU2VsZWN0LnByb3RvdHlwZSwgXCJvbk9wZW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzYoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgTWRTZWxlY3QucHJvdG90eXBlLCBcIm9uQ2xvc2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzYoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgTWRTZWxlY3QucHJvdG90eXBlLCBcImNoYW5nZVwiLCB2b2lkIDApO1xuICAgIE1kU2VsZWN0ID0gX19kZWNvcmF0ZSQzNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXNlbGVjdCwgbWF0LXNlbGVjdCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtc2VsZWN0LXRyaWdnZXJcXFwiIGNkay1vdmVybGF5LW9yaWdpbiAoY2xpY2spPVxcXCJ0b2dnbGUoKVxcXCIgI29yaWdpbj1cXFwiY2RrT3ZlcmxheU9yaWdpblxcXCIgI3RyaWdnZXI+PHNwYW4gY2xhc3M9XFxcIm1hdC1zZWxlY3QtcGxhY2Vob2xkZXJcXFwiIFtjbGFzcy5tYXQtZmxvYXRpbmctcGxhY2Vob2xkZXJdPVxcXCJ0aGlzLnNlbGVjdGVkXFxcIiBbQHRyYW5zZm9ybVBsYWNlaG9sZGVyXT1cXFwiX3BsYWNlaG9sZGVyU3RhdGVcXFwiIFtzdHlsZS53aWR0aC5weF09XFxcIl9zZWxlY3RlZFZhbHVlV2lkdGhcXFwiPnt7IHBsYWNlaG9sZGVyIH19IDwvc3Bhbj48c3BhbiBjbGFzcz1cXFwibWF0LXNlbGVjdC12YWx1ZVxcXCIgKm5nSWY9XFxcInNlbGVjdGVkXFxcIj48c3BhbiBjbGFzcz1cXFwibWF0LXNlbGVjdC12YWx1ZS10ZXh0XFxcIj57eyBzZWxlY3RlZD8udmlld1ZhbHVlIH19PC9zcGFuPiA8L3NwYW4+PHNwYW4gY2xhc3M9XFxcIm1hdC1zZWxlY3QtYXJyb3dcXFwiPjwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcIm1hdC1zZWxlY3QtdW5kZXJsaW5lXFxcIj48L3NwYW4+PC9kaXY+PHRlbXBsYXRlIGNkay1jb25uZWN0ZWQtb3ZlcmxheSBbb3JpZ2luXT1cXFwib3JpZ2luXFxcIiBbb3Blbl09XFxcInBhbmVsT3BlblxcXCIgaGFzQmFja2Ryb3AgKGJhY2tkcm9wQ2xpY2spPVxcXCJjbG9zZSgpXFxcIiBiYWNrZHJvcENsYXNzPVxcXCJjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcFxcXCIgW3Bvc2l0aW9uc109XFxcIl9wb3NpdGlvbnNcXFwiIFttaW5XaWR0aF09XFxcIl90cmlnZ2VyV2lkdGhcXFwiIFtvZmZzZXRZXT1cXFwiX29mZnNldFlcXFwiIFtvZmZzZXRYXT1cXFwiX29mZnNldFhcXFwiIChhdHRhY2gpPVxcXCJfc2V0U2Nyb2xsVG9wKClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zZWxlY3QtcGFuZWxcXFwiIFtAdHJhbnNmb3JtUGFuZWxdPVxcXCInc2hvd2luZydcXFwiIChAdHJhbnNmb3JtUGFuZWwuZG9uZSk9XFxcIl9vblBhbmVsRG9uZSgpXFxcIiAoa2V5ZG93bik9XFxcIl9rZXlNYW5hZ2VyLm9uS2V5ZG93bigkZXZlbnQpXFxcIiBbc3R5bGUudHJhbnNmb3JtT3JpZ2luXT1cXFwiX3RyYW5zZm9ybU9yaWdpblxcXCIgW2NsYXNzLm1hdC1zZWxlY3QtcGFuZWwtZG9uZS1hbmltYXRpbmddPVxcXCJfcGFuZWxEb25lQW5pbWF0aW5nXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtc2VsZWN0LWNvbnRlbnRcXFwiIFtAZmFkZUluQ29udGVudF09XFxcIidzaG93aW5nJ1xcXCIgKEBmYWRlSW5Db250ZW50LmRvbmUpPVxcXCJfb25GYWRlSW5Eb25lKClcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48L2Rpdj48L3RlbXBsYXRlPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNlbGVjdHtkaXNwbGF5OmlubGluZS1ibG9jaztvdXRsaW5lOjA7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZn0ubWF0LXNlbGVjdC10cmlnZ2Vye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjMwcHg7bWluLXdpZHRoOjExMnB4O2N1cnNvcjpwb2ludGVyO3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtmb250LXNpemU6MTZweH1bYXJpYS1kaXNhYmxlZD10cnVlXSAubWF0LXNlbGVjdC10cmlnZ2Vye2N1cnNvcjpkZWZhdWx0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0ubWF0LXNlbGVjdC11bmRlcmxpbmV7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjFweH1bYXJpYS1kaXNhYmxlZD10cnVlXSAubWF0LXNlbGVjdC11bmRlcmxpbmV7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgwLDAsMCwuMjYpIDAscmdiYSgwLDAsMCwuMjYpIDMzJSx0cmFuc3BhcmVudCAwKTtiYWNrZ3JvdW5kLXNpemU6NHB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JhY2tncm91bmQtcG9zaXRpb246MCBib3R0b219Lm1hdC1zZWxlY3QtcGxhY2Vob2xkZXJ7cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzowIDJweDt0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wO2ZsZXgtZ3JvdzoxfS5tYXQtc2VsZWN0LXBsYWNlaG9sZGVyLm1hdC1mbG9hdGluZy1wbGFjZWhvbGRlcnt0b3A6LTIycHg7bGVmdDotMnB4O3RleHQtYWxpZ246bGVmdDt0cmFuc2Zvcm06c2NhbGUoLjc1KX1bZGlyPXJ0bF0gLm1hdC1zZWxlY3QtcGxhY2Vob2xkZXJ7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCB0b3B9W2Rpcj1ydGxdIC5tYXQtc2VsZWN0LXBsYWNlaG9sZGVyLm1hdC1mbG9hdGluZy1wbGFjZWhvbGRlcntsZWZ0OjJweDt0ZXh0LWFsaWduOnJpZ2h0fVthcmlhLXJlcXVpcmVkPXRydWVdIC5tYXQtc2VsZWN0LXBsYWNlaG9sZGVyOjphZnRlcntjb250ZW50OicqJ30ubWF0LXNlbGVjdC12YWx1ZXtwb3NpdGlvbjphYnNvbHV0ZTttYXgtd2lkdGg6Y2FsYygxMDAlIC0gMThweCk7ZmxleC1ncm93OjE7dG9wOjA7bGVmdDowO2JvdHRvbTowO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9W2Rpcj1ydGxdIC5tYXQtc2VsZWN0LXZhbHVle2xlZnQ6YXV0bztyaWdodDowfS5tYXQtc2VsZWN0LXZhbHVlLXRleHR7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93LXg6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7bGluZS1oZWlnaHQ6MzBweH0ubWF0LXNlbGVjdC1hcnJvd3t3aWR0aDowO2hlaWdodDowO2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci10b3A6NXB4IHNvbGlkO21hcmdpbjowIDRweH0ubWF0LXNlbGVjdC1wYW5lbHtib3gtc2hhZG93OjAgNXB4IDVweCAtM3B4IHJnYmEoMCwwLDAsLjIpLDAgOHB4IDEwcHggMXB4IHJnYmEoMCwwLDAsLjE0KSwwIDNweCAxNHB4IDJweCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjExMnB4O21heC13aWR0aDoyODBweDtvdmVyZmxvdzphdXRvOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDttYXgtaGVpZ2h0OjI1NnB4fUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtc2VsZWN0LXBhbmVse291dGxpbmU6c29saWQgMXB4fX1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnbGlzdGJveCcsXG4gICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfZ2V0VGFiSW5kZXgoKScsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1yZXF1aXJlZF0nOiAncmVxdWlyZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWludmFsaWRdJzogJ19jb250cm9sPy5pbnZhbGlkIHx8IFwiZmFsc2VcIicsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtb3duc10nOiAnX29wdGlvbklkcycsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2VsZWN0LWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2VsZWN0XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX29uQmx1cigpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1QbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1QYW5lbCxcbiAgICAgICAgICAgICAgICBmYWRlSW5Db250ZW50XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZFNlbGVjdCcsXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDYoNCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSQ2KDUsIF9hbmd1bGFyX2NvcmUuU2VsZigpKSxcbiAgICAgICAgX19wYXJhbSQ2KDUsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIFZpZXdwb3J0UnVsZXIsIF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0b3JSZWYsIERpciwgX2FuZ3VsYXJfZm9ybXMuTmdDb250cm9sXSlcbiAgICBdLCBNZFNlbGVjdCk7XG4gICAgcmV0dXJuIE1kU2VsZWN0O1xufSgpKTtcbi8qKiBDbGFtcHMgYSB2YWx1ZSBuIGJldHdlZW4gbWluIGFuZCBtYXggdmFsdWVzLiAqL1xuZnVuY3Rpb24gY2xhbXBWYWx1ZShtaW4sIG4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG4pLCBtYXgpO1xufVxuXG52YXIgX19kZWNvcmF0ZSQzNSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzNSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kU2VsZWN0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNlbGVjdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRTZWxlY3RNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFNlbGVjdE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kU2VsZWN0TW9kdWxlID0gX19kZWNvcmF0ZSQzNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIE92ZXJsYXlNb2R1bGUsIE1kT3B0aW9uTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFNlbGVjdCwgTWRPcHRpb25Nb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRTZWxlY3RdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRTZWxlY3RNb2R1bGUpO1xuICAgIHJldHVybiBNZFNlbGVjdE1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDM3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTURfU0xJREVfVE9HR0xFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IF9hbmd1bGFyX2Zvcm1zLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRTbGlkZVRvZ2dsZTsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vLyBBIHNpbXBsZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBieSB0aGUgTWRTbGlkZVRvZ2dsZSBjb21wb25lbnQuXG52YXIgTWRTbGlkZVRvZ2dsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZUNoYW5nZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGVDaGFuZ2U7XG59KCkpO1xuLy8gSW5jcmVhc2luZyBpbnRlZ2VyIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBpZHMgZm9yIHNsaWRlLXRvZ2dsZSBjb21wb25lbnRzLlxudmFyIG5leHRJZCQxID0gMDtcbi8qKlxuICogVHdvLXN0YXRlIGNvbnRyb2wsIHdoaWNoIGNhbiBiZSBhbHNvIGNhbGxlZCBgc3dpdGNoYC5cbiAqL1xudmFyIE1kU2xpZGVUb2dnbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVUb2dnbGUoX2VsZW1lbnRSZWYsIF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8vIEEgdW5pcXVlIGlkIGZvciB0aGUgc2xpZGUtdG9nZ2xlLiBCeSBkZWZhdWx0IHRoZSBpZCBpcyBhdXRvLWdlbmVyYXRlZC5cbiAgICAgICAgdGhpcy5fdW5pcXVlSWQgPSBcIm1kLXNsaWRlLXRvZ2dsZS1cIiArICsrbmV4dElkJDE7XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2xpZGVSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIC8vIE5lZWRzIHRvIGJlIHB1YmxpYyB0byBzdXBwb3J0IEFPVCBjb21waWxhdGlvbiAoYXMgaG9zdCBiaW5kaW5nKS5cbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgLyoqIE5hbWUgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBpbnB1dCBlbGVtZW50IGlmIHByZXNlbnQgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgLyoqIEEgdW5pcXVlIGlkIGZvciB0aGUgc2xpZGUtdG9nZ2xlIGlucHV0LiBJZiBub25lIGlzIHN1cHBsaWVkLCBpdCB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLiAqL1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5fdW5pcXVlSWQ7XG4gICAgICAgIC8qKiBVc2VkIHRvIHNwZWNpZnkgdGhlIHRhYkluZGV4IHZhbHVlIGZvciB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBhcHBlYXIgYWZ0ZXIgb3IgYmVmb3JlIHRoZSBzbGlkZS10b2dnbGUuIERlZmF1bHRzIHRvICdhZnRlcicgKi9cbiAgICAgICAgdGhpcy5sYWJlbFBvc2l0aW9uID0gJ2FmdGVyJztcbiAgICAgICAgLyoqIFVzZWQgdG8gc2V0IHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZSBvbiB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuICAgICAgICB0aGlzLmFyaWFMYWJlbCA9IG51bGw7XG4gICAgICAgIC8qKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZSBvbiB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuICAgICAgICB0aGlzLmFyaWFMYWJlbGxlZGJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBBbiBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgZWFjaCB0aW1lIHRoZSBzbGlkZS10b2dnbGUgY2hhbmdlcyBpdHMgdmFsdWUuICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgc2xpZGUtdG9nZ2xlIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgaXMgcmVxdWlyZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3JlcXVpcmVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImlucHV0SWRcIiwge1xuICAgICAgICAvKiogUmV0dXJucyB0aGUgdW5pcXVlIGlkIGZvciB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5pZCB8fCB0aGlzLl91bmlxdWVJZCkgKyBcIi1pbnB1dFwiOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIgPSBuZXcgU2xpZGVUb2dnbGVSZW5kZXJlcih0aGlzLl9lbGVtZW50UmVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBvbkNoYW5nZUV2ZW50IG1ldGhvZCB3aWxsIGJlIGFsc28gY2FsbGVkIG9uIGNsaWNrLlxuICAgICAqIFRoaXMgaXMgYmVjYXVzZSBldmVyeXRoaW5nIGZvciB0aGUgc2xpZGUtdG9nZ2xlIGlzIHdyYXBwZWQgaW5zaWRlIG9mIGEgbGFiZWwsXG4gICAgICogd2hpY2ggdHJpZ2dlcnMgYSBvbkNoYW5nZSBldmVudCBvbiBjbGljay5cbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25DaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIG9uIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY2hhbmdlIGV2ZW50LCBmcm9tIHRoZSBpbnB1dCBlbGVtZW50LCB3aWxsIGJ1YmJsZSB1cCBhbmRcbiAgICAgICAgLy8gZW1pdCBpdHMgZXZlbnQgb2JqZWN0IHRvIHRoZSBjb21wb25lbnQncyBgY2hhbmdlYCBvdXRwdXQuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBPbmNlIGEgZHJhZyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MsIHdlIGRvIG5vdCB3YW50IHRvIHRvZ2dsZSB0aGUgc2xpZGUtdG9nZ2xlIG9uIGEgY2xpY2suXG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhdGhpcy5fc2xpZGVSZW5kZXJlci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAvLyBFbWl0IG91ciBjdXN0b20gY2hhbmdlIGV2ZW50IGlmIHRoZSBuYXRpdmUgaW5wdXQgZW1pdHRlZCBvbmUuXG4gICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gb25seSBlbWl0IGl0LCBpZiB0aGUgbmF0aXZlIGlucHV0IHRyaWdnZXJlZCBvbmUsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgd2hlbiB0aGUgYGNoZWNrZWRgIHZhcmlhYmxlIGNoYW5nZXMgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gZm9yIGNsaWNrIGV2ZW50cyBvbiB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB3aGVuIGEgdXNlciBjbGlja3Mgb24gYSBsYWJlbCBlbGVtZW50LCBhIGdlbmVyYXRlZCBjbGljayBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGRpc3BhdGNoZWQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gU2luY2Ugd2UgYXJlIHVzaW5nIGEgbGFiZWwgZWxlbWVudCBhcyBvdXJcbiAgICAgICAgLy8gcm9vdCBjb250YWluZXIsIHRoZSBjbGljayBldmVudCBvbiB0aGUgYHNsaWRlLXRvZ2dsZWAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cbiAgICAgICAgLy8gVGhlIHJlYWwgY2xpY2sgZXZlbnQgd2lsbCBidWJibGUgdXAsIGFuZCB0aGUgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IGFsc28gdHJpZXMgdG8gYnViYmxlIHVwLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbGVhZCB0byBtdWx0aXBsZSBjbGljayBldmVudHMuXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9zZXRNb3VzZWRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdlIG9ubHkgKnNob3cqIHRoZSBmb2N1cyBzdHlsZSB3aGVuIGZvY3VzIGhhcyBjb21lIHRvIHRoZSBidXR0b24gdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgICAgLy8gVGhlIE1hdGVyaWFsIERlc2lnbiBzcGVjIGlzIHNpbGVudCBvbiB0aGlzIHRvcGljLCBhbmQgd2l0aG91dCBkb2luZyB0aGlzLCB0aGVcbiAgICAgICAgLy8gYnV0dG9uIGNvbnRpbnVlcyB0byBsb29rIDphY3RpdmUgYWZ0ZXIgY2xpY2tpbmcuXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL21hcmN5c3V0dG9uLmNvbS9idXR0b24tZm9jdXMtaGVsbC9cbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9pc01vdXNlZG93biA9IGZhbHNlOyB9LCAxMDApO1xuICAgIH07XG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT25seSBzaG93IHRoZSBmb2N1cyAvIHJpcHBsZSBpbmRpY2F0b3Igd2hlbiB0aGUgZm9jdXMgd2FzIG5vdCB0cmlnZ2VyZWQgYnkgYSBtb3VzZVxuICAgICAgICAvLyBpbnRlcmFjdGlvbiBvbiB0aGUgY29tcG9uZW50LlxuICAgICAgICBpZiAoIXRoaXMuX2lzTW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNGb2N1cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9vbklucHV0Qmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICB9O1xuICAgIC8qKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKiogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci4gKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKiogSW1wbGVtZW50ZWQgYXMgYSBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBzbGlkZS10b2dnbGUuICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpO1xuICAgICAgICB0aGlzLl9vbklucHV0Rm9jdXMoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlLXRvZ2dsZSBpcyBjaGVja2VkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5fY2hlY2tlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQgIT09ICEhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLl9jaGVja2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgc2xpZGUtdG9nZ2xlLiBDYW4gYmUgcHJpbWFyeSwgYWNjZW50LCBvciB3YXJuLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogVG9nZ2xlcyB0aGUgY2hlY2tlZCBzdGF0ZSBvZiB0aGUgc2xpZGUtdG9nZ2xlLiAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yLCBpc0FkZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBFbWl0cyB0aGUgY2hhbmdlIGV2ZW50IHRvIHRoZSBgY2hhbmdlYCBvdXRwdXQgRXZlbnRFbWl0dGVyICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kU2xpZGVUb2dnbGVDaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQuY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcbiAgICAgICAgdGhpcy5fY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIuc3RhcnRUaHVtYkRyYWcodGhpcy5jaGVja2VkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fc2xpZGVSZW5kZXJlci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIudXBkYXRlVGh1bWJQb3NpdGlvbihldmVudC5kZWx0YVgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25EcmFnRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX3NsaWRlUmVuZGVyZXIuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgd2UgaGF2ZSB0byBzdG9wIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgZXZlbnQgaGFuZGxlcixcbiAgICAgICAgLy8gYmVjYXVzZSBvdGhlcndpc2UgdGhlIGNsaWNrIGV2ZW50IHdpbGwgYmUgZmlyZWQgYW5kIHdpbGwgcmVzZXQgdGhlIG5ldyBjaGVja2VkIHZhcmlhYmxlLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNoZWNrZWQgPSBfdGhpcy5fc2xpZGVSZW5kZXJlci5zdG9wVGh1bWJEcmFnKCk7XG4gICAgICAgICAgICBfdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwibGFiZWxQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLWxhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJhcmlhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JyksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJhcmlhTGFiZWxsZWRieVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKCdpbnB1dCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiX2lucHV0RWxlbWVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBNZFNsaWRlVG9nZ2xlID0gX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXNsaWRlLXRvZ2dsZSwgbWF0LXNsaWRlLXRvZ2dsZScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGUtdG9nZ2xlXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2VkXSc6ICdjaGVja2VkJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF0LXNsaWRlLXRvZ2dsZSBwcmVmaXggd2lsbCBjaGFuZ2UsIG9uY2UgdGhlIHRlbXBvcmFyeSByaXBwbGUgaXMgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZS10b2dnbGUtZm9jdXNlZF0nOiAnX2hhc0ZvY3VzJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlXSc6ICdsYWJlbFBvc2l0aW9uID09IFwiYmVmb3JlXCInLFxuICAgICAgICAgICAgICAgICcobW91c2Vkb3duKSc6ICdfc2V0TW91c2Vkb3duKCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLWxhYmVsXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLWNvbnRhaW5lclxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1iYXJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyXFxcIiAoc2xpZGVzdGFydCk9XFxcIl9vbkRyYWdTdGFydCgpXFxcIiAoc2xpZGUpPVxcXCJfb25EcmFnKCRldmVudClcXFwiIChzbGlkZWVuZCk9XFxcIl9vbkRyYWdFbmQoKVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS10aHVtYlxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LWluay1yaXBwbGVcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjxpbnB1dCAjaW5wdXQgY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtaW5wdXQgY2RrLXZpc3VhbGx5LWhpZGRlblxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIFtpZF09XFxcImlucHV0SWRcXFwiIFtyZXF1aXJlZF09XFxcInJlcXVpcmVkXFxcIiBbdGFiSW5kZXhdPVxcXCJ0YWJJbmRleFxcXCIgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJhcmlhTGFiZWxcXFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcImFyaWFMYWJlbGxlZGJ5XFxcIiAoYmx1cik9XFxcIl9vbklucHV0Qmx1cigpXFxcIiAoZm9jdXMpPVxcXCJfb25JbnB1dEZvY3VzKClcXFwiIChjaGFuZ2UpPVxcXCJfb25DaGFuZ2VFdmVudCgkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPjwvZGl2PjxzcGFuIGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLWNvbnRlbnRcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+PC9sYWJlbD5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1zbGlkZS10b2dnbGV7ZGlzcGxheTpmbGV4O2hlaWdodDoyNHB4O21hcmdpbjoxNnB4IDA7bGluZS1oZWlnaHQ6MjRweDt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO291dGxpbmU6MH0ubWF0LXNsaWRlLXRvZ2dsZS5tYXQtY2hlY2tlZCAubWF0LXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXJ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwMCUsMCwwKX0ubWF0LXNsaWRlLXRvZ2dsZSAubWF0LWluay1yaXBwbGV7Ym9yZGVyLXJhZGl1czo1MCU7b3BhY2l0eTowO2hlaWdodDo0OHB4O2xlZnQ6NTAlO292ZXJmbG93OmhpZGRlbjtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpO3RyYW5zaXRpb246b3BhY2l0eSBlYXNlIDI4MG1zLGJhY2tncm91bmQtY29sb3IgZWFzZSAyODBtczt3aWR0aDo0OHB4fS5tYXQtc2xpZGUtdG9nZ2xlLm1hdC1zbGlkZS10b2dnbGUtZm9jdXNlZCAubWF0LWluay1yaXBwbGV7b3BhY2l0eToxfS5tYXQtc2xpZGUtdG9nZ2xlLm1hdC1zbGlkZS10b2dnbGUtZGlzYWJsZWQgLm1hdC1pbmstcmlwcGxle2JhY2tncm91bmQtY29sb3I6IzAwMH0ubWF0LXNsaWRlLXRvZ2dsZS5tYXQtZGlzYWJsZWQgLm1hdC1zbGlkZS10b2dnbGUtY29udGFpbmVyLC5tYXQtc2xpZGUtdG9nZ2xlLm1hdC1kaXNhYmxlZCAubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbHtjdXJzb3I6ZGVmYXVsdH0ubWF0LXNsaWRlLXRvZ2dsZS1jb250ZW50e2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NTAwfS5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVse2Rpc3BsYXk6ZmxleDtmbGV4OjE7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVse29yZGVyOjF9Lm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWNvbnRhaW5lcntvcmRlcjoyfS5tYXQtc2xpZGUtdG9nZ2xlLWNvbnRhaW5lcntjdXJzb3I6LXdlYmtpdC1ncmFiO2N1cnNvcjpncmFiO3dpZHRoOjM2cHg7aGVpZ2h0OjI0cHg7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1zbGlkZS10b2dnbGUtY29udGFpbmVyLFtkaXI9cnRsXSAubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbC1iZWZvcmUgLm1hdC1zbGlkZS10b2dnbGUtY29udGFpbmVye21hcmdpbi1yaWdodDo4cHg7bWFyZ2luLWxlZnQ6MH0ubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbC1iZWZvcmUgLm1hdC1zbGlkZS10b2dnbGUtY29udGFpbmVyLFtkaXI9cnRsXSAubWF0LXNsaWRlLXRvZ2dsZS1jb250YWluZXJ7bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDowfS5tYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MnB4O2xlZnQ6MDt6LWluZGV4OjE7d2lkdGg6MTZweDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zaXRpb246YWxsIDgwbXMgbGluZWFyO3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtfS5tYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lci5tYXQtZHJhZ2dpbmd7dHJhbnNpdGlvbi1kdXJhdGlvbjowc30ubWF0LXNsaWRlLXRvZ2dsZS10aHVtYntwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW46MDtsZWZ0OjA7dG9wOjA7aGVpZ2h0OjIwcHg7d2lkdGg6MjBweDtib3JkZXItcmFkaXVzOjUwJTtib3gtc2hhZG93OjAgMnB4IDFweCAtMXB4IHJnYmEoMCwwLDAsLjIpLDAgMXB4IDFweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAzcHggMCByZ2JhKDAsMCwwLC4xMil9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1zbGlkZS10b2dnbGUtdGh1bWJ7YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzAwMH0ubWF0LXNsaWRlLXRvZ2dsZS1iYXJ7YmFja2dyb3VuZDojZmZmfX0ubWF0LXNsaWRlLXRvZ2dsZS1iYXJ7cG9zaXRpb246YWJzb2x1dGU7bGVmdDoxcHg7dG9wOjVweDt3aWR0aDozNHB4O2hlaWdodDoxNHB4O2JvcmRlci1yYWRpdXM6OHB4fS5tYXQtc2xpZGUtdG9nZ2xlLWlucHV0e2JvdHRvbTowO2xlZnQ6MTBweH0ubWF0LXNsaWRlLXRvZ2dsZS1iYXIsLm1hdC1zbGlkZS10b2dnbGUtdGh1bWJ7dHJhbnNpdGlvbjphbGwgODBtcyBsaW5lYXI7dHJhbnNpdGlvbi1wcm9wZXJ0eTpiYWNrZ3JvdW5kLWNvbG9yO3RyYW5zaXRpb24tZGVsYXk6NTBtc31cIl0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9TTElERV9UT0dHTEVfVkFMVUVfQUNDRVNTT1JdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlcl0pXG4gICAgXSwgTWRTbGlkZVRvZ2dsZSk7XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGU7XG59KCkpO1xuLyoqXG4gKiBSZW5kZXJlciBmb3IgdGhlIFNsaWRlIFRvZ2dsZSBjb21wb25lbnQsIHdoaWNoIHNlcGFyYXRlcyBET00gbW9kaWZpY2F0aW9uIGluIGl0cyBvd24gY2xhc3NcbiAqL1xudmFyIFNsaWRlVG9nZ2xlUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWRlVG9nZ2xlUmVuZGVyZXIoX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl90aHVtYkVsID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXInKTtcbiAgICAgICAgdGhpcy5fdGh1bWJCYXJFbCA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1zbGlkZS10b2dnbGUtYmFyJyk7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgaXMgY3VycmVudGx5IGRyYWdnaW5nLiAqL1xuICAgIFNsaWRlVG9nZ2xlUmVuZGVyZXIucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3RodW1iQmFyV2lkdGg7XG4gICAgfTtcbiAgICAvKiogSW5pdGlhbGl6ZXMgdGhlIGRyYWcgb2YgdGhlIHNsaWRlLXRvZ2dsZS4gKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS5zdGFydFRodW1iRHJhZyA9IGZ1bmN0aW9uIChjaGVja2VkKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RodW1iQmFyV2lkdGggPSB0aGlzLl90aHVtYkJhckVsLmNsaWVudFdpZHRoIC0gdGhpcy5fdGh1bWJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJFbC5jbGFzc0xpc3QuYWRkKCdtYXQtZHJhZ2dpbmcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFN0b3BzIHRoZSBjdXJyZW50IGRyYWcgYW5kIHJldHVybnMgdGhlIG5ldyBjaGVja2VkIHZhbHVlLiAqL1xuICAgIFNsaWRlVG9nZ2xlUmVuZGVyZXIucHJvdG90eXBlLnN0b3BUaHVtYkRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJCYXJXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90aHVtYkVsLmNsYXNzTGlzdC5yZW1vdmUoJ21hdC1kcmFnZ2luZycpO1xuICAgICAgICAgICAgYXBwbHlDc3NUcmFuc2Zvcm0odGhpcy5fdGh1bWJFbCwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlcmNlbnRhZ2UgPiA1MDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFVwZGF0ZXMgdGhlIHRodW1iIGNvbnRhaW5lcnMgcG9zaXRpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGRpc3RhbmNlLiAqL1xuICAgIFNsaWRlVG9nZ2xlUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZVRodW1iUG9zaXRpb24gPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fcGVyY2VudGFnZSA9IHRoaXMuX2dldFRodW1iUGVyY2VudGFnZShkaXN0YW5jZSk7XG4gICAgICAgIGFwcGx5Q3NzVHJhbnNmb3JtKHRoaXMuX3RodW1iRWwsIFwidHJhbnNsYXRlM2QoXCIgKyB0aGlzLl9wZXJjZW50YWdlICsgXCIlLCAwLCAwKVwiKTtcbiAgICB9O1xuICAgIC8qKiBSZXRyaWV2ZXMgdGhlIHBlcmNlbnRhZ2Ugb2YgdGh1bWIgZnJvbSB0aGUgbW92ZWQgZGlzdGFuY2UuICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUuX2dldFRodW1iUGVyY2VudGFnZSA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICB2YXIgcGVyY2VudGFnZSA9IChkaXN0YW5jZSAvIHRoaXMuX3RodW1iQmFyV2lkdGgpICogMTAwO1xuICAgICAgICAvLyBXaGVuIHRoZSB0b2dnbGUgd2FzIGluaXRpYWxseSBjaGVja2VkLCB0aGVuIHdlIGhhdmUgdG8gc3RhcnQgdGhlIGRyYWcgYXQgdGhlIGVuZC5cbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZWQpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgKz0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihwZXJjZW50YWdlLCAxMDApKTtcbiAgICB9O1xuICAgIHJldHVybiBTbGlkZVRvZ2dsZVJlbmRlcmVyO1xufSgpKTtcbnZhciBNZFNsaWRlVG9nZ2xlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlVG9nZ2xlTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFNsaWRlVG9nZ2xlTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRTbGlkZVRvZ2dsZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGVNb2R1bGUgPSBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfZm9ybXMuRm9ybXNNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kU2xpZGVUb2dnbGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRTbGlkZVRvZ2dsZV0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5IQU1NRVJfR0VTVFVSRV9DT05GSUcsIHVzZUNsYXNzOiBHZXN0dXJlQ29uZmlnIH1dLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRTbGlkZVRvZ2dsZU1vZHVsZSk7XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGVNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQzOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzOCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNyA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogVmlzdWFsbHksIGEgMzBweCBzZXBhcmF0aW9uIGJldHdlZW4gdGljayBtYXJrcyBsb29rcyBiZXN0LiBUaGlzIGlzIHZlcnkgc3ViamVjdGl2ZSBidXQgaXQgaXNcbiAqIHRoZSBkZWZhdWx0IHNlcGFyYXRpb24gd2UgY2hvc2UuXG4gKi9cbnZhciBNSU5fQVVUT19USUNLX1NFUEFSQVRJT04gPSAzMDtcbi8qKiBUaGUgdGh1bWIgZ2FwIHNpemUgZm9yIGEgZGlzYWJsZWQgc2xpZGVyLiAqL1xudmFyIERJU0FCTEVEX1RIVU1CX0dBUCA9IDc7XG4vKiogVGhlIHRodW1iIGdhcCBzaXplIGZvciBhIG5vbi1hY3RpdmUgc2xpZGVyIGF0IGl0cyBtaW5pbXVtIHZhbHVlLiAqL1xudmFyIE1JTl9WQUxVRV9OT05BQ1RJVkVfVEhVTUJfR0FQID0gNztcbi8qKiBUaGUgdGh1bWIgZ2FwIHNpemUgZm9yIGFuIGFjdGl2ZSBzbGlkZXIgYXQgaXRzIG1pbmltdW0gdmFsdWUuICovXG52YXIgTUlOX1ZBTFVFX0FDVElWRV9USFVNQl9HQVAgPSAxMDtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1zbGlkZXIgdG8gcmVnaXN0ZXIgYXMgYSBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAqIFRoaXMgYWxsb3dzIGl0IHRvIHN1cHBvcnQgWyhuZ01vZGVsKV0gYW5kIFtmb3JtQ29udHJvbF0uXG4gKi9cbnZhciBNRF9TTElERVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogX2FuZ3VsYXJfZm9ybXMuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZFNsaWRlcjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKiogQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgdGhlIE1kU2xpZGVyIGNvbXBvbmVudC4gKi9cbnZhciBNZFNsaWRlckNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXJDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNsaWRlckNoYW5nZTtcbn0oKSk7XG4vKipcbiAqIEFsbG93cyB1c2VycyB0byBzZWxlY3QgZnJvbSBhIHJhbmdlIG9mIHZhbHVlcyBieSBtb3ZpbmcgdGhlIHNsaWRlciB0aHVtYi4gSXQgaXMgc2ltaWxhciBpblxuICogYmVoYXZpb3IgdG8gdGhlIG5hdGl2ZSBgPGlucHV0IHR5cGU9XCJyYW5nZVwiPmAgZWxlbWVudC5cbiAqL1xudmFyIE1kU2xpZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlcihfZGlyLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIC8qKiBBIHJlbmRlcmVyIHRvIGhhbmRsZSB1cGRhdGluZyB0aGUgc2xpZGVyJ3MgdGh1bWIgYW5kIGZpbGwgdHJhY2suICovXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBzbGlkZXIuICovXG4gICAgICAgIHRoaXMuX3NsaWRlckRpbWVuc2lvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90aHVtYkxhYmVsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKiBUaGUgbGFzdCB2YWx1ZXMgZm9yIHdoaWNoIGEgY2hhbmdlIG9yIGlucHV0IGV2ZW50IHdhcyBlbWl0dGVkLiAqL1xuICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0SW5wdXRWYWx1ZSA9IG51bGw7XG4gICAgICAgIC8qKiBvblRvdWNoIGZ1bmN0aW9uIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyT25Ub3VjaCAoQ29udHJvbFZhbHVlQWNjZXNzb3IpLiAqL1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0aHVtYiBpcyBzbGlkaW5nLlxuICAgICAgICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVyZSBzaG91bGQgYmUgYSB0cmFuc2l0aW9uIGZvciB0aGUgdGh1bWIgYW5kIGZpbGwgdHJhY2suXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzbGlkZXIgaXMgYWN0aXZlIChjbGlja2VkIG9yIHNsaWRpbmcpLlxuICAgICAgICAgKiBVc2VkIHRvIHNocmluayBhbmQgZ3JvdyB0aGUgdGh1bWIgYXMgYWNjb3JkaW5nIHRvIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0ZXAgPSAxO1xuICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSAwO1xuICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWxQZXJjZW50ID0gMDtcbiAgICAgICAgdGhpcy5fcGVyY2VudCA9IDA7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWluID0gMDtcbiAgICAgICAgdGhpcy5fbWF4ID0gMTAwO1xuICAgICAgICB0aGlzLl9pbnZlcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2xpZGVyIHZhbHVlIGhhcyBjaGFuZ2VkLiAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzbGlkZXIgdGh1bWIgbW92ZXMuICovXG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgU2xpZGVyUmVuZGVyZXIoZWxlbWVudFJlZik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHNsaWRlciBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRodW1iTGFiZWxcIiwge1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdG8gc2hvdyB0aGUgdGh1bWIgbGFiZWwuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGh1bWJMYWJlbDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fdGh1bWJMYWJlbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RodW1iTGFiZWxEZXByZWNhdGVkXCIsIHtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGh1bWJMYWJlbDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fdGh1bWJMYWJlbCA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInN0ZXBcIiwge1xuICAgICAgICAvKiogVGhlIHZhbHVlcyBhdCB3aGljaCB0aGUgdGh1bWIgd2lsbCBzbmFwLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0ZXA7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl9zdGVwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGVwICUgMSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JvdW5kTGFiZWxUbyA9IHRoaXMuX3N0ZXAudG9TdHJpbmcoKS5zcGxpdCgnLicpLnBvcCgpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ0aWNrSW50ZXJ2YWxcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogSG93IG9mdGVuIHRvIHNob3cgdGlja3MuIFJlbGF0aXZlIHRvIHRoZSBzdGVwIHNvIHRoYXQgYSB0aWNrIGFsd2F5cyBhcHBlYXJzIG9uIGEgc3RlcC5cbiAgICAgICAgICogRXg6IFRpY2sgaW50ZXJ2YWwgb2YgNCB3aXRoIGEgc3RlcCBvZiAzIHdpbGwgZHJhdyBhIHRpY2sgZXZlcnkgNCBzdGVwcyAoZXZlcnkgMTIgdmFsdWVzKS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGlja0ludGVydmFsOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSAodiA9PSAnYXV0bycpID8gdiA6IGNvZXJjZU51bWJlclByb3BlcnR5KHYsIHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RpY2tJbnRlcnZhbERlcHJlY2F0ZWRcIiwge1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRpY2tJbnRlcnZhbDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLnRpY2tJbnRlcnZhbCA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidGlja0ludGVydmFsUGVyY2VudFwiLCB7XG4gICAgICAgIC8qKiBUaGUgc2l6ZSBvZiBhIHRpY2sgaW50ZXJ2YWwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBzaXplIG9mIHRoZSB0cmFjay4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90aWNrSW50ZXJ2YWxQZXJjZW50OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInBlcmNlbnRcIiwge1xuICAgICAgICAvKiogVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciB0aGF0IGNvaW5jaWRlcyB3aXRoIHRoZSB2YWx1ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFtcCh0aGlzLl9wZXJjZW50KTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBWYWx1ZSBvZiB0aGUgc2xpZGVyLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBuZWVkcyB0byBiZSByZWFkIGFuZCBpdCBpcyBzdGlsbCB1bmluaXRpYWxpemVkLCBpbml0aWFsaXplIGl0IHRvIHRoZSBtaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fbWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IGNvZXJjZU51bWJlclByb3BlcnR5KHYsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3BlcmNlbnQgPSB0aGlzLl9jYWxjdWxhdGVQZXJjZW50YWdlKHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtaW5cIiwge1xuICAgICAgICAvKiogVGhlIG1pbmltdW0gdmFsdWUgdGhhdCB0aGUgc2xpZGVyIGNhbiBoYXZlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX21pbiA9IGNvZXJjZU51bWJlclByb3BlcnR5KHYsIHRoaXMuX21pbik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgd2Fzbid0IGV4cGxpY2l0bHkgc2V0IGJ5IHRoZSB1c2VyLCBzZXQgaXQgdG8gdGhlIG1pbi5cbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9taW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wZXJjZW50ID0gdGhpcy5fY2FsY3VsYXRlUGVyY2VudGFnZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtYXhcIiwge1xuICAgICAgICAvKiogVGhlIG1heGltdW0gdmFsdWUgdGhhdCB0aGUgc2xpZGVyIGNhbiBoYXZlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX21heCA9IGNvZXJjZU51bWJlclByb3BlcnR5KHYsIHRoaXMuX21heCk7XG4gICAgICAgICAgICB0aGlzLl9wZXJjZW50ID0gdGhpcy5fY2FsY3VsYXRlUGVyY2VudGFnZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJpbnZlcnRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgc2xpZGVyIGlzIGludmVydGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ludmVydDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5faW52ZXJ0ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBzbGlkZXIgaXMgdmVydGljYWwuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmVydGljYWw7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3ZlcnRpY2FsID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJkaXNwbGF5VmFsdWVcIiwge1xuICAgICAgICAvKiogVGhlIHZhbHVlIHRvIGJlIHVzZWQgZm9yIGRpc3BsYXkgcHVycG9zZXMuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgY291bGQgYmUgaW1wcm92ZWQgZnVydGhlciBieSByb3VuZGluZyBzb21ldGhpbmcgbGlrZSAwLjk5OSB0byAxIG9yXG4gICAgICAgICAgICAvLyAwLjg5OSB0byAwLjksIGhvd2V2ZXIgaXQgaXMgdmVyeSBwZXJmb3JtYW5jZSBzZW5zaXRpdmUsIGJlY2F1c2UgaXQgZ2V0cyBjYWxsZWQgb25cbiAgICAgICAgICAgIC8vIGV2ZXJ5IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUuXG4gICAgICAgICAgICBpZiAodGhpcy5fcm91bmRMYWJlbFRvICYmIHRoaXMudmFsdWUgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG9GaXhlZCh0aGlzLl9yb3VuZExhYmVsVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiaW52ZXJ0QXhpc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBheGlzIG9mIHRoZSBzbGlkZXIgaXMgaW52ZXJ0ZWQuXG4gICAgICAgICAqIChpLmUuIHdoZXRoZXIgbW92aW5nIHRoZSB0aHVtYiBpbiB0aGUgcG9zaXRpdmUgeCBvciB5IGRpcmVjdGlvbiBkZWNyZWFzZXMgdGhlIHNsaWRlcidzIHZhbHVlKS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gU3RhbmRhcmQgbm9uLWludmVydGVkIG1vZGUgZm9yIGEgdmVydGljYWwgc2xpZGVyIHNob3VsZCBiZSBkcmFnZ2luZyB0aGUgdGh1bWIgZnJvbSBib3R0b20gdG9cbiAgICAgICAgICAgIC8vIHRvcC4gSG93ZXZlciBmcm9tIGEgeS1heGlzIHN0YW5kcG9pbnQgdGhpcyBpcyBpbnZlcnRlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsID8gIXRoaXMuaW52ZXJ0IDogdGhpcy5pbnZlcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiaW52ZXJ0TW91c2VDb29yZHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBtb3VzZSBldmVudHMgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIHNsaWRlciBwb3NpdGlvbiBieSBjYWxjdWxhdGluZyB0aGVpciBkaXN0YW5jZVxuICAgICAgICAgKiBmcm9tIHRoZSByaWdodCBvciBib3R0b20gZWRnZSBvZiB0aGUgc2xpZGVyIGFzIG9wcG9zZWQgdG8gdGhlIHRvcCBvciBsZWZ0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZGlyZWN0aW9uID09ICdydGwnICYmICF0aGlzLnZlcnRpY2FsKSA/ICF0aGlzLmludmVydEF4aXMgOiB0aGlzLmludmVydEF4aXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX2lzTWluVmFsdWVcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgc2xpZGVyIGlzIGF0IGl0cyBtaW5pbXVtIHZhbHVlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmNlbnQgPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RodW1iR2FwXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2UgdG8gbGVhdmUgYmV0d2VlbiB0aGUgc2xpZGVyIHRodW1iIGFuZCB0aGUgdHJhY2sgZmlsbCAmIHRyYWNrIGJhY2tncm91bmRcbiAgICAgICAgICogZWxlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERJU0FCTEVEX1RIVU1CX0dBUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc01pblZhbHVlICYmICF0aGlzLnRodW1iTGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNBY3RpdmUgPyBNSU5fVkFMVUVfQUNUSVZFX1RIVU1CX0dBUCA6IE1JTl9WQUxVRV9OT05BQ1RJVkVfVEhVTUJfR0FQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidHJhY2tCYWNrZ3JvdW5kU3R5bGVzXCIsIHtcbiAgICAgICAgLyoqIENTUyBzdHlsZXMgZm9yIHRoZSB0cmFjayBiYWNrZ3JvdW5kIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSB0aGlzLmludmVydE1vdXNlQ29vcmRzID8gJy0nIDogJyc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBcInRyYW5zbGF0ZVwiICsgYXhpcyArIFwiKFwiICsgc2lnbiArIHRoaXMuX3RodW1iR2FwICsgXCJweCkgc2NhbGVcIiArIGF4aXMgKyBcIihcIiArICgxIC0gdGhpcy5wZXJjZW50KSArIFwiKVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRyYWNrRmlsbFN0eWxlc1wiLCB7XG4gICAgICAgIC8qKiBDU1Mgc3R5bGVzIGZvciB0aGUgdHJhY2sgZmlsbCBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy52ZXJ0aWNhbCA/ICdZJyA6ICdYJztcbiAgICAgICAgICAgIHZhciBzaWduID0gdGhpcy5pbnZlcnRNb3VzZUNvb3JkcyA/ICcnIDogJy0nO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVcIiArIGF4aXMgKyBcIihcIiArIHNpZ24gKyB0aGlzLl90aHVtYkdhcCArIFwicHgpIHNjYWxlXCIgKyBheGlzICsgXCIoXCIgKyB0aGlzLnBlcmNlbnQgKyBcIilcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ0aWNrc0NvbnRhaW5lclN0eWxlc1wiLCB7XG4gICAgICAgIC8qKiBDU1Mgc3R5bGVzIGZvciB0aGUgdGlja3MgY29udGFpbmVyIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgLy8gRm9yIGEgaG9yaXpvbnRhbCBzbGlkZXIgaW4gUlRMIGxhbmd1YWdlcyB3ZSBwdXNoIHRoZSB0aWNrcyBjb250YWluZXIgb2ZmIHRoZSBsZWZ0IGVkZ2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIHJpZ2h0IGVkZ2UgdG8gYXZvaWQgY2F1c2luZyBhIGhvcml6b250YWwgc2Nyb2xsYmFyIHRvIGFwcGVhci5cbiAgICAgICAgICAgIHZhciBzaWduID0gIXRoaXMudmVydGljYWwgJiYgdGhpcy5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAnJyA6ICctJztcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnRpY2tJbnRlcnZhbFBlcmNlbnQgLyAyICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVcIiArIGF4aXMgKyBcIihcIiArIHNpZ24gKyBvZmZzZXQgKyBcIiUpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidGlja3NTdHlsZXNcIiwge1xuICAgICAgICAvKiogQ1NTIHN0eWxlcyBmb3IgdGhlIHRpY2tzIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpY2tTaXplID0gdGhpcy50aWNrSW50ZXJ2YWxQZXJjZW50ICogMTAwO1xuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRTaXplID0gdGhpcy52ZXJ0aWNhbCA/IFwiMnB4IFwiICsgdGlja1NpemUgKyBcIiVcIiA6IHRpY2tTaXplICsgXCIlIDJweFwiO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ1knIDogJ1gnO1xuICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gd2UgcHVzaGVkIHRoZSB0aWNrcyBjb250YWluZXIsIHB1c2ggdGhlIHRpY2tzIHRoZSBvcHBvc2l0ZVxuICAgICAgICAgICAgLy8gZGlyZWN0aW9uIHRvIHJlLWNlbnRlciB0aGVtIGJ1dCBjbGlwIG9mZiB0aGUgZW5kIGVkZ2UuIEluIFJUTCBsYW5ndWFnZXMgd2UgbmVlZCB0byBmbGlwIHRoZVxuICAgICAgICAgICAgLy8gdGlja3MgMTgwIGRlZ3JlZXMgc28gd2UncmUgcmVhbGx5IGN1dHRpbmcgb2ZmIHRoZSBlbmQgZWRnZSBhYmQgbm90IHRoZSBzdGFydC5cbiAgICAgICAgICAgIHZhciBzaWduID0gIXRoaXMudmVydGljYWwgJiYgdGhpcy5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAnLScgOiAnJztcbiAgICAgICAgICAgIHZhciByb3RhdGUgPSAhdGhpcy52ZXJ0aWNhbCAmJiB0aGlzLmRpcmVjdGlvbiA9PSAncnRsJyA/ICcgcm90YXRlKDE4MGRlZyknIDogJyc7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kU2l6ZSc6IGJhY2tncm91bmRTaXplLFxuICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgdHJhbnNsYXRlWiB0aWNrcyBzb21ldGltZXMgaml0dGVyIGFzIHRoZSBzbGlkZXIgbW92ZXMgb24gQ2hyb21lICYgRmlyZWZveC5cbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVaKDApIHRyYW5zbGF0ZVwiICsgYXhpcyArIFwiKFwiICsgc2lnbiArIHRpY2tTaXplIC8gMiArIFwiJSlcIiArIHJvdGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc01pblZhbHVlICYmIHRoaXMuX3RodW1iR2FwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZGUgPSB0aGlzLnZlcnRpY2FsID9cbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuaW52ZXJ0QXhpcyA/ICdCb3R0b20nIDogJ1RvcCcpIDpcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuaW52ZXJ0QXhpcyA/ICdSaWdodCcgOiAnTGVmdCcpO1xuICAgICAgICAgICAgICAgIHN0eWxlc1soXCJwYWRkaW5nXCIgKyBzaWRlKV0gPSB0aGlzLl90aHVtYkdhcCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidGh1bWJDb250YWluZXJTdHlsZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy52ZXJ0aWNhbCA/ICdZJyA6ICdYJztcbiAgICAgICAgICAgIC8vIEZvciBhIGhvcml6b250YWwgc2xpZGVyIGluIFJUTCBsYW5ndWFnZXMgd2UgcHVzaCB0aGUgdGh1bWIgY29udGFpbmVyIG9mZiB0aGUgbGVmdCBlZGdlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSByaWdodCBlZGdlIHRvIGF2b2lkIGNhdXNpbmcgYSBob3Jpem9udGFsIHNjcm9sbGJhciB0byBhcHBlYXIuXG4gICAgICAgICAgICB2YXIgaW52ZXJ0T2Zmc2V0ID0gKHRoaXMuZGlyZWN0aW9uID09ICdydGwnICYmICF0aGlzLnZlcnRpY2FsKSA/ICF0aGlzLmludmVydEF4aXMgOiB0aGlzLmludmVydEF4aXM7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKGludmVydE9mZnNldCA/IHRoaXMucGVyY2VudCA6IDEgLSB0aGlzLnBlcmNlbnQpICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVcIiArIGF4aXMgKyBcIigtXCIgKyBvZmZzZXQgKyBcIiUpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIHtcbiAgICAgICAgLyoqIFRoZSBsYW5ndWFnZSBkaXJlY3Rpb24gZm9yIHRoaXMgc2xpZGVyIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09ICdydGwnKSA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25Nb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHNhdmUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNsaWRlciBoZXJlIHNvIHdlIGNhbiB1c2UgdGhlbSB0byB1cGRhdGUgdGhlIHNwYWNpbmcgb2YgdGhlXG4gICAgICAgIC8vIHRpY2tzIGFuZCBkZXRlcm1pbmUgd2hlcmUgb24gdGhlIHNsaWRlciBjbGljayBhbmQgc2xpZGUgZXZlbnRzIGhhcHBlbi5cbiAgICAgICAgdGhpcy5fc2xpZGVyRGltZW5zaW9ucyA9IHRoaXMuX3JlbmRlcmVyLmdldFNsaWRlckRpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGlja0ludGVydmFsUGVyY2VudCgpO1xuICAgIH07XG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkRm9jdXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVGcm9tUG9zaXRpb24oeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pO1xuICAgICAgICAvKiBFbWl0cyBhIGNoYW5nZSBhbmQgaW5wdXQgZXZlbnQgaWYgdGhlIHZhbHVlIGNoYW5nZWQuICovXG4gICAgICAgIHRoaXMuX2VtaXRJbnB1dEV2ZW50KCk7XG4gICAgICAgIHRoaXMuX2VtaXRWYWx1ZUlmQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vblNsaWRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCB0aGUgc2xpZGUgZnJvbSBzZWxlY3RpbmcgYW55dGhpbmcgZWxzZS5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVGcm9tUG9zaXRpb24oeyB4OiBldmVudC5jZW50ZXIueCwgeTogZXZlbnQuY2VudGVyLnkgfSk7XG4gICAgICAgIC8vIE5hdGl2ZSByYW5nZSBlbGVtZW50cyBhbHdheXMgZW1pdCBgaW5wdXRgIGV2ZW50cyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VkIHdoaWxlIHNsaWRpbmcuXG4gICAgICAgIHRoaXMuX2VtaXRJbnB1dEV2ZW50KCk7XG4gICAgfTtcbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uU2xpZGVTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbXVsYXRlIG1vdXNlZW50ZXIgaW4gY2FzZSB0aGlzIGlzIGEgbW9iaWxlIGRldmljZS5cbiAgICAgICAgdGhpcy5fb25Nb3VzZWVudGVyKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkRm9jdXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVGcm9tUG9zaXRpb24oeyB4OiBldmVudC5jZW50ZXIueCwgeTogZXZlbnQuY2VudGVyLnkgfSk7XG4gICAgfTtcbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uU2xpZGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbWl0VmFsdWVJZkNoYW5nZWQoKTtcbiAgICB9O1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgIH07XG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbktleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgUEFHRV9VUDpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQoMTApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQQUdFX0RPV046XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KC0xMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVORDpcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5tYXg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhPTUU6XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubWluO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IEZvciBhIHNpZ2h0ZWQgdXNlciBpdCB3b3VsZCBtYWtlIG1vcmUgc2Vuc2UgdGhhdCB3aGVuIHRoZXkgcHJlc3MgYW4gYXJyb3cga2V5IG9uIGFuXG4gICAgICAgICAgICAgICAgLy8gaW52ZXJ0ZWQgc2xpZGVyIHRoZSB0aHVtYiBtb3ZlcyBpbiB0aGF0IGRpcmVjdGlvbi4gSG93ZXZlciBmb3IgYSBibGluZCB1c2VyLCBub3RoaW5nXG4gICAgICAgICAgICAgICAgLy8gYWJvdXQgdGhlIHNsaWRlciBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBpbnZlcnRlZC4gVGhleSB3aWxsIGV4cGVjdCBsZWZ0IHRvIGJlIGRlY3JlbWVudCxcbiAgICAgICAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIGhvdyBpdCBhcHBlYXJzIG9uIHRoZSBzY3JlZW4uIEZvciBzcGVha2VycyBvZlJUTCBsYW5ndWFnZXMsIHRoZXkgcHJvYmFibHlcbiAgICAgICAgICAgICAgICAvLyBleHBlY3QgbGVmdCB0byBtZWFuIGluY3JlbWVudC4gVGhlcmVmb3JlIHdlIGZsaXAgdGhlIG1lYW5pbmcgb2YgdGhlIHNpZGUgYXJyb3cga2V5cyBmb3JcbiAgICAgICAgICAgICAgICAvLyBSVEwuIEZvciBpbnZlcnRlZCBzbGlkZXJzIHdlIHByZWZlciBhIGdvb2QgYTExeSBleHBlcmllbmNlIHRvIGhhdmluZyBpdCBcImxvb2sgcmlnaHRcIiBmb3JcbiAgICAgICAgICAgICAgICAvLyBzaWdodGVkIHVzZXJzLCB0aGVyZWZvcmUgd2UgZG8gbm90IHN3YXAgdGhlIG1lYW5pbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KHRoaXMuZGlyZWN0aW9uID09ICdydGwnID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICAgICAgICAvLyBTZWUgY29tbWVudCBvbiBMRUZUX0FSUk9XIGFib3V0IHRoZSBjb25kaXRpb25zIHVuZGVyIHdoaWNoIHdlIGZsaXAgdGhlIG1lYW5pbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KHRoaXMuZGlyZWN0aW9uID09ICdydGwnID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZW1lbnQoLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaWYgdGhlIGtleSBpcyBub3Qgb25lIHRoYXQgd2UgZXhwbGljaXRseSBoYW5kbGUgdG8gYXZvaWQgY2FsbGluZyBwcmV2ZW50RGVmYXVsdCBvblxuICAgICAgICAgICAgICAgIC8vIGl0LlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vbktleXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBJbmNyZW1lbnRzIHRoZSBzbGlkZXIgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBzdGVwcyAobmVnYXRpdmUgbnVtYmVyIGRlY3JlbWVudHMpLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5faW5jcmVtZW50ID0gZnVuY3Rpb24gKG51bVN0ZXBzKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9jbGFtcCh0aGlzLnZhbHVlICsgdGhpcy5zdGVwICogbnVtU3RlcHMsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgICAgIHRoaXMuX2VtaXRJbnB1dEV2ZW50KCk7XG4gICAgICAgIHRoaXMuX2VtaXRWYWx1ZUlmQ2hhbmdlZCgpO1xuICAgIH07XG4gICAgLyoqIENhbGN1bGF0ZSB0aGUgbmV3IHZhbHVlIGZyb20gdGhlIG5ldyBwaHlzaWNhbCBsb2NhdGlvbi4gVGhlIHZhbHVlIHdpbGwgYWx3YXlzIGJlIHNuYXBwZWQuICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl91cGRhdGVWYWx1ZUZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zbGlkZXJEaW1lbnNpb25zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudmVydGljYWwgPyB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLnRvcCA6IHRoaXMuX3NsaWRlckRpbWVuc2lvbnMubGVmdDtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnZlcnRpY2FsID8gdGhpcy5fc2xpZGVyRGltZW5zaW9ucy5oZWlnaHQgOiB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB2YXIgcG9zQ29tcG9uZW50ID0gdGhpcy52ZXJ0aWNhbCA/IHBvcy55IDogcG9zLng7XG4gICAgICAgIC8vIFRoZSBleGFjdCB2YWx1ZSBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGV2ZW50IGFuZCB1c2VkIHRvIGZpbmQgdGhlIGNsb3Nlc3Qgc25hcCB2YWx1ZS5cbiAgICAgICAgdmFyIHBlcmNlbnQgPSB0aGlzLl9jbGFtcCgocG9zQ29tcG9uZW50IC0gb2Zmc2V0KSAvIHNpemUpO1xuICAgICAgICBpZiAodGhpcy5pbnZlcnRNb3VzZUNvb3Jkcykge1xuICAgICAgICAgICAgcGVyY2VudCA9IDEgLSBwZXJjZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBleGFjdFZhbHVlID0gdGhpcy5fY2FsY3VsYXRlVmFsdWUocGVyY2VudCk7XG4gICAgICAgIC8vIFRoaXMgY2FsY3VsYXRpb24gZmluZHMgdGhlIGNsb3Nlc3Qgc3RlcCBieSBmaW5kaW5nIHRoZSBjbG9zZXN0IHdob2xlIG51bWJlciBkaXZpc2libGUgYnkgdGhlXG4gICAgICAgIC8vIHN0ZXAgcmVsYXRpdmUgdG8gdGhlIG1pbi5cbiAgICAgICAgdmFyIGNsb3Nlc3RWYWx1ZSA9IE1hdGgucm91bmQoKGV4YWN0VmFsdWUgLSB0aGlzLm1pbikgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwICsgdGhpcy5taW47XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBuZWVkcyB0byBzbmFwIHRvIHRoZSBtaW4gYW5kIG1heC5cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2NsYW1wKGNsb3Nlc3RWYWx1ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICB9O1xuICAgIC8qKiBFbWl0cyBhIGNoYW5nZSBldmVudCBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdCBlbWl0dGVkIHZhbHVlLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fZW1pdFZhbHVlSWZDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPSB0aGlzLl9sYXN0Q2hhbmdlVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xID0gdGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RDaGFuZ2VWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudF8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEVtaXRzIGFuIGlucHV0IGV2ZW50IHdoZW4gdGhlIGN1cnJlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3QgZW1pdHRlZCB2YWx1ZS4gKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2VtaXRJbnB1dEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPSB0aGlzLl9sYXN0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzIgPSB0aGlzLl9jcmVhdGVDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdElucHV0VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5lbWl0KGV2ZW50XzIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gdGlja3MgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSB3aWR0aCBvZiB0aGUgc2xpZGVyLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fdXBkYXRlVGlja0ludGVydmFsUGVyY2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRpY2tJbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpY2tJbnRlcnZhbCA9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHZhciB0cmFja1NpemUgPSB0aGlzLnZlcnRpY2FsID8gdGhpcy5fc2xpZGVyRGltZW5zaW9ucy5oZWlnaHQgOiB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgdmFyIHBpeGVsc1BlclN0ZXAgPSB0cmFja1NpemUgKiB0aGlzLnN0ZXAgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICAgICAgICB2YXIgc3RlcHNQZXJUaWNrID0gTWF0aC5jZWlsKE1JTl9BVVRPX1RJQ0tfU0VQQVJBVElPTiAvIHBpeGVsc1BlclN0ZXApO1xuICAgICAgICAgICAgdmFyIHBpeGVsc1BlclRpY2sgPSBzdGVwc1BlclRpY2sgKiB0aGlzLnN0ZXA7XG4gICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWxQZXJjZW50ID0gcGl4ZWxzUGVyVGljayAvIHRyYWNrU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbFBlcmNlbnQgPSB0aGlzLnRpY2tJbnRlcnZhbCAqIHRoaXMuc3RlcCAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENyZWF0ZXMgYSBzbGlkZXIgY2hhbmdlIG9iamVjdCBmcm9tIHRoZSBzcGVjaWZpZWQgdmFsdWUuICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9jcmVhdGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHRoaXMudmFsdWU7IH1cbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kU2xpZGVyQ2hhbmdlKCk7XG4gICAgICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuICAgIC8qKiBDYWxjdWxhdGVzIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgdGhhdCBhIHZhbHVlIGlzLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlUGVyY2VudGFnZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIH07XG4gICAgLyoqIENhbGN1bGF0ZXMgdGhlIHZhbHVlIGEgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIGNvcnJlc3BvbmRzIHRvLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlVmFsdWUgPSBmdW5jdGlvbiAocGVyY2VudGFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4gKyBwZXJjZW50YWdlICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIH07XG4gICAgLyoqIFJldHVybiBhIG51bWJlciBiZXR3ZWVuIHR3byBudW1iZXJzLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChtaW4gPT09IHZvaWQgMCkgeyBtaW4gPSAwOyB9XG4gICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSAxOyB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vZGVsIHZhbHVlLiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGViIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdG91Y2hlZC5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWRcbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ3RodW1iTGFiZWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwidGh1bWJMYWJlbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgndGh1bWItbGFiZWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RodW1iTGFiZWxEZXByZWNhdGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwic3RlcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcInRpY2tJbnRlcnZhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgndGljay1pbnRlcnZhbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aWNrSW50ZXJ2YWxEZXByZWNhdGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtaW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJpbnZlcnRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJpbnB1dFwiLCB2b2lkIDApO1xuICAgIE1kU2xpZGVyID0gX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXNsaWRlciwgbWF0LXNsaWRlcicsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9TTElERVJfVkFMVUVfQUNDRVNTT1JdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfb25CbHVyKCknLFxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19vbkNsaWNrKCRldmVudCknLFxuICAgICAgICAgICAgICAgICcoa2V5ZG93biknOiAnX29uS2V5ZG93bigkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnKGtleXVwKSc6ICdfb25LZXl1cCgpJyxcbiAgICAgICAgICAgICAgICAnKG1vdXNlZW50ZXIpJzogJ19vbk1vdXNlZW50ZXIoKScsXG4gICAgICAgICAgICAgICAgJyhzbGlkZSknOiAnX29uU2xpZGUoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgJyhzbGlkZWVuZCknOiAnX29uU2xpZGVFbmQoKScsXG4gICAgICAgICAgICAgICAgJyhzbGlkZXN0YXJ0KSc6ICdfb25TbGlkZVN0YXJ0KCRldmVudCknLFxuICAgICAgICAgICAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ21heCcsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtaW5dJzogJ21pbicsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVub3ddJzogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItYWN0aXZlXSc6ICdfaXNBY3RpdmUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1oYXMtdGlja3NdJzogJ3RpY2tJbnRlcnZhbCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLWhvcml6b250YWxdJzogJyF2ZXJ0aWNhbCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWRdJzogJ2ludmVydEF4aXMnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1zbGlkaW5nXSc6ICdfaXNTbGlkaW5nJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZ10nOiAndGh1bWJMYWJlbCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLXZlcnRpY2FsXSc6ICd2ZXJ0aWNhbCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLW1pbi12YWx1ZV0nOiAnX2lzTWluVmFsdWUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1oaWRlLWxhc3QtdGlja10nOiAnX2lzTWluVmFsdWUgJiYgX3RodW1iR2FwICYmIGludmVydEF4aXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItd3JhcHBlclxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10cmFjay13cmFwcGVyXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmRcXFwiIFtuZ1N0eWxlXT1cXFwidHJhY2tCYWNrZ3JvdW5kU3R5bGVzXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRyYWNrLWZpbGxcXFwiIFtuZ1N0eWxlXT1cXFwidHJhY2tGaWxsU3R5bGVzXFxcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRpY2tzLWNvbnRhaW5lclxcXCIgW25nU3R5bGVdPVxcXCJ0aWNrc0NvbnRhaW5lclN0eWxlc1xcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aWNrc1xcXCIgW25nU3R5bGVdPVxcXCJ0aWNrc1N0eWxlc1xcXCI+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aHVtYi1jb250YWluZXJcXFwiIFtuZ1N0eWxlXT1cXFwidGh1bWJDb250YWluZXJTdHlsZXNcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdGh1bWJcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdGh1bWItbGFiZWxcXFwiPjxzcGFuIGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHRcXFwiPnt7ZGlzcGxheVZhbHVlfX08L3NwYW4+PC9kaXY+PC9kaXY+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmQsLm1hdC1zbGlkZXItdHJhY2stZmlsbHt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6OHB4O291dGxpbmU6MDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1hdC1zbGlkZXItd3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZX0ubWF0LXNsaWRlci10cmFjay13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtvdmVyZmxvdzpoaWRkZW59Lm1hdC1zbGlkZXItdHJhY2stZmlsbHtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm0tb3JpZ2luOjAgMH0ubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke3Bvc2l0aW9uOmFic29sdXRlO3RyYW5zZm9ybS1vcmlnaW46MTAwJSAxMDAlfS5tYXQtc2xpZGVyLXRpY2tzLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2xpZGVyLXRpY2tze2JveC1zaXppbmc6Ym9yZGVyLWJveDtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNsaWRlci1kaXNhYmxlZCAubWF0LXNsaWRlci10aWNrc3tvcGFjaXR5OjB9Lm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVye3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdGh1bWJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTEwcHg7Ym90dG9tOi0xMHB4O2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JvcmRlcjozcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czo1MCU7dHJhbnNmb3JtOnNjYWxlKC43KTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm9yZGVyLWNvbG9yIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNsaWRlci10aHVtYi1sYWJlbHtkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MjhweDtoZWlnaHQ6MjhweDtib3JkZXItcmFkaXVzOjUwJTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm9yZGVyLXJhZGl1cyAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdGh1bWItbGFiZWwtdGV4dHt6LWluZGV4OjE7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NzAwO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLXNsaWRpbmcgLm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVyLC5tYXQtc2xpZGVyLXNsaWRpbmcgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZCwubWF0LXNsaWRlci1zbGlkaW5nIC5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7dHJhbnNpdGlvbi1kdXJhdGlvbjowc30ubWF0LXNsaWRlci1oYXMtdGlja3MgLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MCBzb2xpZCByZ2JhKDAsMCwwLC42KTtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNsaWRlci1hY3RpdmUgLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtdGV4dCwubWF0LXNsaWRlci1oYXMtdGlja3MubWF0LXNsaWRlci1hY3RpdmUgLm1hdC1zbGlkZXItdGlja3MsLm1hdC1zbGlkZXItaGFzLXRpY2tzLm1hdC1zbGlkZXItYWN0aXZlOm5vdCgubWF0LXNsaWRlci1oaWRlLWxhc3QtdGljaykgLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXIsLm1hdC1zbGlkZXItaGFzLXRpY2tzOmhvdmVyIC5tYXQtc2xpZGVyLXRpY2tzLC5tYXQtc2xpZGVyLWhhcy10aWNrczpob3Zlcjpub3QoLm1hdC1zbGlkZXItaGlkZS1sYXN0LXRpY2spIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVye29wYWNpdHk6MX0ubWF0LXNsaWRlci10aHVtYi1sYWJlbC1zaG93aW5nIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse2Rpc3BsYXk6ZmxleH0ubWF0LXNsaWRlci1heGlzLWludmVydGVkIC5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7dHJhbnNmb3JtLW9yaWdpbjoxMDAlIDEwMCV9Lm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke3RyYW5zZm9ybS1vcmlnaW46MCAwfS5tYXQtc2xpZGVyLWFjdGl2ZSAubWF0LXNsaWRlci10aHVtYntib3JkZXItd2lkdGg6MnB4O3RyYW5zZm9ybTpzY2FsZSgxKX0ubWF0LXNsaWRlci1hY3RpdmUubWF0LXNsaWRlci10aHVtYi1sYWJlbC1zaG93aW5nIC5tYXQtc2xpZGVyLXRodW1ie3RyYW5zZm9ybTpzY2FsZSgwKX0ubWF0LXNsaWRlci1hY3RpdmUgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7Ym9yZGVyLXJhZGl1czo1MCUgNTAlIDB9Lm1hdC1zbGlkZXItZGlzYWJsZWQgLm1hdC1zbGlkZXItdGh1bWJ7Ym9yZGVyLXdpZHRoOjRweDt0cmFuc2Zvcm06c2NhbGUoLjUpfS5tYXQtc2xpZGVyLWRpc2FibGVkIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse2Rpc3BsYXk6bm9uZX0ubWF0LXNsaWRlci1ob3Jpem9udGFse2hlaWdodDo0OHB4O21pbi13aWR0aDoxMjhweH0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXdyYXBwZXJ7aGVpZ2h0OjJweDt0b3A6MjNweDtsZWZ0OjhweDtyaWdodDo4cHh9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlcntoZWlnaHQ6MnB4O2JvcmRlci1sZWZ0LXdpZHRoOjJweDtyaWdodDowO3RvcDowfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdHJhY2std3JhcHBlcntoZWlnaHQ6MnB4O3dpZHRoOjEwMCV9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10cmFjay1maWxse2hlaWdodDoycHg7d2lkdGg6MTAwJTt0cmFuc2Zvcm06c2NhbGVYKDApfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZHtoZWlnaHQ6MnB4O3dpZHRoOjEwMCU7dHJhbnNmb3JtOnNjYWxlWCgxKX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRpY2tzLWNvbnRhaW5lcntoZWlnaHQ6MnB4O3dpZHRoOjEwMCV9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10aWNrc3tiYWNrZ3JvdW5kOnJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgwLDAsMCwuNikscmdiYSgwLDAsMCwuNikgMnB4LHRyYW5zcGFyZW50IDAsdHJhbnNwYXJlbnQpO2JhY2tncm91bmQ6LW1vei1yZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KC4wMDAxZGVnLHJnYmEoMCwwLDAsLjYpLHJnYmEoMCwwLDAsLjYpIDJweCx0cmFuc3BhcmVudCAwLHRyYW5zcGFyZW50KTtiYWNrZ3JvdW5kLWNsaXA6Y29udGVudC1ib3g7aGVpZ2h0OjJweDt3aWR0aDoxMDAlfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVye3dpZHRoOjEwMCU7aGVpZ2h0OjA7dG9wOjUwJX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse3JpZ2h0Oi0xNHB4O3RvcDotNDBweDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgyNnB4KSBzY2FsZSguMDEpIHJvdGF0ZSg0NWRlZyl9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0e3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0ubWF0LXNsaWRlci1ob3Jpem9udGFsLm1hdC1zbGlkZXItYWN0aXZlIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtc2xpZGVyLXZlcnRpY2Fse3dpZHRoOjQ4cHg7bWluLWhlaWdodDoxMjhweH0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci13cmFwcGVye3dpZHRoOjJweDt0b3A6OHB4O2JvdHRvbTo4cHg7bGVmdDoyM3B4fS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVye3dpZHRoOjJweDtib3JkZXItdG9wLXdpZHRoOjJweDtib3R0b206MDtsZWZ0OjB9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdHJhY2std3JhcHBlcntoZWlnaHQ6MTAwJTt3aWR0aDoycHh9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdHJhY2stZmlsbHtoZWlnaHQ6MTAwJTt3aWR0aDoycHg7dHJhbnNmb3JtOnNjYWxlWSgwKX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke2hlaWdodDoxMDAlO3dpZHRoOjJweDt0cmFuc2Zvcm06c2NhbGVZKDEpfS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRpY2tzLWNvbnRhaW5lcnt3aWR0aDoycHg7aGVpZ2h0OjEwMCV9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdGlja3N7YmFja2dyb3VuZDpyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSxyZ2JhKDAsMCwwLC42KSxyZ2JhKDAsMCwwLC42KSAycHgsdHJhbnNwYXJlbnQgMCx0cmFuc3BhcmVudCk7YmFja2dyb3VuZC1jbGlwOmNvbnRlbnQtYm94O3dpZHRoOjJweDtoZWlnaHQ6MTAwJX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aHVtYi1jb250YWluZXJ7aGVpZ2h0OjEwMCU7d2lkdGg6MDtsZWZ0OjUwJX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtib3R0b206LTE0cHg7bGVmdDotNDBweDt0cmFuc2Zvcm06dHJhbnNsYXRlWCgyNnB4KSBzY2FsZSguMDEpIHJvdGF0ZSgtNDVkZWcpfS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHR7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9Lm1hdC1zbGlkZXItdmVydGljYWwubWF0LXNsaWRlci1hY3RpdmUgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfVtkaXI9cnRsXSAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlcntsZWZ0OjA7cmlnaHQ6YXV0b31bZGlyPXJ0bF0gLm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zZm9ybS1vcmlnaW46MTAwJSAxMDAlfVtkaXI9cnRsXSAubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmQsW2Rpcj1ydGxdIC5tYXQtc2xpZGVyLWhvcml6b250YWwubWF0LXNsaWRlci1heGlzLWludmVydGVkIC5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7dHJhbnNmb3JtLW9yaWdpbjowIDB9W2Rpcj1ydGxdIC5tYXQtc2xpZGVyLWhvcml6b250YWwubWF0LXNsaWRlci1heGlzLWludmVydGVkIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7dHJhbnNmb3JtLW9yaWdpbjoxMDAlIDEwMCV9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ3KDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246cGFyYW10eXBlcycsIFtEaXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRTbGlkZXIpO1xuICAgIHJldHVybiBNZFNsaWRlcjtcbn0oKSk7XG4vKipcbiAqIFJlbmRlcmVyIGNsYXNzIGluIG9yZGVyIHRvIGtlZXAgYWxsIGRvbSBtYW5pcHVsYXRpb24gaW4gb25lIHBsYWNlIGFuZCBvdXRzaWRlIG9mIHRoZSBtYWluIGNsYXNzLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgU2xpZGVyUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsaWRlclJlbmRlcmVyKGVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyRWxlbWVudCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvZiB0aGUgc2xpZGVyIHRyYWNrIGVsZW1lbnQuXG4gICAgICogVGhlIHRyYWNrIGlzIHVzZWQgcmF0aGVyIHRoYW4gdGhlIG5hdGl2ZSBlbGVtZW50IHRvIGlnbm9yZSB0aGUgZXh0cmEgc3BhY2UgdGhhdCB0aGUgdGh1bWIgY2FuXG4gICAgICogdGFrZSB1cC5cbiAgICAgKi9cbiAgICBTbGlkZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2xpZGVyRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXJFbGVtZW50ID0gdGhpcy5fc2xpZGVyRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LXNsaWRlci13cmFwcGVyJyk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIG5hdGl2ZSBlbGVtZW50LlxuICAgICAqIEN1cnJlbnRseSBvbmx5IHVzZWQgdG8gYWxsb3cgYSBibHVyIGV2ZW50IHRvIGZpcmUgYnV0IHdpbGwgYmUgdXNlZCB3aXRoIGtleWJvYXJkIGlucHV0IGxhdGVyLlxuICAgICAqL1xuICAgIFNsaWRlclJlbmRlcmVyLnByb3RvdHlwZS5hZGRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyRWxlbWVudC5mb2N1cygpO1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWRlclJlbmRlcmVyO1xufSgpKTtcbnZhciBNZFNsaWRlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kU2xpZGVyTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRTbGlkZXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFNsaWRlck1vZHVsZSA9IF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBfYW5ndWxhcl9mb3Jtcy5Gb3Jtc01vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRTbGlkZXIsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRTbGlkZXJdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuSEFNTUVSX0dFU1RVUkVfQ09ORklHLCB1c2VDbGFzczogR2VzdHVyZUNvbmZpZyB9XVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRTbGlkZXJNb2R1bGUpO1xuICAgIHJldHVybiBNZFNsaWRlck1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkOSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQzOSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzOSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kOCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gdHdvIE1kU2lkZW5hdiBhcmUgbWF0Y2hpbmcgdGhlIHNhbWUgc2lkZS4gKi9cbnZhciBNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ5KE1kRHVwbGljYXRlZFNpZGVuYXZFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IoYWxpZ24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJBIHNpZGVuYXYgd2FzIGFscmVhZHkgZGVjbGFyZWQgZm9yICdhbGlnbj1cXFwiXCIgKyBhbGlnbiArIFwiXFxcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKiBTaWRlbmF2IHRvZ2dsZSBwcm9taXNlIHJlc3VsdC4gKi9cbnZhciBNZFNpZGVuYXZUb2dnbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2lkZW5hdlRvZ2dsZVJlc3VsdCh0eXBlLCBhbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZpbmlzaGVkID0gYW5pbWF0aW9uRmluaXNoZWQ7XG4gICAgfVxuICAgIHJldHVybiBNZFNpZGVuYXZUb2dnbGVSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiA8bWQtc2lkZW5hdj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBkcmF3ZXIgb2YgdGhlIHNpZGVuYXYuXG4gKlxuICogUGxlYXNlIHJlZmVyIHRvIFJFQURNRS5tZCBmb3IgZXhhbXBsZXMgb24gaG93IHRvIHVzZSBpdC5cbiAqL1xudmFyIE1kU2lkZW5hdiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIF9lbGVtZW50UmVmIFRoZSBET00gZWxlbWVudCByZWZlcmVuY2UuIFVzZWQgZm9yIHRyYW5zaXRpb24gYW5kIHdpZHRoIGNhbGN1bGF0aW9uLlxuICAgICAqICAgICBJZiBub3QgYXZhaWxhYmxlIHdlIGRvIG5vdCBob29rIG9uIHRyYW5zaXRpb25zLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1kU2lkZW5hdihfZWxlbWVudFJlZiwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKiBBbGlnbm1lbnQgb2YgdGhlIHNpZGVuYXYgKGRpcmVjdGlvbiBuZXV0cmFsKTsgd2hldGhlciAnc3RhcnQnIG9yICdlbmQnLiAqL1xuICAgICAgICB0aGlzLl9hbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIHRoaXMuX3ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgLyoqIE1vZGUgb2YgdGhlIHNpZGVuYXY7IHdoZXRoZXIgJ292ZXInIG9yICdzaWRlJy4gKi9cbiAgICAgICAgdGhpcy5tb2RlID0gJ292ZXInO1xuICAgICAgICB0aGlzLl9kaXNhYmxlQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHNpZGVuYXYgaXMgb3BlbmVkLiAqL1xuICAgICAgICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBiZWluZyBvcGVuZWQuIFVzZSB0aGlzIHRvIHN5bmNocm9uaXplIGFuaW1hdGlvbnMuICovXG4gICAgICAgIHRoaXMub25PcGVuU3RhcnQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBmdWxseSBvcGVuZWQuICovXG4gICAgICAgIHRoaXMub25PcGVuID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgYmVpbmcgY2xvc2VkLiBVc2UgdGhpcyB0byBzeW5jaHJvbml6ZSBhbmltYXRpb25zLiAqL1xuICAgICAgICB0aGlzLm9uQ2xvc2VTdGFydCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGlzIGZ1bGx5IGNsb3NlZC4gKi9cbiAgICAgICAgdGhpcy5vbkNsb3NlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgYWxpZ25tZW50IGNoYW5nZXMuICovXG4gICAgICAgIHRoaXMub25BbGlnbkNoYW5nZWQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50IHRvZ2dsZSBhbmltYXRpb24gcHJvbWlzZS4gYG51bGxgIGlmIG5vIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy4gKi9cbiAgICAgICAgdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCB0b2dnbGUgYW5pbWF0aW9uIHByb21pc2UgcmVzb2x1dGlvbiBmdW5jdGlvbi5cbiAgICAgICAgICogYG51bGxgIGlmIG5vIGFuaW1hdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbk9wZW4uc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZVNpZGVuYXZXYXNPcGVuZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0ZvY3VzVHJhcERpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2ZvY3VzVHJhcC5mb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50V2hlblJlYWR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uQ2xvc2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZChfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkLCAnZm9jdXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKF90aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdibHVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyBtZC1zaWRlbmF2IGlzIHBhcnQgb2YgYSB2YWxpZCBtZC1zaWRlbmF2LWNvbnRhaW5lciBjb25maWd1cmF0aW9uLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbGlkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgZHJhd2VycyBhcmUgbm90IGluIGEgdmFsaWQgY29uZmlndXJhdGlvbiB3ZSBjbG9zZSB0aGVtIGFsbCB1bnRpbCB0aGV5IGFyZSBpbiBhIHZhbGlkXG4gICAgICAgICAgICAvLyBjb25maWd1cmF0aW9uIGFnYWluLlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcImFsaWduXCIsIHtcbiAgICAgICAgLyoqIERpcmVjdGlvbiB3aGljaCB0aGUgc2lkZW5hdiBpcyBhbGlnbmVkIGluLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FsaWduOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSB2YWxpZCB2YWx1ZS5cbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID09ICdlbmQnKSA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSB0aGlzLl9hbGlnbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFsaWduQ2hhbmdlZC5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcImRpc2FibGVDbG9zZVwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGNhbiBiZSBjbG9zZWQgd2l0aCB0aGUgZXNjYXBlIGtleSBvciBub3QuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZUNsb3NlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlQ2xvc2UgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJpc0ZvY3VzVHJhcERpc2FibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGUgZm9jdXMgdHJhcCBpcyBvbmx5IGVuYWJsZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBvcGVuIGluIGFueSBtb2RlIG90aGVyIHRoYW4gc2lkZS5cbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5vcGVuZWQgfHwgdGhpcy5tb2RlID09ICdzaWRlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSBzaWRlbmF2IGlzIHNldCB0byBvcGVuZWQgaW4gdGhlIHRlbXBsYXRlIGFuZCB0aGUgdHJhbnNpdGlvblxuICAgICAgICAvLyBpc24ndCBlbmRlZC5cbiAgICAgICAgaWYgKHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib3BlbmVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNpZGVuYXYgaXMgb3BlbmVkLiBXZSBvdmVybG9hZCB0aGlzIGJlY2F1c2Ugd2UgdHJpZ2dlciBhbiBldmVudCB3aGVuIGl0XG4gICAgICAgICAqIHN0YXJ0cyBvciBlbmQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29wZW5lZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoY29lcmNlQm9vbGVhblByb3BlcnR5KHYpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIE9wZW4gdGhpcyBzaWRlbmF2LCBhbmQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGl0J3MgZnVsbHkgb3BlbmVkIChvciBnZXRcbiAgICAgKiByZWplY3RlZCBpZiBpdCBkaWRuJ3QpLiAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhpcyBzaWRlbmF2LCBhbmQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGl0J3MgZnVsbHkgY2xvc2VkIChvciBnZXRcbiAgICAgKiByZWplY3RlZCBpZiBpdCBkaWRuJ3QpLlxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhpcyBzaWRlbmF2LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBvcGVuKCkgd2hlbiBpdCdzIGFscmVhZHkgb3BlbmVkLCBvclxuICAgICAqIGNsb3NlKCkgd2hlbiBpdCdzIGNsb3NlZC5cbiAgICAgKiBAcGFyYW0gaXNPcGVuIFdoZXRoZXIgdGhlIHNpZGVuYXYgc2hvdWxkIGJlIG9wZW4uXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHdoZXRoZXIgdGhlIHNpZGVuYXYgd2FzIG9wZW5lZCBvciBjbG9zZWQuXG4gICAgICovXG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoaXNPcGVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc09wZW4gPT09IHZvaWQgMCkgeyBpc09wZW4gPSAhdGhpcy5vcGVuZWQ7IH1cbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBNZFNpZGVuYXZUb2dnbGVSZXN1bHQoaXNPcGVuID8gJ29wZW4nIDogJ2Nsb3NlJywgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3J0Y3V0IGl0IGlmIHdlJ3JlIGFscmVhZHkgb3BlbmVkLlxuICAgICAgICBpZiAoaXNPcGVuID09PSB0aGlzLm9wZW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgfHxcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobmV3IE1kU2lkZW5hdlRvZ2dsZVJlc3VsdChpc09wZW4gPyAnb3BlbicgOiAnY2xvc2UnLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbmVkID0gaXNPcGVuO1xuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3BlblN0YXJ0LmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZVN0YXJ0LmVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVRvZ2dsZUFuaW1hdGlvblByb21pc2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlID0gZnVuY3Rpb24gKGFuaW1hdGlvbkZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobmV3IE1kU2lkZW5hdlRvZ2dsZVJlc3VsdChpc09wZW4gPyAnb3BlbicgOiAnY2xvc2UnLCBhbmltYXRpb25GaW5pc2hlZCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUga2V5Ym9hcmQgZXZlbnRzLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLmhhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiAhdGhpcy5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRyYW5zaXRpb24gaGFzIGZpbmlzaGVkLCBzZXQgdGhlIGludGVybmFsIHN0YXRlIGZvciBjbGFzc2VzIGFuZCBlbWl0IHRoZSBwcm9wZXIgZXZlbnQuXG4gICAgICogVGhlIGV2ZW50IHBhc3NlZCBpcyBhY3R1YWxseSBvZiB0eXBlIFRyYW5zaXRpb25FdmVudCwgYnV0IHRoYXQgdHlwZSBpcyBub3QgYXZhaWxhYmxlIGluXG4gICAgICogQW5kcm9pZCBzbyB3ZSB1c2UgYW55LlxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUuX29uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25FdmVudC50YXJnZXQgPT0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50XG4gICAgICAgICAgICAmJiB0cmFuc2l0aW9uRXZlbnQucHJvcGVydHlOYW1lLmVuZHNXaXRoKCd0cmFuc2Zvcm0nKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc0Nsb3NpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fb3BlbmVkICYmICEhdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzT3BlbmluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5lZCAmJiAhIXRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc0Nsb3NlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9vcGVuZWQgJiYgIXRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc09wZW5lZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5lZCAmJiAhdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzRW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbiA9PSAnZW5kJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVTaWRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdzaWRlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVPdmVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdvdmVyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVQdXNoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdwdXNoJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX3dpZHRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoRm9jdXNUcmFwKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzkoJ2Rlc2lnbjp0eXBlJywgRm9jdXNUcmFwKVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2ZvY3VzVHJhcFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcImFsaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiZGlzYWJsZUNsb3NlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgnb3Blbi1zdGFydCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJvbk9wZW5TdGFydFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgnb3BlbicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJvbk9wZW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ2Nsb3NlLXN0YXJ0JyksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIm9uQ2xvc2VTdGFydFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgnY2xvc2UnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib25DbG9zZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgnYWxpZ24tY2hhbmdlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJvbkFsaWduQ2hhbmdlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJvcGVuZWRcIiwgbnVsbCk7XG4gICAgTWRTaWRlbmF2ID0gX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXNpZGVuYXYsIG1hdC1zaWRlbmF2JyxcbiAgICAgICAgICAgIC8vIFRPRE8obW1hbGVyYmEpOiBtb3ZlIHRlbXBsYXRlIHRvIHNlcGFyYXRlIGZpbGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8Y2RrLWZvY3VzLXRyYXAgY2xhc3M9XFxcIm1hdC1zaWRlbmF2LWZvY3VzLXRyYXBcXFwiIFtkaXNhYmxlZF09XFxcImlzRm9jdXNUcmFwRGlzYWJsZWRcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Nkay1mb2N1cy10cmFwPlwiLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXZdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICcodHJhbnNpdGlvbmVuZCknOiAnX29uVHJhbnNpdGlvbkVuZCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgLy8gbXVzdCBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYWxpZ25pbmcgdGV4dCBiYXNlZCBvbiB2YWx1ZVxuICAgICAgICAgICAgICAgICdbYXR0ci5hbGlnbl0nOiAnbnVsbCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1jbG9zZWRdJzogJ19pc0Nsb3NlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1jbG9zaW5nXSc6ICdfaXNDbG9zaW5nJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LWVuZF0nOiAnX2lzRW5kJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LW9wZW5lZF0nOiAnX2lzT3BlbmVkJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LW9wZW5pbmddJzogJ19pc09wZW5pbmcnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtb3Zlcl0nOiAnX21vZGVPdmVyJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LXB1c2hdJzogJ19tb2RlUHVzaCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1zaWRlXSc6ICdfbW9kZVNpZGUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtaW52YWxpZF0nOiAnIXZhbGlkJyxcbiAgICAgICAgICAgICAgICAndGFiSW5kZXgnOiAnLTEnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kU2lkZW5hdik7XG4gICAgcmV0dXJuIE1kU2lkZW5hdjtcbn0oKSk7XG4vKipcbiAqIDxtZC1zaWRlbmF2LWNvbnRhaW5lcj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gb25lIG9yIHR3byA8bWQtc2lkZW5hdj5zIHRoYXQgdmFsaWRhdGVzIHRoZSBzdGF0ZSBpbnRlcm5hbGx5XG4gKiBhbmQgY29vcmRpbmF0ZXMgdGhlIGJhY2tkcm9wIGFuZCBjb250ZW50IHN0eWxpbmcuXG4gKi9cbnZhciBNZFNpZGVuYXZDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2lkZW5hdkNvbnRhaW5lcihfZGlyLCBfZWxlbWVudCwgX3JlbmRlcmVyLCBfbmdab25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgICAgICAgdGhpcy5iYWNrZHJvcENsaWNrID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRvIGVuYWJsZSBvcGVuL2Nsb3NlIHRyYW50aW9ucy4gKi9cbiAgICAgICAgdGhpcy5fZW5hYmxlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgLy8gSWYgYSBgRGlyYCBkaXJlY3RpdmUgZXhpc3RzIHVwIHRoZSB0cmVlLCBsaXN0ZW4gZGlyZWN0aW9uIGNoYW5nZXMgYW5kIHVwZGF0ZSB0aGUgbGVmdC9yaWdodFxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRvIHBvaW50IHRvIHRoZSBwcm9wZXIgc3RhcnQvZW5kLlxuICAgICAgICBpZiAoX2RpciAhPSBudWxsKSB7XG4gICAgICAgICAgICBfZGlyLmRpckNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZhbGlkYXRlRHJhd2VycygpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZSwgXCJzdGFydFwiLCB7XG4gICAgICAgIC8qKiBUaGUgc2lkZW5hdiBjaGlsZCB3aXRoIHRoZSBgc3RhcnRgIGFsaWdubWVudC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUsIFwiZW5kXCIsIHtcbiAgICAgICAgLyoqIFRoZSBzaWRlbmF2IGNoaWxkIHdpdGggdGhlIGBlbmRgIGFsaWdubWVudC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbmQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBPbiBjaGFuZ2VzLCBhc3NlcnQgb24gY29uc2lzdGVuY3kuXG4gICAgICAgIHRoaXMuX3NpZGVuYXZzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZURyYXdlcnMoKTsgfSk7XG4gICAgICAgIHRoaXMuX3NpZGVuYXZzLmZvckVhY2goZnVuY3Rpb24gKHNpZGVuYXYpIHtcbiAgICAgICAgICAgIF90aGlzLl93YXRjaFNpZGVuYXZUb2dnbGUoc2lkZW5hdik7XG4gICAgICAgICAgICBfdGhpcy5fd2F0Y2hTaWRlbmF2QWxpZ24oc2lkZW5hdik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZURyYXdlcnMoKTtcbiAgICAgICAgLy8gR2l2ZSB0aGUgdmlldyBhIGNoYW5jZSB0byByZW5kZXIgdGhlIGluaXRpYWwgc3RhdGUsIHRoZW4gZW5hYmxlIHRyYW5zaXRpb25zLlxuICAgICAgICB0aGlzLl9uZ1pvbmUub25NaWNyb3Rhc2tFbXB0eS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZW5hYmxlVHJhbnNpdGlvbnMgPSB0cnVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gc2lkZW5hdiBldmVudHMgaW4gb3JkZXIgdG8gc2V0IGEgY2xhc3Mgb24gdGhlIG1haW4gY29udGFpbmVyIGVsZW1lbnQgd2hlbiB0aGVcbiAgICAgKiBzaWRlbmF2IGlzIG9wZW4gYW5kIHRoZSBiYWNrZHJvcCBpcyB2aXNpYmxlLiBUaGlzIGVuc3VyZXMgYW55IG92ZXJmbG93IG9uIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgICAqIGlzIHByb3Blcmx5IGhpZGRlbi5cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl93YXRjaFNpZGVuYXZUb2dnbGUgPSBmdW5jdGlvbiAoc2lkZW5hdikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXNpZGVuYXYgfHwgc2lkZW5hdi5tb2RlID09PSAnc2lkZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaWRlbmF2Lm9uT3Blbi5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldENvbnRhaW5lckNsYXNzKHNpZGVuYXYsIHRydWUpOyB9KTtcbiAgICAgICAgc2lkZW5hdi5vbkNsb3NlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2V0Q29udGFpbmVyQ2xhc3Moc2lkZW5hdiwgZmFsc2UpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gc2lkZW5hdiBvbkFsaWduQ2hhbmdlZCBldmVudCBpbiBvcmRlciB0byByZS12YWxpZGF0ZSBkcmF3ZXJzIHdoZW4gdGhlIGFsaWduXG4gICAgICogY2hhbmdlcy5cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl93YXRjaFNpZGVuYXZBbGlnbiA9IGZ1bmN0aW9uIChzaWRlbmF2KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghc2lkZW5hdikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNpZGVuYXYub25BbGlnbkNoYW5nZWQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZURyYXdlcnMoKTsgfSk7XG4gICAgfTtcbiAgICAvKiogVG9nZ2xlcyB0aGUgJ21hdC1zaWRlbmF2LW9wZW5lZCcgY2xhc3Mgb24gdGhlIG1haW4gJ21kLXNpZGVuYXYtY29udGFpbmVyJyBlbGVtZW50LiAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX3NldENvbnRhaW5lckNsYXNzID0gZnVuY3Rpb24gKHNpZGVuYXYsIGJvb2wpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21hdC1zaWRlbmF2LW9wZW5lZCcsIGJvb2wpO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIHZhbGlkIHN0YXRlIG9mIHRoZSBkcmF3ZXJzLiAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX3NldERyYXdlcnNWYWxpZCA9IGZ1bmN0aW9uICh2YWxpZCkge1xuICAgICAgICB0aGlzLl9zaWRlbmF2cy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlbmF2KSB7XG4gICAgICAgICAgICBzaWRlbmF2LnZhbGlkID0gdmFsaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2VuZCA9IHRoaXMuX2xlZnQgPSB0aGlzLl9yaWdodCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBWYWxpZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHNpZGVuYXYgY2hpbGRyZW4gY29tcG9uZW50cy4gKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl92YWxpZGF0ZURyYXdlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fZW5kID0gbnVsbDtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhdCBtb3N0IG9uZSBzdGFydCBhbmQgb25lIGVuZCBzaWRlbmF2LlxuICAgICAgICAvLyBOT1RFOiBXZSBtdXN0IGNhbGwgdG9BcnJheSBvbiBfc2lkZW5hdnMgZXZlbiB0aG91Z2ggaXQncyBpdGVyYWJsZVxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzE2NCkuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9zaWRlbmF2cy50b0FycmF5KCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2lkZW5hdiA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChzaWRlbmF2LmFsaWduID09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldERyYXdlcnNWYWxpZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kID0gc2lkZW5hdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldERyYXdlcnNWYWxpZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBzaWRlbmF2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gdGhpcy5fbGVmdCA9IG51bGw7XG4gICAgICAgIC8vIERldGVjdCBpZiB3ZSdyZSBMVFIgb3IgUlRMLlxuICAgICAgICBpZiAodGhpcy5fZGlyID09IG51bGwgfHwgdGhpcy5fZGlyLnZhbHVlID09ICdsdHInKSB7XG4gICAgICAgICAgICB0aGlzLl9sZWZ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX2VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSB0aGlzLl9lbmQ7XG4gICAgICAgICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldERyYXdlcnNWYWxpZCh0cnVlKTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX29uQmFja2Ryb3BDbGlja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJhY2tkcm9wQ2xpY2suZW1pdCgpO1xuICAgICAgICB0aGlzLl9jbG9zZU1vZGFsU2lkZW5hdigpO1xuICAgIH07XG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fY2xvc2VNb2RhbFNpZGVuYXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENsb3NlIGFsbCBvcGVuIHNpZGVuYXYncyB3aGVyZSBjbG9zaW5nIGlzIG5vdCBkaXNhYmxlZCBhbmQgdGhlIG1vZGUgaXMgbm90IGBzaWRlYC5cbiAgICAgICAgW3RoaXMuX3N0YXJ0LCB0aGlzLl9lbmRdXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzaWRlbmF2KSB7IHJldHVybiBzaWRlbmF2ICYmICFzaWRlbmF2LmRpc2FibGVDbG9zZSAmJiBzaWRlbmF2Lm1vZGUgIT09ICdzaWRlJzsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlbmF2KSB7IHJldHVybiBzaWRlbmF2LmNsb3NlKCk7IH0pO1xuICAgIH07XG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5faXNTaG93aW5nQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faXNTaWRlbmF2T3Blbih0aGlzLl9zdGFydCkgJiYgdGhpcy5fc3RhcnQubW9kZSAhPSAnc2lkZScpXG4gICAgICAgICAgICB8fCAodGhpcy5faXNTaWRlbmF2T3Blbih0aGlzLl9lbmQpICYmIHRoaXMuX2VuZC5tb2RlICE9ICdzaWRlJyk7XG4gICAgfTtcbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9pc1NpZGVuYXZPcGVuID0gZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHNpZGUgIT0gbnVsbCAmJiBzaWRlLm9wZW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgd2lkdGggb2YgdGhlIHNpZGVuYXYsIGlmIGl0J3MgaW4gdGhlIHByb3BlciBtb2RlIGFuZCBvcGVuZWQuXG4gICAgICogVGhpcyBtYXkgcmVsYXlvdXQgdGhlIHZpZXcsIHNvIGRvIG5vdCBjYWxsIHRoaXMgb2Z0ZW4uXG4gICAgICogQHBhcmFtIHNpZGVuYXZcbiAgICAgKiBAcGFyYW0gbW9kZVxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCA9IGZ1bmN0aW9uIChzaWRlbmF2LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faXNTaWRlbmF2T3BlbihzaWRlbmF2KSAmJiBzaWRlbmF2Lm1vZGUgPT0gbW9kZSkgPyBzaWRlbmF2Ll93aWR0aCA6IDA7XG4gICAgfTtcbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRNYXJnaW5MZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZW5hdkVmZmVjdGl2ZVdpZHRoKHRoaXMuX2xlZnQsICdzaWRlJyk7XG4gICAgfTtcbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRNYXJnaW5SaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCh0aGlzLl9yaWdodCwgJ3NpZGUnKTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldFBvc2l0aW9uTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCh0aGlzLl9sZWZ0LCAncHVzaCcpO1xuICAgIH07XG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0UG9zaXRpb25SaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCh0aGlzLl9yaWdodCwgJ3B1c2gnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhvcml6b250YWwgb2Zmc2V0IGZvciB0aGUgY29udGVudCBhcmVhLiAgVGhlcmUgc2hvdWxkIG5ldmVyIGJlIGEgdmFsdWUgZm9yIGJvdGhcbiAgICAgKiBsZWZ0IGFuZCByaWdodCwgc28gYnkgc3VidHJhY3RpbmcgdGhlIHJpZ2h0IHZhbHVlIGZyb20gdGhlIGxlZnQgdmFsdWUsIHdlIHNob3VsZCBhbHdheXMgZ2V0XG4gICAgICogdGhlIGFwcHJvcHJpYXRlIG9mZnNldC5cbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRQb3NpdGlvbk9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFBvc2l0aW9uTGVmdCgpIC0gdGhpcy5fZ2V0UG9zaXRpb25SaWdodCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB1c2luZyBbbmdTdHlsZV0gcmF0aGVyIHRoYW4gc2VwYXJhdGUgW3N0eWxlLi4uXSBwcm9wZXJ0aWVzIGJlY2F1c2UgW3N0eWxlLnRyYW5zZm9ybV1cbiAgICAgKiBkb2Vzbid0IHNlZW0gdG8gd29yayByaWdodCBub3cuXG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogdGhpcy5fZ2V0TWFyZ2luTGVmdCgpICsgXCJweFwiLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IHRoaXMuX2dldE1hcmdpblJpZ2h0KCkgKyBcInB4XCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoXCIgKyB0aGlzLl9nZXRQb3NpdGlvbk9mZnNldCgpICsgXCJweCwgMCwgMClcIlxuICAgICAgICB9O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kU2lkZW5hdiksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUsIFwiX3NpZGVuYXZzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLCBcImJhY2tkcm9wQ2xpY2tcIiwgdm9pZCAwKTtcbiAgICBNZFNpZGVuYXZDb250YWluZXIgPSBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtc2lkZW5hdi1jb250YWluZXIsIG1hdC1zaWRlbmF2LWNvbnRhaW5lcicsXG4gICAgICAgICAgICAvLyBEbyBub3QgdXNlIENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaC4gSXQgZG9lcyBub3Qgd29yayBmb3IgdGhpcyBjb21wb25lbnQgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGVjaG5pY2FsbHkgaXQgaXMgYSBzaWJsaW5nIG9mIE1kU2lkZW5hdiAob24gdGhlIGNvbnRlbnQgdHJlZSkgYW5kIGlzbid0IHVwZGF0ZWQgd2hlbiBNZFNpZGVuYXZcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgaXRzIHN0YXRlLlxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXNpZGVuYXYtYmFja2Ryb3BcXFwiIChjbGljayk9XFxcIl9vbkJhY2tkcm9wQ2xpY2tlZCgpXFxcIiBbY2xhc3MubWF0LXNpZGVuYXYtc2hvd25dPVxcXCJfaXNTaG93aW5nQmFja2Ryb3AoKVxcXCI+PC9kaXY+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1zaWRlbmF2LCBtYXQtc2lkZW5hdlxcXCI+PC9uZy1jb250ZW50PjxkaXYgY2xhc3M9XFxcIm1hdC1zaWRlbmF2LWNvbnRlbnRcXFwiIFtuZ1N0eWxlXT1cXFwiX2dldFN0eWxlcygpXFxcIiBjZGstc2Nyb2xsYWJsZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtc2lkZW5hdi1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7ZGlzcGxheTpibG9jaztvdmVyZmxvdzpoaWRkZW59Lm1hdC1zaWRlbmF2LWJhY2tkcm9wLC5tYXQtc2lkZW5hdi1jb250YWluZXJbZnVsbHNjcmVlbl17cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Ym90dG9tOjA7cmlnaHQ6MDtsZWZ0OjB9Lm1hdC1zaWRlbmF2LWNvbnRhaW5lcltmdWxsc2NyZWVuXS5tYXQtc2lkZW5hdi1vcGVuZWR7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2lkZW5hdi1iYWNrZHJvcHtkaXNwbGF5OmJsb2NrO3otaW5kZXg6Mjt2aXNpYmlsaXR5OmhpZGRlbn0ubWF0LXNpZGVuYXYtYmFja2Ryb3AubWF0LXNpZGVuYXYtc2hvd257dmlzaWJpbGl0eTp2aXNpYmxlfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1jbG9zZWQsLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWVuZC5tYXQtc2lkZW5hdi1jbG9zZWQsW2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1jbG9zZWQsW2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtY2xvc2Vke3Zpc2liaWxpdHk6aGlkZGVufUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtc2lkZW5hdi1iYWNrZHJvcHtvcGFjaXR5Oi41fX0ubWF0LXNpZGVuYXYtY29udGVudHtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMCU7b3ZlcmZsb3c6YXV0b30ubWF0LXNpZGVuYXZ7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDt6LWluZGV4OjM7bWluLXdpZHRoOjUlO291dGxpbmU6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTEwMCUsMCwwKX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtb3BlbmVkLC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuaW5ne3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCl9Lm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LXNpZGV7ei1pbmRleDoxfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmR7cmlnaHQ6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTAwJSwwLDApfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtb3BlbmVkLC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtb3BlbmluZ3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfVtkaXI9cnRsXSAubWF0LXNpZGVuYXZ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwMCUsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5lZCxbZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5pbmd7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWVuZHtsZWZ0OjA7cmlnaHQ6YXV0bzt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTEwMCUsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LWVuZC5tYXQtc2lkZW5hdi1vcGVuZWQsW2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtb3BlbmluZ3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuZWQ6bm90KC5tYXQtc2lkZW5hdi1zaWRlKSwubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtb3BlbmluZzpub3QoLm1hdC1zaWRlbmF2LXNpZGUpe2JveC1zaGFkb3c6MCA4cHggMTBweCAtNXB4IHJnYmEoMCwwLDAsLjIpLDAgMTZweCAyNHB4IDJweCByZ2JhKDAsMCwwLC4xNCksMCA2cHggMzBweCA1cHggcmdiYSgwLDAsMCwuMTIpfS5tYXQtc2lkZW5hdi1mb2N1cy10cmFwe2hlaWdodDoxMDAlfS5tYXQtc2lkZW5hdi1mb2N1cy10cmFwPi5jZGstZm9jdXMtdHJhcC1jb250ZW50e2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6MTAwJTtvdmVyZmxvdy15OmF1dG87dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9Lm1hdC1zaWRlbmF2LWludmFsaWR7ZGlzcGxheTpub25lfVwiLFxuXCIubWF0LXNpZGVuYXYtdHJhbnNpdGlvbiAubWF0LXNpZGVuYXZ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2lkZW5hdi10cmFuc2l0aW9uIC5tYXQtc2lkZW5hdi1jb250ZW50e3RyYW5zaXRpb24tZHVyYXRpb246LjRzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjUsLjgsLjI1LDEpO3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtLG1hcmdpbi1sZWZ0LG1hcmdpbi1yaWdodH0ubWF0LXNpZGVuYXYtdHJhbnNpdGlvbiAubWF0LXNpZGVuYXYtYmFja2Ryb3AubWF0LXNpZGVuYXYtc2hvd257dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX1cIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1jb250YWluZXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtdHJhbnNpdGlvbl0nOiAnX2VuYWJsZVRyYW5zaXRpb25zJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDgoMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0RpciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBfYW5ndWxhcl9jb3JlLk5nWm9uZV0pXG4gICAgXSwgTWRTaWRlbmF2Q29udGFpbmVyKTtcbiAgICByZXR1cm4gTWRTaWRlbmF2Q29udGFpbmVyO1xufSgpKTtcbnZhciBNZFNpZGVuYXZNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2lkZW5hdk1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRTaWRlbmF2TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRTaWRlbmF2TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRTaWRlbmF2TW9kdWxlID0gX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGUsIEExMXlNb2R1bGUsIE92ZXJsYXlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kU2lkZW5hdkNvbnRhaW5lciwgTWRTaWRlbmF2LCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2lkZW5hdkNvbnRhaW5lciwgTWRTaWRlbmF2XSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2lkZW5hdk1vZHVsZSk7XG4gICAgcmV0dXJuIE1kU2lkZW5hdk1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDQwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRMaXN0RGl2aWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0RGl2aWRlcigpIHtcbiAgICB9XG4gICAgTWRMaXN0RGl2aWRlciA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWRpdmlkZXIsIG1hdC1kaXZpZGVyJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaXN0RGl2aWRlcik7XG4gICAgcmV0dXJuIE1kTGlzdERpdmlkZXI7XG59KCkpO1xudmFyIE1kTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0KCkge1xuICAgIH1cbiAgICBNZExpc3QgPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtbGlzdCwgbWF0LWxpc3QsIG1kLW5hdi1saXN0LCBtYXQtbmF2LWxpc3QnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3QnIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWxpc3QsLm1hdC1uYXYtbGlzdHtwYWRkaW5nLXRvcDo4cHg7ZGlzcGxheTpibG9ja30ubWF0LWxpc3QgLm1hdC1zdWJoZWFkZXIsLm1hdC1uYXYtbGlzdCAubWF0LXN1YmhlYWRlcntkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtoZWlnaHQ6NDhweDtwYWRkaW5nOjE2cHg7bWFyZ2luOjA7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NTAwfS5tYXQtbGlzdCAubWF0LXN1YmhlYWRlcjpmaXJzdC1jaGlsZCwubWF0LW5hdi1saXN0IC5tYXQtc3ViaGVhZGVyOmZpcnN0LWNoaWxke21hcmdpbi10b3A6LThweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0sLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbXtkaXNwbGF5OmJsb2NrfS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tY29udGVudHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO2JveC1zaXppbmc6Ym9yZGVyLWJveDtmb250LXNpemU6MTZweDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTZweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LWxpc3QtaXRlbS1hdmF0YXIgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC1saXN0LWl0ZW0tYXZhdGFyIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjU2cHh9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0yLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0yLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6NzJweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LTMtbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LTMtbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo4OHB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtbXVsdGktbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LW11bHRpLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6MTAwJTtwYWRkaW5nOjhweCAxNnB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCAxNnB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dD4qLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ+KnttYXJnaW46MDtwYWRkaW5nOjA7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZTppbmhlcml0fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eSwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ6Zmlyc3QtY2hpbGQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDpmaXJzdC1jaGlsZHtwYWRkaW5nOjB9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1hdmF0YXIsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtYXZhdGFye2ZsZXgtc2hyaW5rOjA7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtib3JkZXItcmFkaXVzOjUwJX0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWljb24sLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaWNvbnt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2JvcmRlci1yYWRpdXM6NTAlO3BhZGRpbmc6NHB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmUsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93LXg6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGluZTpudGgtY2hpbGQobisyKSwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGluZTpudGgtY2hpbGQobisyKXtmb250LXNpemU6MTRweH0ubWF0LWxpc3RbZGVuc2VdLC5tYXQtbmF2LWxpc3RbZGVuc2Vde3BhZGRpbmctdG9wOjRweDtkaXNwbGF5OmJsb2NrfS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1zdWJoZWFkZXIsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1zdWJoZWFkZXJ7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjQwcHg7cGFkZGluZzoxNnB4O21hcmdpbjowO2ZvbnQtc2l6ZToxM3B4O2ZvbnQtd2VpZ2h0OjUwMH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtc3ViaGVhZGVyOmZpcnN0LWNoaWxkLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtc3ViaGVhZGVyOmZpcnN0LWNoaWxke21hcmdpbi10b3A6LTRweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVte2Rpc3BsYXk6YmxvY2t9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdzthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtib3gtc2l6aW5nOmJvcmRlci1ib3g7Zm9udC1zaXplOjEzcHg7aGVpZ2h0OjQwcHg7cGFkZGluZzowIDE2cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtbGlzdC1pdGVtLWF2YXRhciAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC1saXN0LWl0ZW0tYXZhdGFyIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjQ4cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtMi1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LTItbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo2MHB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LTMtbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6NzZweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC1tdWx0aS1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LW11bHRpLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6MTAwJTtwYWRkaW5nOjhweCAxNnB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowIDE2cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dD4qLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0Pip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmVtcHR5LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmZpcnN0LWNoaWxkLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmZpcnN0LWNoaWxke3BhZGRpbmc6MH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1hdmF0YXIsLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWF2YXRhcntmbGV4LXNocmluazowO3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaWNvbiwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaWNvbnt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2JvcmRlci1yYWRpdXM6NTAlO3BhZGRpbmc6NHB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5lLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGluZXt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3cteDpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpcztkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGluZTpudGgtY2hpbGQobisyKSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMil7Zm9udC1zaXplOjEzcHh9Lm1hdC1kaXZpZGVye2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItdG9wLXdpZHRoOjFweDttYXJnaW46MH0ubWF0LW5hdi1saXN0IGF7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6aW5oZXJpdH0ubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7Y3Vyc29yOnBvaW50ZXJ9Lm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS1jb250ZW50Lm1hdC1saXN0LWl0ZW0tZm9jdXMsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS1jb250ZW50OmhvdmVye291dGxpbmU6MH1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGlzdCk7XG4gICAgcmV0dXJuIE1kTGlzdDtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRMaXN0Q3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3RDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kTGlzdENzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWxpc3QsIG1hdC1saXN0JyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1saXN0XSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaXN0Q3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRMaXN0Q3NzTWF0U3R5bGVyO1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZE5hdkxpc3RDc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTmF2TGlzdENzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWROYXZMaXN0Q3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQ0MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtbmF2LWxpc3QsIG1hdC1uYXYtbGlzdCcsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbmF2LWxpc3RdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZE5hdkxpc3RDc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZE5hdkxpc3RDc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kRGl2aWRlckNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaXZpZGVyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZERpdmlkZXJDc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1kaXZpZGVyLCBtYXQtZGl2aWRlcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZGl2aWRlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kRGl2aWRlckNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kRGl2aWRlckNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKiBOZWVkIGRpcmVjdGl2ZSBmb3IgYSBDb250ZW50Q2hpbGQgcXVlcnkgaW4gbGlzdC1pdGVtICovXG52YXIgTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1saXN0LWF2YXRhcl0sIFttYXQtbGlzdC1hdmF0YXJdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1saXN0LWF2YXRhcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKiBOZWVkIGRpcmVjdGl2ZSB0byBhZGQgbWF0LSBDU1Mgc3R5bGluZyAqL1xudmFyIE1kTGlzdEljb25Dc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdEljb25Dc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kTGlzdEljb25Dc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtbGlzdC1pY29uXSwgW21hdC1saXN0LWljb25dJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1saXN0LWljb25dJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZExpc3RJY29uQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRMaXN0SWNvbkNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1zdWJoZWFkZXJdLCBbbWF0LXN1YmhlYWRlcl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXN1YmhlYWRlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlcjtcbn0oKSk7XG52YXIgTWRMaXN0SXRlbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0SXRlbShfcmVuZGVyZXIsIF9lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZExpc3RJdGVtLnByb3RvdHlwZSwgXCJfaGFzQXZhdGFyXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXZhdGFyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbWF0LWxpc3QtaXRlbS1hdmF0YXInLCBhdmF0YXIgIT0gbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kTGlzdEl0ZW0ucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGluZVNldHRlciA9IG5ldyBNZExpbmVTZXR0ZXIodGhpcy5fbGluZXMsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9O1xuICAgIE1kTGlzdEl0ZW0ucHJvdG90eXBlLl9oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSB0cnVlO1xuICAgIH07XG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUuX2hhbmRsZUJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRMaW5lKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDAoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRMaXN0SXRlbS5wcm90b3R5cGUsIFwiX2xpbmVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ0MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkKE1kTGlzdEF2YXRhckNzc01hdFN0eWxlciksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246dHlwZScsIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlciksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXJdKVxuICAgIF0sIE1kTGlzdEl0ZW0ucHJvdG90eXBlLCBcIl9oYXNBdmF0YXJcIiwgbnVsbCk7XG4gICAgTWRMaXN0SXRlbSA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1saXN0LWl0ZW0sIG1hdC1saXN0LWl0ZW0sIGFbbWQtbGlzdC1pdGVtXSwgYVttYXQtbGlzdC1pdGVtXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnbGlzdGl0ZW0nLFxuICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ19oYW5kbGVGb2N1cygpJyxcbiAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19oYW5kbGVCbHVyKCknLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWxpc3QtaXRlbV0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LWxpc3QtaXRlbS1jb250ZW50XFxcIiBbY2xhc3MubWF0LWxpc3QtaXRlbS1mb2N1c109XFxcIl9oYXNGb2N1c1xcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtbGlzdC1hdmF0YXJdLFttZC1saXN0LWljb25dLCBbbWF0LWxpc3QtYXZhdGFyXSwgW21hdC1saXN0LWljb25dXFxcIj48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LWxpc3QtdGV4dFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtbGluZV0sIFttYXQtbGluZV1cXFwiPjwvbmctY29udGVudD48L2Rpdj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kTGlzdEl0ZW0pO1xuICAgIHJldHVybiBNZExpc3RJdGVtO1xufSgpKTtcbnZhciBNZExpc3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRMaXN0TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRMaXN0TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRMaXN0TW9kdWxlID0gX19kZWNvcmF0ZSQ0MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW01kTGluZU1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTWRMaXN0LFxuICAgICAgICAgICAgICAgIE1kTGlzdEl0ZW0sXG4gICAgICAgICAgICAgICAgTWRMaXN0RGl2aWRlcixcbiAgICAgICAgICAgICAgICBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRMaW5lTW9kdWxlLFxuICAgICAgICAgICAgICAgIENvbXBhdGliaWxpdHlNb2R1bGUsXG4gICAgICAgICAgICAgICAgTWRMaXN0SWNvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZExpc3RDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWROYXZMaXN0Q3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kRGl2aWRlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBNZExpc3QsXG4gICAgICAgICAgICAgICAgTWRMaXN0SXRlbSxcbiAgICAgICAgICAgICAgICBNZExpc3REaXZpZGVyLFxuICAgICAgICAgICAgICAgIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZExpc3RJY29uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kTGlzdENzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZE5hdkxpc3RDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWREaXZpZGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlclxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGlzdE1vZHVsZSk7XG4gICAgcmV0dXJuIE1kTGlzdE1vZHVsZTtcbn0oKSk7XG5cbi8qKlxuICogQ29udmVydHMgdmFsdWVzIGludG8gc3RyaW5ncy4gRmFsc3kgdmFsdWVzIGJlY29tZSBlbXB0eSBzdHJpbmdzLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb2VyY2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBcIlwiICsgKHZhbHVlIHx8ICcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB2YWx1ZSB0aGF0IG1pZ2h0IGJlIGEgc3RyaW5nIGludG8gYSBudW1iZXIuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh2YWx1ZSwgMTApIDogdmFsdWU7XG59XG5cbnZhciBfX2RlY29yYXRlJDQyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRHcmlkVGlsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZShfcmVuZGVyZXIsIF9lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3Jvd3NwYW4gPSAxO1xuICAgICAgICB0aGlzLl9jb2xzcGFuID0gMTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kR3JpZFRpbGUucHJvdG90eXBlLCBcInJvd3NwYW5cIiwge1xuICAgICAgICAvKiogQW1vdW50IG9mIHJvd3MgdGhhdCB0aGUgZ3JpZCB0aWxlIHRha2VzIHVwLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvd3NwYW47IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3Jvd3NwYW4gPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJjb2xzcGFuXCIsIHtcbiAgICAgICAgLyoqIEFtb3VudCBvZiBjb2x1bW5zIHRoYXQgdGhlIGdyaWQgdGlsZSB0YWtlcyB1cC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xzcGFuOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9jb2xzcGFuID0gY29lcmNlVG9OdW1iZXIodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHlsZSBvZiB0aGUgZ3JpZC10aWxlIGVsZW1lbnQuICBOZWVkcyB0byBiZSBzZXQgbWFudWFsbHkgdG8gYXZvaWRcbiAgICAgKiBcIkNoYW5nZWQgYWZ0ZXIgY2hlY2tlZFwiIGVycm9ycyB0aGF0IHdvdWxkIG9jY3VyIHdpdGggSG9zdEJpbmRpbmcuXG4gICAgICovXG4gICAgTWRHcmlkVGlsZS5wcm90b3R5cGUuX3NldFN0eWxlID0gZnVuY3Rpb24gKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kR3JpZFRpbGUucHJvdG90eXBlLCBcInJvd3NwYW5cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ0MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kR3JpZFRpbGUucHJvdG90eXBlLCBcImNvbHNwYW5cIiwgbnVsbCk7XG4gICAgTWRHcmlkVGlsZSA9IF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1ncmlkLXRpbGUsIG1hdC1ncmlkLXRpbGUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3RpdGVtJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1ncmlkLXRpbGVdJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxmaWd1cmUgY2xhc3M9XFxcIm1hdC1maWd1cmVcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2ZpZ3VyZT5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1ncmlkLWxpc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWdyaWQtdGlsZXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbn0ubWF0LWdyaWQtdGlsZSAubWF0LWZpZ3VyZXtkaXNwbGF5OmZsZXg7cG9zaXRpb246YWJzb2x1dGU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7aGVpZ2h0OjEwMCU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7cGFkZGluZzowO21hcmdpbjowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtoZWlnaHQ6NDhweDtjb2xvcjojZmZmO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMzgpO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgMTZweDtmb250LXNpemU6MTZweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXIgLm1hdC1saW5lLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlciAubWF0LWxpbmV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93LXg6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyIC5tYXQtbGluZTpudGgtY2hpbGQobisyKSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXIgLm1hdC1saW5lOm50aC1jaGlsZChuKzIpe2ZvbnQtc2l6ZToxMnB4fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1saXN0LXRleHQ+KiwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXI+KiwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXI+KnttYXJnaW46MDtwYWRkaW5nOjA7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZTppbmhlcml0fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlci5tYXQtMi1saW5lLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlci5tYXQtMi1saW5le2hlaWdodDo2OHB4fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1saXN0LXRleHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW59Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcjplbXB0eSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7dG9wOjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVye2JvdHRvbTowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1hdmF0YXJ7cGFkZGluZy1yaWdodDoxNnB4fVtkaXI9cnRsXSAubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MTZweH1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZEdyaWRUaWxlKTtcbiAgICByZXR1cm4gTWRHcmlkVGlsZTtcbn0oKSk7XG52YXIgTWRHcmlkVGlsZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZFRpbGVUZXh0KF9yZW5kZXJlciwgX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICB9XG4gICAgTWRHcmlkVGlsZVRleHQucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGluZVNldHRlciA9IG5ldyBNZExpbmVTZXR0ZXIodGhpcy5fbGluZXMsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZExpbmUpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MignZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZEdyaWRUaWxlVGV4dC5wcm90b3R5cGUsIFwiX2xpbmVzXCIsIHZvaWQgMCk7XG4gICAgTWRHcmlkVGlsZVRleHQgPSBfX2RlY29yYXRlJDQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLWhlYWRlciwgbWF0LWdyaWQtdGlsZS1oZWFkZXIsIG1kLWdyaWQtdGlsZS1mb290ZXIsIG1hdC1ncmlkLXRpbGUtZm9vdGVyJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWdyaWQtYXZhdGFyXSwgW21hdC1ncmlkLWF2YXRhcl1cXFwiPjwvbmctY29udGVudD48ZGl2IGNsYXNzPVxcXCJtYXQtZ3JpZC1saXN0LXRleHRcXFwiPjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWxpbmVdLCBbbWF0LWxpbmVdXFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZEdyaWRUaWxlVGV4dCk7XG4gICAgcmV0dXJuIE1kR3JpZFRpbGVUZXh0O1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQ0MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWdyaWQtYXZhdGFyXSwgW21hdC1ncmlkLWF2YXRhcl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWdyaWQtYXZhdGFyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyO1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQ0MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLWhlYWRlciwgbWF0LWdyaWQtdGlsZS1oZWFkZXInLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWdyaWQtdGlsZS1oZWFkZXJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWdyaWQtdGlsZS1mb290ZXIsIG1hdC1ncmlkLXRpbGUtZm9vdGVyJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1ncmlkLXRpbGUtZm9vdGVyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDEwID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGNvbHMgcHJvcGVydHkgaXMgbWlzc2luZyBmcm9tIGdyaWQtbGlzdFxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRHcmlkTGlzdENvbHNFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEwKE1kR3JpZExpc3RDb2xzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdENvbHNFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJtZC1ncmlkLWxpc3Q6IG11c3QgcGFzcyBpbiBudW1iZXIgb2YgY29sdW1ucy4gRXhhbXBsZTogPG1kLWdyaWQtbGlzdCBjb2xzPVxcXCIzXFxcIj5cIik7XG4gICAgfVxuICAgIHJldHVybiBNZEdyaWRMaXN0Q29sc0Vycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhIHRpbGUncyBjb2xzcGFuIGlzIGxvbmdlciB0aGFuIHRoZSBudW1iZXIgb2YgY29scyBpbiBsaXN0XG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEdyaWRUaWxlVG9vV2lkZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTAoTWRHcmlkVGlsZVRvb1dpZGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEdyaWRUaWxlVG9vV2lkZUVycm9yKGNvbHMsIGxpc3RMZW5ndGgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJtZC1ncmlkLWxpc3Q6IHRpbGUgd2l0aCBjb2xzcGFuIFwiICsgY29scyArIFwiIGlzIHdpZGVyIHRoYW4gZ3JpZCB3aXRoIGNvbHM9XFxcIlwiICsgbGlzdExlbmd0aCArIFwiXFxcIi5cIik7XG4gICAgfVxuICAgIHJldHVybiBNZEdyaWRUaWxlVG9vV2lkZUVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhbiBpbnZhbGlkIHJhdGlvIGlzIHBhc3NlZCBpbiBhcyBhIHJvd0hlaWdodFxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRHcmlkTGlzdEJhZFJhdGlvRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMChNZEdyaWRMaXN0QmFkUmF0aW9FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEdyaWRMaXN0QmFkUmF0aW9FcnJvcih2YWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIm1kLWdyaWQtbGlzdDogaW52YWxpZCByYXRpbyBnaXZlbiBmb3Igcm93LWhlaWdodDogXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBNZEdyaWRMaXN0QmFkUmF0aW9FcnJvcjtcbn0oTWRFcnJvcikpO1xuXG4vKipcbiAqIENsYXNzIGZvciBkZXRlcm1pbmluZywgZnJvbSBhIGxpc3Qgb2YgdGlsZXMsIHRoZSAocm93LCBjb2wpIHBvc2l0aW9uIG9mIGVhY2ggb2YgdGhvc2UgdGlsZXNcbiAqIGluIHRoZSBncmlkLiBUaGlzIGlzIG5lY2Vzc2FyeSAocmF0aGVyIHRoYW4ganVzdCByZW5kZXJpbmcgdGhlIHRpbGVzIGluIG5vcm1hbCBkb2N1bWVudCBmbG93KVxuICogYmVjYXVzZSB0aGUgdGlsZXMgY2FuIGhhdmUgYSByb3dzcGFuLlxuICpcbiAqIFRoZSBwb3NpdGlvbmluZyBhbGdvcml0aG0gZ3JlZWRpbHkgcGxhY2VzIGVhY2ggdGlsZSBhcyBzb29uIGFzIGl0IGVuY291bnRlcnMgYSBnYXAgaW4gdGhlIGdyaWRcbiAqIGxhcmdlIGVub3VnaCB0byBhY2NvbW1vZGF0ZSBpdCBzbyB0aGF0IHRoZSB0aWxlcyBzdGlsbCByZW5kZXIgaW4gdGhlIHNhbWUgb3JkZXIgaW4gd2hpY2ggdGhleVxuICogYXJlIGdpdmVuLlxuICpcbiAqIFRoZSBiYXNpcyBvZiB0aGUgYWxnb3JpdGhtIGlzIHRoZSB1c2Ugb2YgYW4gYXJyYXkgdG8gdHJhY2sgdGhlIGFscmVhZHkgcGxhY2VkIHRpbGVzLiBFYWNoXG4gKiBlbGVtZW50IG9mIHRoZSBhcnJheSBjb3JyZXNwb25kcyB0byBhIGNvbHVtbiwgYW5kIHRoZSB2YWx1ZSBpbmRpY2F0ZXMgaG93IG1hbnkgY2VsbHMgaW4gdGhhdFxuICogY29sdW1uIGFyZSBhbHJlYWR5IG9jY3VwaWVkOyB6ZXJvIGluZGljYXRlcyBhbiBlbXB0eSBjZWxsLiBNb3ZpbmcgXCJkb3duXCIgdG8gdGhlIG5leHQgcm93XG4gKiBkZWNyZW1lbnRzIGVhY2ggdmFsdWUgaW4gdGhlIHRyYWNraW5nIGFycmF5IChpbmRpY2F0aW5nIHRoYXQgdGhlIGNvbHVtbiBpcyBvbmUgY2VsbCBjbG9zZXIgdG9cbiAqIGJlaW5nIGZyZWUpLlxuICpcbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFRpbGVDb29yZGluYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGlsZUNvb3JkaW5hdG9yKG51bUNvbHVtbnMsIHRpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBJbmRleCBhdCB3aGljaCB0aGUgc2VhcmNoIGZvciB0aGUgbmV4dCBnYXAgd2lsbCBzdGFydC4gKi9cbiAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCByb3cgaW5kZXguICovXG4gICAgICAgIHRoaXMucm93SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSBuZXcgQXJyYXkobnVtQ29sdW1ucyk7XG4gICAgICAgIHRoaXMudHJhY2tlci5maWxsKDAsIDAsIHRoaXMudHJhY2tlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHRpbGVzLm1hcChmdW5jdGlvbiAodGlsZSkgeyByZXR1cm4gX3RoaXMuX3RyYWNrVGlsZSh0aWxlKTsgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLCBcInJvd0NvdW50XCIsIHtcbiAgICAgICAgLyoqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiByb3dzIG9jY3VwaWVkIGJ5IHRpbGVzICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3dJbmRleCArIDE7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLCBcInJvd3NwYW5cIiwge1xuICAgICAgICAvKiogR2V0cyB0aGUgdG90YWwgc3BhbiBvZiByb3dzIG9jY3VwaWVkIGJ5IHRpbGVzLlxuICAgICAgICAgKiBFeDogQSBsaXN0IHdpdGggMSByb3cgdGhhdCBjb250YWlucyBhIHRpbGUgd2l0aCByb3dzcGFuIDIgd2lsbCBoYXZlIGEgdG90YWwgcm93c3BhbiBvZiAyLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Um93TWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdGhpcy50cmFja2VyKTtcbiAgICAgICAgICAgIC8vIGlmIGFueSBvZiB0aGUgdGlsZXMgaGFzIGEgcm93c3BhbiB0aGF0IHB1c2hlcyBpdCBiZXlvbmQgdGhlIHRvdGFsIHJvdyBjb3VudCxcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZGlmZmVyZW5jZSB0byB0aGUgcm93Y291bnRcbiAgICAgICAgICAgIHJldHVybiBsYXN0Um93TWF4ID4gMSA/IHRoaXMucm93Q291bnQgKyBsYXN0Um93TWF4IC0gMSA6IHRoaXMucm93Q291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBDYWxjdWxhdGVzIHRoZSByb3cgYW5kIGNvbCBwb3NpdGlvbiBvZiBhIHRpbGUuICovXG4gICAgVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZS5fdHJhY2tUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgLy8gRmluZCBhIGdhcCBsYXJnZSBlbm91Z2ggZm9yIHRoaXMgdGlsZS5cbiAgICAgICAgdmFyIGdhcFN0YXJ0SW5kZXggPSB0aGlzLl9maW5kTWF0Y2hpbmdHYXAodGlsZS5jb2xzcGFuKTtcbiAgICAgICAgLy8gUGxhY2UgdGlsZSBpbiB0aGUgcmVzdWx0aW5nIGdhcC5cbiAgICAgICAgdGhpcy5fbWFya1RpbGVQb3NpdGlvbihnYXBTdGFydEluZGV4LCB0aWxlKTtcbiAgICAgICAgLy8gVGhlIG5leHQgdGltZSB3ZSBsb29rIGZvciBhIGdhcCwgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IGF0IGNvbHVtbkluZGV4LCB3aGljaCBzaG91bGQgYmVcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHRpbGUgdGhhdCBoYXMganVzdCBiZWVuIHBsYWNlZC5cbiAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IGdhcFN0YXJ0SW5kZXggKyB0aWxlLmNvbHNwYW47XG4gICAgICAgIHJldHVybiBuZXcgVGlsZVBvc2l0aW9uKHRoaXMucm93SW5kZXgsIGdhcFN0YXJ0SW5kZXgpO1xuICAgIH07XG4gICAgLyoqIEZpbmRzIHRoZSBuZXh0IGF2YWlsYWJsZSBzcGFjZSBsYXJnZSBlbm91Z2ggdG8gZml0IHRoZSB0aWxlLiAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX2ZpbmRNYXRjaGluZ0dhcCA9IGZ1bmN0aW9uICh0aWxlQ29scykge1xuICAgICAgICBpZiAodGlsZUNvbHMgPiB0aGlzLnRyYWNrZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRHcmlkVGlsZVRvb1dpZGVFcnJvcih0aWxlQ29scywgdGhpcy50cmFja2VyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgaW5kZXggaXMgaW5jbHVzaXZlLCBlbmQgaW5kZXggaXMgZXhjbHVzaXZlLlxuICAgICAgICB2YXIgZ2FwU3RhcnRJbmRleCA9IC0xO1xuICAgICAgICB2YXIgZ2FwRW5kSW5kZXggPSAtMTtcbiAgICAgICAgLy8gTG9vayBmb3IgYSBnYXAgbGFyZ2UgZW5vdWdoIHRvIGZpdCB0aGUgZ2l2ZW4gdGlsZS4gRW1wdHkgc3BhY2VzIGFyZSBtYXJrZWQgd2l0aCBhIHplcm8uXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcm93LCBnbyB0byB0aGUgbmV4dCByb3cuXG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5JbmRleCArIHRpbGVDb2xzID4gdGhpcy50cmFja2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRSb3coKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcFN0YXJ0SW5kZXggPSB0aGlzLnRyYWNrZXIuaW5kZXhPZigwLCB0aGlzLmNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIGVtcHR5IHNwYWNlcyBpbiB0aGlzIHJvdyBhdCBhbGwsIG1vdmUgb24gdG8gdGhlIG5leHQgcm93LlxuICAgICAgICAgICAgaWYgKGdhcFN0YXJ0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0Um93KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBFbmRJbmRleCA9IHRoaXMuX2ZpbmRHYXBFbmRJbmRleChnYXBTdGFydEluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIGEgZ2FwIGxhcmdlIGVub3VnaCBpc24ndCBmb3VuZCwgd2Ugd2FudCB0byBzdGFydCBsb29raW5nIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBnYXAgb24gdGhlIG5leHQgaXRlcmF0aW9uLlxuICAgICAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IGdhcFN0YXJ0SW5kZXggKyAxO1xuICAgICAgICB9IHdoaWxlIChnYXBFbmRJbmRleCAtIGdhcFN0YXJ0SW5kZXggPCB0aWxlQ29scyk7XG4gICAgICAgIHJldHVybiBnYXBTdGFydEluZGV4O1xuICAgIH07XG4gICAgLyoqIE1vdmUgXCJkb3duXCIgdG8gdGhlIG5leHQgcm93LiAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX25leHRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgIC8vIERlY3JlbWVudCBhbGwgc3BhY2VzIGJ5IG9uZSB0byByZWZsZWN0IG1vdmluZyBkb3duIG9uZSByb3cuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXJbaV0gPSBNYXRoLm1heCgwLCB0aGlzLnRyYWNrZXJbaV0gLSAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVuZCBpbmRleCAoZXhjbHVzaXZlKSBvZiBhIGdhcCBnaXZlbiB0aGUgaW5kZXggZnJvbSB3aGljaCB0byBzdGFydCBsb29raW5nLlxuICAgICAqIFRoZSBnYXAgZW5kcyB3aGVuIGEgbm9uLXplcm8gdmFsdWUgaXMgZm91bmQuXG4gICAgICovXG4gICAgVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZS5fZmluZEdhcEVuZEluZGV4ID0gZnVuY3Rpb24gKGdhcFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGdhcFN0YXJ0SW5kZXggKyAxOyBpIDwgdGhpcy50cmFja2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFja2VyW2ldICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZ2FwIGVuZHMgd2l0aCB0aGUgZW5kIG9mIHRoZSByb3cuXG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrZXIubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqIFVwZGF0ZSB0aGUgdGlsZSB0cmFja2VyIHRvIGFjY291bnQgZm9yIHRoZSBnaXZlbiB0aWxlIGluIHRoZSBnaXZlbiBzcGFjZS4gKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9tYXJrVGlsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCB0aWxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZS5jb2xzcGFuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlcltzdGFydCArIGldID0gdGlsZS5yb3dzcGFuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGlsZUNvb3JkaW5hdG9yO1xufSgpKTtcbi8qKlxuICogU2ltcGxlIGRhdGEgc3RydWN0dXJlIGZvciB0aWxlIHBvc2l0aW9uIChyb3csIGNvbCkuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBUaWxlUG9zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVQb3NpdGlvbihyb3csIGNvbCkge1xuICAgICAgICB0aGlzLnJvdyA9IHJvdztcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgfVxuICAgIHJldHVybiBUaWxlUG9zaXRpb247XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogU2V0cyB0aGUgc3R5bGUgcHJvcGVydGllcyBmb3IgYW4gaW5kaXZpZHVhbCB0aWxlLCBnaXZlbiB0aGUgcG9zaXRpb24gY2FsY3VsYXRlZCBieSB0aGVcbiAqIFRpbGUgQ29vcmRpbmF0b3IuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBUaWxlU3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWxlU3R5bGVyKCkge1xuICAgICAgICB0aGlzLl9yb3dzID0gMDtcbiAgICAgICAgdGhpcy5fcm93c3BhbiA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZ3JpZC1saXN0IGxheW91dCBpbmZvIG9uY2UgaXQgaXMgYXZhaWxhYmxlLiBDYW5ub3QgYmUgcHJvY2Vzc2VkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqIGJlY2F1c2UgdGhlc2UgcHJvcGVydGllcyBoYXZlbid0IGJlZW4gY2FsY3VsYXRlZCBieSB0aGF0IHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGd1dHRlclNpemUgU2l6ZSBvZiB0aGUgZ3JpZCdzIGd1dHRlci5cbiAgICAgKiBAcGFyYW0gdHJhY2tlciBJbnN0YW5jZSBvZiB0aGUgVGlsZUNvb3JkaW5hdG9yLlxuICAgICAqIEBwYXJhbSBjb2xzIEFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBncmlkLlxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gTGF5b3V0IGRpcmVjdGlvbiBvZiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGd1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ndXR0ZXJTaXplID0gbm9ybWFsaXplVW5pdHMoZ3V0dGVyU2l6ZSk7XG4gICAgICAgIHRoaXMuX3Jvd3MgPSB0cmFja2VyLnJvd0NvdW50O1xuICAgICAgICB0aGlzLl9yb3dzcGFuID0gdHJhY2tlci5yb3dzcGFuO1xuICAgICAgICB0aGlzLl9jb2xzID0gY29scztcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiBzcGFjZSBhIHNpbmdsZSAxeDEgdGlsZSB3b3VsZCB0YWtlIHVwICh3aWR0aCBvciBoZWlnaHQpLlxuICAgICAqIFVzZWQgYXMgYSBiYXNpcyBmb3Igb3RoZXIgY2FsY3VsYXRpb25zLlxuICAgICAqIEBwYXJhbSBzaXplUGVyY2VudCBQZXJjZW50IG9mIHRoZSB0b3RhbCBncmlkLWxpc3Qgc3BhY2UgdGhhdCBvbmUgMXgxIHRpbGUgd291bGQgdGFrZSB1cC5cbiAgICAgKiBAcGFyYW0gZ3V0dGVyRnJhY3Rpb24gRnJhY3Rpb24gb2YgdGhlIGd1dHRlciBzaXplIHRha2VuIHVwIGJ5IG9uZSAxeDEgdGlsZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBzaXplIG9mIGEgMXgxIHRpbGUgYXMgYW4gZXhwcmVzc2lvbiB0aGF0IGNhbiBiZSBldmFsdWF0ZWQgdmlhIENTUyBjYWxjKCkuXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0QmFzZVRpbGVTaXplID0gZnVuY3Rpb24gKHNpemVQZXJjZW50LCBndXR0ZXJGcmFjdGlvbikge1xuICAgICAgICAvLyBUYWtlIHRoZSBiYXNlIHNpemUgcGVyY2VudCAoYXMgd291bGQgYmUgaWYgZXZlbmx5IGRpdmlkaW5nIHRoZSBzaXplIGJldHdlZW4gY2VsbHMpLFxuICAgICAgICAvLyBhbmQgdGhlbiBzdWJ0cmFjdGluZyB0aGUgc2l6ZSBvZiBvbmUgZ3V0dGVyLiBIb3dldmVyLCBzaW5jZSB0aGVyZSBhcmUgbm8gZ3V0dGVycyBvbiB0aGVcbiAgICAgICAgLy8gZWRnZXMsIGVhY2ggdGlsZSBvbmx5IHVzZXMgYSBmcmFjdGlvbiAoZ3V0dGVyU2hhcmUgPSBudW1HdXR0ZXJzIC8gbnVtQ2VsbHMpIG9mIHRoZSBndXR0ZXJcbiAgICAgICAgLy8gc2l6ZS4gKEltYWdpbmUgaGF2aW5nIG9uZSBndXR0ZXIgcGVyIHRpbGUsIGFuZCB0aGVuIGJyZWFraW5nIHVwIHRoZSBleHRyYSBndXR0ZXIgb24gdGhlXG4gICAgICAgIC8vIGVkZ2UgZXZlbmx5IGFtb25nIHRoZSBjZWxscykuXG4gICAgICAgIHJldHVybiBcIihcIiArIHNpemVQZXJjZW50ICsgXCIlIC0gKCBcIiArIHRoaXMuX2d1dHRlclNpemUgKyBcIiAqIFwiICsgZ3V0dGVyRnJhY3Rpb24gKyBcIiApKVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBUaGUgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiBhIHRpbGUsIGUuZy4sIHRoZSAndG9wJyBvciAnbGVmdCcgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIG9mZnNldCBOdW1iZXIgb2YgdGlsZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZW5kZXJlZCBpbiB0aGUgcm93L2NvbHVtbi5cbiAgICAgKiBAcGFyYW0gYmFzZVNpemUgQmFzZSBzaXplIG9mIGEgMXgxIHRpbGUgKGFzIGNvbXB1dGVkIGluIGdldEJhc2VUaWxlU2l6ZSkuXG4gICAgICogQHJldHVybiBQb3NpdGlvbiBvZiB0aGUgdGlsZSBhcyBhIENTUyBjYWxjKCkgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRUaWxlUG9zaXRpb24gPSBmdW5jdGlvbiAoYmFzZVNpemUsIG9mZnNldCkge1xuICAgICAgICAvLyBUaGUgcG9zaXRpb24gY29tZXMgdGhlIHNpemUgb2YgYSAxeDEgdGlsZSBwbHVzIGd1dHRlciBmb3IgZWFjaCBwcmV2aW91cyB0aWxlIGluIHRoZVxuICAgICAgICAvLyByb3cvY29sdW1uIChvZmZzZXQpLlxuICAgICAgICByZXR1cm4gY2FsYyhcIihcIiArIGJhc2VTaXplICsgXCIgKyBcIiArIHRoaXMuX2d1dHRlclNpemUgKyBcIikgKiBcIiArIG9mZnNldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhY3R1YWwgc2l6ZSBvZiBhIHRpbGUsIGUuZy4sIHdpZHRoIG9yIGhlaWdodCwgdGFraW5nIHJvd3NwYW4gb3IgY29sc3BhbiBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIGJhc2VTaXplIEJhc2Ugc2l6ZSBvZiBhIDF4MSB0aWxlIChhcyBjb21wdXRlZCBpbiBnZXRCYXNlVGlsZVNpemUpLlxuICAgICAqIEBwYXJhbSBzcGFuIFRoZSB0aWxlJ3Mgcm93c3BhbiBvciBjb2xzcGFuLlxuICAgICAqIEByZXR1cm4gU2l6ZSBvZiB0aGUgdGlsZSBhcyBhIENTUyBjYWxjKCkgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRUaWxlU2l6ZSA9IGZ1bmN0aW9uIChiYXNlU2l6ZSwgc3Bhbikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBiYXNlU2l6ZSArIFwiICogXCIgKyBzcGFuICsgXCIpICsgKFwiICsgKHNwYW4gLSAxKSArIFwiICogXCIgKyB0aGlzLl9ndXR0ZXJTaXplICsgXCIpXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQgdG8gYSB0aWxlIGZvciB0aGUgZ2l2ZW4gcm93IGFuZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHRpbGUgVGlsZSB0byB3aGljaCB0byBhcHBseSB0aGUgc3R5bGluZy5cbiAgICAgKiBAcGFyYW0gcm93SW5kZXggSW5kZXggb2YgdGhlIHRpbGUncyByb3cuXG4gICAgICogQHBhcmFtIGNvbEluZGV4IEluZGV4IG9mIHRoZSB0aWxlJ3MgY29sdW1uLlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBjb2xJbmRleCkge1xuICAgICAgICAvLyBQZXJjZW50IG9mIHRoZSBhdmFpbGFibGUgaG9yaXpvbnRhbCBzcGFjZSB0aGF0IG9uZSBjb2x1bW4gdGFrZXMgdXAuXG4gICAgICAgIHZhciBwZXJjZW50V2lkdGhQZXJUaWxlID0gMTAwIC8gdGhpcy5fY29scztcbiAgICAgICAgLy8gRnJhY3Rpb24gb2YgdGhlIHZlcnRpY2FsIGd1dHRlciBzaXplIHRoYXQgZWFjaCBjb2x1bW4gdGFrZXMgdXAuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBpZiB0aGVyZSBhcmUgNSBjb2x1bW5zLCBlYWNoIGNvbHVtbiB1c2VzIDQvNSA9IDAuOCB0aW1lcyB0aGUgZ3V0dGVyIHdpZHRoLlxuICAgICAgICB2YXIgZ3V0dGVyV2lkdGhGcmFjdGlvblBlclRpbGUgPSAodGhpcy5fY29scyAtIDEpIC8gdGhpcy5fY29scztcbiAgICAgICAgdGhpcy5zZXRDb2xTdHlsZXModGlsZSwgY29sSW5kZXgsIHBlcmNlbnRXaWR0aFBlclRpbGUsIGd1dHRlcldpZHRoRnJhY3Rpb25QZXJUaWxlKTtcbiAgICAgICAgdGhpcy5zZXRSb3dTdHlsZXModGlsZSwgcm93SW5kZXgsIHBlcmNlbnRXaWR0aFBlclRpbGUsIGd1dHRlcldpZHRoRnJhY3Rpb25QZXJUaWxlKTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSBob3Jpem9udGFsIHBsYWNlbWVudCBvZiB0aGUgdGlsZSBpbiB0aGUgbGlzdC4gKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRDb2xTdHlsZXMgPSBmdW5jdGlvbiAodGlsZSwgY29sSW5kZXgsIHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpIHtcbiAgICAgICAgLy8gQmFzZSBob3Jpem9udGFsIHNpemUgb2YgYSBjb2x1bW4uXG4gICAgICAgIHZhciBiYXNlVGlsZVdpZHRoID0gdGhpcy5nZXRCYXNlVGlsZVNpemUocGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCk7XG4gICAgICAgIC8vIFRoZSB3aWR0aCBhbmQgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiBlYWNoIHRpbGUgaXMgYWx3YXlzIGNhbGN1bGF0ZWQgdGhlIHNhbWUgd2F5LCBidXQgdGhlXG4gICAgICAgIC8vIGhlaWdodCBhbmQgdmVydGljYWwgcG9zaXRpb24gZGVwZW5kcyBvbiB0aGUgcm93TW9kZS5cbiAgICAgICAgdmFyIHNpZGUgPSB0aGlzLl9kaXJlY3Rpb24gPT09ICdsdHInID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoc2lkZSwgdGhpcy5nZXRUaWxlUG9zaXRpb24oYmFzZVRpbGVXaWR0aCwgY29sSW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ3dpZHRoJywgY2FsYyh0aGlzLmdldFRpbGVTaXplKGJhc2VUaWxlV2lkdGgsIHRpbGUuY29sc3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHRvdGFsIHNpemUgdGFrZW4gdXAgYnkgZ3V0dGVycyBhY3Jvc3Mgb25lIGF4aXMgb2YgYSBsaXN0LlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmdldEd1dHRlclNwYW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ndXR0ZXJTaXplICsgXCIgKiAoXCIgKyB0aGlzLl9yb3dzcGFuICsgXCIgLSAxKVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdG90YWwgc2l6ZSB0YWtlbiB1cCBieSB0aWxlcyBhY3Jvc3Mgb25lIGF4aXMgb2YgYSBsaXN0LlxuICAgICAqIEBwYXJhbSB0aWxlSGVpZ2h0IEhlaWdodCBvZiB0aGUgdGlsZS5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRUaWxlU3BhbiA9IGZ1bmN0aW9uICh0aWxlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dzcGFuICsgXCIgKiBcIiArIHRoaXMuZ2V0VGlsZVNpemUodGlsZUhlaWdodCwgMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2ZXJ0aWNhbCBwbGFjZW1lbnQgb2YgdGhlIHRpbGUgaW4gdGhlIGxpc3QuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIHR5cGUgb2YgVGlsZVN0eWxlci5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Um93U3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7IH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY29tcHV0ZWQgaGVpZ2h0IGFuZCByZXR1cm5zIHRoZSBjb3JyZWN0IHN0eWxlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZSBvZiBUaWxlU3R5bGVyLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFRpbGVTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBUaGlzIHR5cGUgb2Ygc3R5bGVyIGlzIGluc3RhbnRpYXRlZCB3aGVuIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGZpeGVkIHJvdyBoZWlnaHQuXG4gKiBFeGFtcGxlIDxtZC1ncmlkLWxpc3QgY29scz1cIjNcIiByb3dIZWlnaHQ9XCIxMDBweFwiPlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgRml4ZWRUaWxlU3R5bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTEoRml4ZWRUaWxlU3R5bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpeGVkVGlsZVN0eWxlcihmaXhlZFJvd0hlaWdodCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5maXhlZFJvd0hlaWdodCA9IGZpeGVkUm93SGVpZ2h0O1xuICAgIH1cbiAgICBGaXhlZFRpbGVTdHlsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZ3V0dGVyU2l6ZSwgdHJhY2tlciwgY29scywgZGlyZWN0aW9uKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGd1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuZml4ZWRSb3dIZWlnaHQgPSBub3JtYWxpemVVbml0cyh0aGlzLmZpeGVkUm93SGVpZ2h0KTtcbiAgICB9O1xuICAgIEZpeGVkVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Um93U3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCd0b3AnLCB0aGlzLmdldFRpbGVQb3NpdGlvbih0aGlzLmZpeGVkUm93SGVpZ2h0LCByb3dJbmRleCkpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTaXplKHRoaXMuZml4ZWRSb3dIZWlnaHQsIHRpbGUucm93c3BhbikpKTtcbiAgICB9O1xuICAgIEZpeGVkVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTcGFuKHRoaXMuZml4ZWRSb3dIZWlnaHQpICsgXCIgKyBcIiArIHRoaXMuZ2V0R3V0dGVyU3BhbigpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgcmV0dXJuIEZpeGVkVGlsZVN0eWxlcjtcbn0oVGlsZVN0eWxlcikpO1xuLyoqXG4gKiBUaGlzIHR5cGUgb2Ygc3R5bGVyIGlzIGluc3RhbnRpYXRlZCB3aGVuIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHdpZHRoOmhlaWdodCByYXRpb1xuICogZm9yIHRoZSByb3cgaGVpZ2h0LiAgRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiMzoxXCI+XG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBSYXRpb1RpbGVTdHlsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMShSYXRpb1RpbGVTdHlsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmF0aW9UaWxlU3R5bGVyKHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wYXJzZVJhdGlvKHZhbHVlKTtcbiAgICB9XG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRSb3dTdHlsZXMgPSBmdW5jdGlvbiAodGlsZSwgcm93SW5kZXgsIHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpIHtcbiAgICAgICAgdmFyIHBlcmNlbnRIZWlnaHRQZXJUaWxlID0gcGVyY2VudFdpZHRoIC8gdGhpcy5yb3dIZWlnaHRSYXRpbztcbiAgICAgICAgdGhpcy5iYXNlVGlsZUhlaWdodCA9IHRoaXMuZ2V0QmFzZVRpbGVTaXplKHBlcmNlbnRIZWlnaHRQZXJUaWxlLCBndXR0ZXJXaWR0aCk7XG4gICAgICAgIC8vIFVzZSBwYWRkaW5nVG9wIGFuZCBtYXJnaW5Ub3AgdG8gbWFpbnRhaW4gdGhlIGdpdmVuIGFzcGVjdCByYXRpbywgYXNcbiAgICAgICAgLy8gYSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlIGZvciB0aGVzZSBwcm9wZXJ0aWVzIGlzIGFwcGxpZWQgdmVyc3VzIHRoZSAqd2lkdGgqIG9mIHRoZVxuICAgICAgICAvLyBjb250YWluaW5nIGJsb2NrLiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMi9ib3guaHRtbCNtYXJnaW4tcHJvcGVydGllc1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnbWFyZ2luVG9wJywgdGhpcy5nZXRUaWxlUG9zaXRpb24odGhpcy5iYXNlVGlsZUhlaWdodCwgcm93SW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ3BhZGRpbmdUb3AnLCBjYWxjKHRoaXMuZ2V0VGlsZVNpemUodGhpcy5iYXNlVGlsZUhlaWdodCwgdGlsZS5yb3dzcGFuKSkpO1xuICAgIH07XG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdwYWRkaW5nQm90dG9tJywgY2FsYyh0aGlzLmdldFRpbGVTcGFuKHRoaXMuYmFzZVRpbGVIZWlnaHQpICsgXCIgKyBcIiArIHRoaXMuZ2V0R3V0dGVyU3BhbigpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5fcGFyc2VSYXRpbyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmF0aW9QYXJ0cyA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChyYXRpb1BhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kR3JpZExpc3RCYWRSYXRpb0Vycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0hlaWdodFJhdGlvID0gcGFyc2VGbG9hdChyYXRpb1BhcnRzWzBdKSAvIHBhcnNlRmxvYXQocmF0aW9QYXJ0c1sxXSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmF0aW9UaWxlU3R5bGVyO1xufShUaWxlU3R5bGVyKSk7XG4vKipcbiAqIFRoaXMgdHlwZSBvZiBzdHlsZXIgaXMgaW5zdGFudGlhdGVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIFwiZml0XCIgcm93IGhlaWdodCBtb2RlLlxuICogSW4gb3RoZXIgd29yZHMsIHRoZSByb3cgaGVpZ2h0IHdpbGwgcmVmbGVjdCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIgZGl2aWRlZFxuICogYnkgdGhlIG51bWJlciBvZiByb3dzLiAgRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiZml0XCI+XG4gKlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgRml0VGlsZVN0eWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDExKEZpdFRpbGVTdHlsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRml0VGlsZVN0eWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEZpdFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkge1xuICAgICAgICAvLyBQZXJjZW50IG9mIHRoZSBhdmFpbGFibGUgdmVydGljYWwgc3BhY2UgdGhhdCBvbmUgcm93IHRha2VzIHVwLlxuICAgICAgICB2YXIgcGVyY2VudEhlaWdodFBlclRpbGUgPSAxMDAgLyB0aGlzLl9yb3dzcGFuO1xuICAgICAgICAvLyBGcmFjdGlvbiBvZiB0aGUgaG9yaXpvbnRhbCBndXR0ZXIgc2l6ZSB0aGF0IGVhY2ggY29sdW1uIHRha2VzIHVwLlxuICAgICAgICB2YXIgZ3V0dGVySGVpZ2h0UGVyVGlsZSA9ICh0aGlzLl9yb3dzIC0gMSkgLyB0aGlzLl9yb3dzO1xuICAgICAgICAvLyBCYXNlIHZlcnRpY2FsIHNpemUgb2YgYSBjb2x1bW4uXG4gICAgICAgIHZhciBiYXNlVGlsZUhlaWdodCA9IHRoaXMuZ2V0QmFzZVRpbGVTaXplKHBlcmNlbnRIZWlnaHRQZXJUaWxlLCBndXR0ZXJIZWlnaHRQZXJUaWxlKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ3RvcCcsIHRoaXMuZ2V0VGlsZVBvc2l0aW9uKGJhc2VUaWxlSGVpZ2h0LCByb3dJbmRleCkpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTaXplKGJhc2VUaWxlSGVpZ2h0LCB0aWxlLnJvd3NwYW4pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRml0VGlsZVN0eWxlcjtcbn0oVGlsZVN0eWxlcikpO1xuLyoqIFdyYXBzIGEgQ1NTIHN0cmluZyBpbiBhIGNhbGMgZnVuY3Rpb24gKi9cbmZ1bmN0aW9uIGNhbGMoZXhwKSB7IHJldHVybiBcImNhbGMoXCIgKyBleHAgKyBcIilcIjsgfVxuLyoqIEFwcGVuZHMgcGl4ZWxzIHRvIGEgQ1NTIHN0cmluZyBpZiBubyB1bml0cyBhcmUgZ2l2ZW4uICovXG5mdW5jdGlvbiBub3JtYWxpemVVbml0cyh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUubWF0Y2goL3B4fGVtfHJlbS8pKSA/IHZhbHVlIDogdmFsdWUgKyAncHgnO1xufVxuXG52YXIgX19kZWNvcmF0ZSQ0MSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kOSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8vIFRPRE8oa2FyYSk6IENvbmRpdGlvbmFsIChyZXNwb25zaXZlKSBjb2x1bW4gY291bnQgLyByb3cgc2l6ZS5cbi8vIFRPRE8oa2FyYSk6IFJlLWxheW91dCBvbiB3aW5kb3cgcmVzaXplIC8gbWVkaWEgY2hhbmdlIChkZWJvdW5jZWQpLlxuLy8gVE9ETyhrYXJhKTogZ3JpZFRpbGVIZWFkZXIgYW5kIGdyaWRUaWxlRm9vdGVyLlxudmFyIE1EX0ZJVF9NT0RFID0gJ2ZpdCc7XG52YXIgTWRHcmlkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdChfcmVuZGVyZXIsIF9lbGVtZW50LCBfZGlyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIC8qKiBUaGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gdGlsZXMuIFRoaXMgd2lsbCBiZSBzb21ldGhpbmcgbGlrZSAnNXB4JyBvciAnMmVtJy4gKi9cbiAgICAgICAgdGhpcy5fZ3V0dGVyID0gJzFweCc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJjb2xzXCIsIHtcbiAgICAgICAgLyoqIEFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBncmlkIGxpc3QuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sczsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fY29scyA9IGNvZXJjZVRvTnVtYmVyKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kR3JpZExpc3QucHJvdG90eXBlLCBcImd1dHRlclNpemVcIiwge1xuICAgICAgICAvKiogU2l6ZSBvZiB0aGUgZ3JpZCBsaXN0J3MgZ3V0dGVyIGluIHBpeGVscy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ndXR0ZXI7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2d1dHRlciA9IGNvZXJjZVRvU3RyaW5nKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kR3JpZExpc3QucHJvdG90eXBlLCBcInJvd0hlaWdodFwiLCB7XG4gICAgICAgIC8qKiBTZXQgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2Ygcm93IGhlaWdodCBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlLiAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gY29lcmNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VGlsZVN0eWxlcigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb2xzKCk7XG4gICAgICAgIHRoaXMuX2NoZWNrUm93SGVpZ2h0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgbGF5b3V0IGNhbGN1bGF0aW9uIGlzIGZhaXJseSBjaGVhcCBpZiBub3RoaW5nIGNoYW5nZXMsIHNvIHRoZXJlJ3MgbGl0dGxlIGNvc3RcbiAgICAgKiB0byBydW4gaXQgZnJlcXVlbnRseS5cbiAgICAgKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xheW91dFRpbGVzKCk7XG4gICAgfTtcbiAgICAvKiogVGhyb3cgYSBmcmllbmRseSBlcnJvciBpZiBjb2xzIHByb3BlcnR5IGlzIG1pc3NpbmcgKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5fY2hlY2tDb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29scykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kR3JpZExpc3RDb2xzRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIERlZmF1bHQgdG8gZXF1YWwgd2lkdGg6aGVpZ2h0IGlmIHJvd0hlaWdodCBwcm9wZXJ0eSBpcyBtaXNzaW5nICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX2NoZWNrUm93SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvd0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBSYXRpb1RpbGVTdHlsZXIoJzE6MScpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQ3JlYXRlcyBjb3JyZWN0IFRpbGUgU3R5bGVyIHN1YnR5cGUgYmFzZWQgb24gcm93SGVpZ2h0IHBhc3NlZCBpbiBieSB1c2VyICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX3NldFRpbGVTdHlsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dIZWlnaHQgPT09IE1EX0ZJVF9NT0RFKSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlU3R5bGVyID0gbmV3IEZpdFRpbGVTdHlsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9yb3dIZWlnaHQgJiYgdGhpcy5fcm93SGVpZ2h0LmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlU3R5bGVyID0gbmV3IFJhdGlvVGlsZVN0eWxlcih0aGlzLl9yb3dIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBGaXhlZFRpbGVTdHlsZXIodGhpcy5fcm93SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENvbXB1dGVzIGFuZCBhcHBsaWVzIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBmb3IgYWxsIGNoaWxkcmVuIGdyaWQgdGlsZXMuICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX2xheW91dFRpbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHJhY2tlciA9IG5ldyBUaWxlQ29vcmRpbmF0b3IodGhpcy5jb2xzLCB0aGlzLl90aWxlcyk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgdGhpcy5fdGlsZVN0eWxlci5pbml0KHRoaXMuZ3V0dGVyU2l6ZSwgdHJhY2tlciwgdGhpcy5jb2xzLCBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLl90aWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0aWxlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRyYWNrZXIucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIF90aGlzLl90aWxlU3R5bGVyLnNldFN0eWxlKHRpbGUsIHBvcy5yb3csIHBvcy5jb2wpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2V0TGlzdFN0eWxlKHRoaXMuX3RpbGVTdHlsZXIuZ2V0Q29tcHV0ZWRIZWlnaHQoKSk7XG4gICAgfTtcbiAgICAvKiogU2V0cyBzdHlsZSBvbiB0aGUgbWFpbiBncmlkLWxpc3QgZWxlbWVudCwgZ2l2ZW4gdGhlIHN0eWxlIG5hbWUgYW5kIHZhbHVlLiAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9zZXRMaXN0U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUkJDEpIHtcbiAgICAgICAgaWYgKHN0eWxlJCQxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBzdHlsZSQkMVswXSwgc3R5bGUkJDFbMV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRHcmlkVGlsZSksIFxuICAgICAgICBfX21ldGFkYXRhJDQxKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kR3JpZExpc3QucHJvdG90eXBlLCBcIl90aWxlc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJjb2xzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJndXR0ZXJTaXplXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQxKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDQxKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIE1kR3JpZExpc3QucHJvdG90eXBlLCBcInJvd0hlaWdodFwiLCBudWxsKTtcbiAgICBNZEdyaWRMaXN0ID0gX19kZWNvcmF0ZSQ0MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWdyaWQtbGlzdCwgbWF0LWdyaWQtbGlzdCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2PjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1ncmlkLWxpc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWdyaWQtdGlsZXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OmhpZGRlbn0ubWF0LWdyaWQtdGlsZSAubWF0LWZpZ3VyZXtkaXNwbGF5OmZsZXg7cG9zaXRpb246YWJzb2x1dGU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7aGVpZ2h0OjEwMCU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7cGFkZGluZzowO21hcmdpbjowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtoZWlnaHQ6NDhweDtjb2xvcjojZmZmO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMzgpO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgMTZweDtmb250LXNpemU6MTZweDtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXIgLm1hdC1saW5lLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlciAubWF0LWxpbmV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93LXg6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyIC5tYXQtbGluZTpudGgtY2hpbGQobisyKSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXIgLm1hdC1saW5lOm50aC1jaGlsZChuKzIpe2ZvbnQtc2l6ZToxMnB4fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1saXN0LXRleHQ+KiwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXI+KiwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXI+KnttYXJnaW46MDtwYWRkaW5nOjA7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZTppbmhlcml0fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlci5tYXQtMi1saW5lLC5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWhlYWRlci5tYXQtMi1saW5le2hlaWdodDo2OHB4fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1saXN0LXRleHR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW59Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcjplbXB0eSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0OmVtcHR5e2Rpc3BsYXk6bm9uZX0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXJ7dG9wOjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVye2JvdHRvbTowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1hdmF0YXJ7cGFkZGluZy1yaWdodDoxNnB4fVtkaXI9cnRsXSAubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MTZweH1cIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZ3JpZC1saXN0XSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDkoMiwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgRGlyXSlcbiAgICBdLCBNZEdyaWRMaXN0KTtcbiAgICByZXR1cm4gTWRHcmlkTGlzdDtcbn0oKSk7XG52YXIgTWRHcmlkTGlzdE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRHcmlkTGlzdE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kR3JpZExpc3RNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZEdyaWRMaXN0TW9kdWxlID0gX19kZWNvcmF0ZSQ0MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW01kTGluZU1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTWRHcmlkTGlzdCxcbiAgICAgICAgICAgICAgICBNZEdyaWRUaWxlLFxuICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVUZXh0LFxuICAgICAgICAgICAgICAgIE1kTGluZU1vZHVsZSxcbiAgICAgICAgICAgICAgICBDb21wYXRpYmlsaXR5TW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBNZEdyaWRMaXN0LFxuICAgICAgICAgICAgICAgIE1kR3JpZFRpbGUsXG4gICAgICAgICAgICAgICAgTWRHcmlkVGlsZVRleHQsXG4gICAgICAgICAgICAgICAgTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEdyaWRMaXN0TW9kdWxlKTtcbiAgICByZXR1cm4gTWRHcmlkTGlzdE1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDQzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENvbnRlbnQgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZENvbnRlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZENvbnRlbnQoKSB7XG4gICAgfVxuICAgIE1kQ2FyZENvbnRlbnQgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWNvbnRlbnQsIG1hdC1jYXJkLWNvbnRlbnQnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtY29udGVudF0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZENvbnRlbnQpO1xuICAgIHJldHVybiBNZENhcmRDb250ZW50O1xufSgpKTtcbi8qKlxuICogVGl0bGUgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZFRpdGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRUaXRsZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkVGl0bGUgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLXRpdGxlLCBtYXQtY2FyZC10aXRsZScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC10aXRsZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZFRpdGxlKTtcbiAgICByZXR1cm4gTWRDYXJkVGl0bGU7XG59KCkpO1xuLyoqXG4gKiBTdWItdGl0bGUgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZFN1YnRpdGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRTdWJ0aXRsZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkU3VidGl0bGUgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLXN1YnRpdGxlLCBtYXQtY2FyZC1zdWJ0aXRsZScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1zdWJ0aXRsZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZFN1YnRpdGxlKTtcbiAgICByZXR1cm4gTWRDYXJkU3VidGl0bGU7XG59KCkpO1xuLyoqXG4gKiBBY3Rpb24gc2VjdGlvbiBvZiBhIGNhcmQsIG5lZWRlZCBhcyBpdCdzIHVzZWQgYXMgYSBzZWxlY3RvciBpbiB0aGUgQVBJLlxuICovXG52YXIgTWRDYXJkQWN0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkQWN0aW9ucygpIHtcbiAgICB9XG4gICAgTWRDYXJkQWN0aW9ucyA9IF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWNhcmQtYWN0aW9ucywgbWF0LWNhcmQtYWN0aW9ucycsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1hY3Rpb25zXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkQWN0aW9ucyk7XG4gICAgcmV0dXJuIE1kQ2FyZEFjdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBGb290ZXIgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZEZvb3RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkRm9vdGVyKCkge1xuICAgIH1cbiAgICBNZENhcmRGb290ZXIgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWZvb3RlciwgbWF0LWNhcmQtZm9vdGVyJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLWZvb3Rlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZEZvb3Rlcik7XG4gICAgcmV0dXJuIE1kQ2FyZEZvb3Rlcjtcbn0oKSk7XG4vKipcbiAqIEltYWdlIHVzZWQgaW4gYSBjYXJkLCBuZWVkZWQgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nLlxuICovXG52YXIgTWRDYXJkU21JbWFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkU21JbWFnZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkU21JbWFnZSA9IF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLXNtLWltYWdlXSwgW21hdC1jYXJkLXNtLWltYWdlXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1zbS1pbWFnZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZFNtSW1hZ2UpO1xuICAgIHJldHVybiBNZENhcmRTbUltYWdlO1xufSgpKTtcbi8qKlxuICogSW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKi9cbnZhciBNZENhcmRNZEltYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRNZEltYWdlKCkge1xuICAgIH1cbiAgICBNZENhcmRNZEltYWdlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWNhcmQtbWQtaW1hZ2VdLCBbbWF0LWNhcmQtbWQtaW1hZ2VdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLW1kLWltYWdlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkTWRJbWFnZSk7XG4gICAgcmV0dXJuIE1kQ2FyZE1kSW1hZ2U7XG59KCkpO1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqL1xudmFyIE1kQ2FyZExnSW1hZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZExnSW1hZ2UoKSB7XG4gICAgfVxuICAgIE1kQ2FyZExnSW1hZ2UgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtY2FyZC1sZy1pbWFnZV0sIFttYXQtY2FyZC1sZy1pbWFnZV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdjbGFzcy5tYXQtY2FyZC1sZy1pbWFnZSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkTGdJbWFnZSk7XG4gICAgcmV0dXJuIE1kQ2FyZExnSW1hZ2U7XG59KCkpO1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqL1xudmFyIE1kQ2FyZEltYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRJbWFnZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkSW1hZ2UgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtY2FyZC1pbWFnZV0sIFttYXQtY2FyZC1pbWFnZV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtaW1hZ2VdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRJbWFnZSk7XG4gICAgcmV0dXJuIE1kQ2FyZEltYWdlO1xufSgpKTtcbi8qKlxuICogTGFyZ2UgaW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKi9cbnZhciBNZENhcmRYbEltYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRYbEltYWdlKCkge1xuICAgIH1cbiAgICBNZENhcmRYbEltYWdlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC14bC1pbWFnZSwgbWF0LWNhcmQteGwtaW1hZ2UnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQteGwtaW1hZ2VdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRYbEltYWdlKTtcbiAgICByZXR1cm4gTWRDYXJkWGxJbWFnZTtcbn0oKSk7XG4vKipcbiAqIEF2YXRhciBpbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqL1xudmFyIE1kQ2FyZEF2YXRhciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkQXZhdGFyKCkge1xuICAgIH1cbiAgICBNZENhcmRBdmF0YXIgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWF2YXRhciwgbWF0LWNhcmQtYXZhdGFyJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLWF2YXRhcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZEF2YXRhcik7XG4gICAgcmV0dXJuIE1kQ2FyZEF2YXRhcjtcbn0oKSk7XG4vKipcbiAqIEEgYmFzaWMgY29udGVudCBjb250YWluZXIgY29tcG9uZW50IHRoYXQgYWRkcyB0aGUgc3R5bGVzIG9mIGEgTWF0ZXJpYWwgZGVzaWduIGNhcmQuXG4gKlxuICogV2hpbGUgdGhpcyBjb21wb25lbnQgY2FuIGJlIHVzZWQgYWxvbmUsIGl0IGFsc28gcHJvdmlkZXMgYSBudW1iZXJcbiAqIG9mIHByZXNldCBzdHlsZXMgZm9yIGNvbW1vbiBjYXJkIHNlY3Rpb25zLCBpbmNsdWRpbmc6XG4gKiAtIG1kLWNhcmQtdGl0bGVcbiAqIC0gbWQtY2FyZC1zdWJ0aXRsZVxuICogLSBtZC1jYXJkLWNvbnRlbnRcbiAqIC0gbWQtY2FyZC1hY3Rpb25zXG4gKiAtIG1kLWNhcmQtZm9vdGVyXG4gKi9cbnZhciBNZENhcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZCgpIHtcbiAgICB9XG4gICAgTWRDYXJkID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWNhcmQsIG1hdC1jYXJkJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1jYXJke2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKTt0cmFuc2l0aW9uOmJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKC40LDAsLjIsMSk7d2lsbC1jaGFuZ2U6Ym94LXNoYWRvdztkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6MjRweDtib3JkZXItcmFkaXVzOjJweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtY2FyZHtvdXRsaW5lOnNvbGlkIDFweH19Lm1hdC1jYXJkLWZsYXR7Ym94LXNoYWRvdzpub25lfS5tYXQtY2FyZC1hY3Rpb25zLC5tYXQtY2FyZC1jb250ZW50LC5tYXQtY2FyZC1zdWJ0aXRsZSwubWF0LWNhcmQtdGl0bGV7ZGlzcGxheTpibG9jazttYXJnaW4tYm90dG9tOjE2cHh9Lm1hdC1jYXJkLXRpdGxle2ZvbnQtc2l6ZToyNHB4O2ZvbnQtd2VpZ2h0OjQwMH0ubWF0LWNhcmQtY29udGVudCwubWF0LWNhcmQtaGVhZGVyIC5tYXQtY2FyZC10aXRsZSwubWF0LWNhcmQtc3VidGl0bGV7Zm9udC1zaXplOjE0cHh9Lm1hdC1jYXJkLWFjdGlvbnN7bWFyZ2luLWxlZnQ6LTE2cHg7bWFyZ2luLXJpZ2h0Oi0xNnB4O3BhZGRpbmc6OHB4IDB9Lm1hdC1jYXJkLWFjdGlvbnNbYWxpZ249ZW5kXXtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS5tYXQtY2FyZC1pbWFnZXt3aWR0aDpjYWxjKDEwMCUgKyA0OHB4KTttYXJnaW46MCAtMjRweCAxNnB4fS5tYXQtY2FyZC14bC1pbWFnZXt3aWR0aDoyNDBweDtoZWlnaHQ6MjQwcHg7bWFyZ2luOi04cHh9Lm1hdC1jYXJkLWZvb3Rlcntwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO21pbi1oZWlnaHQ6NXB4O2JvdHRvbTowO2xlZnQ6MH0ubWF0LWNhcmQtYWN0aW9ucyAubWF0LWJ1dHRvbiwubWF0LWNhcmQtYWN0aW9ucyAubWF0LXJhaXNlZC1idXR0b257bWFyZ2luOjAgNHB4fS5tYXQtY2FyZC1oZWFkZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdztoZWlnaHQ6NDBweDttYXJnaW46LThweCAwIDE2cHh9Lm1hdC1jYXJkLWhlYWRlci10ZXh0e2hlaWdodDo0MHB4O21hcmdpbjowIDhweH0ubWF0LWNhcmQtYXZhdGFye2hlaWdodDo0MHB4O3dpZHRoOjQwcHg7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1jYXJkLWxnLWltYWdlLC5tYXQtY2FyZC1tZC1pbWFnZSwubWF0LWNhcmQtc20taW1hZ2V7bWFyZ2luOi04cHggMH0ubWF0LWNhcmQtdGl0bGUtZ3JvdXB7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO21hcmdpbjowIC04cHh9Lm1hdC1jYXJkLXNtLWltYWdle3dpZHRoOjgwcHg7aGVpZ2h0OjgwcHh9Lm1hdC1jYXJkLW1kLWltYWdle3dpZHRoOjExMnB4O2hlaWdodDoxMTJweH0ubWF0LWNhcmQtbGctaW1hZ2V7d2lkdGg6MTUycHg7aGVpZ2h0OjE1MnB4fUBtZWRpYSAobWF4LXdpZHRoOjYwMHB4KXsubWF0LWNhcmR7cGFkZGluZzoyNHB4IDE2cHh9Lm1hdC1jYXJkLWFjdGlvbnN7bWFyZ2luLWxlZnQ6LThweDttYXJnaW4tcmlnaHQ6LThweH0ubWF0LWNhcmQtaW1hZ2V7d2lkdGg6Y2FsYygxMDAlICsgMzJweCk7bWFyZ2luOjE2cHggLTE2cHh9Lm1hdC1jYXJkLXRpdGxlLWdyb3Vwe21hcmdpbjowfS5tYXQtY2FyZC14bC1pbWFnZXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5tYXQtY2FyZC1oZWFkZXJ7bWFyZ2luOi04cHggMCAwfX0ubWF0LWNhcmQtY29udGVudD46Zmlyc3QtY2hpbGQsLm1hdC1jYXJkPjpmaXJzdC1jaGlsZHttYXJnaW4tdG9wOjB9Lm1hdC1jYXJkLWNvbnRlbnQ+Omxhc3QtY2hpbGQsLm1hdC1jYXJkPjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0ubWF0LWNhcmQtaW1hZ2U6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDotMjRweH0ubWF0LWNhcmQ+Lm1hdC1jYXJkLWFjdGlvbnM6bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOi0xNnB4O3BhZGRpbmctYm90dG9tOjB9Lm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1idXR0b246Zmlyc3QtY2hpbGQsLm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1yYWlzZWQtYnV0dG9uOmZpcnN0LWNoaWxke21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9Lm1hdC1jYXJkLXN1YnRpdGxlOm5vdCg6Zmlyc3QtY2hpbGQpLC5tYXQtY2FyZC10aXRsZTpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tdG9wOi00cHh9Lm1hdC1jYXJkLWhlYWRlciAubWF0LWNhcmQtc3VidGl0bGU6bm90KDpmaXJzdC1jaGlsZCksLm1hdC1jYXJkPi5tYXQtY2FyZC14bC1pbWFnZTpmaXJzdC1jaGlsZHttYXJnaW4tdG9wOi04cHh9Lm1hdC1jYXJkPi5tYXQtY2FyZC14bC1pbWFnZTpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206LThweH1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmRdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmQpO1xuICAgIHJldHVybiBNZENhcmQ7XG59KCkpO1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gdGhlIGA8bWQtY2FyZD5gIGNvbXBvbmVudC4gSXQgYWRkcyBzdHlsZXMgZm9yIGFcbiAqIHByZXNldCBoZWFkZXIgc2VjdGlvbiAoaS5lLiBhIHRpdGxlLCBzdWJ0aXRsZSwgYW5kIGF2YXRhciBsYXlvdXQpLlxuICovXG52YXIgTWRDYXJkSGVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRIZWFkZXIoKSB7XG4gICAgfVxuICAgIE1kQ2FyZEhlYWRlciA9IF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1jYXJkLWhlYWRlciwgbWF0LWNhcmQtaGVhZGVyJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWNhcmQtYXZhdGFyXSwgW21hdC1jYXJkLWF2YXRhcl1cXFwiPjwvbmctY29udGVudD48ZGl2IGNsYXNzPVxcXCJtYXQtY2FyZC1oZWFkZXItdGV4dFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1jYXJkLXRpdGxlLCBtYXQtY2FyZC10aXRsZSwgbWQtY2FyZC1zdWJ0aXRsZSwgbWF0LWNhcmQtc3VidGl0bGVcXFwiPjwvbmctY29udGVudD48L2Rpdj48bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtaGVhZGVyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkSGVhZGVyKTtcbiAgICByZXR1cm4gTWRDYXJkSGVhZGVyO1xufSgpKTtcbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIHRoZSA8bWQtY2FyZD4gY29tcG9uZW50LiBJdCBhZGRzIHN0eWxlcyBmb3IgYSBwcmVzZXRcbiAqIGxheW91dCB0aGF0IGdyb3VwcyBhbiBpbWFnZSB3aXRoIGEgdGl0bGUgc2VjdGlvbi5cbiAqL1xudmFyIE1kQ2FyZFRpdGxlR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZFRpdGxlR3JvdXAoKSB7XG4gICAgfVxuICAgIE1kQ2FyZFRpdGxlR3JvdXAgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtY2FyZC10aXRsZS1ncm91cCwgbWF0LWNhcmQtdGl0bGUtZ3JvdXAnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWNhcmQtdGl0bGUsIG1hdC1jYXJkLXRpdGxlLCBtZC1jYXJkLXN1YnRpdGxlLCBtYXQtY2FyZC1zdWJ0aXRsZVxcXCI+PC9uZy1jb250ZW50PjwvZGl2PjxuZy1jb250ZW50IHNlbGVjdD1cXFwiaW1nXFxcIj48L25nLWNvbnRlbnQ+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLXRpdGxlLWdyb3VwXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkVGl0bGVHcm91cCk7XG4gICAgcmV0dXJuIE1kQ2FyZFRpdGxlR3JvdXA7XG59KCkpO1xudmFyIE1kQ2FyZE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZENhcmRNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZENhcmRNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZENhcmRNb2R1bGUgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTWRDYXJkLFxuICAgICAgICAgICAgICAgIE1kQ2FyZEhlYWRlcixcbiAgICAgICAgICAgICAgICBNZENhcmRUaXRsZUdyb3VwLFxuICAgICAgICAgICAgICAgIE1kQ2FyZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgTWRDYXJkVGl0bGUsXG4gICAgICAgICAgICAgICAgTWRDYXJkU3VidGl0bGUsXG4gICAgICAgICAgICAgICAgTWRDYXJkQWN0aW9ucyxcbiAgICAgICAgICAgICAgICBNZENhcmRGb290ZXIsXG4gICAgICAgICAgICAgICAgTWRDYXJkU21JbWFnZSxcbiAgICAgICAgICAgICAgICBNZENhcmRNZEltYWdlLFxuICAgICAgICAgICAgICAgIE1kQ2FyZExnSW1hZ2UsXG4gICAgICAgICAgICAgICAgTWRDYXJkSW1hZ2UsXG4gICAgICAgICAgICAgICAgTWRDYXJkWGxJbWFnZSxcbiAgICAgICAgICAgICAgICBNZENhcmRBdmF0YXIsXG4gICAgICAgICAgICAgICAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBNZENhcmQsIE1kQ2FyZEhlYWRlciwgTWRDYXJkVGl0bGVHcm91cCwgTWRDYXJkQ29udGVudCwgTWRDYXJkVGl0bGUsIE1kQ2FyZFN1YnRpdGxlLFxuICAgICAgICAgICAgICAgIE1kQ2FyZEFjdGlvbnMsIE1kQ2FyZEZvb3RlciwgTWRDYXJkU21JbWFnZSwgTWRDYXJkTWRJbWFnZSwgTWRDYXJkTGdJbWFnZSwgTWRDYXJkSW1hZ2UsXG4gICAgICAgICAgICAgICAgTWRDYXJkWGxJbWFnZSwgTWRDYXJkQXZhdGFyLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZE1vZHVsZSk7XG4gICAgcmV0dXJuIE1kQ2FyZE1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDQ1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIE1hdGVyaWFsIGRlc2lnbiBzdHlsZWQgQ2hpcCBjb21wb25lbnQuIFVzZWQgaW5zaWRlIHRoZSBNZENoaXBMaXN0IGNvbXBvbmVudC5cbiAqL1xudmFyIE1kQ2hpcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGlwKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBjaGlwIGlzIGRpc2FibGVkLiBEaXNhYmxlZCBjaGlwcyBjYW5ub3QgYmUgZm9jdXNlZC4gKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIGNoaXAgaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgcGFsZXR0ZSBjb2xvciBvZiBzZWxlY3RlZCBjaGlwcy4gKi9cbiAgICAgICAgdGhpcy5fY29sb3IgPSAncHJpbWFyeSc7XG4gICAgICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIGNoaXAgaXMgZm9jdXNlZC4gKi9cbiAgICAgICAgdGhpcy5vbkZvY3VzID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIGNoaXAgaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIGNoaXAgaXMgZGVzZWxlY3RlZC4gKi9cbiAgICAgICAgdGhpcy5kZXNlbGVjdCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBjaGlwIGlzIGRlc3Ryb3llZC4gKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE1kQ2hpcC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FkZERlZmF1bHRDU1NDbGFzcygpO1xuICAgICAgICB0aGlzLl91cGRhdGVDb2xvcih0aGlzLl9jb2xvcik7XG4gICAgfTtcbiAgICBNZENoaXAucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kuZW1pdCh7IGNoaXA6IHRoaXMgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGlwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgY2hpcCBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBTZXRzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgY2hpcC4gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKSA/IHRydWUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGlwLnByb3RvdHlwZSwgXCJfaXNBcmlhRGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogQSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgZGlzYWJsZWQgc3RhdGUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhjb2VyY2VCb29sZWFuUHJvcGVydHkodGhpcy5kaXNhYmxlZCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGlwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGNoaXAgaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh7IGNoaXA6IHRoaXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0LmVtaXQoeyBjaGlwOiB0aGlzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBjdXJyZW50IHNlbGVjdGVkIHN0YXRlIG9mIHRoaXMgY2hpcC5cbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIGNoaXAgaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS50b2dnbGVTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9ICF0aGlzLnNlbGVjdGVkO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoaXAucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgY2hpcC4gQ2FuIGJlIGBwcmltYXJ5YCwgYGFjY2VudGAsIG9yIGB3YXJuYC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBBbGxvd3MgZm9yIHByb2dyYW1tYXRpYyBmb2N1c2luZyBvZiB0aGUgY2hpcC4gKi9cbiAgICBNZENoaXAucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgICAgIHRoaXMub25Gb2N1cy5lbWl0KHsgY2hpcDogdGhpcyB9KTtcbiAgICB9O1xuICAgIC8qKiBFbnN1cmVzIGV2ZW50cyBmaXJlIHByb3Blcmx5IHVwb24gY2xpY2suICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5faGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgZGlzYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEluaXRpYWxpemVzIHRoZSBhcHByb3ByaWF0ZSBDU1MgY2xhc3NlcyBiYXNlZCBvbiB0aGUgY2hpcCB0eXBlIChiYXNpYyBvciBzdGFuZGFyZCkuICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5fYWRkRGVmYXVsdENTU0NsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIEFsd2F5cyBhZGQgdGhlIGBtYXQtY2hpcGAgY2xhc3NcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbWF0LWNoaXAnKTtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGEgYmFzaWMgY2hpcCwgYWxzbyBhZGQgdGhlIGBtYXQtYmFzaWMtY2hpcGAgY2xhc3MgZm9yIDpub3QoKSB0YXJnZXRpbmdcbiAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ21hdC1iYXNpYy1jaGlwJyB8fCBlbC5oYXNBdHRyaWJ1dGUoJ21hdC1iYXNpYy1jaGlwJykgfHxcbiAgICAgICAgICAgIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ21kLWJhc2ljLWNoaXAnIHx8IGVsLmhhc0F0dHJpYnV0ZSgnbWQtYmFzaWMtY2hpcCcpKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdtYXQtYmFzaWMtY2hpcCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgcHJpdmF0ZSBfY29sb3IgdmFyaWFibGUgYW5kIHRoZSBuYXRpdmUgZWxlbWVudC4gKi9cbiAgICBNZENoaXAucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSBtYXQtY29sb3Igb24gdGhlIG5hdGl2ZSBlbGVtZW50LiAqL1xuICAgIE1kQ2hpcC5wcm90b3R5cGUuX3NldEVsZW1lbnRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwgJiYgY29sb3IgIT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgY29sb3IsIGlzQWRkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ1KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZENoaXAucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRDaGlwLnByb3RvdHlwZSwgXCJkZXNlbGVjdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRDaGlwLnByb3RvdHlwZSwgXCJkZXN0cm95XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ0NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDUoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZENoaXAucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ1KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRDaGlwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRDaGlwLnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBNZENoaXAgPSBfX2RlY29yYXRlJDQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe1xuICAgICAgICAgICAgc2VsZWN0b3I6IFwibWQtYmFzaWMtY2hpcCwgW21kLWJhc2ljLWNoaXBdLCBtZC1jaGlwLCBbbWQtY2hpcF0sXFxuICAgICAgICAgICAgIG1hdC1iYXNpYy1jaGlwLCBbbWF0LWJhc2ljLWNoaXBdLCBtYXQtY2hpcCwgW21hdC1jaGlwXVwiLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoaXBdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICctMScsXG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnb3B0aW9uJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGlwLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ19pc0FyaWFEaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJyhjbGljayknOiAnX2hhbmRsZUNsaWNrKCRldmVudCknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZENoaXApO1xuICAgIHJldHVybiBNZENoaXA7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ0NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0NCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBBIG1hdGVyaWFsIGRlc2lnbiBjaGlwcyBjb21wb25lbnQgKG5hbWVkIENoaXBMaXN0IGZvciBpdCdzIHNpbWlsYXJpdHkgdG8gdGhlIExpc3QgY29tcG9uZW50KS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA8bWQtY2hpcC1saXN0PlxuICogICAgICAgPG1kLWNoaXA+Q2hpcCAxPG1kLWNoaXA+XG4gKiAgICAgICA8bWQtY2hpcD5DaGlwIDI8bWQtY2hpcD5cbiAqICAgICA8L21kLWNoaXAtbGlzdD5cbiAqL1xudmFyIE1kQ2hpcExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hpcExpc3QoX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKiogVHJhY2sgd2hpY2ggY2hpcHMgd2UncmUgbGlzdGVuaW5nIHRvIGZvciBmb2N1cy9kZXN0cnVjdGlvbi4gKi9cbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlZCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgY2hpcCBpcyBzZWxlY3RhYmxlLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcih0aGlzLmNoaXBzKS53aXRoV3JhcCgpO1xuICAgICAgICAvLyBHbyBhaGVhZCBhbmQgc3Vic2NyaWJlIGFsbCBvZiB0aGUgaW5pdGlhbCBjaGlwc1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVDaGlwcyh0aGlzLmNoaXBzKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgbGlzdCBjaGFuZ2VzLCByZS1zdWJzY3JpYmVcbiAgICAgICAgdGhpcy5jaGlwcy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoY2hpcHMpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmVDaGlwcyhjaGlwcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hpcExpc3QucHJvdG90eXBlLCBcInNlbGVjdGFibGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBjaGlwIGlzIHNlbGVjdGFibGUuIFdoZW4gYSBjaGlwIGlzIG5vdCBzZWxlY3RhYmxlLFxuICAgICAgICAgKiBpdCdzIHNlbGVjdGVkIHN0YXRlIGlzIGFsd2F5cyBpZ25vcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGFibGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBjaGlwIGxpc3QuIFRoaXMgaW4gdHVybiBmb2N1c2VzIHRoZSBmaXJzdFxuICAgICAqIG5vbi1kaXNhYmxlZCBjaGlwIGluIHRoaXMgY2hpcCBsaXN0LlxuICAgICAqL1xuICAgIE1kQ2hpcExpc3QucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBBUklBIHNheXMgdGhpcyBzaG91bGQgZm9jdXMgdGhlIGZpcnN0IGBzZWxlY3RlZGAgY2hpcC5cbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICB9O1xuICAgIC8qKiBQYXNzZXMgcmVsZXZhbnQga2V5IHByZXNzZXMgdG8gb3VyIGtleSBtYW5hZ2VyLiAqL1xuICAgIE1kQ2hpcExpc3QucHJvdG90eXBlLl9rZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIC8vIElmIHRoZXkgYXJlIG9uIGEgY2hpcCwgY2hlY2sgZm9yIHNwYWNlL2xlZnQvcmlnaHQsIG90aGVyd2lzZSBwYXNzIHRvIG91ciBrZXkgbWFuYWdlclxuICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21hdC1jaGlwJykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBzZWxlY3RhYmxlLCB0b2dnbGUgdGhlIGZvY3VzZWQgY2hpcFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVTZWxlY3RPbkZvY3VzZWRDaGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHByZXZlbnQgc3BhY2UgZnJvbSBzY3JvbGxpbmcgdGhlIHBhZ2Ugc2luY2UgdGhlIGxpc3QgaGFzIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRQcmV2aW91c0l0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXROZXh0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBUb2dnbGVzIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgY3VycmVudGx5IGZvY3VzZWQgY2hpcC4gKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5fdG9nZ2xlU2VsZWN0T25Gb2N1c2VkQ2hpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQWxsb3cgZGlzYWJsaW5nIG9mIGNoaXAgc2VsZWN0aW9uXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvY3VzZWRJbmRleCA9IHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbUluZGV4O1xuICAgICAgICBpZiAodGhpcy5faXNWYWxpZEluZGV4KGZvY3VzZWRJbmRleCkpIHtcbiAgICAgICAgICAgIHZhciBmb2N1c2VkQ2hpcCA9IHRoaXMuY2hpcHMudG9BcnJheSgpW2ZvY3VzZWRJbmRleF07XG4gICAgICAgICAgICBpZiAoZm9jdXNlZENoaXApIHtcbiAgICAgICAgICAgICAgICBmb2N1c2VkQ2hpcC50b2dnbGVTZWxlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgY2hpcHMgYW5kIGFkZCB0aGVtIHRvIG91ciBsaXN0IG9mXG4gICAgICogc3Vic2NyaWJlZCBjaGlwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGlwcyBUaGUgbGlzdCBvZiBjaGlwcyB0byBiZSBzdWJzY3JpYmVkLlxuICAgICAqL1xuICAgIE1kQ2hpcExpc3QucHJvdG90eXBlLl9zdWJzY3JpYmVDaGlwcyA9IGZ1bmN0aW9uIChjaGlwcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjaGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlwKSB7IHJldHVybiBfdGhpcy5fYWRkQ2hpcChjaGlwKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBzcGVjaWZpYyBjaGlwIHRvIG91ciBzdWJzY3JpYmVkIGxpc3QuIElmIHRoZSBjaGlwIGhhc1xuICAgICAqIGFscmVhZHkgYmVlbiBzdWJzY3JpYmVkLCB0aGlzIGVuc3VyZXMgaXQgaXMgb25seSBzdWJzY3JpYmVkXG4gICAgICogb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGlwIFRoZSBjaGlwIHRvIGJlIHN1YnNjcmliZWQgKG9yIGNoZWNrZWQgZm9yIGV4aXN0aW5nXG4gICAgICogc3Vic2NyaXB0aW9uKS5cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5fYWRkQ2hpcCA9IGZ1bmN0aW9uIChjaGlwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgYmVlbiBzdWJzY3JpYmVkIHRvIGEgcGFyZW50LCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpYmVkLmhhcyhjaGlwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhdGNoIGZvciBmb2N1cyBldmVudHMgb3V0c2lkZSBvZiB0aGUga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgICAgICBjaGlwLm9uRm9jdXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGlwSW5kZXggPSBfdGhpcy5jaGlwcy50b0FycmF5KCkuaW5kZXhPZihjaGlwKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNWYWxpZEluZGV4KGNoaXBJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fa2V5TWFuYWdlci51cGRhdGVBY3RpdmVJdGVtSW5kZXgoY2hpcEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9uIGRlc3Ryb3ksIHJlbW92ZSB0aGUgaXRlbSBmcm9tIG91ciBsaXN0LCBhbmQgY2hlY2sgZm9jdXNcbiAgICAgICAgY2hpcC5kZXN0cm95LnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpcEluZGV4ID0gX3RoaXMuY2hpcHMudG9BcnJheSgpLmluZGV4T2YoY2hpcCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzVmFsaWRJbmRleChjaGlwSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgY2hpcCBpcyB0aGUgbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKGNoaXBJbmRleCA8IF90aGlzLmNoaXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShjaGlwSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlwSW5kZXggLSAxID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShjaGlwSW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlZC5kZWxldGUoY2hpcCk7XG4gICAgICAgICAgICBjaGlwLmRlc3Ryb3kudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZWQuc2V0KGNoaXAsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBlbnN1cmUgYWxsIGluZGV4ZXMgYXJlIHZhbGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGluZGV4IGlzIHZhbGlkIGZvciBvdXIgbGlzdCBvZiBjaGlwcy5cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5faXNWYWxpZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5jaGlwcy5sZW5ndGg7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQ0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NCgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQ2hpcExpc3QucHJvdG90eXBlLCBcInNlbGVjdGFibGVcIiwgbnVsbCk7XG4gICAgTWRDaGlwTGlzdCA9IF9fZGVjb3JhdGUkNDQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1jaGlwLWxpc3QsIG1hdC1jaGlwLWxpc3QnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWQtY2hpcC1saXN0LXdyYXBwZXJcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3Rib3gnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoaXAtbGlzdF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgLy8gRXZlbnRzXG4gICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnZm9jdXMoKScsXG4gICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdfa2V5ZG93bigkZXZlbnQpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgICAgICAgICBjaGlwczogbmV3IF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kQ2hpcClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtY2hpcC1saXN0LXdyYXBwZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdztmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0fS5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe21hcmdpbjowIDNweH0ubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKTpmaXJzdC1jaGlsZHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDozcHh9Lm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCk6bGFzdC1jaGlsZCxbZGlyPXJ0bF0gLm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCk6Zmlyc3QtY2hpbGR7bWFyZ2luLWxlZnQ6M3B4O21hcmdpbi1yaWdodDowfVtkaXI9cnRsXSAubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKTpsYXN0LWNoaWxke21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjNweH0ubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCl7ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzo4cHggMTJweDtib3JkZXItcmFkaXVzOjI0cHg7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MTZweH0ubWF0LWNoaXAtbGlzdC1zdGFja2VkIC5tYXQtY2hpcC1saXN0LXdyYXBwZXJ7ZGlzcGxheTpibG9ja30ubWF0LWNoaXAtbGlzdC1zdGFja2VkIC5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjAgMCA4cHh9W2Rpcj1ydGxdIC5tYXQtY2hpcC1saXN0LXN0YWNrZWQgLm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCl7bWFyZ2luOjAgMCA4cHh9Lm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKTpsYXN0LWNoaWxkLFtkaXI9cnRsXSAubWF0LWNoaXAtbGlzdC1zdGFja2VkIC5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTowfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ0KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kQ2hpcExpc3QpO1xuICAgIHJldHVybiBNZENoaXBMaXN0O1xufSgpKTtcbnZhciBNZENoaXBzTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoaXBzTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZENoaXBzTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRDaGlwc01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kQ2hpcHNNb2R1bGUgPSBfX2RlY29yYXRlJDQ0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZENoaXBMaXN0LCBNZENoaXBdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRDaGlwTGlzdCwgTWRDaGlwXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDaGlwc01vZHVsZSk7XG4gICAgcmV0dXJuIE1kQ2hpcHNNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDEzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDQ3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGxvYWQgYW4gaWNvbiB3aXRoIGEgbmFtZSB0aGF0IGNhbm5vdCBiZSBmb3VuZC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTMoTWRJY29uTmFtZU5vdEZvdW5kRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRJY29uTmFtZU5vdEZvdW5kRXJyb3IoaWNvbk5hbWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJVbmFibGUgdG8gZmluZCBpY29uIHdpdGggdGhlIG5hbWUgXFxcIlwiICsgaWNvbk5hbWUgKyBcIlxcXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25OYW1lTm90Rm91bmRFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBsb2FkIFNWRyBjb250ZW50IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgZXhwZWN0ZWRcbiAqIDxzdmc+IHRhZy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kSWNvblN2Z1RhZ05vdEZvdW5kRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMyhNZEljb25TdmdUYWdOb3RGb3VuZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSWNvblN2Z1RhZ05vdEZvdW5kRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICc8c3ZnPiB0YWcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25TdmdUYWdOb3RGb3VuZEVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGFuIGljb24sIGluY2x1ZGluZyB0aGUgVVJMIGFuZCBwb3NzaWJseSB0aGUgY2FjaGVkIFNWRyBlbGVtZW50LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgU3ZnSWNvbkNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3ZnSWNvbkNvbmZpZyh1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBTdmdJY29uQ29uZmlnO1xufSgpKTtcbi8qKiBSZXR1cm5zIHRoZSBjYWNoZSBrZXkgdG8gdXNlIGZvciBhbiBpY29uIG5hbWVzcGFjZSBhbmQgbmFtZS4gKi9cbnZhciBpY29uS2V5ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbmFtZSkgeyByZXR1cm4gbmFtZXNwYWNlICsgJzonICsgbmFtZTsgfTtcbi8qKlxuICogU2VydmljZSB0byByZWdpc3RlciBhbmQgZGlzcGxheSBpY29ucyB1c2VkIGJ5IHRoZSA8bWQtaWNvbj4gY29tcG9uZW50LlxuICogLSBSZWdpc3RlcnMgaWNvbiBVUkxzIGJ5IG5hbWVzcGFjZSBhbmQgbmFtZS5cbiAqIC0gUmVnaXN0ZXJzIGljb24gc2V0IFVSTHMgYnkgbmFtZXNwYWNlLlxuICogLSBSZWdpc3RlcnMgYWxpYXNlcyBmb3IgQ1NTIGNsYXNzZXMsIGZvciB1c2Ugd2l0aCBpY29uIGZvbnRzLlxuICogLSBMb2FkcyBpY29ucyBmcm9tIFVSTHMgYW5kIGV4dHJhY3RzIGluZGl2aWR1YWwgaWNvbnMgZnJvbSBpY29uIHNldHMuXG4gKi9cbnZhciBNZEljb25SZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRJY29uUmVnaXN0cnkoX2h0dHAsIF9zYW5pdGl6ZXIpIHtcbiAgICAgICAgdGhpcy5faHR0cCA9IF9odHRwO1xuICAgICAgICB0aGlzLl9zYW5pdGl6ZXIgPSBfc2FuaXRpemVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVVJMcyBhbmQgY2FjaGVkIFNWRyBlbGVtZW50cyBmb3IgaW5kaXZpZHVhbCBpY29ucy4gS2V5cyBhcmUgb2YgdGhlIGZvcm1hdCBcIltuYW1lc3BhY2VdOltpY29uXVwiLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3ZnSWNvbkNvbmZpZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdmdJY29uQ29uZmlnIG9iamVjdHMgYW5kIGNhY2hlZCBTVkcgZWxlbWVudHMgZm9yIGljb24gc2V0cywga2V5ZWQgYnkgbmFtZXNwYWNlLlxuICAgICAgICAgKiBNdWx0aXBsZSBpY29uIHNldHMgY2FuIGJlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNhbWUgbmFtZXNwYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faWNvblNldENvbmZpZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBDYWNoZSBmb3IgaWNvbnMgbG9hZGVkIGJ5IGRpcmVjdCBVUkxzLiAqL1xuICAgICAgICB0aGlzLl9jYWNoZWRJY29uc0J5VXJsID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogSW4tcHJvZ3Jlc3MgaWNvbiBmZXRjaGVzLiBVc2VkIHRvIGNvYWxlc2NlIG11bHRpcGxlIHJlcXVlc3RzIHRvIHRoZSBzYW1lIFVSTC4gKi9cbiAgICAgICAgdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBNYXAgZnJvbSBmb250IGlkZW50aWZpZXJzIHRvIHRoZWlyIENTUyBjbGFzcyBuYW1lcy4gVXNlZCBmb3IgaWNvbiBmb250cy4gKi9cbiAgICAgICAgdGhpcy5fZm9udENzc0NsYXNzZXNCeUFsaWFzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIENTUyBjbGFzcyB0byBhcHBseSB3aGVuIGFuIDxtZC1pY29uPiBjb21wb25lbnQgaGFzIG5vIGljb24gbmFtZSwgdXJsLCBvciBmb250IHNwZWNpZmllZC5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgJ21hdGVyaWFsLWljb25zJyB2YWx1ZSBhc3N1bWVzIHRoYXQgdGhlIG1hdGVyaWFsIGljb24gZm9udCBoYXMgYmVlbiBsb2FkZWQgYXNcbiAgICAgICAgICogZGVzY3JpYmVkIGF0IGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29ucy8jaWNvbi1mb250LWZvci10aGUtd2ViXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZWZhdWx0Rm9udFNldENsYXNzID0gJ21hdGVyaWFsLWljb25zJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gYnkgVVJMIGluIHRoZSBkZWZhdWx0IG5hbWVzcGFjZS5cbiAgICAgKiBAcGFyYW0gaWNvbk5hbWUgTmFtZSB1bmRlciB3aGljaCB0aGUgaWNvbiBzaG91bGQgYmUgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmFkZFN2Z0ljb24gPSBmdW5jdGlvbiAoaWNvbk5hbWUsIHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTdmdJY29uSW5OYW1lc3BhY2UoJycsIGljb25OYW1lLCB1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gYnkgVVJMIGluIHRoZSBzcGVjaWZpZWQgbmFtZXNwYWNlLlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgTmFtZXNwYWNlIGluIHdoaWNoIHRoZSBpY29uIHNob3VsZCBiZSByZWdpc3RlcmVkLlxuICAgICAqIEBwYXJhbSBpY29uTmFtZSBOYW1lIHVuZGVyIHdoaWNoIHRoZSBpY29uIHNob3VsZCBiZSByZWdpc3RlcmVkLlxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuYWRkU3ZnSWNvbkluTmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgaWNvbk5hbWUsIHVybCkge1xuICAgICAgICB2YXIga2V5ID0gaWNvbktleShuYW1lc3BhY2UsIGljb25OYW1lKTtcbiAgICAgICAgdGhpcy5fc3ZnSWNvbkNvbmZpZ3Muc2V0KGtleSwgbmV3IFN2Z0ljb25Db25maWcodXJsKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gc2V0IGJ5IFVSTCBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRTdmdJY29uU2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UoJycsIHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaWNvbiBzZXQgYnkgVVJMIGluIHRoZSBzcGVjaWZpZWQgbmFtZXNwYWNlLlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgTmFtZXNwYWNlIGluIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBpY29uIHNldC5cbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmFkZFN2Z0ljb25TZXRJbk5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIHVybCkge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IFN2Z0ljb25Db25maWcodXJsKTtcbiAgICAgICAgaWYgKHRoaXMuX2ljb25TZXRDb25maWdzLmhhcyhuYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uU2V0Q29uZmlncy5nZXQobmFtZXNwYWNlKS5wdXNoKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pY29uU2V0Q29uZmlncy5zZXQobmFtZXNwYWNlLCBbY29uZmlnXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGFuIGFsaWFzIGZvciBhIENTUyBjbGFzcyBuYW1lIHRvIGJlIHVzZWQgZm9yIGljb24gZm9udHMuIENyZWF0aW5nIGFuIG1kSWNvblxuICAgICAqIGNvbXBvbmVudCB3aXRoIHRoZSBhbGlhcyBhcyB0aGUgZm9udFNldCBpbnB1dCB3aWxsIGNhdXNlIHRoZSBjbGFzcyBuYW1lIHRvIGJlIGFwcGxpZWRcbiAgICAgKiB0byB0aGUgPG1kLWljb24+IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWxpYXMgQWxpYXMgZm9yIHRoZSBmb250LlxuICAgICAqIEBwYXJhbSBjbGFzc05hbWUgQ2xhc3MgbmFtZSBvdmVycmlkZSB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGFsaWFzLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlckZvbnRDbGFzc0FsaWFzID0gZnVuY3Rpb24gKGFsaWFzLCBjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gdm9pZCAwKSB7IGNsYXNzTmFtZSA9IGFsaWFzOyB9XG4gICAgICAgIHRoaXMuX2ZvbnRDc3NDbGFzc2VzQnlBbGlhcy5zZXQoYWxpYXMsIGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQ1NTIGNsYXNzIG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhbGlhcyBieSBhIHByZXZpb3VzIGNhbGwgdG9cbiAgICAgKiByZWdpc3RlckZvbnRDbGFzc0FsaWFzLiBJZiBubyBDU1MgY2xhc3MgaGFzIGJlZW4gYXNzb2NpYXRlZCwgcmV0dXJucyB0aGUgYWxpYXMgdW5tb2RpZmllZC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuY2xhc3NOYW1lRm9yRm9udEFsaWFzID0gZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250Q3NzQ2xhc3Nlc0J5QWxpYXMuZ2V0KGFsaWFzKSB8fCBhbGlhcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIENTUyBjbGFzcyBuYW1lIHRvIGJlIHVzZWQgZm9yIGljb24gZm9udHMgd2hlbiBhbiA8bWQtaWNvbj4gY29tcG9uZW50IGRvZXMgbm90XG4gICAgICogaGF2ZSBhIGZvbnRTZXQgaW5wdXQgdmFsdWUsIGFuZCBpcyBub3QgbG9hZGluZyBhbiBpY29uIGJ5IG5hbWUgb3IgVVJMLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5zZXREZWZhdWx0Rm9udFNldENsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0Rm9udFNldENsYXNzID0gY2xhc3NOYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIENTUyBjbGFzcyBuYW1lIHRvIGJlIHVzZWQgZm9yIGljb24gZm9udHMgd2hlbiBhbiA8bWQtaWNvbj4gY29tcG9uZW50IGRvZXMgbm90XG4gICAgICogaGF2ZSBhIGZvbnRTZXQgaW5wdXQgdmFsdWUsIGFuZCBpcyBub3QgbG9hZGluZyBhbiBpY29uIGJ5IG5hbWUgb3IgVVJMLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXREZWZhdWx0Rm9udFNldENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEZvbnRTZXRDbGFzcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHByb2R1Y2VzIHRoZSBpY29uIChhcyBhbiA8c3ZnPiBET00gZWxlbWVudCkgZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICAgICAqIFRoZSByZXNwb25zZSBmcm9tIHRoZSBVUkwgbWF5IGJlIGNhY2hlZCBzbyB0aGlzIHdpbGwgbm90IGFsd2F5cyBjYXVzZSBhbiBIVFRQIHJlcXVlc3QsIGJ1dFxuICAgICAqIHRoZSBwcm9kdWNlZCBlbGVtZW50IHdpbGwgYWx3YXlzIGJlIGEgbmV3IGNvcHkgb2YgdGhlIG9yaWdpbmFsbHkgZmV0Y2hlZCBpY29uLiAoVGhhdCBpcyxcbiAgICAgKiBpdCB3aWxsIG5vdCBjb250YWluIGFueSBtb2RpZmljYXRpb25zIG1hZGUgdG8gZWxlbWVudHMgcHJldmlvdXNseSByZXR1cm5lZCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2FmZVVybCBVUkwgZnJvbSB3aGljaCB0byBmZXRjaCB0aGUgU1ZHIGljb24uXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmdldFN2Z0ljb25Gcm9tVXJsID0gZnVuY3Rpb24gKHNhZmVVcmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuX3Nhbml0aXplci5zYW5pdGl6ZShfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIHNhZmVVcmwpO1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkSWNvbnNCeVVybC5oYXModXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLm9mKGNsb25lU3ZnKHRoaXMuX2NhY2hlZEljb25zQnlVcmwuZ2V0KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFN2Z0ljb25Gcm9tQ29uZmlnKG5ldyBTdmdJY29uQ29uZmlnKHVybCkpXG4gICAgICAgICAgICAuZG8oZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gX3RoaXMuX2NhY2hlZEljb25zQnlVcmwuc2V0KHVybCwgc3ZnKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gY2xvbmVTdmcoc3ZnKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBwcm9kdWNlcyB0aGUgaWNvbiAoYXMgYW4gPHN2Zz4gRE9NIGVsZW1lbnQpIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICAgKiBhbmQgbmFtZXNwYWNlLiBUaGUgaWNvbiBtdXN0IGhhdmUgYmVlbiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRJY29uIG9yIGFkZEljb25TZXQ7XG4gICAgICogaWYgbm90LCB0aGUgT2JzZXJ2YWJsZSB3aWxsIHRocm93IGFuIE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgaWNvbiB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtIG5hbWVzcGFjZSBOYW1lc3BhY2UgaW4gd2hpY2ggdG8gbG9vayBmb3IgdGhlIGljb24uXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmdldE5hbWVkU3ZnSWNvbiA9IGZ1bmN0aW9uIChuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdm9pZCAwKSB7IG5hbWVzcGFjZSA9ICcnOyB9XG4gICAgICAgIC8vIFJldHVybiAoY29weSBvZikgY2FjaGVkIGljb24gaWYgcG9zc2libGUuXG4gICAgICAgIHZhciBrZXkgPSBpY29uS2V5KG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICAgIGlmICh0aGlzLl9zdmdJY29uQ29uZmlncy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN2Z0Zyb21Db25maWcodGhpcy5fc3ZnSWNvbkNvbmZpZ3MuZ2V0KGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBpZiB3ZSBoYXZlIGFueSBpY29uIHNldHMgcmVnaXN0ZXJlZCBmb3IgdGhlIG5hbWVzcGFjZS5cbiAgICAgICAgdmFyIGljb25TZXRDb25maWdzID0gdGhpcy5faWNvblNldENvbmZpZ3MuZ2V0KG5hbWVzcGFjZSk7XG4gICAgICAgIGlmIChpY29uU2V0Q29uZmlncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN2Z0Zyb21JY29uU2V0Q29uZmlncyhuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLnRocm93KG5ldyBNZEljb25OYW1lTm90Rm91bmRFcnJvcihrZXkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhY2hlZCBpY29uIGZvciBhIFN2Z0ljb25Db25maWcgaWYgYXZhaWxhYmxlLCBvciBmZXRjaGVzIGl0IGZyb20gaXRzIFVSTCBpZiBub3QuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9nZXRTdmdGcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgU1ZHIGVsZW1lbnQgZm9yIHRoaXMgaWNvbiwgcmV0dXJuIGEgY29weS5cbiAgICAgICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5vZihjbG9uZVN2Zyhjb25maWcuc3ZnRWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGljb24gZnJvbSB0aGUgY29uZmlnJ3MgVVJMLCBjYWNoZSBpdCwgYW5kIHJldHVybiBhIGNvcHkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFN2Z0ljb25Gcm9tQ29uZmlnKGNvbmZpZylcbiAgICAgICAgICAgICAgICAuZG8oZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gY29uZmlnLnN2Z0VsZW1lbnQgPSBzdmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBjbG9uZVN2ZyhzdmcpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZmluZCBhbiBpY29uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGluIGFueSBvZiB0aGUgU1ZHIGljb24gc2V0cy5cbiAgICAgKiBGaXJzdCBzZWFyY2hlcyB0aGUgYXZhaWxhYmxlIGNhY2hlZCBpY29ucyBmb3IgYSBuZXN0ZWQgZWxlbWVudCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSwgYW5kXG4gICAgICogaWYgZm91bmQgY29waWVzIHRoZSBlbGVtZW50IHRvIGEgbmV3IDxzdmc+IGVsZW1lbnQuIElmIG5vdCBmb3VuZCwgZmV0Y2hlcyBhbGwgaWNvbiBzZXRzXG4gICAgICogdGhhdCBoYXZlIG5vdCBiZWVuIGNhY2hlZCwgYW5kIHNlYXJjaGVzIGFnYWluIGFmdGVyIGFsbCBmZXRjaGVzIGFyZSBjb21wbGV0ZWQuXG4gICAgICogVGhlIHJldHVybmVkIE9ic2VydmFibGUgcHJvZHVjZXMgdGhlIFNWRyBlbGVtZW50IGlmIHBvc3NpYmxlLCBhbmQgdGhyb3dzXG4gICAgICogTWRJY29uTmFtZU5vdEZvdW5kRXJyb3IgaWYgbm8gaWNvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBjYW4gYmUgZm91bmQuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9nZXRTdmdGcm9tSWNvblNldENvbmZpZ3MgPSBmdW5jdGlvbiAobmFtZSwgaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRm9yIGFsbCB0aGUgaWNvbiBzZXQgU1ZHIGVsZW1lbnRzIHdlJ3ZlIGZldGNoZWQsIHNlZSBpZiBhbnkgY29udGFpbiBhbiBpY29uIHdpdGggdGhlXG4gICAgICAgIC8vIHJlcXVlc3RlZCBuYW1lLlxuICAgICAgICB2YXIgbmFtZWRJY29uID0gdGhpcy5fZXh0cmFjdEljb25XaXRoTmFtZUZyb21BbnlTZXQobmFtZSwgaWNvblNldENvbmZpZ3MpO1xuICAgICAgICBpZiAobmFtZWRJY29uKSB7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCBjYWNoZSBuYW1lZEljb24gaW4gX3N2Z0ljb25Db25maWdzLCBidXQgc2luY2Ugd2UgaGF2ZSB0byBtYWtlIGEgY29weSBldmVyeVxuICAgICAgICAgICAgLy8gdGltZSBhbnl3YXksIHRoZXJlJ3MgcHJvYmFibHkgbm90IG11Y2ggYWR2YW50YWdlIGNvbXBhcmVkIHRvIGp1c3QgYWx3YXlzIGV4dHJhY3RpbmdcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGljb24gc2V0LlxuICAgICAgICAgICAgcmV0dXJuIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLm9mKG5hbWVkSWNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IGZvdW5kIGluIGFueSBjYWNoZWQgaWNvbiBzZXRzLiBJZiB0aGVyZSBhcmUgaWNvbiBzZXRzIHdpdGggVVJMcyB0aGF0IHdlIGhhdmVuJ3RcbiAgICAgICAgLy8gZmV0Y2hlZCwgZmV0Y2ggdGhlbSBub3cgYW5kIGxvb2sgZm9yIGljb25OYW1lIGluIHRoZSByZXN1bHRzLlxuICAgICAgICB2YXIgaWNvblNldEZldGNoUmVxdWVzdHMgPSBpY29uU2V0Q29uZmlnc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaWNvblNldENvbmZpZykgeyByZXR1cm4gIWljb25TZXRDb25maWcuc3ZnRWxlbWVudDsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGljb25TZXRDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbG9hZFN2Z0ljb25TZXRGcm9tQ29uZmlnKGljb25TZXRDb25maWcpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIsIGNhdWdodCkge1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfdGhpcy5fc2FuaXRpemVyLnNhbml0aXplKF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgaWNvblNldENvbmZpZy51cmwpO1xuICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgZXJyb3JzIGZldGNoaW5nIGluZGl2aWR1YWwgVVJMcyBzbyB0aGUgY29tYmluZWQgT2JzZXJ2YWJsZSB3b24ndFxuICAgICAgICAgICAgICAgIC8vIG5lY2Vzc2FyaWx5IGZhaWwuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkaW5nIGljb24gc2V0IFVSTDogXCIgKyB1cmwgKyBcIiBmYWlsZWQ6IFwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUub2YobnVsbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5kbyhmdW5jdGlvbiAoc3ZnKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgU1ZHIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKHN2Zykge1xuICAgICAgICAgICAgICAgICAgICBpY29uU2V0Q29uZmlnLnN2Z0VsZW1lbnQgPSBzdmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGZXRjaCBhbGwgdGhlIGljb24gc2V0IFVSTHMuIFdoZW4gdGhlIHJlcXVlc3RzIGNvbXBsZXRlLCBldmVyeSBJY29uU2V0IHNob3VsZCBoYXZlIGFcbiAgICAgICAgLy8gY2FjaGVkIFNWRyBlbGVtZW50ICh1bmxlc3MgdGhlIHJlcXVlc3QgZmFpbGVkKSwgYW5kIHdlIGNhbiBjaGVjayBhZ2FpbiBmb3IgdGhlIGljb24uXG4gICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5mb3JrSm9pbihpY29uU2V0RmV0Y2hSZXF1ZXN0cylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGlnbm9yZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgZm91bmRJY29uID0gX3RoaXMuX2V4dHJhY3RJY29uV2l0aE5hbWVGcm9tQW55U2V0KG5hbWUsIGljb25TZXRDb25maWdzKTtcbiAgICAgICAgICAgIGlmICghZm91bmRJY29uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kSWNvbjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyB0aGUgY2FjaGVkIFNWRyBlbGVtZW50cyBmb3IgdGhlIGdpdmVuIGljb24gc2V0cyBmb3IgYSBuZXN0ZWQgaWNvbiBlbGVtZW50IHdob3NlIFwiaWRcIlxuICAgICAqIHRhZyBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgbmFtZS4gSWYgZm91bmQsIGNvcGllcyB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYSBuZXcgU1ZHIGVsZW1lbnQgYW5kXG4gICAgICogcmV0dXJucyBpdC4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldCA9IGZ1bmN0aW9uIChpY29uTmFtZSwgaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgLy8gSXRlcmF0ZSBiYWNrd2FyZHMsIHNvIGljb24gc2V0cyBhZGRlZCBsYXRlciBoYXZlIHByZWNlZGVuY2UuXG4gICAgICAgIGZvciAodmFyIGkgPSBpY29uU2V0Q29uZmlncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGljb25TZXRDb25maWdzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kSWNvbiA9IHRoaXMuX2V4dHJhY3RTdmdJY29uRnJvbVNldChjb25maWcuc3ZnRWxlbWVudCwgaWNvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kSWNvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgY29udGVudCBvZiB0aGUgaWNvbiBVUkwgc3BlY2lmaWVkIGluIHRoZSBTdmdJY29uQ29uZmlnIGFuZCBjcmVhdGVzIGFuIFNWRyBlbGVtZW50XG4gICAgICogZnJvbSBpdC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2xvYWRTdmdJY29uRnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoVXJsKGNvbmZpZy51cmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdmdUZXh0KSB7IHJldHVybiBfdGhpcy5fY3JlYXRlU3ZnRWxlbWVudEZvclNpbmdsZUljb24oc3ZnVGV4dCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGNvbnRlbnQgb2YgdGhlIGljb24gc2V0IFVSTCBzcGVjaWZpZWQgaW4gdGhlIFN2Z0ljb25Db25maWcgYW5kIGNyZWF0ZXMgYW4gU1ZHIGVsZW1lbnRcbiAgICAgKiBmcm9tIGl0LlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fbG9hZFN2Z0ljb25TZXRGcm9tQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUT0RPOiBEb2N1bWVudCB0aGF0IGljb25zIHNob3VsZCBvbmx5IGJlIGxvYWRlZCBmcm9tIHRydXN0ZWQgc291cmNlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoVXJsKGNvbmZpZy51cmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdmdUZXh0KSB7IHJldHVybiBfdGhpcy5fc3ZnRWxlbWVudEZyb21TdHJpbmcoc3ZnVGV4dCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERPTSBlbGVtZW50IGZyb20gdGhlIGdpdmVuIFNWRyBzdHJpbmcsIGFuZCBhZGRzIGRlZmF1bHQgYXR0cmlidXRlcy5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2NyZWF0ZVN2Z0VsZW1lbnRGb3JTaW5nbGVJY29uID0gZnVuY3Rpb24gKHJlc3BvbnNlVGV4dCkge1xuICAgICAgICB2YXIgc3ZnID0gdGhpcy5fc3ZnRWxlbWVudEZyb21TdHJpbmcocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgdGhpcy5fc2V0U3ZnQXR0cmlidXRlcyhzdmcpO1xuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIGNhY2hlZCBlbGVtZW50IG9mIHRoZSBnaXZlbiBTdmdJY29uQ29uZmlnIGZvciBhIG5lc3RlZCBpY29uIGVsZW1lbnQgd2hvc2UgXCJpZFwiXG4gICAgICogdGFnIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBuYW1lLiBJZiBmb3VuZCwgY29waWVzIHRoZSBuZXN0ZWQgZWxlbWVudCB0byBhIG5ldyBTVkcgZWxlbWVudCBhbmRcbiAgICAgKiByZXR1cm5zIGl0LiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2V4dHJhY3RTdmdJY29uRnJvbVNldCA9IGZ1bmN0aW9uIChpY29uU2V0LCBpY29uTmFtZSkge1xuICAgICAgICB2YXIgaWNvbk5vZGUgPSBpY29uU2V0LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWNvbk5hbWUpO1xuICAgICAgICBpZiAoIWljb25Ob2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaWNvbiBub2RlIGlzIGl0c2VsZiBhbiA8c3ZnPiBub2RlLCBjbG9uZSBhbmQgcmV0dXJuIGl0IGRpcmVjdGx5LiBJZiBub3QsIHNldCBpdCBhc1xuICAgICAgICAvLyB0aGUgY29udGVudCBvZiBhIG5ldyA8c3ZnPiBub2RlLlxuICAgICAgICBpZiAoaWNvbk5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICdzdmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0U3ZnQXR0cmlidXRlcyhpY29uTm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZUVsZW1lbnQoJ1NWRycpIGRvZXNuJ3Qgd29yayBhcyBleHBlY3RlZDsgdGhlIERPTSBlbmRzIHVwIHdpdGhcbiAgICAgICAgLy8gdGhlIGNvcnJlY3Qgbm9kZXMsIGJ1dCB0aGUgU1ZHIGNvbnRlbnQgZG9lc24ndCByZW5kZXIuIEluc3RlYWQgd2VcbiAgICAgICAgLy8gaGF2ZSB0byBjcmVhdGUgYW4gZW1wdHkgU1ZHIG5vZGUgdXNpbmcgaW5uZXJIVE1MIGFuZCBhcHBlbmQgaXRzIGNvbnRlbnQuXG4gICAgICAgIC8vIEVsZW1lbnRzIGNyZWF0ZWQgdXNpbmcgRE9NUGFyc2VyLnBhcnNlRnJvbVN0cmluZyBoYXZlIHRoZSBzYW1lIHByb2JsZW0uXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjMwMDMyNzgvc3ZnLWlubmVyaHRtbC1pbi1maXJlZm94LWNhbi1ub3QtZGlzcGxheVxuICAgICAgICB2YXIgc3ZnID0gdGhpcy5fc3ZnRWxlbWVudEZyb21TdHJpbmcoJzxzdmc+PC9zdmc+Jyk7XG4gICAgICAgIC8vIENsb25lIHRoZSBub2RlIHNvIHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIHRoZSBwYXJlbnQgaWNvbiBzZXQgZWxlbWVudC5cbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGljb25Ob2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRTdmdBdHRyaWJ1dGVzKHN2Zyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gU1ZHIHN0cmluZy5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIGJldHRlciB3YXkgdGhhbiBpbm5lckhUTUw/IFJlbmRlcmVyIGRvZXNuJ3QgYXBwZWFyIHRvIGhhdmUgYSBtZXRob2QgZm9yXG4gICAgICAgIC8vIGNyZWF0aW5nIGFuIGVsZW1lbnQgZnJvbSBhbiBIVE1MIHN0cmluZy5cbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gc3RyO1xuICAgICAgICB2YXIgc3ZnID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xuICAgICAgICBpZiAoIXN2Zykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kSWNvblN2Z1RhZ05vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBhbiBTVkcgZWxlbWVudCB0byBiZSB1c2VkIGFzIGFuIGljb24uXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9zZXRTdmdBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN2Zykge1xuICAgICAgICBpZiAoIXN2Zy5nZXRBdHRyaWJ1dGUoJ3htbG5zJykpIHtcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnZml0JywgJycpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAneE1pZFlNaWQgbWVldCcpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdmb2N1c2FibGUnLCAnZmFsc2UnKTsgLy8gRGlzYWJsZSBJRTExIGRlZmF1bHQgYmVoYXZpb3IgdG8gbWFrZSBTVkdzIGZvY3VzYWJsZS5cbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB3aGljaCBwcm9kdWNlcyB0aGUgc3RyaW5nIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBVUkwuIFJlc3VsdHMgbWF5IGJlXG4gICAgICogY2FjaGVkLCBzbyBmdXR1cmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBVUkwgbWF5IG5vdCBjYXVzZSBhbm90aGVyIEhUVFAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2ZldGNoVXJsID0gZnVuY3Rpb24gKHNhZmVVcmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVybCA9IHRoaXMuX3Nhbml0aXplci5zYW5pdGl6ZShfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIHNhZmVVcmwpO1xuICAgICAgICAvLyBTdG9yZSBpbi1wcm9ncmVzcyBmZXRjaGVzIHRvIGF2b2lkIHNlbmRpbmcgYSBkdXBsaWNhdGUgcmVxdWVzdCBmb3IgYSBVUkwgd2hlbiB0aGVyZSBpc1xuICAgICAgICAvLyBhbHJlYWR5IGEgcmVxdWVzdCBpbiBwcm9ncmVzcyBmb3IgdGhhdCBVUkwuIEl0J3MgbmVjZXNzYXJ5IHRvIGNhbGwgc2hhcmUoKSBvbiB0aGVcbiAgICAgICAgLy8gT2JzZXJ2YWJsZSByZXR1cm5lZCBieSBodHRwLmdldCgpIHNvIHRoYXQgbXVsdGlwbGUgc3Vic2NyaWJlcnMgZG9uJ3QgY2F1c2UgbXVsdGlwbGUgWEhScy5cbiAgICAgICAgaWYgKHRoaXMuX2luUHJvZ3Jlc3NVcmxGZXRjaGVzLmhhcyh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMuZ2V0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IGZvciBzb21lIHJlYXNvbiwgdGhlIGBmaW5hbGx5YCBvcGVyYXRvciBcImxvc2VzXCIgdGhlIGdlbmVyaWMgdHlwZSBvbiB0aGVcbiAgICAgICAgLy8gT2JzZXJ2YWJsZS4gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC5cbiAgICAgICAgdmFyIHJlcSA9IHRoaXMuX2h0dHAuZ2V0KHVybClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZS50ZXh0KCk7IH0pXG4gICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMuZGVsZXRlKHVybCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc2hhcmUoKTtcbiAgICAgICAgdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMuc2V0KHVybCwgcmVxKTtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9O1xuICAgIE1kSWNvblJlZ2lzdHJ5ID0gX19kZWNvcmF0ZSQ0NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfaHR0cC5IdHRwLCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRG9tU2FuaXRpemVyXSlcbiAgICBdLCBNZEljb25SZWdpc3RyeSk7XG4gICAgcmV0dXJuIE1kSWNvblJlZ2lzdHJ5O1xufSgpKTtcbi8qKiBDbG9uZXMgYW4gU1ZHRWxlbWVudCB3aGlsZSBwcmVzZXJ2aW5nIHR5cGUgaW5mb3JtYXRpb24uICovXG5mdW5jdGlvbiBjbG9uZVN2ZyhzdmcpIHtcbiAgICByZXR1cm4gc3ZnLmNsb25lTm9kZSh0cnVlKTtcbn1cblxudmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ0NiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0NiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhbiBpbnZhbGlkIGljb24gbmFtZSBpcyBwYXNzZWQgdG8gYW4gbWQtaWNvbiBjb21wb25lbnQuICovXG52YXIgTWRJY29uSW52YWxpZE5hbWVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEyKE1kSWNvbkludmFsaWROYW1lRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRJY29uSW52YWxpZE5hbWVFcnJvcihpY29uTmFtZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkludmFsaWQgaWNvbiBuYW1lOiBcXFwiXCIgKyBpY29uTmFtZSArIFwiXFxcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kSWNvbkludmFsaWROYW1lRXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogQ29tcG9uZW50IHRvIGRpc3BsYXkgYW4gaWNvbi4gSXQgY2FuIGJlIHVzZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBTcGVjaWZ5IHRoZSBzdmdTcmMgaW5wdXQgdG8gbG9hZCBhbiBTVkcgaWNvbiBmcm9tIGEgVVJMLiBUaGUgU1ZHIGNvbnRlbnQgaXMgZGlyZWN0bHkgaW5saW5lZFxuICogICBhcyBhIGNoaWxkIG9mIHRoZSA8bWQtaWNvbj4gY29tcG9uZW50LCBzbyB0aGF0IENTUyBzdHlsZXMgY2FuIGVhc2lseSBiZSBhcHBsaWVkIHRvIGl0LlxuICogICBUaGUgVVJMIGlzIGxvYWRlZCB2aWEgYW4gWE1MSHR0cFJlcXVlc3QsIHNvIGl0IG11c3QgYmUgb24gdGhlIHNhbWUgZG9tYWluIGFzIHRoZSBwYWdlIG9yIGl0c1xuICogICBzZXJ2ZXIgbXVzdCBiZSBjb25maWd1cmVkIHRvIGFsbG93IGNyb3NzLWRvbWFpbiByZXF1ZXN0cy5cbiAqICAgRXhhbXBsZTpcbiAqICAgICA8bWQtaWNvbiBzdmdTcmM9XCJhc3NldHMvYXJyb3cuc3ZnXCI+PC9tZC1pY29uPlxuICpcbiAqIC0gU3BlY2lmeSB0aGUgc3ZnSWNvbiBpbnB1dCB0byBsb2FkIGFuIFNWRyBpY29uIGZyb20gYSBVUkwgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggdGhlXG4gKiAgIGFkZFN2Z0ljb24sIGFkZFN2Z0ljb25Jbk5hbWVzcGFjZSwgYWRkU3ZnSWNvblNldCwgb3IgYWRkU3ZnSWNvblNldEluTmFtZXNwYWNlIG1ldGhvZHMgb2ZcbiAqICAgTWRJY29uUmVnaXN0cnkuIElmIHRoZSBzdmdJY29uIHZhbHVlIGNvbnRhaW5zIGEgY29sb24gaXQgaXMgYXNzdW1lZCB0byBiZSBpbiB0aGUgZm9ybWF0XG4gKiAgIFwiW25hbWVzcGFjZV06W25hbWVdXCIsIGlmIG5vdCB0aGUgdmFsdWUgd2lsbCBiZSB0aGUgbmFtZSBvZiBhbiBpY29uIGluIHRoZSBkZWZhdWx0IG5hbWVzcGFjZS5cbiAqICAgRXhhbXBsZXM6XG4gKiAgICAgPG1kLWljb24gc3ZnSWNvbj1cImxlZnQtYXJyb3dcIj48L21kLWljb24+XG4gKiAgICAgPG1kLWljb24gc3ZnSWNvbj1cImFuaW1hbHM6Y2F0XCI+PC9tZC1pY29uPlxuICpcbiAqIC0gVXNlIGEgZm9udCBsaWdhdHVyZSBhcyBhbiBpY29uIGJ5IHB1dHRpbmcgdGhlIGxpZ2F0dXJlIHRleHQgaW4gdGhlIGNvbnRlbnQgb2YgdGhlIDxtZC1pY29uPlxuICogICBjb21wb25lbnQuIEJ5IGRlZmF1bHQgdGhlIE1hdGVyaWFsIGljb25zIGZvbnQgaXMgdXNlZCBhcyBkZXNjcmliZWQgYXRcbiAqICAgaHR0cDovL2dvb2dsZS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25zLyNpY29uLWZvbnQtZm9yLXRoZS13ZWIuIFlvdSBjYW4gc3BlY2lmeSBhblxuICogICBhbHRlcm5hdGUgZm9udCBieSBzZXR0aW5nIHRoZSBmb250U2V0IGlucHV0IHRvIGVpdGhlciB0aGUgQ1NTIGNsYXNzIHRvIGFwcGx5IHRvIHVzZSB0aGVcbiAqICAgZGVzaXJlZCBmb250LCBvciB0byBhbiBhbGlhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBNZEljb25SZWdpc3RyeS5yZWdpc3RlckZvbnRDbGFzc0FsaWFzLlxuICogICBFeGFtcGxlczpcbiAqICAgICA8bWQtaWNvbj5ob21lPC9tZC1pY29uPlxuICogICAgIDxtZC1pY29uIGZvbnRTZXQ9XCJteWZvbnRcIj5zdW48L21kLWljb24+XG4gKlxuICogLSBTcGVjaWZ5IGEgZm9udCBnbHlwaCB0byBiZSBpbmNsdWRlZCB2aWEgQ1NTIHJ1bGVzIGJ5IHNldHRpbmcgdGhlIGZvbnRTZXQgaW5wdXQgdG8gc3BlY2lmeSB0aGVcbiAqICAgZm9udCwgYW5kIHRoZSBmb250SWNvbiBpbnB1dCB0byBzcGVjaWZ5IHRoZSBpY29uLiBUeXBpY2FsbHkgdGhlIGZvbnRJY29uIHdpbGwgc3BlY2lmeSBhXG4gKiAgIENTUyBjbGFzcyB3aGljaCBjYXVzZXMgdGhlIGdseXBoIHRvIGJlIGRpc3BsYXllZCB2aWEgYSA6YmVmb3JlIHNlbGVjdG9yLCBhcyBpblxuICogICBodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvZXhhbXBsZXMvXG4gKiAgIEV4YW1wbGU6XG4gKiAgICAgPG1kLWljb24gZm9udFNldD1cImZhXCIgZm9udEljb249XCJhbGFybVwiPjwvbWQtaWNvbj5cbiAqL1xudmFyIE1kSWNvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRJY29uKF9lbGVtZW50UmVmLCBfcmVuZGVyZXIsIF9tZEljb25SZWdpc3RyeSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9tZEljb25SZWdpc3RyeSA9IF9tZEljb25SZWdpc3RyeTtcbiAgICAgICAgLyoqIFNjcmVlbnJlYWRlciBsYWJlbCBmb3IgdGhlIGljb24uICovXG4gICAgICAgIHRoaXMuaG9zdEFyaWFMYWJlbCA9ICcnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJY29uLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKiBDb2xvciBvZiB0aGUgaWNvbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xvcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZEljb24ucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwgJiYgY29sb3IgIT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgY29sb3IsIGlzQWRkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3BsaXRzIGFuIHN2Z0ljb24gYmluZGluZyB2YWx1ZSBpbnRvIGl0cyBpY29uIHNldCBhbmQgaWNvbiBuYW1lIGNvbXBvbmVudHMuXG4gICAgICogUmV0dXJucyBhIDItZWxlbWVudCBhcnJheSBvZiBbKGljb24gc2V0KSwgKGljb24gbmFtZSldLlxuICAgICAqIFRoZSBzZXBhcmF0b3IgZm9yIHRoZSB0d28gZmllbGRzIGlzICc6Jy4gSWYgdGhlcmUgaXMgbm8gc2VwYXJhdG9yLCBhbiBlbXB0eVxuICAgICAqIHN0cmluZyBpcyByZXR1cm5lZCBmb3IgdGhlIGljb24gc2V0IGFuZCB0aGUgZW50aXJlIHZhbHVlIGlzIHJldHVybmVkIGZvclxuICAgICAqIHRoZSBpY29uIG5hbWUuIElmIHRoZSBhcmd1bWVudCBpcyBmYWxzeSwgcmV0dXJucyBhbiBhcnJheSBvZiB0d28gZW1wdHkgc3RyaW5ncy5cbiAgICAgKiBUaHJvd3MgYSBNZEljb25JbnZhbGlkTmFtZUVycm9yIGlmIHRoZSBuYW1lIGNvbnRhaW5zIHR3byBvciBtb3JlICc6JyBzZXBhcmF0b3JzLlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqICAgJ3NvY2lhbDpjYWtlJyAtPiBbJ3NvY2lhbCcsICdjYWtlJ11cbiAgICAgKiAgICdwZW5ndWluJyAtPiBbJycsICdwZW5ndWluJ11cbiAgICAgKiAgIG51bGwgLT4gWycnLCAnJ11cbiAgICAgKiAgICdhOmI6YycgLT4gKHRocm93cyBNZEljb25JbnZhbGlkTmFtZUVycm9yKVxuICAgICAqL1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3NwbGl0SWNvbk5hbWUgPSBmdW5jdGlvbiAoaWNvbk5hbWUpIHtcbiAgICAgICAgaWYgKCFpY29uTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnJywgJyddO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0cyA9IGljb25OYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgIHN3aXRjaCAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICAgIHJldHVybiBbJycsIHBhcnRzWzBdXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZEljb25JbnZhbGlkTmFtZUVycm9yKGljb25OYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRJY29uLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGFuZ2VkSW5wdXRzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBpbmxpbmUgU1ZHIGljb24gaWYgdGhlIGlucHV0cyBjaGFuZ2VkLCB0byBhdm9pZCB1bm5lY2Vzc2FyeSBET00gb3BlcmF0aW9ucy5cbiAgICAgICAgaWYgKGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnSWNvbicpICE9IC0xIHx8IGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnU3JjJykgIT0gLTEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN2Z0ljb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9zcGxpdEljb25OYW1lKHRoaXMuc3ZnSWNvbiksIG5hbWVzcGFjZSA9IF9hWzBdLCBpY29uTmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmdldE5hbWVkU3ZnSWNvbihpY29uTmFtZSwgbmFtZXNwYWNlKS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBfdGhpcy5fc2V0U3ZnRWxlbWVudChzdmcpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjb25zb2xlLmxvZyhcIkVycm9yIHJldHJpZXZpbmcgaWNvbjogXCIgKyBlcnIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGb250SWNvbkNsYXNzZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVBcmlhTGFiZWwoKTtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBmb250IGNsYXNzZXMgYmVjYXVzZSBuZ09uQ2hhbmdlcyB3b24ndCBiZSBjYWxsZWQgaWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBwcmVzZW50LFxuICAgICAgICAvLyBlLmcuIDxtZC1pY29uPmFycm93PC9tZC1pY29uPi4gSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gYWRkIGEgQ1NTIGNsYXNzIGZvciB0aGUgZGVmYXVsdCBmb250LlxuICAgICAgICBpZiAodGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGb250SWNvbkNsYXNzZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRJY29uLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBhcmlhIGxhYmVsIGhlcmUgYmVjYXVzZSBpdCBtYXkgZGVwZW5kIG9uIHRoZSBwcm9qZWN0ZWQgdGV4dCBjb250ZW50LlxuICAgICAgICAvLyAoZS5nLiA8bWQtaWNvbj5ob21lPC9tZC1pY29uPiBzaG91bGQgdXNlICdob21lJykuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFyaWFMYWJlbCgpO1xuICAgIH07XG4gICAgTWRJY29uLnByb3RvdHlwZS5fdXBkYXRlQXJpYUxhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJpYUxhYmVsID0gdGhpcy5fZ2V0QXJpYUxhYmVsKCk7XG4gICAgICAgIGlmIChhcmlhTGFiZWwgJiYgYXJpYUxhYmVsICE9PSB0aGlzLl9wcmV2aW91c0FyaWFMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNBcmlhTGFiZWwgPSBhcmlhTGFiZWw7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50QXR0cmlidXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2FyaWEtbGFiZWwnLCBhcmlhTGFiZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEljb24ucHJvdG90eXBlLl9nZXRBcmlhTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgcHJvdmlkZWQgYW4gYXJpYS1sYWJlbCBhdHRyaWJ1dGUgdmFsdWUsIHVzZSBpdCBhcy1pcy4gT3RoZXJ3aXNlIGxvb2sgZm9yIGFcbiAgICAgICAgLy8gcmVhc29uYWJsZSB2YWx1ZSBmcm9tIHRoZSBhbHQgYXR0cmlidXRlLCBmb250IGljb24gbmFtZSwgU1ZHIGljb24gbmFtZSwgb3IgKGZvciBsaWdhdHVyZXMpXG4gICAgICAgIC8vIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGRpcmVjdGl2ZS5cbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5ob3N0QXJpYUxhYmVsIHx8XG4gICAgICAgICAgICB0aGlzLmFsdCB8fFxuICAgICAgICAgICAgdGhpcy5mb250SWNvbiB8fFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRJY29uTmFtZSh0aGlzLnN2Z0ljb24pWzFdO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgXCJjb250ZW50XCIgb2YgYW4gU1ZHIGljb24gaXMgbm90IGEgdXNlZnVsIGxhYmVsLlxuICAgICAgICBpZiAodGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogV2FybiBoZXJlIGluIGRldiBtb2RlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3VzaW5nRm9udEljb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5zdmdJY29uO1xuICAgIH07XG4gICAgTWRJY29uLnByb3RvdHlwZS5fc2V0U3ZnRWxlbWVudCA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgdmFyIGxheW91dEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBjaGlsZCBub2RlcyBhbmQgYWRkIHRoZSBuZXcgU1ZHIGVsZW1lbnQuXG4gICAgICAgIC8vIFdlIHdvdWxkIHVzZSByZW5kZXJlci5kZXRhY2hWaWV3KEFycmF5LmZyb20obGF5b3V0RWxlbWVudC5jaGlsZE5vZGVzKSkgaGVyZSxcbiAgICAgICAgLy8gYnV0IGl0IGZhaWxzIGluIElFMTE6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzYzMjdcbiAgICAgICAgbGF5b3V0RWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucHJvamVjdE5vZGVzKGxheW91dEVsZW1lbnQsIFtzdmddKTtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3VwZGF0ZUZvbnRJY29uQ2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl91c2luZ0ZvbnRJY29uKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIGZvbnRTZXRDbGFzcyA9IHRoaXMuZm9udFNldCA/XG4gICAgICAgICAgICB0aGlzLl9tZEljb25SZWdpc3RyeS5jbGFzc05hbWVGb3JGb250QWxpYXModGhpcy5mb250U2V0KSA6XG4gICAgICAgICAgICB0aGlzLl9tZEljb25SZWdpc3RyeS5nZXREZWZhdWx0Rm9udFNldENsYXNzKCk7XG4gICAgICAgIGlmIChmb250U2V0Q2xhc3MgIT0gdGhpcy5fcHJldmlvdXNGb250U2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtLCB0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvbnRTZXRDbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtLCBmb250U2V0Q2xhc3MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNGb250U2V0Q2xhc3MgPSBmb250U2V0Q2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9udEljb24gIT0gdGhpcy5fcHJldmlvdXNGb250SWNvbkNsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNGb250SWNvbkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW0sIHRoaXMuX3ByZXZpb3VzRm9udEljb25DbGFzcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZm9udEljb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbSwgdGhpcy5mb250SWNvbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MgPSB0aGlzLmZvbnRJY29uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJY29uLnByb3RvdHlwZSwgXCJzdmdJY29uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ0NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSWNvbi5wcm90b3R5cGUsIFwiZm9udFNldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEljb24ucHJvdG90eXBlLCBcImZvbnRJY29uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ0NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSWNvbi5wcm90b3R5cGUsIFwiYWx0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ0NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtbGFiZWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSWNvbi5wcm90b3R5cGUsIFwiaG9zdEFyaWFMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEljb24ucHJvdG90eXBlLCBcImNvbG9yXCIsIG51bGwpO1xuICAgIE1kSWNvbiA9IF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7dGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtaWNvbiwgbWF0LWljb24nLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWljb257YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZpbGw6Y3VycmVudENvbG9yO2hlaWdodDoyNHB4O3dpZHRoOjI0cHh9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ2ltZycsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtaWNvbl0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIE1kSWNvblJlZ2lzdHJ5XSlcbiAgICBdLCBNZEljb24pO1xuICAgIHJldHVybiBNZEljb247XG59KCkpO1xuZnVuY3Rpb24gSUNPTl9SRUdJU1RSWV9QUk9WSURFUl9GQUNUT1JZKHBhcmVudFJlZ2lzdHJ5LCBodHRwLCBzYW5pdGl6ZXIpIHtcbiAgICByZXR1cm4gcGFyZW50UmVnaXN0cnkgfHwgbmV3IE1kSWNvblJlZ2lzdHJ5KGh0dHAsIHNhbml0aXplcik7XG59XG5cbnZhciBJQ09OX1JFR0lTVFJZX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gTWRJY29uUmVnaXN0cnkgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBNZEljb25SZWdpc3RyeSxcbiAgICBkZXBzOiBbW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLlNraXBTZWxmKCksIE1kSWNvblJlZ2lzdHJ5XSwgX2FuZ3VsYXJfaHR0cC5IdHRwLCBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuRG9tU2FuaXRpemVyXSxcbiAgICB1c2VGYWN0b3J5OiBJQ09OX1JFR0lTVFJZX1BST1ZJREVSX0ZBQ1RPUlksXG59O1xudmFyIE1kSWNvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRJY29uTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZEljb25Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZEljb25Nb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRJY29uTW9kdWxlID0gX19kZWNvcmF0ZSQ0NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2h0dHAuSHR0cE1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRJY29uLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kSWNvbl0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtJQ09OX1JFR0lTVFJZX1BST1ZJREVSXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kSWNvbk1vZHVsZSk7XG4gICAgcmV0dXJuIE1kSWNvbk1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMTQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkNDggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8vIFRPRE8oam9zZXBocGVycm90dCk6IEJlbmNocHJlc3MgdGVzdHMuXG4vKiogQSBzaW5nbGUgZGVncmVlIGluIHJhZGlhbnMuICovXG52YXIgREVHUkVFX0lOX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuLyoqIER1cmF0aW9uIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbi4gKi9cbnZhciBEVVJBVElPTl9JTkRFVEVSTUlOQVRFID0gNjY3O1xuLyoqIER1cmF0aW9uIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbi4gKi9cbnZhciBEVVJBVElPTl9ERVRFUk1JTkFURSA9IDIyNTtcbi8qKiBTdGFydCBhbmltYXRpb24gdmFsdWUgb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uICovXG52YXIgc3RhcnRJbmRldGVybWluYXRlID0gMztcbi8qKiBFbmQgYW5pbWF0aW9uIHZhbHVlIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbiAqL1xudmFyIGVuZEluZGV0ZXJtaW5hdGUgPSA4MDtcbi8qIE1heGltdW0gYW5nbGUgZm9yIHRoZSBhcmMuIFRoZSBhbmdsZSBjYW4ndCBiZSBleGFjdGx5IDM2MCwgYmVjYXVzZSB0aGUgYXJjIGJlY29tZXMgaGlkZGVuLiAqL1xudmFyIE1BWF9BTkdMRSA9IDM1OS45OSAvIDEwMDtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQ0OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcHJvZ3Jlc3Mtc3Bpbm5lciwgbWF0LXByb2dyZXNzLXNwaW5uZXInLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXByb2dyZXNzLXNwaW5uZXJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyO1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZFByb2dyZXNzQ2lyY2xlQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzQ2lyY2xlQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZFByb2dyZXNzQ2lyY2xlQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQ0OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcHJvZ3Jlc3MtY2lyY2xlLCBtYXQtcHJvZ3Jlc3MtY2lyY2xlJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wcm9ncmVzcy1jaXJjbGVdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFByb2dyZXNzQ2lyY2xlQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIDxtZC1wcm9ncmVzcy1zcGlubmVyPiBjb21wb25lbnQuXG4gKi9cbnZhciBNZFByb2dyZXNzU3Bpbm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcm9ncmVzc1NwaW5uZXIoX25nWm9uZSwgX2VsZW1lbnRSZWYsIF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAvKiogVGhlIGlkIG9mIHRoZSBsYXN0IHJlcXVlc3RlZCBhbmltYXRpb24uICovXG4gICAgICAgIHRoaXMuX2xhc3RBbmltYXRpb25JZCA9IDA7XG4gICAgICAgIHRoaXMuX21vZGUgPSAnZGV0ZXJtaW5hdGUnO1xuICAgICAgICB0aGlzLl9jb2xvciA9ICdwcmltYXJ5JztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJfYXJpYVZhbHVlTWluXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlcyBmb3IgYXJpYSBtYXggYW5kIG1pbiBhcmUgb25seSBkZWZpbmVkIGFzIG51bWJlcnMgd2hlbiBpbiBhIGRldGVybWluYXRlIG1vZGUuICBXZSBkbyB0aGlzXG4gICAgICAgICAqIGJlY2F1c2Ugdm9pY2VvdmVyIGRvZXMgbm90IHJlcG9ydCB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIGFzIGluZGV0ZXJtaW5hdGUgaWYgdGhlIGFyaWEgbWluXG4gICAgICAgICAqIGFuZC9vciBtYXggdmFsdWUgYXJlIG51bWJlciB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT0gJ2RldGVybWluYXRlJyA/IDAgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIl9hcmlhVmFsdWVNYXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT0gJ2RldGVybWluYXRlJyA/IDEwMCA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwiaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsXCIsIHtcbiAgICAgICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJkZXRlcm1pbmF0ZUludGVydmFsO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJkZXRlcm1pbmF0ZUludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIGFueSBhbmltYXRpb25zIHRoYXQgd2VyZSBydW5uaW5nLlxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBwcm9ncmVzcy1zcGlubmVyLiBDYW4gYmUgcHJpbWFyeSwgYWNjZW50LCBvciB3YXJuLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqIFZhbHVlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGUuIEl0IGlzIGJvdW5kIHRvIHRoZSBob3N0IGFzIHRoZSBhdHRyaWJ1dGUgYXJpYS12YWx1ZW5vdy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2ICE9IG51bGwgJiYgdGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjbGFtcCh2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlQ2lyY2xlKCh0aGlzLnZhbHVlIHx8IDApLCBuZXdWYWx1ZSwgbGluZWFyRWFzZSwgRFVSQVRJT05fREVURVJNSU5BVEUsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwibW9kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGVcbiAgICAgICAgICpcbiAgICAgICAgICogSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIFByb2dyZXNzTW9kZSwgZGVmYXVsdHMgdG8gJ2RldGVybWluYXRlJy5cbiAgICAgICAgICogbW9kZSBpcyBib3VuZCB0byB0aGUgaG9zdCBhcyB0aGUgYXR0cmlidXRlIGhvc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAobSA9PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBJbmRldGVybWluYXRlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb2RlID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGNpcmNsZSBmcm9tIG9uZSBwZXJjZW50YWdlIHZhbHVlIHRvIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5pbWF0ZUZyb20gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNpcmNsZSBmaWxsZWQgc3RhcnRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gYW5pbWF0ZVRvIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaXJjbGUgZmlsbGVkIGVuZGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSBlYXNlIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gbWFuYWdlIHRoZSBwYWNlIG9mIGNoYW5nZSBpbiB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgbGVuZ3RoIG9mIHRpbWUgdG8gc2hvdyB0aGUgYW5pbWF0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIHJvdGF0aW9uIFRoZSBzdGFydGluZyBhbmdsZSBvZiB0aGUgY2lyY2xlIGZpbGwsIHdpdGggMMKwIHJlcHJlc2VudGVkIGF0IHRoZSB0b3AgY2VudGVyXG4gICAgICogICAgb2YgdGhlIGNpcmNsZS5cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX2FuaW1hdGVDaXJjbGUgPSBmdW5jdGlvbiAoYW5pbWF0ZUZyb20sIGFuaW1hdGVUbywgZWFzZSwgZHVyYXRpb24sIHJvdGF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9ICsrdGhpcy5fbGFzdEFuaW1hdGlvbklkO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGNoYW5nZUluVmFsdWUgPSBhbmltYXRlVG8gLSBhbmltYXRlRnJvbTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBhbmltYXRlIGl0IGlmIHRoZSB2YWx1ZXMgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChhbmltYXRlVG8gPT09IGFuaW1hdGVGcm9tKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJBcmMoYW5pbWF0ZVRvLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSwgZHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVuZGVyQXJjKGVhc2UoZWxhcHNlZFRpbWUsIGFuaW1hdGVGcm9tLCBjaGFuZ2VJblZhbHVlLCBkdXJhdGlvbiksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG92ZXJsYXBwaW5nIGFuaW1hdGlvbnMgYnkgY2hlY2tpbmcgaWYgYSBuZXcgYW5pbWF0aW9uIGhhcyBiZWVuIGNhbGxlZCBmb3IgYW5kXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgbGFzdGVkIGxvbmdlciB0aGFuIHRoZSBhbmltYXRpb24gZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGlkID09PSBfdGhpcy5fbGFzdEFuaW1hdGlvbklkICYmIGVsYXBzZWRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbl8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUnVuIHRoZSBhbmltYXRpb24gb3V0c2lkZSBvZiBBbmd1bGFyJ3Mgem9uZSwgaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGhpdHRpbmcgWm9uZUpTIGFuZCBjaGFuZ2UgZGV0ZWN0aW9uIG9uIGVhY2ggZnJhbWUuXG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoYW5pbWF0aW9uXzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uIGludGVydmFsLCBpZiBpdCBpcyBub3QgYWxyZWFkeSBydW5uaW5nLlxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fc3RhcnRJbmRldGVybWluYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcm90YXRpb25TdGFydFBvaW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gc3RhcnRJbmRldGVybWluYXRlO1xuICAgICAgICB2YXIgZW5kID0gZW5kSW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gRFVSQVRJT05fSU5ERVRFUk1JTkFURTtcbiAgICAgICAgdmFyIGFuaW1hdGUkJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fYW5pbWF0ZUNpcmNsZShzdGFydCwgZW5kLCBtYXRlcmlhbEVhc2UsIGR1cmF0aW9uLCByb3RhdGlvblN0YXJ0UG9pbnQpO1xuICAgICAgICAgICAgLy8gUHJldmVudCByb3RhdGlvbiBmcm9tIHJlYWNoaW5nIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLlxuICAgICAgICAgICAgcm90YXRpb25TdGFydFBvaW50ID0gKHJvdGF0aW9uU3RhcnRQb2ludCArIGVuZCkgJSAxMDA7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSAtZW5kO1xuICAgICAgICAgICAgZW5kID0gLXRlbXA7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoYW5pbWF0ZSQkMSwgZHVyYXRpb24gKyA1MCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGUkJDEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGludGVydmFsLCBlbmRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX2NsZWFudXBJbmRldGVybWluYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBhcmMgb250byB0aGUgU1ZHIGVsZW1lbnQuIFByb3hpZXMgYGdldEFyY2Agd2hpbGUgc2V0dGluZyB0aGUgcHJvcGVyXG4gICAgICogRE9NIGF0dHJpYnV0ZSBvbiB0aGUgYDxwYXRoPmAuXG4gICAgICovXG4gICAgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9yZW5kZXJBcmMgPSBmdW5jdGlvbiAoY3VycmVudFZhbHVlLCByb3RhdGlvbikge1xuICAgICAgICAvLyBDYWNoZXMgdGhlIHBhdGggcmVmZXJlbmNlIHNvIGl0IGRvZXNuJ3QgaGF2ZSB0byBiZSBsb29rZWQgdXAgZXZlcnkgdGltZS5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoID0gdGhpcy5fcGF0aCB8fCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcGF0aCB3YXMgZm91bmQuIFRoaXMgbWF5IG5vdCBiZSB0aGUgY2FzZSBpZiB0aGVcbiAgICAgICAgLy8gYW5pbWF0aW9uIGZ1bmN0aW9uIGZpcmVzIHRvbyBlYXJseS5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgZ2V0U3ZnQXJjKGN1cnJlbnRWYWx1ZSwgcm90YXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29sb3Igb2YgdGhlIHByb2dyZXNzLXNwaW5uZXIgYnkgYWRkaW5nIHRoZSBuZXcgcGFsZXR0ZSBjbGFzcyB0byB0aGUgZWxlbWVudFxuICAgICAqIGFuZCByZW1vdmluZyB0aGUgb2xkIG9uZS5cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yID0gZnVuY3Rpb24gKG5ld0NvbG9yKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcih0aGlzLl9jb2xvciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IobmV3Q29sb3IsIHRydWUpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld0NvbG9yO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIGdpdmVuIHBhbGV0dGUgY2xhc3Mgb24gdGhlIGNvbXBvbmVudCBlbGVtZW50LiAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fc2V0RWxlbWVudENvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBpc0FkZCkge1xuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBjb2xvciAhPSAnJykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyBjb2xvciwgaXNBZGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OCgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcImNvbG9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLm1vZGUnKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIm1vZGVcIiwgbnVsbCk7XG4gICAgTWRQcm9ncmVzc1NwaW5uZXIgPSBfX2RlY29yYXRlJDQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtcHJvZ3Jlc3Mtc3Bpbm5lciwgbWF0LXByb2dyZXNzLXNwaW5uZXIsIG1kLXByb2dyZXNzLWNpcmNsZSwgbWF0LXByb2dyZXNzLWNpcmNsZScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWluXSc6ICdfYXJpYVZhbHVlTWluJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1heF0nOiAnX2FyaWFWYWx1ZU1heCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3ZnIHZpZXdCb3g9XFxcIjAgMCAxMDAgMTAwXFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWlkWU1pZCBtZWV0XFxcIj48cGF0aD48L3BhdGg+PC9zdmc+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMHB4O3dpZHRoOjEwMHB4O292ZXJmbG93OmhpZGRlbn06aG9zdCBzdmd7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcn06aG9zdCBwYXRoe2ZpbGw6dHJhbnNwYXJlbnQ7c3Ryb2tlLXdpZHRoOjEwcHh9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSBzdmd7YW5pbWF0aW9uLWR1cmF0aW9uOjUuMjVzLDIuODg3czthbmltYXRpb24tbmFtZTptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zcG9yYWRpYy1yb3RhdGUsbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzUsMCwuMjUsMSksbGluZWFyO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6aW5maW5pdGU7dHJhbnNpdGlvbjpub25lfUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZXswJXt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXNwb3JhZGljLXJvdGF0ZXsxMi41JXt0cmFuc2Zvcm06cm90YXRlKDEzNWRlZyl9MjUle3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX0zNy41JXt0cmFuc2Zvcm06cm90YXRlKDQwNWRlZyl9NTAle3RyYW5zZm9ybTpyb3RhdGUoNTQwZGVnKX02Mi41JXt0cmFuc2Zvcm06cm90YXRlKDY3NWRlZyl9NzUle3RyYW5zZm9ybTpyb3RhdGUoODEwZGVnKX04Ny41JXt0cmFuc2Zvcm06cm90YXRlKDk0NWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDEwODBkZWcpfX1cIl0sXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuTmdab25lLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kUHJvZ3Jlc3NTcGlubmVyKTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc1NwaW5uZXI7XG59KCkpO1xuLyoqXG4gKiA8bWQtc3Bpbm5lcj4gY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgYSBjb21wb25lbnQgZGVmaW5pdGlvbiB0byBiZSB1c2VkIGFzIGEgY29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIGNyZWF0ZSBhblxuICogaW5kZXRlcm1pbmF0ZSA8bWQtcHJvZ3Jlc3Mtc3Bpbm5lcj4gaW5zdGFuY2UuXG4gKi9cbnZhciBNZFNwaW5uZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxNChNZFNwaW5uZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRTcGlubmVyKGVsZW1lbnRSZWYsIG5nWm9uZSwgcmVuZGVyZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbmdab25lLCBlbGVtZW50UmVmLCByZW5kZXJlcik7XG4gICAgICAgIHRoaXMubW9kZSA9ICdpbmRldGVybWluYXRlJztcbiAgICB9XG4gICAgTWRTcGlubmVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhlIGBuZ09uRGVzdHJveWAgZnJvbSBgTWRQcm9ncmVzc1NwaW5uZXJgIHNob3VsZCBiZSBjYWxsZWQgZXhwbGljaXRseSwgYmVjYXVzZVxuICAgICAgICAvLyBpbiBjZXJ0YWluIGNhc2VzIEFuZ3VsYXIgd29uJ3QgY2FsbCBpdCAoZS5nLiB3aGVuIHVzaW5nIEFvVCBhbmQgaW4gdW5pdCB0ZXN0cykuXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIE1kU3Bpbm5lciA9IF9fZGVjb3JhdGUkNDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1zcGlubmVyLCBtYXQtc3Bpbm5lcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICdtb2RlJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNwaW5uZXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxzdmcgdmlld0JveD1cXFwiMCAwIDEwMCAxMDBcXFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XFxcInhNaWRZTWlkIG1lZXRcXFwiPjxwYXRoPjwvcGF0aD48L3N2Zz5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpibG9jaztoZWlnaHQ6MTAwcHg7d2lkdGg6MTAwcHg7b3ZlcmZsb3c6aGlkZGVufTpob3N0IHN2Z3toZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyfTpob3N0IHBhdGh7ZmlsbDp0cmFuc3BhcmVudDtzdHJva2Utd2lkdGg6MTBweH06aG9zdFttb2RlPWluZGV0ZXJtaW5hdGVdIHN2Z3thbmltYXRpb24tZHVyYXRpb246NS4yNXMsMi44ODdzO2FuaW1hdGlvbi1uYW1lOm1hdC1wcm9ncmVzcy1zcGlubmVyLXNwb3JhZGljLXJvdGF0ZSxtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1saW5lYXItcm90YXRlO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKSxsaW5lYXI7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZTt0cmFuc2l0aW9uOm5vbmV9QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1saW5lYXItcm90YXRlezAle3RyYW5zZm9ybTpyb3RhdGUoMCl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItc3BvcmFkaWMtcm90YXRlezEyLjUle3RyYW5zZm9ybTpyb3RhdGUoMTM1ZGVnKX0yNSV7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfTM3LjUle3RyYW5zZm9ybTpyb3RhdGUoNDA1ZGVnKX01MCV7dHJhbnNmb3JtOnJvdGF0ZSg1NDBkZWcpfTYyLjUle3RyYW5zZm9ybTpyb3RhdGUoNjc1ZGVnKX03NSV7dHJhbnNmb3JtOnJvdGF0ZSg4MTBkZWcpfTg3LjUle3RyYW5zZm9ybTpyb3RhdGUoOTQ1ZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMTA4MGRlZyl9fVwiXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ4KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuTmdab25lLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFNwaW5uZXIpO1xuICAgIHJldHVybiBNZFNwaW5uZXI7XG59KE1kUHJvZ3Jlc3NTcGlubmVyKSk7XG4vKipcbiAqIE1vZHVsZSBmdW5jdGlvbnMuXG4gKi9cbi8qKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4gKi9cbmZ1bmN0aW9uIGNsYW1wKHYpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCB2KSk7XG59XG4vKipcbiAqIENvbnZlcnRzIFBvbGFyIGNvb3JkaW5hdGVzIHRvIENhcnRlc2lhbi5cbiAqL1xuZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXMsIHBhdGhSYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgdmFyIGFuZ2xlSW5SYWRpYW5zID0gKGFuZ2xlSW5EZWdyZWVzIC0gOTApICogREVHUkVFX0lOX1JBRElBTlM7XG4gICAgcmV0dXJuIChyYWRpdXMgKyAocGF0aFJhZGl1cyAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKSkpICtcbiAgICAgICAgJywnICsgKHJhZGl1cyArIChwYXRoUmFkaXVzICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpKSk7XG59XG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbiBmb3IgbGluZWFyIGFuaW1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbGluZWFyRWFzZShjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgY2hhbmdlSW5WYWx1ZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gY2hhbmdlSW5WYWx1ZSAqIGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKyBzdGFydFZhbHVlO1xufVxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb24gdG8gbWF0Y2ggbWF0ZXJpYWwgZGVzaWduIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRlcmlhbEVhc2UoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgdmFyIHRpbWUgPSBjdXJyZW50VGltZSAvIGR1cmF0aW9uO1xuICAgIHZhciB0aW1lQ3ViZWQgPSBNYXRoLnBvdyh0aW1lLCAzKTtcbiAgICB2YXIgdGltZVF1YWQgPSBNYXRoLnBvdyh0aW1lLCA0KTtcbiAgICB2YXIgdGltZVF1aW50ID0gTWF0aC5wb3codGltZSwgNSk7XG4gICAgcmV0dXJuIHN0YXJ0VmFsdWUgKyBjaGFuZ2VJblZhbHVlICogKCg2ICogdGltZVF1aW50KSArICgtMTUgKiB0aW1lUXVhZCkgKyAoMTAgKiB0aW1lQ3ViZWQpKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcGF0aCB2YWx1ZSB0byBkZWZpbmUgdGhlIGFyYy4gIENvbnZlcnRpbmcgcGVyY2VudGFnZSB2YWx1ZXMgdG8gdG8gcG9sYXJcbiAqIGNvb3JkaW5hdGVzIG9uIHRoZSBjaXJjbGUsIGFuZCB0aGVuIHRvIGNhcnRlc2lhbiBjb29yZGluYXRlcyBpbiB0aGUgdmlld3BvcnQuXG4gKlxuICogQHBhcmFtIGN1cnJlbnRWYWx1ZSBUaGUgY3VycmVudCBwZXJjZW50YWdlIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGUsIHRoZSBwZXJjZW50YWdlIG9mIHRoZVxuICogICAgY2lyY2xlIHRvIGZpbGwuXG4gKiBAcGFyYW0gcm90YXRpb24gVGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBjaXJjbGUgd2l0aCAwIGJlaW5nIHRoZSAwIGRlZ3JlZSBwb2ludC5cbiAqIEByZXR1cm4gQSBzdHJpbmcgZm9yIGFuIFNWRyBwYXRoIHJlcHJlc2VudGluZyBhIGNpcmNsZSBmaWxsZWQgZnJvbSB0aGUgc3RhcnRpbmcgcG9pbnQgdG8gdGhlXG4gKiAgICBwZXJjZW50YWdlIHZhbHVlIHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBnZXRTdmdBcmMoY3VycmVudFZhbHVlLCByb3RhdGlvbikge1xuICAgIHZhciBzdGFydFBvaW50ID0gcm90YXRpb24gfHwgMDtcbiAgICB2YXIgcmFkaXVzID0gNTA7XG4gICAgdmFyIHBhdGhSYWRpdXMgPSA0MDtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHN0YXJ0UG9pbnQgKiBNQVhfQU5HTEU7XG4gICAgdmFyIGVuZEFuZ2xlID0gY3VycmVudFZhbHVlICogTUFYX0FOR0xFO1xuICAgIHZhciBzdGFydCA9IHBvbGFyVG9DYXJ0ZXNpYW4ocmFkaXVzLCBwYXRoUmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICB2YXIgZW5kID0gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXMsIHBhdGhSYWRpdXMsIGVuZEFuZ2xlICsgc3RhcnRBbmdsZSk7XG4gICAgdmFyIGFyY1N3ZWVwID0gZW5kQW5nbGUgPCAwID8gMCA6IDE7XG4gICAgdmFyIGxhcmdlQXJjRmxhZztcbiAgICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgICAgIGxhcmdlQXJjRmxhZyA9IGVuZEFuZ2xlID49IC0xODAgPyAwIDogMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxhcmdlQXJjRmxhZyA9IGVuZEFuZ2xlIDw9IDE4MCA/IDAgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gXCJNXCIgKyBzdGFydCArIFwiQVwiICsgcGF0aFJhZGl1cyArIFwiLFwiICsgcGF0aFJhZGl1cyArIFwiIDAgXCIgKyBsYXJnZUFyY0ZsYWcgKyBcIixcIiArIGFyY1N3ZWVwICsgXCIgXCIgKyBlbmQ7XG59XG52YXIgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUgPSBfX2RlY29yYXRlJDQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXIsXG4gICAgICAgICAgICAgICAgTWRTcGlubmVyLFxuICAgICAgICAgICAgICAgIENvbXBhdGliaWxpdHlNb2R1bGUsXG4gICAgICAgICAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlclxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgIE1kUHJvZ3Jlc3NTcGlubmVyLFxuICAgICAgICAgICAgICAgIE1kU3Bpbm5lcixcbiAgICAgICAgICAgICAgICBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZFByb2dyZXNzQ2lyY2xlQ3NzTWF0U3R5bGVyXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUpO1xuICAgIHJldHVybiBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZTtcbn0oKSk7XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuXG52YXIgX19kZWNvcmF0ZSQ0OSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0OSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLy8gVE9ETyhqb3NlcGhwZXJyb3R0KTogQmVuY2hwcmVzcyB0ZXN0cy5cbi8vIFRPRE8oam9zZXBocGVycm90dCk6IEFkZCBBUklBIGF0dHJpYnV0ZXMgZm9yIHByb2dyZXNzYmFyIFwiZm9yXCIuXG4vKipcbiAqIDxtZC1wcm9ncmVzcy1iYXI+IGNvbXBvbmVudC5cbiAqL1xudmFyIE1kUHJvZ3Jlc3NCYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NCYXIoKSB7XG4gICAgICAgIC8qKiBDb2xvciBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiAqL1xuICAgICAgICB0aGlzLmNvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX2J1ZmZlclZhbHVlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGUgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiBkZXRlcm1pbmF0ZSwgaW5kZXRlcm1pbmF0ZSwgYnVmZmVyLCBxdWVyeSwgZGVmYXVsdHMgdG9cbiAgICAgICAgICogJ2RldGVybWluYXRlJy5cbiAgICAgICAgICogTWlycm9yZWQgdG8gbW9kZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGUgPSAnZGV0ZXJtaW5hdGUnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogVmFsdWUgb2YgdGhlIHByb2dyZXNzYmFyLiBEZWZhdWx0cyB0byB6ZXJvLiBNaXJyb3JlZCB0byBhcmlhLXZhbHVlbm93LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuX3ZhbHVlID0gY2xhbXAkMSh2IHx8IDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwiYnVmZmVyVmFsdWVcIiwge1xuICAgICAgICAvKiogQnVmZmVyIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBiYXIuIERlZmF1bHRzIHRvIHplcm8uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYnVmZmVyVmFsdWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5fYnVmZmVyVmFsdWUgPSBjbGFtcCQxKHYgfHwgMCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBHZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB2YWx1ZSBmb3IgdGhlIHByb2dyZXNzIGJhcidzIHByaW1hcnkgaW5kaWNhdG9yLiAqL1xuICAgIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLl9wcmltYXJ5VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnZhbHVlIC8gMTAwO1xuICAgICAgICByZXR1cm4geyB0cmFuc2Zvcm06IFwic2NhbGVYKFwiICsgc2NhbGUgKyBcIilcIiB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm0gdmFsdWUgZm9yIHRoZSBwcm9ncmVzcyBiYXIncyBidWZmZXIgaW5kaWNhdG9yLiAgT25seSB1c2VkIGlmIHRoZVxuICAgICAqIHByb2dyZXNzIG1vZGUgaXMgc2V0IHRvIGJ1ZmZlciwgb3RoZXJ3aXNlIHJldHVybnMgYW4gdW5kZWZpbmVkLCBjYXVzaW5nIG5vIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLl9idWZmZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuYnVmZmVyVmFsdWUgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4geyB0cmFuc2Zvcm06IFwic2NhbGVYKFwiICsgc2NhbGUgKyBcIilcIiB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVub3cnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJidWZmZXJWYWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLm1vZGUnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICBNZFByb2dyZXNzQmFyID0gX19kZWNvcmF0ZSQ0OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXByb2dyZXNzLWJhciwgbWF0LXByb2dyZXNzLWJhcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWluJzogJzAnLFxuICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWF4JzogJzEwMCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHJpbWFyeV0nOiAnY29sb3IgPT0gXCJwcmltYXJ5XCInLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWFjY2VudF0nOiAnY29sb3IgPT0gXCJhY2NlbnRcIicsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtd2Fybl0nOiAnY29sb3IgPT0gXCJ3YXJuXCInLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXByb2dyZXNzLWJhcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kIG1hdC1wcm9ncmVzcy1iYXItZWxlbWVudFxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXByb2dyZXNzLWJhci1idWZmZXIgbWF0LXByb2dyZXNzLWJhci1lbGVtZW50XFxcIiBbbmdTdHlsZV09XFxcIl9idWZmZXJUcmFuc2Zvcm0oKVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXByb2dyZXNzLWJhci1wcmltYXJ5IG1hdC1wcm9ncmVzcy1iYXItZmlsbCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiIFtuZ1N0eWxlXT1cXFwiX3ByaW1hcnlUcmFuc2Zvcm0oKVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnkgbWF0LXByb2dyZXNzLWJhci1maWxsIG1hdC1wcm9ncmVzcy1iYXItZWxlbWVudFxcXCI+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjVweDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNpdGlvbjpvcGFjaXR5IDI1MG1zIGxpbmVhcjt3aWR0aDoxMDAlfTpob3N0IC5tYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnQsOmhvc3QgLm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7aGVpZ2h0OjEwMCU7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5ke2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2JhY2tncm91bmQtc2l6ZToxMHB4IDRweDtkaXNwbGF5Om5vbmV9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItYnVmZmVye3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMjUwbXMgZWFzZX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnl7ZGlzcGxheTpub25lfTpob3N0IC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGx7YW5pbWF0aW9uOm5vbmU7dHJhbnNmb3JtLW9yaWdpbjp0b3AgbGVmdDt0cmFuc2l0aW9uOnRyYW5zZm9ybSAyNTBtcyBlYXNlfTpob3N0IC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVye2FuaW1hdGlvbjpub25lO2NvbnRlbnQ6Jyc7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGVmdDowfTpob3N0W21vZGU9cXVlcnlde3RyYW5zZm9ybTpyb3RhdGVaKDE4MGRlZyl9Omhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItZmlsbCw6aG9zdFttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGx7dHJhbnNpdGlvbjpub25lfTpob3N0W21vZGU9cXVlcnldIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnksOmhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5e2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGUgMnMgaW5maW5pdGUgbGluZWFyO2xlZnQ6LTE0NS4xNjY2MTElfTpob3N0W21vZGU9cXVlcnldIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlciw6aG9zdFttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlcnthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtc2NhbGUgMnMgaW5maW5pdGUgbGluZWFyfTpob3N0W21vZGU9cXVlcnldIC5tYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeSw6aG9zdFttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeXthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGUgMnMgaW5maW5pdGUgbGluZWFyO2xlZnQ6LTU0Ljg4ODg5MSU7ZGlzcGxheTpibG9ja306aG9zdFttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlciw6aG9zdFttb2RlPWluZGV0ZXJtaW5hdGVdIC5tYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVye2FuaW1hdGlvbjptYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXNjYWxlIDJzIGluZmluaXRlIGxpbmVhcn06aG9zdFttb2RlPWJ1ZmZlcl0gLm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZHthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kLXNjcm9sbCAyNTBtcyBpbmZpbml0ZSBsaW5lYXI7ZGlzcGxheTpibG9ja306aG9zdC1jb250ZXh0KFtkaXI9cnRsXSl7dHJhbnNmb3JtOnJvdGF0ZVkoMTgwZGVnKX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS1pbmRldGVybWluYXRlLXRyYW5zbGF0ZXswJXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX0yMCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjUsMCwuNzAxNzMsLjQ5NTgyKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX01OS4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjMwMjQ0LC4zODEzNSwuNTUsLjk1NjM1KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg4My42NzE0MiUpfTEwMCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjAwLjYxMTA2JSl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtc2NhbGV7MCV7dHJhbnNmb3JtOnNjYWxlWCguMDgpfTM2LjY1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzM0NzMsLjEyNDgyLC43ODU4NCwxKTt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9NjkuMTUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4wNiwuMTEsLjYsMSk7dHJhbnNmb3JtOnNjYWxlWCguNjYxNDgpfTEwMCV7dHJhbnNmb3JtOnNjYWxlWCguMDgpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5LWluZGV0ZXJtaW5hdGUtdHJhbnNsYXRlezAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4xNSwwLC41MTUwNiwuNDA5NjkpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfTI1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzEwMzMsLjI4NDA2LC44LC43MzM3MSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMzcuNjUxOTElKX00OC4zNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsLjYyNzA0LC42LC45MDIwMyk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoODQuMzg2MTclKX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGVYKDE2MC4yNzc3OCUpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5LWluZGV0ZXJtaW5hdGUtc2NhbGV7MCV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE1LDAsLjUxNTA2LC40MDk2OSk7dHJhbnNmb3JtOnNjYWxlWCguMDgpfTE5LjE1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzEwMzMsLjI4NDA2LC44LC43MzM3MSk7dHJhbnNmb3JtOnNjYWxlWCguNDU3MSl9NDQuMTUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC40LC42MjcwNCwuNiwuOTAyMDMpO3RyYW5zZm9ybTpzY2FsZVgoLjcyNzk2KX0xMDAle3RyYW5zZm9ybTpzY2FsZVgoLjA4KX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQtc2Nyb2xse3Rve3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KX19XCJdLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXIpO1xuICAgIHJldHVybiBNZFByb2dyZXNzQmFyO1xufSgpKTtcbi8qKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIHR3byBudW1iZXJzLCBieSBkZWZhdWx0IDAgYW5kIDEwMC4gKi9cbmZ1bmN0aW9uIGNsYW1wJDEodiwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID09PSB2b2lkIDApIHsgbWluID0gMDsgfVxuICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSAxMDA7IH1cbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHYpKTtcbn1cbnZhciBNZFByb2dyZXNzQmFyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzQmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFByb2dyZXNzQmFyTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRQcm9ncmVzc0Jhck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kUHJvZ3Jlc3NCYXJNb2R1bGUgPSBfX2RlY29yYXRlJDQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRQcm9ncmVzc0JhciwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFByb2dyZXNzQmFyXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXJNb2R1bGUpO1xuICAgIHJldHVybiBNZFByb2dyZXNzQmFyTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIE1kSW5wdXRDb250YWluZXJQbGFjZWhvbGRlckNvbmZsaWN0RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxNShNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSW5wdXRDb250YWluZXJQbGFjZWhvbGRlckNvbmZsaWN0RXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdQbGFjZWhvbGRlciBhdHRyaWJ1dGUgYW5kIGNoaWxkIGVsZW1lbnQgd2VyZSBib3RoIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kSW5wdXRDb250YWluZXJQbGFjZWhvbGRlckNvbmZsaWN0RXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKiBAZG9jcy1wcml2YXRlICovXG52YXIgTWRJbnB1dENvbnRhaW5lclVuc3VwcG9ydGVkVHlwZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTUoTWRJbnB1dENvbnRhaW5lclVuc3VwcG9ydGVkVHlwZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvcih0eXBlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW5wdXQgdHlwZSBcXFwiXCIgKyB0eXBlICsgXCJcXFwiIGlzbid0IHN1cHBvcnRlZCBieSBtZC1pbnB1dC1jb250YWluZXIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRJbnB1dENvbnRhaW5lclVuc3VwcG9ydGVkVHlwZUVycm9yO1xufShNZEVycm9yKSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTUoTWRJbnB1dENvbnRhaW5lckR1cGxpY2F0ZWRIaW50RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRJbnB1dENvbnRhaW5lckR1cGxpY2F0ZWRIaW50RXJyb3IoYWxpZ24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJBIGhpbnQgd2FzIGFscmVhZHkgZGVjbGFyZWQgZm9yICdhbGlnbj1cXFwiXCIgKyBhbGlnbiArIFwiXFxcIicuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRJbnB1dENvbnRhaW5lckR1cGxpY2F0ZWRIaW50RXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKiBAZG9jcy1wcml2YXRlICovXG52YXIgTWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxNShNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ21kLWlucHV0LWNvbnRhaW5lciBtdXN0IGNvbnRhaW4gYW4gbWRJbnB1dCBkaXJlY3RpdmUuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCBtZElucHV0ICcgK1xuICAgICAgICAgICAgJ3RvIHRoZSBuYXRpdmUgaW5wdXQgb3IgdGV4dGFyZWEgZWxlbWVudD8nKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kSW5wdXRDb250YWluZXJNaXNzaW5nTWRJbnB1dEVycm9yO1xufShNZEVycm9yKSk7XG5cbnZhciBfX2RlY29yYXRlJDUxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDUxID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxMCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8vIEludmFsaWQgaW5wdXQgdHlwZS4gVXNpbmcgb25lIG9mIHRoZXNlIHdpbGwgdGhyb3cgYW4gTWRJbnB1dENvbnRhaW5lclVuc3VwcG9ydGVkVHlwZUVycm9yLlxudmFyIE1EX0lOUFVUX0lOVkFMSURfVFlQRVMgPSBbXG4gICAgJ2J1dHRvbicsXG4gICAgJ2NoZWNrYm94JyxcbiAgICAnY29sb3InLFxuICAgICdmaWxlJyxcbiAgICAnaGlkZGVuJyxcbiAgICAnaW1hZ2UnLFxuICAgICdyYWRpbycsXG4gICAgJ3JhbmdlJyxcbiAgICAncmVzZXQnLFxuICAgICdzdWJtaXQnXG5dO1xudmFyIG5leHRVbmlxdWVJZCQxID0gMDtcbi8qKlxuICogVGhlIHBsYWNlaG9sZGVyIGRpcmVjdGl2ZS4gVGhlIGNvbnRlbnQgY2FuIGRlY2xhcmUgdGhpcyB0byBpbXBsZW1lbnQgbW9yZVxuICogY29tcGxleCBwbGFjZWhvbGRlcnMuXG4gKi9cbnZhciBNZFBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFBsYWNlaG9sZGVyKCkge1xuICAgIH1cbiAgICBNZFBsYWNlaG9sZGVyID0gX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcGxhY2Vob2xkZXIsIG1hdC1wbGFjZWhvbGRlcidcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUGxhY2Vob2xkZXIpO1xuICAgIHJldHVybiBNZFBsYWNlaG9sZGVyO1xufSgpKTtcbi8qKiBUaGUgaGludCBkaXJlY3RpdmUsIHVzZWQgdG8gdGFnIGNvbnRlbnQgYXMgaGludCBsYWJlbHMgKGdvaW5nIHVuZGVyIHRoZSBpbnB1dCkuICovXG52YXIgTWRIaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEhpbnQoKSB7XG4gICAgICAgIC8vIFdoZXRoZXIgdG8gYWxpZ24gdGhlIGhpbnQgbGFiZWwgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgbGluZS5cbiAgICAgICAgdGhpcy5hbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIC8vIFVuaXF1ZSBJRCBmb3IgdGhlIGhpbnQuIFVzZWQgZm9yIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IG9uIHRoZSBpbnB1dC5cbiAgICAgICAgdGhpcy5pZCA9IFwibWQtaW5wdXQtaGludC1cIiArIG5leHRVbmlxdWVJZCQxKys7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEhpbnQucHJvdG90eXBlLCBcImFsaWduXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSGludC5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICBNZEhpbnQgPSBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1oaW50LCBtYXQtaGludCcsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtaGludF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcmlnaHRdJzogJ2FsaWduID09IFwiZW5kXCInLFxuICAgICAgICAgICAgICAgICdbYXR0ci5pZF0nOiAnaWQnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRIaW50KTtcbiAgICByZXR1cm4gTWRIaW50O1xufSgpKTtcbi8qKiBUaGUgaW5wdXQgZGlyZWN0aXZlLCB1c2VkIHRvIG1hcmsgdGhlIGlucHV0IHRoYXQgYE1kSW5wdXRDb250YWluZXJgIGlzIHdyYXBwaW5nLiAqL1xudmFyIE1kSW5wdXREaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSW5wdXREaXJlY3RpdmUoX2VsZW1lbnRSZWYsIF9yZW5kZXJlciwgX25nQ29udHJvbCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9uZ0NvbnRyb2wgPSBfbmdDb250cm9sO1xuICAgICAgICAvKiogVmFyaWFibGVzIHVzZWQgYXMgY2FjaGUgZm9yIGdldHRlcnMgYW5kIHNldHRlcnMuICovXG4gICAgICAgIHRoaXMuX3R5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGZvY3VzZWQgb3Igbm90LiAqL1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHBsYWNlaG9sZGVyIGNoYW5nZXMgc28gdGhhdCB0aGUgYG1kLWlucHV0LWNvbnRhaW5lcmAgY2FuIHJlLXZhbGlkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJDaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fbmV2ZXJFbXB0eUlucHV0VHlwZXMgPSBbXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnLFxuICAgICAgICAgICAgJ2RhdGV0aW1lLWxvY2FsJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAndGltZScsXG4gICAgICAgICAgICAnd2VlaydcbiAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGdldFN1cHBvcnRlZElucHV0VHlwZXMoKS5oYXModCk7IH0pO1xuICAgICAgICAvLyBGb3JjZSBzZXR0ZXIgdG8gYmUgY2FsbGVkIGluIGNhc2UgaWQgd2FzIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmdDb250cm9sID8gdGhpcy5fbmdDb250cm9sLmRpc2FibGVkIDogdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKiBVbmlxdWUgaWQgb2YgdGhlIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2lkID0gdmFsdWUgfHwgdGhpcy5fdWlkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwge1xuICAgICAgICAvKiogUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJDaGFuZ2UuZW1pdCh0aGlzLl9wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHJlcXVpcmVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9yZXF1aXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgLyoqIElucHV0IHR5cGUgb2YgdGhlIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdHlwZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZSB8fCAndGV4dCc7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVR5cGUoKTtcbiAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgQW5ndWxhciBpbnB1dHMsIGRldmVsb3BlcnMgYXJlIG5vIGxvbmdlciBhYmxlIHRvIHNldCB0aGUgcHJvcGVydGllcyBvbiB0aGUgbmF0aXZlXG4gICAgICAgICAgICAvLyBpbnB1dCBlbGVtZW50LiBUbyBlbnN1cmUgdGhhdCBiaW5kaW5ncyBmb3IgYHR5cGVgIHdvcmssIHdlIG5lZWQgdG8gc3luYyB0aGUgc2V0dGVyXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSBuYXRpdmUgcHJvcGVydHkuIFRleHRhcmVhIGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgdGhlIHR5cGUgcHJvcGVydHkgb3IgYXR0cmlidXRlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1RleHRhcmVhKCkgJiYgZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcygpLmhhcyh0aGlzLl90eXBlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd0eXBlJywgdGhpcy5fdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBUaGUgaW5wdXQgZWxlbWVudCdzIHZhbHVlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbXB0eVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9pc05ldmVyRW1wdHkoKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnZhbHVlID09IG51bGwgfHwgdGhpcy52YWx1ZSA9PT0gJycpICYmXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGlucHV0IGNvbnRhaW5zIGJhZCBpbnB1dC4gSWYgc28sIHdlIGtub3cgdGhhdCBpdCBvbmx5IGFwcGVhcnMgZW1wdHkgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBmYWlsZWQgdG8gcGFyc2UuIEZyb20gdGhlIHVzZXIncyBwZXJzcGVjdGl2ZSBpdCBpcyBub3QgZW1wdHkuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtbWFsZXJiYSk6IEFkZCBlMmUgdGVzdCBmb3IgYmFkIGlucHV0IGNhc2UuXG4gICAgICAgICAgICAgICAgIXRoaXMuX2lzQmFkSW5wdXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcIl91aWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NhY2hlZFVpZCA9IHRoaXMuX2NhY2hlZFVpZCB8fCBcIm1kLWlucHV0LVwiICsgbmV4dFVuaXF1ZUlkJDErKzsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEZvY3VzZXMgdGhlIGlucHV0IGVsZW1lbnQuICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKTsgfTtcbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb2N1c2VkID0gdHJ1ZTsgfTtcbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmZvY3VzZWQgPSBmYWxzZTsgfTtcbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5fb25JbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5vb3AgZnVuY3Rpb24gYW5kIGlzIHVzZWQgdG8gbGV0IEFuZ3VsYXIga25vdyB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgICAgLy8gQW5ndWxhciB3aWxsIHJ1biBhIG5ldyBjaGFuZ2UgZGV0ZWN0aW9uIGVhY2ggdGltZSB0aGUgYGlucHV0YCBldmVudCBoYXMgYmVlbiBkaXNwYXRjaGVkLlxuICAgICAgICAvLyBJdCdzIG5lY2Vzc2FyeSB0aGF0IEFuZ3VsYXIgcmVjb2duaXplcyB0aGUgdmFsdWUgY2hhbmdlLCBiZWNhdXNlIHdoZW4gZmxvYXRpbmdMYWJlbFxuICAgICAgICAvLyBpcyBzZXQgdG8gZmFsc2UgYW5kIEFuZ3VsYXIgZm9ybXMgYXJlbid0IHVzZWQsIHRoZSBwbGFjZWhvbGRlciB3b24ndCByZWNvZ25pemUgdGhlXG4gICAgICAgIC8vIHZhbHVlIGNoYW5nZXMgYW5kIHdpbGwgbm90IGRpc2FwcGVhci5cbiAgICAgICAgLy8gTGlzdGVuaW5nIHRvIHRoZSBpbnB1dCBldmVudCB3b3VsZG4ndCBiZSBuZWNlc3Nhcnkgd2hlbiB0aGUgaW5wdXQgaXMgdXNpbmcgdGhlXG4gICAgICAgIC8vIEZvcm1zTW9kdWxlIG9yIFJlYWN0aXZlRm9ybXNNb2R1bGUsIGJlY2F1c2UgQW5ndWxhciBmb3JtcyBhbHNvIGxpc3RlbnMgdG8gaW5wdXQgZXZlbnRzLlxuICAgIH07XG4gICAgLyoqIE1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgYSBzdXBwb3J0ZWQgdHlwZS4gKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5fdmFsaWRhdGVUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoTURfSU5QVVRfSU5WQUxJRF9UWVBFUy5pbmRleE9mKHRoaXMuX3R5cGUpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvcih0aGlzLl90eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX2lzTmV2ZXJFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25ldmVyRW1wdHlJbnB1dFR5cGVzLmluZGV4T2YodGhpcy5fdHlwZSkgIT09IC0xOyB9O1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLl9pc0JhZElucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbGlkaXR5LmJhZElucHV0O1xuICAgIH07XG4gICAgLyoqIERldGVybWluZXMgaWYgdGhlIGNvbXBvbmVudCBob3N0IGlzIGEgdGV4dGFyZWEuIElmIG5vdCByZWNvZ25pemFibGUgaXQgcmV0dXJucyBmYWxzZS4gKi9cbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5faXNUZXh0YXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBuYXRpdmVFbGVtZW50ID8gbmF0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGV4dGFyZWEnIDogZmFsc2U7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImlkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInR5cGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJfcGxhY2Vob2xkZXJDaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBNZElucHV0RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBcImlucHV0W21kSW5wdXRdLCB0ZXh0YXJlYVttZElucHV0XSwgaW5wdXRbbWF0SW5wdXRdLCB0ZXh0YXJlYVttYXRJbnB1dF1cIixcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1pbnB1dC1lbGVtZW50XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAvLyBOYXRpdmUgaW5wdXQgcHJvcGVydGllcyB0aGF0IGFyZSBvdmVyd3JpdHRlbiBieSBBbmd1bGFyIGlucHV0cyBuZWVkIHRvIGJlIHN5bmNlZCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50LiBPdGhlcndpc2UgcHJvcGVydHkgYmluZGluZ3MgZm9yIHRob3NlIGRvbid0IHdvcmsuXG4gICAgICAgICAgICAgICAgJ1tpZF0nOiAnaWQnLFxuICAgICAgICAgICAgICAgICdbcGxhY2Vob2xkZXJdJzogJ3BsYWNlaG9sZGVyJyxcbiAgICAgICAgICAgICAgICAnW2Rpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1tyZXF1aXJlZF0nOiAncmVxdWlyZWQnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XSc6ICdhcmlhRGVzY3JpYmVkYnknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX29uQmx1cigpJyxcbiAgICAgICAgICAgICAgICAnKGZvY3VzKSc6ICdfb25Gb2N1cygpJyxcbiAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdfb25JbnB1dCgpJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMTAoMiwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfZm9ybXMuTmdDb250cm9sXSlcbiAgICBdLCBNZElucHV0RGlyZWN0aXZlKTtcbiAgICByZXR1cm4gTWRJbnB1dERpcmVjdGl2ZTtcbn0oKSk7XG4vKipcbiAqIENvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgYSB0ZXh0IGlucHV0LiBJdCBlbmNhcHN1bGF0ZXMgdGhlIDxpbnB1dD4gSFRNTEVsZW1lbnQgYW5kXG4gKiBpbXByb3ZlIG9uIGl0cyBiZWhhdmlvdXIsIGFsb25nIHdpdGggc3R5bGluZyBpdCBhY2NvcmRpbmcgdG8gdGhlIE1hdGVyaWFsIERlc2lnbi5cbiAqL1xudmFyIE1kSW5wdXRDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSW5wdXRDb250YWluZXIoKSB7XG4gICAgICAgIC8qKiBBbGlnbm1lbnQgb2YgdGhlIGlucHV0IGNvbnRhaW5lcidzIGNvbnRlbnQuICovXG4gICAgICAgIHRoaXMuYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICAvKiogQ29sb3Igb2YgdGhlIGlucHV0IGRpdmlkZXIsIGJhc2VkIG9uIHRoZSB0aGVtZS4gKi9cbiAgICAgICAgdGhpcy5kaXZpZGVyQ29sb3IgPSAncHJpbWFyeSc7XG4gICAgICAgIHRoaXMuX2hpbnRMYWJlbCA9ICcnO1xuICAgICAgICAvLyBVbmlxdWUgaWQgZm9yIHRoZSBoaW50IGxhYmVsLlxuICAgICAgICB0aGlzLl9oaW50TGFiZWxJZCA9IFwibWQtaW5wdXQtaGludC1cIiArIG5leHRVbmlxdWVJZCQxKys7XG4gICAgICAgIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIgPSAnYXV0byc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJfc2hvdWxkQWx3YXlzRmxvYXRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgZmxvYXRpbmcgbGFiZWwgc2hvdWxkIGFsd2F5cyBmbG9hdCBvciBub3QuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZmxvYXRQbGFjZWhvbGRlciA9PT0gJ2Fsd2F5cyc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJfY2FuUGxhY2Vob2xkZXJGbG9hdFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBwbGFjZWhvbGRlciBjYW4gZmxvYXQgb3Igbm90LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIgIT09ICduZXZlcic7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJoaW50TGFiZWxcIiwge1xuICAgICAgICAvKiogVGV4dCBmb3IgdGhlIGlucHV0IGhpbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGludExhYmVsOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGludExhYmVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzSGludHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcImZsb2F0UGxhY2Vob2xkZXJcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGFsd2F5cyBmbG9hdCwgbmV2ZXIgZmxvYXQgb3IgZmxvYXQgYXMgdGhlIHVzZXIgdHlwZXMuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZmxvYXRQbGFjZWhvbGRlcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIgPSB2YWx1ZSB8fCAnYXV0byc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9tZElucHV0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NIaW50cygpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVBsYWNlaG9sZGVycygpO1xuICAgICAgICAvLyBSZS12YWxpZGF0ZSB3aGVuIHRoaW5ncyBjaGFuZ2UuXG4gICAgICAgIHRoaXMuX2hpbnRDaGlsZHJlbi5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcHJvY2Vzc0hpbnRzKCk7IH0pO1xuICAgICAgICB0aGlzLl9tZElucHV0Q2hpbGQuX3BsYWNlaG9sZGVyQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmFsaWRhdGVQbGFjZWhvbGRlcnMoKTsgfSk7XG4gICAgfTtcbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgY2xhc3MgZnJvbSB0aGUgTmdDb250cm9sIHNob3VsZCBiZSBmb3J3YXJkZWQgdG8gdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fc2hvdWxkRm9yd2FyZCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHZhciBjb250cm9sID0gdGhpcy5fbWRJbnB1dENoaWxkID8gdGhpcy5fbWRJbnB1dENoaWxkLl9uZ0NvbnRyb2wgOiBudWxsO1xuICAgICAgICByZXR1cm4gY29udHJvbCAmJiBjb250cm9sW3Byb3BdO1xuICAgIH07XG4gICAgLyoqIFdoZXRoZXIgdGhlIGlucHV0IGhhcyBhIHBsYWNlaG9sZGVyLiAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl9oYXNQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhKHRoaXMuX21kSW5wdXRDaGlsZC5wbGFjZWhvbGRlciB8fCB0aGlzLl9wbGFjZWhvbGRlckNoaWxkKTsgfTtcbiAgICAvKiogRm9jdXNlcyB0aGUgdW5kZXJseWluZyBpbnB1dC4gKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fZm9jdXNJbnB1dCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fbWRJbnB1dENoaWxkLmZvY3VzKCk7IH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgcGxhY2Vob2xkZXIgKGVpdGhlciBgaW5wdXRgIGF0dHJpYnV0ZSBvciBjaGlsZCBlbGVtZW50IHdpdGggdGhlXG4gICAgICogYG1kLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3ZhbGlkYXRlUGxhY2Vob2xkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWRJbnB1dENoaWxkLnBsYWNlaG9sZGVyICYmIHRoaXMuX3BsYWNlaG9sZGVyQ2hpbGQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERvZXMgYW55IGV4dHJhIHByb2Nlc3NpbmcgdGhhdCBpcyByZXF1aXJlZCB3aGVuIGhhbmRsaW5nIHRoZSBoaW50cy5cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fcHJvY2Vzc0hpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUhpbnRzKCk7XG4gICAgICAgIHRoaXMuX3N5bmNBcmlhRGVzY3JpYmVkYnkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgbWF4aW11bSBvZiBvbmUgb2YgZWFjaCBgPG1kLWhpbnQ+YCBhbGlnbm1lbnQgc3BlY2lmaWVkLCB3aXRoIHRoZVxuICAgICAqIGF0dHJpYnV0ZSBiZWluZyBjb25zaWRlcmVkIGFzIGBhbGlnbj1cInN0YXJ0XCJgLlxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl92YWxpZGF0ZUhpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faGludENoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRIaW50XzEgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGVuZEhpbnRfMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9oaW50Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoaGludCkge1xuICAgICAgICAgICAgICAgIGlmIChoaW50LmFsaWduID09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0SGludF8xIHx8IF90aGlzLmhpbnRMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SGludF8xID0gaGludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGludC5hbGlnbiA9PSAnZW5kJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSGludF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWRJbnB1dENvbnRhaW5lckR1cGxpY2F0ZWRIaW50RXJyb3IoJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZEhpbnRfMSA9IGhpbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNoaWxkIGlucHV0J3MgYGFyaWEtZGVzY3JpYmVkYnlgIHRvIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGlkc1xuICAgICAqIG9mIHRoZSBjdXJyZW50bHktc3BlY2lmaWVkIGhpbnRzLCBhcyB3ZWxsIGFzIGEgZ2VuZXJhdGVkIGlkIGZvciB0aGUgaGludCBsYWJlbC5cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fc3luY0FyaWFEZXNjcmliZWRieSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnRIaW50ID0gdGhpcy5faGludENoaWxkcmVuID9cbiAgICAgICAgICAgIHRoaXMuX2hpbnRDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChoaW50KSB7IHJldHVybiBoaW50LmFsaWduID09PSAnc3RhcnQnOyB9KSA6IG51bGw7XG4gICAgICAgIHZhciBlbmRIaW50ID0gdGhpcy5faGludENoaWxkcmVuID9cbiAgICAgICAgICAgIHRoaXMuX2hpbnRDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChoaW50KSB7IHJldHVybiBoaW50LmFsaWduID09PSAnZW5kJzsgfSkgOiBudWxsO1xuICAgICAgICBpZiAoc3RhcnRIaW50KSB7XG4gICAgICAgICAgICBpZHMucHVzaChzdGFydEhpbnQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2hpbnRMYWJlbCkge1xuICAgICAgICAgICAgaWRzLnB1c2godGhpcy5faGludExhYmVsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRIaW50KSB7XG4gICAgICAgICAgICBpZHMucHVzaChlbmRIaW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZElucHV0Q2hpbGQuYXJpYURlc2NyaWJlZGJ5ID0gaWRzLmpvaW4oJyAnKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJhbGlnblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJkaXZpZGVyQ29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaGludExhYmVsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJmbG9hdFBsYWNlaG9sZGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZChNZElucHV0RGlyZWN0aXZlKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgTWRJbnB1dERpcmVjdGl2ZSlcbiAgICBdLCBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJfbWRJbnB1dENoaWxkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkKE1kUGxhY2Vob2xkZXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBNZFBsYWNlaG9sZGVyKVxuICAgIF0sIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcIl9wbGFjZWhvbGRlckNoaWxkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kSGludCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcIl9oaW50Q2hpbGRyZW5cIiwgdm9pZCAwKTtcbiAgICBNZElucHV0Q29udGFpbmVyID0gX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWlucHV0LWNvbnRhaW5lciwgbWF0LWlucHV0LWNvbnRhaW5lcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtd3JhcHBlclxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LXRhYmxlXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtcHJlZml4XFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIlttZFByZWZpeF0sIFttYXRQcmVmaXhdLCBbbWQtcHJlZml4XVxcXCI+PC9uZy1jb250ZW50PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC1pbmZpeFxcXCIgW2NsYXNzLm1hdC1lbmRdPVxcXCJhbGlnbiA9PSAnZW5kJ1xcXCI+PG5nLWNvbnRlbnQgc2VsZWN0b3I9XFxcImlucHV0LCB0ZXh0YXJlYVxcXCI+PC9uZy1jb250ZW50PjxzcGFuIGNsYXNzPVxcXCJtYXQtaW5wdXQtcGxhY2Vob2xkZXItd3JhcHBlclxcXCI+PGxhYmVsIGNsYXNzPVxcXCJtYXQtaW5wdXQtcGxhY2Vob2xkZXJcXFwiIFthdHRyLmZvcl09XFxcIl9tZElucHV0Q2hpbGQuaWRcXFwiIFtjbGFzcy5tYXQtZW1wdHldPVxcXCJfbWRJbnB1dENoaWxkLmVtcHR5ICYmICFfc2hvdWxkQWx3YXlzRmxvYXRcXFwiIFtjbGFzcy5tYXQtZm9jdXNlZF09XFxcIl9tZElucHV0Q2hpbGQuZm9jdXNlZFxcXCIgW2NsYXNzLm1hdC1mbG9hdF09XFxcIl9jYW5QbGFjZWhvbGRlckZsb2F0XFxcIiBbY2xhc3MubWF0LWFjY2VudF09XFxcImRpdmlkZXJDb2xvciA9PSAnYWNjZW50J1xcXCIgW2NsYXNzLm1hdC13YXJuXT1cXFwiZGl2aWRlckNvbG9yID09ICd3YXJuJ1xcXCIgKm5nSWY9XFxcIl9oYXNQbGFjZWhvbGRlcigpXFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXBsYWNlaG9sZGVyLCBtYXQtcGxhY2Vob2xkZXJcXFwiPjwvbmctY29udGVudD57e19tZElucHV0Q2hpbGQucGxhY2Vob2xkZXJ9fSA8c3BhbiBjbGFzcz1cXFwibWF0LXBsYWNlaG9sZGVyLXJlcXVpcmVkXFxcIiAqbmdJZj1cXFwiX21kSW5wdXRDaGlsZC5yZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtc3VmZml4XFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIlttZFN1ZmZpeF0sIFttYXRTdWZmaXhdLCBbbWQtc3VmZml4XVxcXCI+PC9uZy1jb250ZW50PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC11bmRlcmxpbmVcXFwiIFtjbGFzcy5tYXQtZGlzYWJsZWRdPVxcXCJfbWRJbnB1dENoaWxkLmRpc2FibGVkXFxcIj48c3BhbiBjbGFzcz1cXFwibWF0LWlucHV0LXJpcHBsZVxcXCIgW2NsYXNzLm1hdC1mb2N1c2VkXT1cXFwiX21kSW5wdXRDaGlsZC5mb2N1c2VkXFxcIiBbY2xhc3MubWF0LWFjY2VudF09XFxcImRpdmlkZXJDb2xvciA9PSAnYWNjZW50J1xcXCIgW2NsYXNzLm1hdC13YXJuXT1cXFwiZGl2aWRlckNvbG9yID09ICd3YXJuJ1xcXCI+PC9zcGFuPjwvZGl2PjxkaXYgKm5nSWY9XFxcImhpbnRMYWJlbCAhPSAnJ1xcXCIgW2F0dHIuaWRdPVxcXCJfaGludExhYmVsSWRcXFwiIGNsYXNzPVxcXCJtYXQtaGludFxcXCI+e3toaW50TGFiZWx9fTwvZGl2PjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtaGludCwgbWF0LWhpbnRcXFwiPjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1pbnB1dC1jb250YWluZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtsaW5lLWhlaWdodDpub3JtYWw7dGV4dC1hbGlnbjpsZWZ0fS5tYXQtZW5kIC5tYXQtaW5wdXQtZWxlbWVudCxbZGlyPXJ0bF0gLm1hdC1pbnB1dC1jb250YWluZXJ7dGV4dC1hbGlnbjpyaWdodH0ubWF0LWlucHV0LXdyYXBwZXJ7bWFyZ2luOjFlbSAwO3BhZGRpbmctYm90dG9tOjZweH0ubWF0LWlucHV0LXRhYmxle2Rpc3BsYXk6aW5saW5lLXRhYmxlO2ZsZXgtZmxvdzpjb2x1bW47dmVydGljYWwtYWxpZ246Ym90dG9tO3dpZHRoOjEwMCV9Lm1hdC1pbnB1dC10YWJsZT4qe2Rpc3BsYXk6dGFibGUtY2VsbH0ubWF0LWlucHV0LWluZml4e3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtaW5wdXQtZWxlbWVudHtmb250OmluaGVyaXQ7YmFja2dyb3VuZDowIDA7Y29sb3I6Y3VycmVudENvbG9yO2JvcmRlcjpub25lO291dGxpbmU6MDtwYWRkaW5nOjA7d2lkdGg6MTAwJX0ubWF0LWlucHV0LXBsYWNlaG9sZGVyLC5tYXQtaW5wdXQtcGxhY2Vob2xkZXItd3JhcHBlcntwYWRkaW5nLXRvcDoxZW07cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZX1bZGlyPXJ0bF0gLm1hdC1lbmQgLm1hdC1pbnB1dC1lbGVtZW50e3RleHQtYWxpZ246bGVmdH0ubWF0LWlucHV0LWVsZW1lbnQ6LW1vei11aS1pbnZhbGlke2JveC1zaGFkb3c6bm9uZX0ubWF0LWlucHV0LWVsZW1lbnQ6LXdlYmtpdC1hdXRvZmlsbCsubWF0LWlucHV0LXBsYWNlaG9sZGVyLm1hdC1mbG9hdHtkaXNwbGF5OmJsb2NrO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xLjM1ZW0pIHNjYWxlKC43NSk7d2lkdGg6MTMzLjMzMzMzJX0ubWF0LWlucHV0LWVsZW1lbnQ6OnBsYWNlaG9sZGVye2NvbG9yOnRyYW5zcGFyZW50fS5tYXQtaW5wdXQtZWxlbWVudDo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjp0cmFuc3BhcmVudH0ubWF0LWlucHV0LWVsZW1lbnQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6dHJhbnNwYXJlbnR9Lm1hdC1pbnB1dC1lbGVtZW50Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjp0cmFuc3BhcmVudH0ubWF0LWlucHV0LXBsYWNlaG9sZGVye2xlZnQ6MDt0b3A6MDtmb250LXNpemU6MTAwJTt6LWluZGV4OjE7d2lkdGg6MTAwJTtkaXNwbGF5Om5vbmU7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7b3ZlcmZsb3cteDpoaWRkZW47dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtLW9yaWdpbjpib3R0b20gbGVmdDt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLHdpZHRoIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LWlucHV0LXBsYWNlaG9sZGVyLm1hdC1lbXB0eXtkaXNwbGF5OmJsb2NrO2N1cnNvcjp0ZXh0fS5tYXQtaW5wdXQtcGxhY2Vob2xkZXIubWF0LWZsb2F0Lm1hdC1mb2N1c2VkLC5tYXQtaW5wdXQtcGxhY2Vob2xkZXIubWF0LWZsb2F0Om5vdCgubWF0LWVtcHR5KXtkaXNwbGF5OmJsb2NrO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xLjM1ZW0pIHNjYWxlKC43NSk7d2lkdGg6MTMzLjMzMzMzJX1bZGlyPXJ0bF0gLm1hdC1pbnB1dC1wbGFjZWhvbGRlcnt0cmFuc2Zvcm0tb3JpZ2luOmJvdHRvbSByaWdodDtsZWZ0OmF1dG87cmlnaHQ6MH0ubWF0LWlucHV0LXBsYWNlaG9sZGVyLXdyYXBwZXJ7bGVmdDowO3RvcDotMWVtO3dpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5tYXQtaW5wdXQtcGxhY2Vob2xkZXItd3JhcHBlcjo6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmlubGluZS10YWJsZX0ubWF0LWlucHV0LXVuZGVybGluZXtwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MXB4O3dpZHRoOjEwMCU7bWFyZ2luLXRvcDo0cHg7Ym9yZGVyLXRvcC13aWR0aDoxcHg7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZH0ubWF0LWlucHV0LXVuZGVybGluZS5tYXQtZGlzYWJsZWR7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQscmdiYSgwLDAsMCwuMjYpIDAscmdiYSgwLDAsMCwuMjYpIDMzJSx0cmFuc3BhcmVudCAwKTtiYWNrZ3JvdW5kLXNpemU6NHB4IDFweDtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtib3JkZXItdG9wOjA7YmFja2dyb3VuZC1wb3NpdGlvbjowfS5tYXQtaW5wdXQtdW5kZXJsaW5lIC5tYXQtaW5wdXQtcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoycHg7ei1pbmRleDoxO3RvcDotMXB4O3dpZHRoOjEwMCU7dHJhbnNmb3JtLW9yaWdpbjp0b3A7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZVkoMCk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLG9wYWNpdHkgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtaW5wdXQtdW5kZXJsaW5lIC5tYXQtaW5wdXQtcmlwcGxlLm1hdC1mb2N1c2Vke29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGVZKDEpfS5tYXQtaGludHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2ZvbnQtc2l6ZTo3NSU7Ym90dG9tOjB9Lm1hdC1oaW50Lm1hdC1yaWdodHtyaWdodDowfVtkaXI9cnRsXSAubWF0LWhpbnR7cmlnaHQ6MDtsZWZ0OmF1dG99W2Rpcj1ydGxdIC5tYXQtaGludC5tYXQtcmlnaHR7cmlnaHQ6YXV0bztsZWZ0OjB9Lm1hdC1pbnB1dC1wcmVmaXgsLm1hdC1pbnB1dC1zdWZmaXh7d2lkdGg6LjFweDt3aGl0ZS1zcGFjZTpub3dyYXB9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWlucHV0LWNvbnRhaW5lcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsaWduIGF0dHJpYnV0ZSB0byBwcmV2ZW50IGl0IGZyb20gaW50ZXJmZXJpbmcgd2l0aCBsYXlvdXQuXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFsaWduXSc6ICdudWxsJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXVudG91Y2hlZF0nOiAnX3Nob3VsZEZvcndhcmQoXCJ1bnRvdWNoZWRcIiknLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubmctdG91Y2hlZF0nOiAnX3Nob3VsZEZvcndhcmQoXCJ0b3VjaGVkXCIpJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXByaXN0aW5lXSc6ICdfc2hvdWxkRm9yd2FyZChcInByaXN0aW5lXCIpJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLWRpcnR5XSc6ICdfc2hvdWxkRm9yd2FyZChcImRpcnR5XCIpJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXZhbGlkXSc6ICdfc2hvdWxkRm9yd2FyZChcInZhbGlkXCIpJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLWludmFsaWRdJzogJ19zaG91bGRGb3J3YXJkKFwiaW52YWxpZFwiKScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1wZW5kaW5nXSc6ICdfc2hvdWxkRm9yd2FyZChcInBlbmRpbmdcIiknLFxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19mb2N1c0lucHV0KCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kSW5wdXRDb250YWluZXIpO1xuICAgIHJldHVybiBNZElucHV0Q29udGFpbmVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNTIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogRGlyZWN0aXZlIHRvIGF1dG9tYXRpY2FsbHkgcmVzaXplIGEgdGV4dGFyZWEgdG8gZml0IGl0cyBjb250ZW50LlxuICovXG52YXIgTWRUZXh0YXJlYUF1dG9zaXplID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRleHRhcmVhQXV0b3NpemUoX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJtZEF1dG9zaXplTWluUm93c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluUm93cztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWluUm93cyA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJtZEF1dG9zaXplTWF4Um93c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4Um93cztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWF4Um93cyA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJfbWluSGVpZ2h0XCIsIHtcbiAgICAgICAgLyoqIFRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgdGV4dGFyZWEgYXMgZGV0ZXJtaW5lZCBieSBtaW5Sb3dzLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pblJvd3MgPyB0aGlzLm1pblJvd3MgKiB0aGlzLl9jYWNoZWRMaW5lSGVpZ2h0ICsgXCJweFwiIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwiX21heEhlaWdodFwiLCB7XG4gICAgICAgIC8qKiBUaGUgbWF4aW11bSBoZWlnaHQgb2YgdGhlIHRleHRhcmVhIGFzIGRldGVybWluZWQgYnkgbWF4Um93cy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhSb3dzID8gdGhpcy5tYXhSb3dzICogdGhpcy5fY2FjaGVkTGluZUhlaWdodCArIFwicHhcIiA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlVGV4dGFyZWFMaW5lSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMucmVzaXplVG9GaXRDb250ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGUgaGVpZ2h0IG9mIGEgc2luZ2xlLXJvdyB0ZXh0YXJlYS5cbiAgICAgKlxuICAgICAqIFdlIG5lZWQgdG8ga25vdyBob3cgbGFyZ2UgYSBzaW5nbGUgXCJyb3dcIiBvZiBhIHRleHRhcmVhIGlzIGluIG9yZGVyIHRvIGFwcGx5IG1pblJvd3MgYW5kXG4gICAgICogbWF4Um93cy4gRm9yIHRoZSBpbml0aWFsIHZlcnNpb24sIHdlIHdpbGwgYXNzdW1lIHRoYXQgdGhlIGhlaWdodCBvZiBhIHNpbmdsZSBsaW5lIGluIHRoZVxuICAgICAqIHRleHRhcmVhIGRvZXMgbm90IGV2ZXIgY2hhbmdlLlxuICAgICAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUuX2NhY2hlVGV4dGFyZWFMaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIFVzZSBhIGNsb25lIGVsZW1lbnQgYmVjYXVzZSB3ZSBoYXZlIHRvIG92ZXJyaWRlIHNvbWUgc3R5bGVzLlxuICAgICAgICB2YXIgdGV4dGFyZWFDbG9uZSA9IHRleHRhcmVhLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIHRleHRhcmVhQ2xvbmUucm93cyA9IDE7XG4gICAgICAgIC8vIFVzZSBgcG9zaXRpb246IGFic29sdXRlYCBzbyB0aGF0IHRoaXMgZG9lc24ndCBjYXVzZSBhIGJyb3dzZXIgbGF5b3V0IGFuZCB1c2VcbiAgICAgICAgLy8gYHZpc2liaWxpdHk6IGhpZGRlbmAgc28gdGhhdCBub3RoaW5nIGlzIHJlbmRlcmVkLiBDbGVhciBhbnkgb3RoZXIgc3R5bGVzIHRoYXRcbiAgICAgICAgLy8gd291bGQgYWZmZWN0IHRoZSBoZWlnaHQuXG4gICAgICAgIHRleHRhcmVhQ2xvbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgICAgIHRleHRhcmVhQ2xvbmUuc3R5bGUucGFkZGluZyA9ICcnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLm1pbkhlaWdodCA9ICcnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLm1heEhlaWdodCA9ICcnO1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRleHRhcmVhQ2xvbmUpO1xuICAgICAgICB0aGlzLl9jYWNoZWRMaW5lSGVpZ2h0ID0gdGV4dGFyZWFDbG9uZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGV4dGFyZWFDbG9uZSk7XG4gICAgfTtcbiAgICAvKiogUmVzaXplIHRoZSB0ZXh0YXJlYSB0byBmaXQgaXRzIGNvbnRlbnQuICovXG4gICAgTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZS5yZXNpemVUb0ZpdENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRleHRhcmVhIGhlaWdodCB0byBhdXRvIGluIG9yZGVyIHRvIHNocmluayBiYWNrIHRvIGl0cyBkZWZhdWx0IHNpemUuXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgLy8gVXNlIHRoZSBzY3JvbGxIZWlnaHQgdG8ga25vdyBob3cgbGFyZ2UgdGhlIHRleHRhcmVhICp3b3VsZCogYmUgaWYgZml0IGl0cyBlbnRpcmUgdmFsdWUuXG4gICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IHRleHRhcmVhLnNjcm9sbEhlaWdodCArIFwicHhcIjtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNTIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUyKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLCBcIm1pblJvd3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDUyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MignZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJtZEF1dG9zaXplTWluUm93c1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDUyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MignZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJtYXhSb3dzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTIoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwibWRBdXRvc2l6ZU1heFJvd3NcIiwgbnVsbCk7XG4gICAgTWRUZXh0YXJlYUF1dG9zaXplID0gX19kZWNvcmF0ZSQ1MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAndGV4dGFyZWFbbWQtYXV0b3NpemVdLCB0ZXh0YXJlYVttZFRleHRhcmVhQXV0b3NpemVdLCcgK1xuICAgICAgICAgICAgICAgICd0ZXh0YXJlYVttYXQtYXV0b3NpemVdLCB0ZXh0YXJlYVttYXRUZXh0YXJlYUF1dG9zaXplXScsXG4gICAgICAgICAgICBleHBvcnRBczogJ21kVGV4dGFyZWFBdXRvc2l6ZScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJyhpbnB1dCknOiAncmVzaXplVG9GaXRDb250ZW50KCknLFxuICAgICAgICAgICAgICAgICdbc3R5bGUubWluLWhlaWdodF0nOiAnX21pbkhlaWdodCcsXG4gICAgICAgICAgICAgICAgJ1tzdHlsZS5tYXgtaGVpZ2h0XSc6ICdfbWF4SGVpZ2h0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZFRleHRhcmVhQXV0b3NpemUpO1xuICAgIHJldHVybiBNZFRleHRhcmVhQXV0b3NpemU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ1MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1MCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kSW5wdXRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSW5wdXRNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kSW5wdXRNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZElucHV0TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kSW5wdXRNb2R1bGUgPSBfX2RlY29yYXRlJDUwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBNZFBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIE1kSW5wdXRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgTWRIaW50LFxuICAgICAgICAgICAgICAgIE1kVGV4dGFyZWFBdXRvc2l6ZSxcbiAgICAgICAgICAgICAgICBNZElucHV0RGlyZWN0aXZlXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJfZm9ybXMuRm9ybXNNb2R1bGUsXG4gICAgICAgICAgICAgICAgUGxhdGZvcm1Nb2R1bGUsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgTWRJbnB1dENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBNZEhpbnQsXG4gICAgICAgICAgICAgICAgTWRUZXh0YXJlYUF1dG9zaXplLFxuICAgICAgICAgICAgICAgIE1kSW5wdXREaXJlY3RpdmVcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZElucHV0TW9kdWxlKTtcbiAgICByZXR1cm4gTWRJbnB1dE1vZHVsZTtcbn0oKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiB1c2VkIHdoZW4gb3BlbmluZyBhIHNuYWNrLWJhci5cbiAqL1xudmFyIE1kU25hY2tCYXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJDb25maWcoKSB7XG4gICAgICAgIC8qKiBUaGUgcG9saXRlbmVzcyBsZXZlbCBmb3IgdGhlIE1kQXJpYUxpdmVBbm5vdW5jZXIgYW5ub3VuY2VtZW50LiAqL1xuICAgICAgICB0aGlzLnBvbGl0ZW5lc3MgPSAnYXNzZXJ0aXZlJztcbiAgICAgICAgLyoqIE1lc3NhZ2UgdG8gYmUgYW5ub3VuY2VkIGJ5IHRoZSBNZEFyaWFMaXZlQW5ub3VuY2VyICovXG4gICAgICAgIHRoaXMuYW5ub3VuY2VtZW50TWVzc2FnZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHZpZXcgY29udGFpbmVyIHRvIHBsYWNlIHRoZSBvdmVybGF5IGZvciB0aGUgc25hY2sgYmFyIGludG8uICovXG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgbGVuZ3RoIG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGF1dG9tYXRpY2FsbHkgZGlzbWlzc2luZyB0aGUgc25hY2sgYmFyLiAqL1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1kU25hY2tCYXJDb25maWc7XG59KCkpO1xuXG4vLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBJbXBsZW1lbnQgb25BY3Rpb24gb2JzZXJ2YWJsZS5cbi8qKlxuICogUmVmZXJlbmNlIHRvIGEgc25hY2sgYmFyIGRpc3BhdGNoZWQgZnJvbSB0aGUgc25hY2sgYmFyIHNlcnZpY2UuXG4gKi9cbnZhciBNZFNuYWNrQmFyUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyUmVmKGluc3RhbmNlLCBjb250YWluZXJJbnN0YW5jZSwgX292ZXJsYXlSZWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IF9vdmVybGF5UmVmO1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgdGhlIHNuYWNrIGJhciBoYXMgY2xvc2VkLiAqL1xuICAgICAgICB0aGlzLl9hZnRlckNsb3NlZCA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgdGhlIHNuYWNrIGJhciBhY3Rpb24gd2FzIGNhbGxlZC4gKi9cbiAgICAgICAgdGhpcy5fb25BY3Rpb24gPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICAgICAgLy8gU2V0cyB0aGUgcmVhZG9ubHkgaW5zdGFuY2Ugb2YgdGhlIHNuYWNrIGJhciBjb250ZW50IGNvbXBvbmVudC5cbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5jb250YWluZXJJbnN0YW5jZSA9IGNvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAvLyBEaXNtaXNzIHNuYWNrYmFyIG9uIGFjdGlvbi5cbiAgICAgICAgdGhpcy5vbkFjdGlvbigpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kaXNtaXNzKCk7IH0pO1xuICAgICAgICBjb250YWluZXJJbnN0YW5jZS5fb25FeGl0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9maW5pc2hEaXNtaXNzKCk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbmFja0JhclJlZi5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICAvKiogVGhlIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgbWFraW5nIHVwIHRoZSBjb250ZW50IG9mIHRoZSBzbmFjayBiYXIuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogRGlzbWlzc2VzIHRoZSBzbmFjayBiYXIuICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUuZGlzbWlzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hZnRlckNsb3NlZC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVySW5zdGFuY2UuZXhpdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogTWFya3MgdGhlIHNuYWNrYmFyIGFjdGlvbiBjbGlja2VkLiAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLl9hY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb25BY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkFjdGlvbi5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkFjdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogTWFya3MgdGhlIHNuYWNrYmFyIGFzIG9wZW5lZCAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FmdGVyT3BlbmVkLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJPcGVuZWQubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5fYWZ0ZXJPcGVuZWQuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENsZWFucyB1cCB0aGUgRE9NIGFmdGVyIGNsb3NpbmcuICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUuX2ZpbmlzaERpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9hZnRlckNsb3NlZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICAvKiogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgc25hY2sgYmFyIGlzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUuYWZ0ZXJEaXNtaXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZnRlckNsb3NlZC5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBzbmFjayBiYXIgaGFzIG9wZW5lZCBhbmQgYXBwZWFyZWQuICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUuYWZ0ZXJPcGVuZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckluc3RhbmNlLl9vbkVudGVyKCk7XG4gICAgfTtcbiAgICAvKiogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgc25hY2sgYmFyIGFjdGlvbiBpcyBjYWxsZWQuICovXG4gICAgTWRTbmFja0JhclJlZi5wcm90b3R5cGUub25BY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkFjdGlvbi5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBNZFNuYWNrQmFyUmVmO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEVycm9yIHRoYXQgaXMgdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhdHRhY2ggYSBzbmFjayBiYXIgdGhhdCBpcyBhbHJlYWR5IGF0dGFjaGVkLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRTbmFja0JhckNvbnRlbnRBbHJlYWR5QXR0YWNoZWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxNyhNZFNuYWNrQmFyQ29udGVudEFscmVhZHlBdHRhY2hlZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyQ29udGVudEFscmVhZHlBdHRhY2hlZCgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIHNuYWNrIGJhciBjb250ZW50IGFmdGVyIGNvbnRlbnQgaXMgYWxyZWFkeSBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gTWRTbmFja0JhckNvbnRlbnRBbHJlYWR5QXR0YWNoZWQ7XG59KE1kRXJyb3IpKTtcblxudmFyIF9fZXh0ZW5kcyQxNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ1NSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1NSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLy8gVE9ETyhqZWxib3Vybik6IHdlIGNhbid0IHVzZSBjb25zdGFudHMgZnJvbSBhbmltYXRpb24udHMgaGVyZSBiZWNhdXNlIHlvdSBjYW4ndCB1c2Vcbi8vIGEgdGV4dCBpbnRlcnBvbGF0aW9uIGluIGFueXRoaW5nIHRoYXQgaXMgYW5hbHl6ZWQgc3RhdGljYWxseSB3aXRoIG5nYyAoZm9yIEFvVCBjb21waWxlKS5cbnZhciBTSE9XX0FOSU1BVElPTiA9ICcyMjVtcyBjdWJpYy1iZXppZXIoMC40LDAuMCwxLDEpJztcbnZhciBISURFX0FOSU1BVElPTiA9ICcxOTVtcyBjdWJpYy1iZXppZXIoMC4wLDAuMCwwLjIsMSknO1xuLyoqXG4gKiBJbnRlcm5hbCBjb21wb25lbnQgdGhhdCB3cmFwcyB1c2VyLXByb3ZpZGVkIHNuYWNrIGJhciBjb250ZW50LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRTbmFja0JhckNvbnRhaW5lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDE2KE1kU25hY2tCYXJDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRTbmFja0JhckNvbnRhaW5lcihfbmdab25lLCBfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoYXQgdGhlIHNuYWNrIGJhciBoYXMgZXhpdGVkIGZyb20gdmlldy4gKi9cbiAgICAgICAgdGhpcy5vbkV4aXQgPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IHRoZSBzbmFjayBiYXIgaGFzIGZpbmlzaGVkIGVudGVyaW5nIHRoZSB2aWV3LiAqL1xuICAgICAgICB0aGlzLm9uRW50ZXIgPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICAgICAgLyoqIFRoZSBzdGF0ZSBvZiB0aGUgc25hY2sgYmFyIGFuaW1hdGlvbnMuICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnaW5pdGlhbCc7XG4gICAgfVxuICAgIC8qKiBBdHRhY2ggYSBjb21wb25lbnQgcG9ydGFsIGFzIGNvbnRlbnQgdG8gdGhpcyBzbmFjayBiYXIgY29udGFpbmVyLiAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLmF0dGFjaENvbXBvbmVudFBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kU25hY2tCYXJDb250ZW50QWxyZWFkeUF0dGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc25hY2tCYXJDb25maWcuZXh0cmFDbGFzc2VzKSB7XG4gICAgICAgICAgICAvLyBOb3QgdGhlIG1vc3QgZWZmaWNpZW50IHdheSBvZiBhZGRpbmcgY2xhc3NlcywgYnV0IHRoZSByZW5kZXJlciBkb2Vzbid0IGFsbG93IHVzXG4gICAgICAgICAgICAvLyB0byBwYXNzIGluIGFuIGFycmF5IG9yIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3QuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5zbmFja0JhckNvbmZpZy5leHRyYUNsYXNzZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzc0NsYXNzID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGNzc0NsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsSG9zdC5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICB9O1xuICAgIC8qKiBBdHRhY2ggYSB0ZW1wbGF0ZSBwb3J0YWwgYXMgY29udGVudCB0byB0aGlzIHNuYWNrIGJhciBjb250YWluZXIuICovXG4gICAgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUuYXR0YWNoVGVtcGxhdGVQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKiogSGFuZGxlIGVuZCBvZiBhbmltYXRpb25zLCB1cGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIHNuYWNrYmFyLiAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLm9uQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAndm9pZCcgfHwgZXZlbnQudG9TdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGVFeGl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25FbnRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25FbnRlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBCZWdpbiBhbmltYXRpb24gb2Ygc25hY2sgYmFyIGVudHJhbmNlIGludG8gdmlldy4gKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICd2aXNpYmxlJztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgcmVzb2x2aW5nIHdoZW4gdGhlIGVudGVyIGFuaW1hdGlvbiBjb21wbGV0ZXMuICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLl9vbkVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ3Zpc2libGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkVudGVyLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqIEJlZ2luIGFuaW1hdGlvbiBvZiB0aGUgc25hY2sgYmFyIGV4aXRpbmcgZnJvbSB2aWV3LiAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLmV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAnY29tcGxldGUnO1xuICAgICAgICByZXR1cm4gdGhpcy5fb25FeGl0KCk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIGFmdGVyIHRoZSBjbG9zaW5nIGFuaW1hdGlvbiBpcyBkb25lLiAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLl9vbkV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRXhpdC5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgdGhlIGV4aXQgY2FsbGJhY2tzIGhhdmUgYmVlbiBpbnZva2VkIHdoZW4gdGhlIGVsZW1lbnQgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZUV4aXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgem9uZSB0byBzZXR0bGUgYmVmb3JlIHJlbW92aW5nIHRoZSBlbGVtZW50LiBIZWxwcyBwcmV2ZW50XG4gICAgICogZXJyb3JzIHdoZXJlIHdlIGVuZCB1cCByZW1vdmluZyBhbiBlbGVtZW50IHdoaWNoIGlzIGluIHRoZSBtaWRkbGUgb2YgYW4gYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLl9jb21wbGV0ZUV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm9uRXhpdC5uZXh0KCk7XG4gICAgICAgICAgICBfdGhpcy5vbkV4aXQuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDU1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoUG9ydGFsSG9zdERpcmVjdGl2ZSksIFxuICAgICAgICBfX21ldGFkYXRhJDU1KCdkZXNpZ246dHlwZScsIFBvcnRhbEhvc3REaXJlY3RpdmUpXG4gICAgXSwgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUsIFwiX3BvcnRhbEhvc3RcIiwgdm9pZCAwKTtcbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyID0gX19kZWNvcmF0ZSQ1NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ3NuYWNrLWJhci1jb250YWluZXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRlbXBsYXRlIGNka1BvcnRhbEhvc3Q+PC90ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7YmFja2dyb3VuZDojMzIzMjMyO2JvcmRlci1yYWRpdXM6MnB4O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jaztoZWlnaHQ6MjBweDttYXgtd2lkdGg6NTY4cHg7bWluLXdpZHRoOjI4OHB4O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjE0cHggMjRweDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMDAlKX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXs6aG9zdHtib3JkZXI6MXB4IHNvbGlkfX1cIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnYWxlcnQnLFxuICAgICAgICAgICAgICAgICdbQHN0YXRlXSc6ICdhbmltYXRpb25TdGF0ZScsXG4gICAgICAgICAgICAgICAgJyhAc3RhdGUuZG9uZSknOiAnb25BbmltYXRpb25FbmQoJGV2ZW50KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS50cmlnZ2VyKCdzdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnaW5pdGlhbCcsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDEwMCUpJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ3Zpc2libGUnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwJSknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnY29tcGxldGUnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMDAlKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJ3Zpc2libGUgPT4gY29tcGxldGUnLCBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoSElERV9BTklNQVRJT04pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCdpbml0aWFsID0+IHZpc2libGUsIHZvaWQgPT4gdmlzaWJsZScsIF9hbmd1bGFyX2NvcmUuYW5pbWF0ZShTSE9XX0FOSU1BVElPTikpLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuTmdab25lLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kU25hY2tCYXJDb250YWluZXIpO1xuICAgIHJldHVybiBNZFNuYWNrQmFyQ29udGFpbmVyO1xufShCYXNlUG9ydGFsSG9zdCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ1NiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1NiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBBIGNvbXBvbmVudCB1c2VkIHRvIG9wZW4gYXMgdGhlIGRlZmF1bHQgc25hY2sgYmFyLCBtYXRjaGluZyBtYXRlcmlhbCBzcGVjLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHNuYWNrIGJhciBzZXJ2aWNlLlxuICovXG52YXIgU2ltcGxlU25hY2tCYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZVNuYWNrQmFyKCkge1xuICAgIH1cbiAgICAvKiogRGlzbWlzc2VzIHRoZSBzbmFjayBiYXIuICovXG4gICAgU2ltcGxlU25hY2tCYXIucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc25hY2tCYXJSZWYuX2FjdGlvbigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVNuYWNrQmFyLnByb3RvdHlwZSwgXCJoYXNBY3Rpb25cIiwge1xuICAgICAgICAvKiogSWYgdGhlIGFjdGlvbiBidXR0b24gc2hvdWxkIGJlIHNob3duLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5hY3Rpb247IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNpbXBsZVNuYWNrQmFyID0gX19kZWNvcmF0ZSQ1NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ3NpbXBsZS1zbmFjay1iYXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHNwYW4gY2xhc3M9XFxcIm1hdC1zaW1wbGUtc25hY2tiYXItbWVzc2FnZVxcXCI+e3ttZXNzYWdlfX08L3NwYW4+IDxidXR0b24gY2xhc3M9XFxcIm1hdC1zaW1wbGUtc25hY2tiYXItYWN0aW9uXFxcIiAqbmdJZj1cXFwiaGFzQWN0aW9uXFxcIiAoY2xpY2spPVxcXCJkaXNtaXNzKClcXFwiPnt7YWN0aW9ufX08L2J1dHRvbj5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2NvbG9yOiNmZmY7bGluZS1oZWlnaHQ6MjBweDtmb250LXNpemU6MTRweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmfS5tYXQtc2ltcGxlLXNuYWNrYmFyLW1lc3NhZ2V7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93LXg6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9Lm1hdC1zaW1wbGUtc25hY2tiYXItYWN0aW9ue2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDowIDA7bWFyZ2luOi01cHggMCAwO3BhZGRpbmc6NXB4O3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZTtjb2xvcjppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7ZmxleC1zaHJpbms6MDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtd2VpZ2h0OjYwMH1cIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2ltcGxlLXNuYWNrYmFyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDU2KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIFNpbXBsZVNuYWNrQmFyKTtcbiAgICByZXR1cm4gU2ltcGxlU25hY2tCYXI7XG59KCkpO1xuXG4vKipcbiAqIEV4dGVuZHMgYW4gb2JqZWN0IHdpdGggdGhlICplbnVtZXJhYmxlKiBhbmQgKm93biogcHJvcGVydGllcyBvZiBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyxcbiAqIHNpbWlsYXIgdG8gT2JqZWN0LmFzc2lnbi5cbiAqXG4gKiBAcGFyYW0gZGVzdCBUaGUgb2JqZWN0IHdoaWNoIHdpbGwgaGF2ZSBwcm9wZXJ0aWVzIGNvcGllZCB0byBpdC5cbiAqIEBwYXJhbSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cyBmcm9tIHdoaWNoIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZE9iamVjdChkZXN0KSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzb3VyY2VzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoZGVzdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGZvciAodmFyIF9hID0gMCwgc291cmNlc18xID0gc291cmNlczsgX2EgPCBzb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzXzFbX2FdO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuXG52YXIgX19kZWNvcmF0ZSQ1NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1NCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTEgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFNlcnZpY2UgdG8gZGlzcGF0Y2ggTWF0ZXJpYWwgRGVzaWduIHNuYWNrIGJhciBtZXNzYWdlcy5cbiAqL1xudmFyIE1kU25hY2tCYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXIoX292ZXJsYXksIF9saXZlLCBfcGFyZW50U25hY2tCYXIpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl9saXZlID0gX2xpdmU7XG4gICAgICAgIHRoaXMuX3BhcmVudFNuYWNrQmFyID0gX3BhcmVudFNuYWNrQmFyO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbmFja0Jhci5wcm90b3R5cGUsIFwiX29wZW5lZFNuYWNrQmFyUmVmXCIsIHtcbiAgICAgICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IG9wZW5lZCBzbmFja2JhciBhdCAqYW55KiBsZXZlbC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50U25hY2tCYXIgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudFNuYWNrQmFyLl9vcGVuZWRTbmFja0JhclJlZiA6IHRoaXMuX3NuYWNrQmFyUmVmQXRUaGlzTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50U25hY2tCYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnRTbmFja0Jhci5fb3BlbmVkU25hY2tCYXJSZWYgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NuYWNrQmFyUmVmQXRUaGlzTGV2ZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgZGlzcGF0Y2hlcyBhIHNuYWNrIGJhciB3aXRoIGEgY3VzdG9tIGNvbXBvbmVudCBmb3IgdGhlIGNvbnRlbnQsIHJlbW92aW5nIGFueVxuICAgICAqIGN1cnJlbnRseSBvcGVuZWQgc25hY2sgYmFycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIEV4dHJhIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzbmFjayBiYXIuXG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUub3BlbkZyb21Db21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uZmlnID0gX2FwcGx5Q29uZmlnRGVmYXVsdHMoY29uZmlnKTtcbiAgICAgICAgdmFyIG92ZXJsYXlSZWYgPSB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgIHZhciBzbmFja0JhckNvbnRhaW5lciA9IHRoaXMuX2F0dGFjaFNuYWNrQmFyQ29udGFpbmVyKG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIHZhciBzbmFja0JhclJlZiA9IHRoaXMuX2F0dGFjaFNuYWNrYmFyQ29udGVudChjb21wb25lbnQsIHNuYWNrQmFyQ29udGFpbmVyLCBvdmVybGF5UmVmKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgc25hY2tiYXIgaXMgZGlzbWlzc2VkLCBjbGVhciB0aGUgcmVmZXJlbmNlIHRvIGl0LlxuICAgICAgICBzbmFja0JhclJlZi5hZnRlckRpc21pc3NlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgc25hY2tiYXIgcmVmIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVwbGFjZWQgYnkgYSBuZXdlciBzbmFja2Jhci5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPT0gc25hY2tCYXJSZWYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgYSBzbmFjayBiYXIgaXMgYWxyZWFkeSBpbiB2aWV3LCBkaXNtaXNzIGl0IGFuZCBlbnRlciB0aGUgbmV3IHNuYWNrIGJhciBhZnRlciBleGl0XG4gICAgICAgIC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgICAgaWYgKHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRTbmFja0JhclJlZi5hZnRlckRpc21pc3NlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc25hY2tCYXJSZWYuY29udGFpbmVySW5zdGFuY2UuZW50ZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYuZGlzbWlzcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc25hY2tCYXJSZWYuY29udGFpbmVySW5zdGFuY2UuZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIGRpc21pc3MgdGltZW91dCBpcyBwcm92aWRlZCwgc2V0IHVwIGRpc21pc3MgYmFzZWQgb24gYWZ0ZXIgdGhlIHNuYWNrYmFyIGlzIG9wZW5lZC5cbiAgICAgICAgaWYgKGNvbmZpZy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIHNuYWNrQmFyUmVmLmFmdGVyT3BlbmVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNuYWNrQmFyUmVmLmRpc21pc3MoKTsgfSwgY29uZmlnLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpdmUuYW5ub3VuY2UoY29uZmlnLmFubm91bmNlbWVudE1lc3NhZ2UsIGNvbmZpZy5wb2xpdGVuZXNzKTtcbiAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYgPSBzbmFja0JhclJlZjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBzbmFja2JhciB3aXRoIGEgbWVzc2FnZSBhbmQgYW4gb3B0aW9uYWwgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNob3cgaW4gdGhlIHNuYWNrYmFyLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gVGhlIGxhYmVsIGZvciB0aGUgc25hY2tiYXIgYWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb25maWcgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBzbmFja2Jhci5cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGFjdGlvbiwgY29uZmlnKSB7XG4gICAgICAgIGlmIChhY3Rpb24gPT09IHZvaWQgMCkgeyBhY3Rpb24gPSAnJzsgfVxuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgY29uZmlnLmFubm91bmNlbWVudE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB2YXIgc2ltcGxlU25hY2tCYXJSZWYgPSB0aGlzLm9wZW5Gcm9tQ29tcG9uZW50KFNpbXBsZVNuYWNrQmFyLCBjb25maWcpO1xuICAgICAgICBzaW1wbGVTbmFja0JhclJlZi5pbnN0YW5jZS5zbmFja0JhclJlZiA9IHNpbXBsZVNuYWNrQmFyUmVmO1xuICAgICAgICBzaW1wbGVTbmFja0JhclJlZi5pbnN0YW5jZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgc2ltcGxlU25hY2tCYXJSZWYuaW5zdGFuY2UuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICByZXR1cm4gc2ltcGxlU25hY2tCYXJSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgc25hY2sgYmFyIGNvbnRhaW5lciBjb21wb25lbnQgdG8gdGhlIG92ZXJsYXkuXG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUuX2F0dGFjaFNuYWNrQmFyQ29udGFpbmVyID0gZnVuY3Rpb24gKG92ZXJsYXlSZWYsIGNvbmZpZykge1xuICAgICAgICB2YXIgY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZFNuYWNrQmFyQ29udGFpbmVyLCBjb25maWcudmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHZhciBjb250YWluZXJSZWYgPSBvdmVybGF5UmVmLmF0dGFjaChjb250YWluZXJQb3J0YWwpO1xuICAgICAgICBjb250YWluZXJSZWYuaW5zdGFuY2Uuc25hY2tCYXJDb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuaW5zdGFuY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQbGFjZXMgYSBuZXcgY29tcG9uZW50IGFzIHRoZSBjb250ZW50IG9mIHRoZSBzbmFjayBiYXIgY29udGFpbmVyLlxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9hdHRhY2hTbmFja2JhckNvbnRlbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjb250YWluZXIsIG92ZXJsYXlSZWYpIHtcbiAgICAgICAgdmFyIHBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGNvbnRlbnRSZWYgPSBjb250YWluZXIuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIHJldHVybiBuZXcgTWRTbmFja0JhclJlZihjb250ZW50UmVmLmluc3RhbmNlLCBjb250YWluZXIsIG92ZXJsYXlSZWYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvdmVybGF5IGFuZCBwbGFjZXMgaXQgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSQkMSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbiAgICAgICAgc3RhdGUkJDEucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKS5nbG9iYWwoKVxuICAgICAgICAgICAgLmNlbnRlckhvcml6b250YWxseSgpXG4gICAgICAgICAgICAuYm90dG9tKCcwJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LmNyZWF0ZShzdGF0ZSQkMSk7XG4gICAgfTtcbiAgICBNZFNuYWNrQmFyID0gX19kZWNvcmF0ZSQ1NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLFxuICAgICAgICBfX3BhcmFtJDExKDIsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kMTEoMiwgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXksIExpdmVBbm5vdW5jZXIsIE1kU25hY2tCYXJdKVxuICAgIF0sIE1kU25hY2tCYXIpO1xuICAgIHJldHVybiBNZFNuYWNrQmFyO1xufSgpKTtcbi8qKlxuICogQXBwbGllcyBkZWZhdWx0IG9wdGlvbnMgdG8gdGhlIHNuYWNrYmFyIGNvbmZpZy5cbiAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gd2hpY2ggdGhlIGRlZmF1bHRzIHdpbGwgYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIFRoZSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBkZWZhdWx0cyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBfYXBwbHlDb25maWdEZWZhdWx0cyhjb25maWcpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JqZWN0KG5ldyBNZFNuYWNrQmFyQ29uZmlnKCksIGNvbmZpZyk7XG59XG5cbnZhciBfX2RlY29yYXRlJDUzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDUzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRTbmFja0Jhck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbmFja0Jhck1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRTbmFja0Jhck1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kU25hY2tCYXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFNuYWNrQmFyTW9kdWxlID0gX19kZWNvcmF0ZSQ1MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW092ZXJsYXlNb2R1bGUsIFBvcnRhbE1vZHVsZSwgX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRTbmFja0JhckNvbnRhaW5lciwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNuYWNrQmFyQ29udGFpbmVyLCBTaW1wbGVTbmFja0Jhcl0sXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtNZFNuYWNrQmFyQ29udGFpbmVyLCBTaW1wbGVTbmFja0Jhcl0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNZFNuYWNrQmFyLCBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUl1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDUzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU25hY2tCYXJNb2R1bGUpO1xuICAgIHJldHVybiBNZFNuYWNrQmFyTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ1OCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1OCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqIFVzZWQgdG8gZmxhZyB0YWIgbGFiZWxzIGZvciB1c2Ugd2l0aCB0aGUgcG9ydGFsIGRpcmVjdGl2ZSAqL1xudmFyIE1kVGFiTGFiZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxOChNZFRhYkxhYmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kVGFiTGFiZWwodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cbiAgICBNZFRhYkxhYmVsID0gX19kZWNvcmF0ZSQ1OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXRhYi1sYWJlbF0sIFttYXQtdGFiLWxhYmVsXScsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1OCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmXSlcbiAgICBdLCBNZFRhYkxhYmVsKTtcbiAgICByZXR1cm4gTWRUYWJMYWJlbDtcbn0oVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUpKTtcblxudmFyIF9fZGVjb3JhdGUkNTkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBVc2VkIGluIHRoZSBgbWQtdGFiLWdyb3VwYCB2aWV3IHRvIGRpc3BsYXkgdGFiIGxhYmVscyAqL1xudmFyIE1kVGFiTGFiZWxXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYkxhYmVsV3JhcHBlcihlbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0YWIgbGFiZWwgaXMgZGlzYWJsZWQuICAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJMYWJlbFdyYXBwZXIucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFNldHMgZm9jdXMgb24gdGhlIHdyYXBwZXIgZWxlbWVudCAqL1xuICAgIE1kVGFiTGFiZWxXcmFwcGVyLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgfTtcbiAgICBNZFRhYkxhYmVsV3JhcHBlci5wcm90b3R5cGUuZ2V0T2Zmc2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgfTtcbiAgICBNZFRhYkxhYmVsV3JhcHBlci5wcm90b3R5cGUuZ2V0T2Zmc2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNTkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDU5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRhYkxhYmVsV3JhcHBlci5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRUYWJMYWJlbFdyYXBwZXIgPSBfX2RlY29yYXRlJDU5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtdGFiLWxhYmVsLXdyYXBwZXJdLCBbbWF0LXRhYi1sYWJlbC13cmFwcGVyXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWRpc2FibGVkXSc6ICdkaXNhYmxlZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDU5KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kVGFiTGFiZWxXcmFwcGVyKTtcbiAgICByZXR1cm4gTWRUYWJMYWJlbFdyYXBwZXI7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ2MSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqIFRoZSBpbmstYmFyIGlzIHVzZWQgdG8gZGlzcGxheSBhbmQgYW5pbWF0ZSB0aGUgbGluZSB1bmRlcm5lYXRoIHRoZSBjdXJyZW50IGFjdGl2ZSB0YWIgbGFiZWwuICovXG52YXIgTWRJbmtCYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSW5rQmFyKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3R5bGVzIGZyb20gdGhlIHByb3ZpZGVkIGVsZW1lbnQgaW4gb3JkZXIgdG8gYWxpZ24gdGhlIGluay1iYXIgdG8gdGhhdCBlbGVtZW50LlxuICAgICAqIFNob3dzIHRoZSBpbmsgYmFyIGlmIHByZXZpb3VzbHkgc2V0IGFzIGhpZGRlbi5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIE1kSW5rQmFyLnByb3RvdHlwZS5hbGlnblRvRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbGVmdCcsIHRoaXMuX2dldExlZnRQb3NpdGlvbihlbGVtZW50KSk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIHRoaXMuX2dldEVsZW1lbnRXaWR0aChlbGVtZW50KSk7XG4gICAgfTtcbiAgICAvKiogU2hvd3MgdGhlIGluayBiYXIuICovXG4gICAgTWRJbmtCYXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICB9O1xuICAgIC8qKiBIaWRlcyB0aGUgaW5rIGJhci4gKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHBpeGVsIGRpc3RhbmNlIGZyb20gdGhlIGxlZnQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGVsZW1lbnQgaW4gc3RyaW5nIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIE1kSW5rQmFyLnByb3RvdHlwZS5fZ2V0TGVmdFBvc2l0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm9mZnNldExlZnQgKyAncHgnIDogJzAnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBwaXhlbCB3aWR0aCBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIHN0cmluZyBmb3JtYXQuXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuX2dldEVsZW1lbnRXaWR0aCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vZmZzZXRXaWR0aCArICdweCcgOiAnMCc7XG4gICAgfTtcbiAgICBNZElua0JhciA9IF9fZGVjb3JhdGUkNjEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWluay1iYXIsIG1hdC1pbmstYmFyJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1pbmstYmFyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZElua0Jhcik7XG4gICAgcmV0dXJuIE1kSW5rQmFyO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxOSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ2MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2MCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBOYXZpZ2F0aW9uIGNvbXBvbmVudCBtYXRjaGluZyB0aGUgc3R5bGVzIG9mIHRoZSB0YWIgZ3JvdXAgaGVhZGVyLlxuICogUHJvdmlkZXMgYW5jaG9yZWQgbmF2aWdhdGlvbiB3aXRoIGFuaW1hdGVkIGluayBiYXIuXG4gKi9cbnZhciBNZFRhYk5hdkJhciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJOYXZCYXIoKSB7XG4gICAgfVxuICAgIC8qKiBOb3RpZmllcyB0aGUgY29tcG9uZW50IHRoYXQgdGhlIGFjdGl2ZSBsaW5rIGhhcyBiZWVuIGNoYW5nZWQuICovXG4gICAgTWRUYWJOYXZCYXIucHJvdG90eXBlLnVwZGF0ZUFjdGl2ZUxpbmsgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVMaW5rQ2hhbmdlZCA9IHRoaXMuX2FjdGl2ZUxpbmtFbGVtZW50ICE9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxpbmtFbGVtZW50ID0gZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKiBDaGVja3MgaWYgdGhlIGFjdGl2ZSBsaW5rIGhhcyBiZWVuIGNoYW5nZWQgYW5kLCBpZiBzbywgd2lsbCB1cGRhdGUgdGhlIGluayBiYXIuICovXG4gICAgTWRUYWJOYXZCYXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxpbmtDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmtCYXIuYWxpZ25Ub0VsZW1lbnQodGhpcy5fYWN0aXZlTGlua0VsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVMaW5rQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDYwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoTWRJbmtCYXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MCgnZGVzaWduOnR5cGUnLCBNZElua0JhcilcbiAgICBdLCBNZFRhYk5hdkJhci5wcm90b3R5cGUsIFwiX2lua0JhclwiLCB2b2lkIDApO1xuICAgIE1kVGFiTmF2QmFyID0gX19kZWNvcmF0ZSQ2MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ1ttZC10YWItbmF2LWJhcl0sIFttYXQtdGFiLW5hdi1iYXJdJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGlua3NcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48bWQtaW5rLWJhcj48L21kLWluay1iYXI+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdGFiLWxpbmssLm1hdC10YWItbmF2LWJhcntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59Lm1hdC10YWItbmF2LWJhcntmbGV4LXNocmluazowfS5tYXQtdGFiLWxpbmtze2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LXRhYi1saW5re2xpbmUtaGVpZ2h0OjQ4cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDEycHg7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yOmN1cnJlbnRDb2xvcjtvcGFjaXR5Oi42O21pbi13aWR0aDoxNjBweDt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZX0ubWF0LXRhYi1saW5rOmZvY3Vze291dGxpbmU6MDtvcGFjaXR5OjF9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxpbmt7bWluLXdpZHRoOjcycHh9fS5tYXQtaW5rLWJhcntwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtoZWlnaHQ6MnB4O3RyYW5zaXRpb246LjVzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Lm1hdC10YWItZ3JvdXAtaW52ZXJ0ZWQtaGVhZGVyIC5tYXQtaW5rLWJhcntib3R0b206YXV0bzt0b3A6MH1cIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLW5hdi1iYXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDYwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kVGFiTmF2QmFyKTtcbiAgICByZXR1cm4gTWRUYWJOYXZCYXI7XG59KCkpO1xuLyoqXG4gKiBMaW5rIGluc2lkZSBvZiBhIGBtZC10YWItbmF2LWJhcmAuXG4gKi9cbnZhciBNZFRhYkxpbmsgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFiTGluayhfbWRUYWJOYXZCYXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX21kVGFiTmF2QmFyID0gX21kVGFiTmF2QmFyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkxpbmsucHJvdG90eXBlLCBcImFjdGl2ZVwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBsaW5rIGlzIGFjdGl2ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pc0FjdGl2ZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQWN0aXZlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZFRhYk5hdkJhci51cGRhdGVBY3RpdmVMaW5rKHRoaXMuX2VsZW1lbnRSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlJDYwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MCgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kVGFiTGluay5wcm90b3R5cGUsIFwiYWN0aXZlXCIsIG51bGwpO1xuICAgIE1kVGFiTGluayA9IF9fZGVjb3JhdGUkNjAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10YWItbGlua10sIFttYXQtdGFiLWxpbmtdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItbGlua10nOiAndHJ1ZScsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbTWRUYWJOYXZCYXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRUYWJMaW5rKTtcbiAgICByZXR1cm4gTWRUYWJMaW5rO1xufSgpKTtcbi8qKlxuICogU2ltcGxlIGRpcmVjdGl2ZSB0aGF0IGV4dGVuZHMgdGhlIHJpcHBsZSBhbmQgbWF0Y2hlcyB0aGUgc2VsZWN0b3Igb2YgdGhlIE1kVGFiTGluay4gVGhpc1xuICogYWRkcyB0aGUgcmlwcGxlIGJlaGF2aW9yIHRvIG5hdiBiYXIgbGFiZWxzLlxuICovXG52YXIgTWRUYWJMaW5rUmlwcGxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTkoTWRUYWJMaW5rUmlwcGxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kVGFiTGlua1JpcHBsZShlbGVtZW50UmVmLCBuZ1pvbmUsIHJ1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGVsZW1lbnRSZWYsIG5nWm9uZSwgcnVsZXIpO1xuICAgIH1cbiAgICBNZFRhYkxpbmtSaXBwbGUgPSBfX2RlY29yYXRlJDYwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtdGFiLWxpbmtdLCBbbWF0LXRhYi1saW5rXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWxpbmtdJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDYwKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuTmdab25lLCBWaWV3cG9ydFJ1bGVyXSlcbiAgICBdLCBNZFRhYkxpbmtSaXBwbGUpO1xuICAgIHJldHVybiBNZFRhYkxpbmtSaXBwbGU7XG59KE1kUmlwcGxlKSk7XG5cbnZhciBfX2RlY29yYXRlJDYyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDYyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRUYWIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFiKF92aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgLyoqIFRoZSBwbGFpbiB0ZXh0IGxhYmVsIGZvciB0aGUgdGFiLCB1c2VkIHdoZW4gdGhlcmUgaXMgbm8gdGVtcGxhdGUgbGFiZWwuICovXG4gICAgICAgIHRoaXMudGV4dExhYmVsID0gJyc7XG4gICAgICAgIC8qKiBUaGUgcG9ydGFsIHRoYXQgd2lsbCBiZSB0aGUgaG9zdGVkIGNvbnRlbnQgb2YgdGhlIHRhYiAqL1xuICAgICAgICB0aGlzLl9jb250ZW50UG9ydGFsID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWxhdGl2ZWx5IGluZGV4ZWQgcG9zaXRpb24gd2hlcmUgMCByZXByZXNlbnRzIHRoZSBjZW50ZXIsIG5lZ2F0aXZlIGlzIGxlZnQsIGFuZCBwb3NpdGl2ZVxuICAgICAgICAgKiByZXByZXNlbnRzIHRoZSByaWdodC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgcmVsYXRpdmVseSBpbmRleCBvcmlnaW4gb2YgdGhlIHRhYiBpZiBpdCB3YXMgY3JlYXRlZCBhbmQgc2VsZWN0ZWQgYWZ0ZXIgdGhlcmVcbiAgICAgICAgICogd2FzIGFscmVhZHkgYSBzZWxlY3RlZCB0YWIuIFByb3ZpZGVzIGNvbnRleHQgb2Ygd2hhdCBwb3NpdGlvbiB0aGUgdGFiIHNob3VsZCBvcmlnaW5hdGUgZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250ZW50UG9ydGFsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWIucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHRhYiBpcyBkaXNhYmxlZCAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kVGFiLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29udGVudFBvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLl9jb250ZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZChNZFRhYkxhYmVsKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjIoJ2Rlc2lnbjp0eXBlJywgTWRUYWJMYWJlbClcbiAgICBdLCBNZFRhYi5wcm90b3R5cGUsIFwidGVtcGxhdGVMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZChfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjIoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZilcbiAgICBdLCBNZFRhYi5wcm90b3R5cGUsIFwiX2NvbnRlbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbGFiZWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjIoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kVGFiLnByb3RvdHlwZSwgXCJ0ZXh0TGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MignZGVzaWduOnR5cGUnLCBCb29sZWFuKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0Jvb2xlYW5dKVxuICAgIF0sIE1kVGFiLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBNZFRhYiA9IF9fZGVjb3JhdGUkNjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC10YWIsIG1hdC10YWInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRlbXBsYXRlPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3RlbXBsYXRlPlwiLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZl0pXG4gICAgXSwgTWRUYWIpO1xuICAgIHJldHVybiBNZFRhYjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDYzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDYzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxMiA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogV3JhcHBlciBmb3IgdGhlIGNvbnRlbnRzIG9mIGEgdGFiLlxuICovXG52YXIgTWRUYWJCb2R5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYkJvZHkoX2RpciwgX2VsZW1lbnRSZWYsIF9jaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB0YWIgYmVnaW5zIHRvIGFuaW1hdGUgdG93YXJkcyB0aGUgY2VudGVyIGFzIHRoZSBhY3RpdmUgdGFiLiAqL1xuICAgICAgICB0aGlzLm9uQ2VudGVyaW5nID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHRhYiBjb21wbGV0ZXMgaXRzIGFuaW1hdGlvbiB0b3dhcmRzIHRoZSBjZW50ZXIuICovXG4gICAgICAgIHRoaXMub25DZW50ZXJlZCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWxsb3dlZCB0byBiZSBhbmltYXRlZC4gKi9cbiAgICAgICAgdGhpcy5fY2FuQmVBbmltYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJCb2R5LnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAnbHRyJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkJvZHkucHJvdG90eXBlLCBcIm9yaWdpblwiLCB7XG4gICAgICAgIC8qKiBUaGUgb3JpZ2luIHBvc2l0aW9uIGZyb20gd2hpY2ggdGhpcyB0YWIgc2hvdWxkIGFwcGVhciB3aGVuIGl0IGlzIGNlbnRlcmVkIGludG8gdmlldy4gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlyID0gdGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoKGRpciA9PSAnbHRyJyAmJiBvcmlnaW4gPD0gMCkgfHwgKGRpciA9PSAncnRsJyAmJiBvcmlnaW4gPiAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFmdGVyIGluaXRpYWxpemVkLCBjaGVjayBpZiB0aGUgY29udGVudCBpcyBjZW50ZXJlZCBhbmQgaGFzIGFuIG9yaWdpbi4gSWYgc28sIHNldCB0aGVcbiAgICAgKiBzcGVjaWFsIHBvc2l0aW9uIHN0YXRlcyB0aGF0IHRyYW5zaXRpb24gdGhlIHRhYiBmcm9tIHRoZSBsZWZ0IG9yIHJpZ2h0IGJlZm9yZSBjZW50ZXJpbmcuXG4gICAgICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uID09ICdjZW50ZXInICYmIHRoaXMuX29yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9vcmlnaW4gPT0gJ2xlZnQnID8gJ2xlZnQtb3JpZ2luLWNlbnRlcicgOiAncmlnaHQtb3JpZ2luLWNlbnRlcic7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSB2aWV3IGhhcyBiZWVuIHNldCwgY2hlY2sgaWYgdGhlIHRhYiBjb250ZW50IGlzIHNldCB0byB0aGUgY2VudGVyIGFuZCBhdHRhY2ggdGhlXG4gICAgICogY29udGVudCBpZiBpdCBpcyBub3QgYWxyZWFkeSBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2VudGVyUG9zaXRpb24odGhpcy5fcG9zaXRpb24pICYmICF0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoKHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZnRlciB0aGUgY29udGVudCBoYXMgYmVlbiBjaGVja2VkLCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGFsbG93ZWQgdG9cbiAgICAgKiBhbmltYXRlLiBUaGlzIGhhcyB0byBiZSBsaW1pdGVkLCBiZWNhdXNlIHVuZGVyIGEgc3BlY2lmaWMgc2V0IG9mIGNpcmN1bXN0YW5jZXMgKHNlZSAjMjE1MSksXG4gICAgICogdGhlIGFuaW1hdGlvbnMgY2FuIGJlIHRyaWdnZXJlZCB0b28gZWFybHksIHdoaWNoIGVpdGhlciBjcmFzaGVzIENocm9tZSBieSBwdXR0aW5nIGl0IGludG8gYW5cbiAgICAgKiBpbmZpbml0ZSBsb29wICh3aXRoIEFuZ3VsYXIgPCAyLjMuMCkgb3IgdGhyb3dzIGFuIGVycm9yIGJlY2F1c2UgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFcbiAgICAgKiBjb21wdXRlZCBzdHlsZSAod2l0aCBBbmd1bGFyID4gMi4zLjApLiBUaGlzIGNhbiBhbHRlcm5hdGl2ZWx5IGJlIGRldGVybWluZWQgYnkgY2hlY2tpbmcgdGhlXG4gICAgICogdHJhbnNmb3JtOiBjYW5CZUFuaW1hdGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSAhPT0gJycsIGhvd2V2ZXIgZG9jdW1lbnQuY29udGFpbnMgc2hvdWxkXG4gICAgICogYmUgZmFzdGVyIHNpbmNlIGl0IGRvZXNuJ3QgY2F1c2UgYSByZWZsb3cuXG4gICAgICpcbiAgICAgKiBUT0RPOiBUaGlzIGNhbiBzYWZlbHkgYmUgcmVtb3ZlZCBhZnRlciB3ZSBzdG9wIHN1cHBvcnRpbmcgQW5ndWxhciA8IDIuNC4yLiBUaGUgZml4IGxhbmRlZCB2aWFcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2NvbW1pdC8yMTAzMGU5YTFjZjMwZTgxMDEzOTlkODUzNWVkNzJkODQ3YTIzYmE2XG4gICAgICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FuQmVBbmltYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2FuQmVBbmltYXRlZCA9IGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW5CZUFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUuX29uVHJhbnNsYXRlVGFiU3RhcnRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NlbnRlclBvc2l0aW9uKGUudG9TdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25DZW50ZXJpbmcuZW1pdCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5fb25UcmFuc2xhdGVUYWJDb21wbGV0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIElmIHRoZSBlbmQgc3RhdGUgaXMgdGhhdCB0aGUgdGFiIGlzIG5vdCBjZW50ZXJlZCwgdGhlbiBkZXRhY2ggdGhlIGNvbnRlbnQuXG4gICAgICAgIGlmICghdGhpcy5faXNDZW50ZXJQb3NpdGlvbihlLnRvU3RhdGUpICYmICF0aGlzLl9pc0NlbnRlclBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5fcG9ydGFsSG9zdC5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdHJhbnNpdGlvbiB0byB0aGUgY2VudGVyIGlzIGNvbXBsZXRlLCBlbWl0IGFuIGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5faXNDZW50ZXJQb3NpdGlvbihlLnRvU3RhdGUpICYmIHRoaXMuX2lzQ2VudGVyUG9zaXRpb24odGhpcy5fcG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2VudGVyZWQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC4gKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLl9nZXRMYXlvdXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gICAgfTtcbiAgICAvKiogV2hldGhlciB0aGUgcHJvdmlkZWQgcG9zaXRpb24gc3RhdGUgaXMgY29uc2lkZXJlZCBjZW50ZXIsIHJlZ2FyZGxlc3Mgb2Ygb3JpZ2luLiAqL1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUuX2lzQ2VudGVyUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09ICdjZW50ZXInIHx8XG4gICAgICAgICAgICBwb3NpdGlvbiA9PSAnbGVmdC1vcmlnaW4tY2VudGVyJyB8fFxuICAgICAgICAgICAgcG9zaXRpb24gPT0gJ3JpZ2h0LW9yaWdpbi1jZW50ZXInO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ2MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKFBvcnRhbEhvc3REaXJlY3RpdmUpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnR5cGUnLCBQb3J0YWxIb3N0RGlyZWN0aXZlKVxuICAgIF0sIE1kVGFiQm9keS5wcm90b3R5cGUsIFwiX3BvcnRhbEhvc3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjMoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgTWRUYWJCb2R5LnByb3RvdHlwZSwgXCJvbkNlbnRlcmluZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcilcbiAgICBdLCBNZFRhYkJvZHkucHJvdG90eXBlLCBcIm9uQ2VudGVyZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnY29udGVudCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnR5cGUnLCBUZW1wbGF0ZVBvcnRhbClcbiAgICBdLCBNZFRhYkJvZHkucHJvdG90eXBlLCBcIl9jb250ZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ3Bvc2l0aW9uJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYzKCdkZXNpZ246dHlwZScsIE51bWJlciksIFxuICAgICAgICBfX21ldGFkYXRhJDYzKCdkZXNpZ246cGFyYW10eXBlcycsIFtOdW1iZXJdKVxuICAgIF0sIE1kVGFiQm9keS5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ29yaWdpbicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnR5cGUnLCBOdW1iZXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbTnVtYmVyXSlcbiAgICBdLCBNZFRhYkJvZHkucHJvdG90eXBlLCBcIm9yaWdpblwiLCBudWxsKTtcbiAgICBNZFRhYkJvZHkgPSBfX2RlY29yYXRlJDYzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdGFiLWJvZHksIG1hdC10YWItYm9keScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWJvZHktY29udGVudFxcXCIgI2NvbnRlbnQgW0B0cmFuc2xhdGVUYWJdPVxcXCJfY2FuQmVBbmltYXRlZCA/IF9wb3NpdGlvbiA6IG51bGxcXFwiIChAdHJhbnNsYXRlVGFiLnN0YXJ0KT1cXFwiX29uVHJhbnNsYXRlVGFiU3RhcnRlZCgkZXZlbnQpXFxcIiAoQHRyYW5zbGF0ZVRhYi5kb25lKT1cXFwiX29uVHJhbnNsYXRlVGFiQ29tcGxldGUoJGV2ZW50KVxcXCI+PHRlbXBsYXRlIGNka1BvcnRhbEhvc3Q+PC90ZW1wbGF0ZT48L2Rpdj5cIixcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItYm9keV0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJpZ2dlcigndHJhbnNsYXRlVGFiJywgW1xuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdsZWZ0JywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdsZWZ0LW9yaWdpbi1jZW50ZXInLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgncmlnaHQtb3JpZ2luLWNlbnRlcicsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdjZW50ZXInLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgncmlnaHQnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCcqID0+IGxlZnQsICogPT4gcmlnaHQsIGxlZnQgPT4gY2VudGVyLCByaWdodCA9PiBjZW50ZXInLCBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoJzUwMG1zIGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKScpKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCd2b2lkID0+IGxlZnQtb3JpZ2luLWNlbnRlcicsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5hbmltYXRlKCc1MDBtcyBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSknKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCd2b2lkID0+IHJpZ2h0LW9yaWdpbi1jZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5hbmltYXRlKCc1MDBtcyBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSknKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDEyKDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDYzKCdkZXNpZ246cGFyYW10eXBlcycsIFtEaXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZl0pXG4gICAgXSwgTWRUYWJCb2R5KTtcbiAgICByZXR1cm4gTWRUYWJCb2R5O1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNjQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDEzID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBUaGUgZGlzdGFuY2UgaW4gcGl4ZWxzIHRoYXQgd2lsbCBiZSBvdmVyc2hvdCB3aGVuIHNjcm9sbGluZyBhIHRhYiBsYWJlbCBpbnRvIHZpZXcuIFRoaXMgaGVscHNcbiAqIHByb3ZpZGUgYSBzbWFsbCBhZmZvcmRhbmNlIHRvIHRoZSBsYWJlbCBuZXh0IHRvIGl0LlxuICovXG52YXIgRVhBR0dFUkFURURfT1ZFUlNDUk9MTCA9IDYwO1xuLyoqXG4gKiBUaGUgaGVhZGVyIG9mIHRoZSB0YWIgZ3JvdXAgd2hpY2ggZGlzcGxheXMgYSBsaXN0IG9mIGFsbCB0aGUgdGFicyBpbiB0aGUgdGFiIGdyb3VwLiBJbmNsdWRlc1xuICogYW4gaW5rIGJhciB0aGF0IGZvbGxvd3MgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YWIuIFdoZW4gdGhlIHRhYnMgbGlzdCdzIHdpZHRoIGV4Y2VlZHMgdGhlXG4gKiB3aWR0aCBvZiB0aGUgaGVhZGVyIGNvbnRhaW5lciwgdGhlbiBhcnJvd3Mgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gYWxsb3cgdGhlIHVzZXIgdG8gc2Nyb2xsXG4gKiBsZWZ0IGFuZCByaWdodCBhY3Jvc3MgdGhlIGhlYWRlci5cbiAqL1xudmFyIE1kVGFiSGVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYkhlYWRlcihfem9uZSwgX2VsZW1lbnRSZWYsIF9kaXIpIHtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIC8qKiBUaGUgdGFiIGluZGV4IHRoYXQgaXMgZm9jdXNlZC4gKi9cbiAgICAgICAgdGhpcy5fZm9jdXNJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgZGlzdGFuY2UgaW4gcGl4ZWxzIHRoYXQgdGhlIHRhYiBsYWJlbHMgc2hvdWxkIGJlIHRyYW5zbGF0ZWQgdG8gdGhlIGxlZnQuICovXG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlID0gMDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGhlYWRlciBzaG91bGQgc2Nyb2xsIHRvIHRoZSBzZWxlY3RlZCBpbmRleCBhZnRlciB0aGUgdmlldyBoYXMgYmVlbiBjaGVja2VkLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgY29udHJvbHMgZm9yIHBhZ2luYXRpb24gc2hvdWxkIGJlIGRpc3BsYXllZCAqL1xuICAgICAgICB0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0YWIgbGlzdCBjYW4gYmUgc2Nyb2xsZWQgbW9yZSB0b3dhcmRzIHRoZSBlbmQgb2YgdGhlIHRhYiBsYWJlbCBsaXN0LiAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQWZ0ZXIgPSB0cnVlO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgdGFiIGxpc3QgY2FuIGJlIHNjcm9sbGVkIG1vcmUgdG93YXJkcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0YWIgbGFiZWwgbGlzdC4gKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZVNjcm9sbEJlZm9yZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBvcHRpb24gaXMgc2VsZWN0ZWQuICovXG4gICAgICAgIHRoaXMuc2VsZWN0Rm9jdXNlZEluZGV4ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gYSBsYWJlbCBpcyBmb2N1c2VkLiAqL1xuICAgICAgICB0aGlzLmluZGV4Rm9jdXNlZCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7IH0sXG4gICAgICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0YWIuICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4Q2hhbmdlZCA9IHRoaXMuX3NlbGVjdGVkSW5kZXggIT0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0luZGV4ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2YgdGFiIGxhYmVscyBoYXZlIGNoYW5nZWQsIGNoZWNrIGlmIHNjcm9sbGluZyBzaG91bGQgYmUgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5fdGFiTGFiZWxDb3VudCAhPSB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fdGFiTGFiZWxDb3VudCA9IHRoaXMuX2xhYmVsV3JhcHBlcnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3RlZCBpbmRleCBoYXMgY2hhbmdlZCwgc2Nyb2xsIHRvIHRoZSBsYWJlbCBhbmQgY2hlY2sgaWYgdGhlIHNjcm9sbGluZyBjb250cm9sc1xuICAgICAgICAvLyBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9MYWJlbCh0aGlzLl9zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduSW5rQmFyVG9TZWxlY3RlZFRhYigpO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsIGRpc3RhbmNlIGhhcyBiZWVuIGNoYW5nZWQgKHRhYiBzZWxlY3RlZCwgZm9jdXNlZCwgc2Nyb2xsIGNvbnRyb2xzIGFjdGl2YXRlZCksXG4gICAgICAgIC8vIHRoZW4gdHJhbnNsYXRlIHRoZSBoZWFkZXIgdG8gcmVmbGVjdCB0aGlzLlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUYWJTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5faGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNOZXh0VGFiKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQcmV2aW91c1RhYigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZvY3VzZWRJbmRleC5lbWl0KHRoaXMuZm9jdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFsaWducyB0aGUgaW5rIGJhciB0byB0aGUgc2VsZWN0ZWQgdGFiIG9uIGxvYWQuXG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWxpZ25JbmtCYXJUb1NlbGVjdGVkVGFiKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3Igd2hlbiB0aGUgTXV0YXRpb25PYnNlcnZlciBkZXRlY3RzIHRoYXQgdGhlIGNvbnRlbnQgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9vbkNvbnRlbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQYWdpbmF0aW9uKCk7XG4gICAgICAgIHRoaXMuX2FsaWduSW5rQmFyVG9TZWxlY3RlZFRhYigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRpbmcgdGhlIHZpZXcgd2hldGhlciBwYWdpbmF0aW9uIHNob3VsZCBiZSBlbmFibGVkIG9yIG5vdFxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fdXBkYXRlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQYWdpbmF0aW9uRW5hYmxlZCgpO1xuICAgICAgICB0aGlzLl9jaGVja1Njcm9sbGluZ0NvbnRyb2xzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRhYlNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcImZvY3VzSW5kZXhcIiwge1xuICAgICAgICAvKiogVHJhY2tzIHdoaWNoIGVsZW1lbnQgaGFzIGZvY3VzOyB1c2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZm9jdXNJbmRleDsgfSxcbiAgICAgICAgLyoqIFdoZW4gdGhlIGZvY3VzIGluZGV4IGlzIHNldCwgd2UgbXVzdCBtYW51YWxseSBzZW5kIGZvY3VzIHRvIHRoZSBjb3JyZWN0IGxhYmVsICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRJbmRleCh2YWx1ZSkgfHwgdGhpcy5fZm9jdXNJbmRleCA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzSW5kZXggPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhGb2N1c2VkLmVtaXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VGFiRm9jdXModmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGFuIGluZGV4IGlzIHZhbGlkLiAgSWYgdGhlIHRhYnMgYXJlIG5vdCByZWFkeSB5ZXQsIHdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyIGlzXG4gICAgICogcHJvdmlkaW5nIGEgdmFsaWQgaW5kZXggYW5kIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5faXNWYWxpZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5fbGFiZWxXcmFwcGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhYiA9IHRoaXMuX2xhYmVsV3JhcHBlcnMgPyB0aGlzLl9sYWJlbFdyYXBwZXJzLnRvQXJyYXkoKVtpbmRleF0gOiBudWxsO1xuICAgICAgICByZXR1cm4gdGFiICYmICF0YWIuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIGZvY3VzIG9uIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBsYWJlbCB3cmFwcGVyIGFuZCBzY3JvbGxzIGl0IGludG8gdGhlIHZpZXcgaWZcbiAgICAgKiBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX3NldFRhYkZvY3VzID0gZnVuY3Rpb24gKHRhYkluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG93UGFnaW5hdGlvbkNvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb0xhYmVsKHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGFiZWxXcmFwcGVycyAmJiB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbdGFiSW5kZXhdLmZvY3VzKCk7XG4gICAgICAgICAgICAvLyBEbyBub3QgbGV0IHRoZSBicm93c2VyIG1hbmFnZSBzY3JvbGxpbmcgdG8gZm9jdXMgdGhlIGVsZW1lbnQsIHRoaXMgd2lsbCBiZSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBieSB1c2luZyB0cmFuc2xhdGlvbi4gSW4gTFRSLCB0aGUgc2Nyb2xsIGxlZnQgc2hvdWxkIGJlIDAuIEluIFJUTCwgdGhlIHNjcm9sbCB3aWR0aFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSBmdWxsIHdpZHRoIG1pbnVzIHRoZSBvZmZzZXQgd2lkdGguXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyRWwgPSB0aGlzLl90YWJMaXN0Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgZGlyID0gdGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZGlyID09ICdsdHInKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbC5zY3JvbGxMZWZ0ID0gY29udGFpbmVyRWwuc2Nyb2xsV2lkdGggLSBjb250YWluZXJFbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGZvY3VzIHRvd2FyZHMgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mIHRoZSBsaXN0IGRlcGVuZGluZyBvbiB0aGUgb2Zmc2V0IHByb3ZpZGVkLlxuICAgICAqIFZhbGlkIG9mZnNldHMgYXJlIDEgYW5kIC0xLlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fbW92ZUZvY3VzID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWxXcmFwcGVycykge1xuICAgICAgICAgICAgdmFyIHRhYnMgPSB0aGlzLl9sYWJlbFdyYXBwZXJzLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmZvY3VzSW5kZXggKyBvZmZzZXQ7IGkgPCB0YWJzLmxlbmd0aCAmJiBpID49IDA7IGkgKz0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRJbmRleChpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogSW5jcmVtZW50IHRoZSBmb2N1cyBpbmRleCBieSAxIHVudGlsIGEgdmFsaWQgdGFiIGlzIGZvdW5kLiAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fZm9jdXNOZXh0VGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3ZlRm9jdXModGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCkgPT0gJ2x0cicgPyAxIDogLTEpO1xuICAgIH07XG4gICAgLyoqIERlY3JlbWVudCB0aGUgZm9jdXMgaW5kZXggYnkgMSB1bnRpbCBhIHZhbGlkIHRhYiBpcyBmb3VuZC4gKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2ZvY3VzUHJldmlvdXNUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vdmVGb2N1cyh0aGlzLl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAnbHRyJyA/IC0xIDogMSk7XG4gICAgfTtcbiAgICAvKiogVGhlIGxheW91dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLiAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fZ2V0TGF5b3V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH07XG4gICAgLyoqIFBlcmZvcm1zIHRoZSBDU1MgdHJhbnNmb3JtYXRpb24gb24gdGhlIHRhYiBsaXN0IHRoYXQgd2lsbCBjYXVzZSB0aGUgbGlzdCB0byBzY3JvbGwuICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl91cGRhdGVUYWJTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZVggPSB0aGlzLnNjcm9sbERpc3RhbmNlICsgJ3B4JztcbiAgICAgICAgaWYgKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVYID0gJy0nICsgdHJhbnNsYXRlWDtcbiAgICAgICAgfVxuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aGlzLl90YWJMaXN0Lm5hdGl2ZUVsZW1lbnQsIFwidHJhbnNsYXRlM2QoXCIgKyB0cmFuc2xhdGVYICsgXCIsIDAsIDApXCIpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJzY3JvbGxEaXN0YW5jZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2Nyb2xsRGlzdGFuY2U7IH0sXG4gICAgICAgIC8qKiBTZXRzIHRoZSBkaXN0YW5jZSBpbiBwaXhlbHMgdGhhdCB0aGUgdGFiIGhlYWRlciBzaG91bGQgYmUgdHJhbnNmb3JtZWQgaW4gdGhlIFgtYXhpcy4gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2UgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLl9nZXRNYXhTY3JvbGxEaXN0YW5jZSgpLCB2KSk7XG4gICAgICAgICAgICAvLyBNYXJrIHRoYXQgdGhlIHNjcm9sbCBkaXN0YW5jZSBoYXMgY2hhbmdlZCBzbyB0aGF0IGFmdGVyIHRoZSB2aWV3IGlzIGNoZWNrZWQsIHRoZSBDU1NcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybWF0aW9uIGNhbiBtb3ZlIHRoZSBoZWFkZXIuXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxEaXN0YW5jZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tTY3JvbGxpbmdDb250cm9scygpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgdGFiIGxpc3QgaW4gdGhlICdiZWZvcmUnIG9yICdhZnRlcicgZGlyZWN0aW9uICh0b3dhcmRzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3Qgb3JcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBsaXN0LCByZXNwZWN0aXZlbHkpLiBUaGUgZGlzdGFuY2UgdG8gc2Nyb2xsIGlzIGNvbXB1dGVkIHRvIGJlIGEgdGhpcmQgb2YgdGhlXG4gICAgICogbGVuZ3RoIG9mIHRoZSB0YWIgbGlzdCB2aWV3IHdpbmRvdy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZXhwZW5zaXZlIGNhbGwgdGhhdCBmb3JjZXMgYSBsYXlvdXQgcmVmbG93IHRvIGNvbXB1dGUgYm94IGFuZCBzY3JvbGwgbWV0cmljcyBhbmRcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIHNwYXJpbmdseS5cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX3Njcm9sbEhlYWRlciA9IGZ1bmN0aW9uIChzY3JvbGxEaXIpIHtcbiAgICAgICAgdmFyIHZpZXdMZW5ndGggPSB0aGlzLl90YWJMaXN0Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8vIE1vdmUgdGhlIHNjcm9sbCBkaXN0YW5jZSBvbmUtdGhpcmQgdGhlIGxlbmd0aCBvZiB0aGUgdGFiIGxpc3QncyB2aWV3cG9ydC5cbiAgICAgICAgdGhpcy5zY3JvbGxEaXN0YW5jZSArPSAoc2Nyb2xsRGlyID09ICdiZWZvcmUnID8gLTEgOiAxKSAqIHZpZXdMZW5ndGggLyAzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHRhYiBsaXN0IHN1Y2ggdGhhdCB0aGUgZGVzaXJlZCB0YWIgbGFiZWwgKG1hcmtlZCBieSBpbmRleCkgaXMgbW92ZWQgaW50byB2aWV3LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fc2Nyb2xsVG9MYWJlbCA9IGZ1bmN0aW9uIChsYWJlbEluZGV4KSB7XG4gICAgICAgIHZhciBzZWxlY3RlZExhYmVsID0gdGhpcy5fbGFiZWxXcmFwcGVyc1xuICAgICAgICAgICAgPyB0aGlzLl9sYWJlbFdyYXBwZXJzLnRvQXJyYXkoKVtsYWJlbEluZGV4XVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIXNlbGVjdGVkTGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdmlldyBsZW5ndGggaXMgdGhlIHZpc2libGUgd2lkdGggb2YgdGhlIHRhYiBsYWJlbHMuXG4gICAgICAgIHZhciB2aWV3TGVuZ3RoID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB2YXIgbGFiZWxCZWZvcmVQb3MsIGxhYmVsQWZ0ZXJQb3M7XG4gICAgICAgIGlmICh0aGlzLl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAnbHRyJykge1xuICAgICAgICAgICAgbGFiZWxCZWZvcmVQb3MgPSBzZWxlY3RlZExhYmVsLmdldE9mZnNldExlZnQoKTtcbiAgICAgICAgICAgIGxhYmVsQWZ0ZXJQb3MgPSBsYWJlbEJlZm9yZVBvcyArIHNlbGVjdGVkTGFiZWwuZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsQWZ0ZXJQb3MgPSB0aGlzLl90YWJMaXN0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLSBzZWxlY3RlZExhYmVsLmdldE9mZnNldExlZnQoKTtcbiAgICAgICAgICAgIGxhYmVsQmVmb3JlUG9zID0gbGFiZWxBZnRlclBvcyAtIHNlbGVjdGVkTGFiZWwuZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVmb3JlVmlzaWJsZVBvcyA9IHRoaXMuc2Nyb2xsRGlzdGFuY2U7XG4gICAgICAgIHZhciBhZnRlclZpc2libGVQb3MgPSB0aGlzLnNjcm9sbERpc3RhbmNlICsgdmlld0xlbmd0aDtcbiAgICAgICAgaWYgKGxhYmVsQmVmb3JlUG9zIDwgYmVmb3JlVmlzaWJsZVBvcykge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIGhlYWRlciB0byBtb3ZlIGxhYmVsIHRvIHRoZSBiZWZvcmUgZGlyZWN0aW9uXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpc3RhbmNlIC09IGJlZm9yZVZpc2libGVQb3MgLSBsYWJlbEJlZm9yZVBvcyArIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFiZWxBZnRlclBvcyA+IGFmdGVyVmlzaWJsZVBvcykge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIGhlYWRlciB0byBtb3ZlIGxhYmVsIHRvIHRoZSBhZnRlciBkaXJlY3Rpb25cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlzdGFuY2UgKz0gbGFiZWxBZnRlclBvcyAtIGFmdGVyVmlzaWJsZVBvcyArIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHdoZXRoZXIgdGhlIHBhZ2luYXRpb24gY29udHJvbHMgc2hvdWxkIGJlIGRpc3BsYXllZC4gSWYgdGhlIHNjcm9sbCB3aWR0aCBvZiB0aGVcbiAgICAgKiB0YWIgbGlzdCBpcyB3aWRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBoZWFkZXIgY29udGFpbmVyLCB0aGVuIHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIHNob3VsZFxuICAgICAqIGJlIHNob3duLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fY2hlY2tQYWdpbmF0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2hvd1BhZ2luYXRpb25Db250cm9scyA9XG4gICAgICAgICAgICB0aGlzLl90YWJMaXN0Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsV2lkdGggPiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGlmICghdGhpcy5fc2hvd1BhZ2luYXRpb25Db250cm9scykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXN0YW5jZSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHdoZXRoZXIgdGhlIGJlZm9yZSBhbmQgYWZ0ZXIgY29udHJvbHMgc2hvdWxkIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gICAgICogSWYgdGhlIGhlYWRlciBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0IChzY3JvbGwgZGlzdGFuY2UgaXMgZXF1YWwgdG8gMCkgdGhlbiBkaXNhYmxlIHRoZVxuICAgICAqIGJlZm9yZSBidXR0b24uIElmIHRoZSBoZWFkZXIgaXMgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCAoc2Nyb2xsIGRpc3RhbmNlIGlzIGVxdWFsIHRvIHRoZVxuICAgICAqIG1heGltdW0gZGlzdGFuY2Ugd2UgY2FuIHNjcm9sbCksIHRoZW4gZGlzYWJsZSB0aGUgYWZ0ZXIgYnV0dG9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fY2hlY2tTY3JvbGxpbmdDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBhZ2luYXRpb24gYXJyb3dzIHNob3VsZCBiZSBhY3RpdmF0ZWQuXG4gICAgICAgIHRoaXMuX2Rpc2FibGVTY3JvbGxCZWZvcmUgPSB0aGlzLnNjcm9sbERpc3RhbmNlID09IDA7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVTY3JvbGxBZnRlciA9IHRoaXMuc2Nyb2xsRGlzdGFuY2UgPT0gdGhpcy5fZ2V0TWF4U2Nyb2xsRGlzdGFuY2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hhdCBpcyB0aGUgbWF4aW11bSBsZW5ndGggaW4gcGl4ZWxzIHRoYXQgY2FuIGJlIHNldCBmb3IgdGhlIHNjcm9sbCBkaXN0YW5jZS4gVGhpc1xuICAgICAqIGlzIGVxdWFsIHRvIHRoZSBkaWZmZXJlbmNlIGluIHdpZHRoIGJldHdlZW4gdGhlIHRhYiBsaXN0IGNvbnRhaW5lciBhbmQgdGFiIGhlYWRlciBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBjYWxsIHRoYXQgZm9yY2VzIGEgbGF5b3V0IHJlZmxvdyB0byBjb21wdXRlIGJveCBhbmQgc2Nyb2xsIG1ldHJpY3MgYW5kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBzcGFyaW5nbHkuXG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9nZXRNYXhTY3JvbGxEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbmd0aE9mVGFiTGlzdCA9IHRoaXMuX3RhYkxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgdmFyIHZpZXdMZW5ndGggPSB0aGlzLl90YWJMaXN0Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIHJldHVybiBsZW5ndGhPZlRhYkxpc3QgLSB2aWV3TGVuZ3RoO1xuICAgIH07XG4gICAgLyoqIFRlbGxzIHRoZSBpbmstYmFyIHRvIGFsaWduIGl0c2VsZiB0byB0aGUgY3VycmVudCBsYWJlbCB3cmFwcGVyICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9hbGlnbklua0JhclRvU2VsZWN0ZWRUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3RlZExhYmVsV3JhcHBlciA9IHRoaXMuX2xhYmVsV3JhcHBlcnMgJiYgdGhpcy5fbGFiZWxXcmFwcGVycy5sZW5ndGhcbiAgICAgICAgICAgID8gdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4XS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnRcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbmtCYXIuYWxpZ25Ub0VsZW1lbnQoc2VsZWN0ZWRMYWJlbFdyYXBwZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ2NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kVGFiTGFiZWxXcmFwcGVyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjQoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcIl9sYWJlbFdyYXBwZXJzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKE1kSW5rQmFyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjQoJ2Rlc2lnbjp0eXBlJywgTWRJbmtCYXIpXG4gICAgXSwgTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcIl9pbmtCYXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDY0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoJ3RhYkxpc3RDb250YWluZXInKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjQoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJfdGFiTGlzdENvbnRhaW5lclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgndGFiTGlzdCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NCgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYpXG4gICAgXSwgTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcIl90YWJMaXN0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjQoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW051bWJlcl0pXG4gICAgXSwgTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDY0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRhYkhlYWRlci5wcm90b3R5cGUsIFwic2VsZWN0Rm9jdXNlZEluZGV4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDY0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRhYkhlYWRlci5wcm90b3R5cGUsIFwiaW5kZXhGb2N1c2VkXCIsIHZvaWQgMCk7XG4gICAgTWRUYWJIZWFkZXIgPSBfX2RlY29yYXRlJDY0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdGFiLWhlYWRlciwgbWF0LXRhYi1oZWFkZXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbiBtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZSBtYXQtZWxldmF0aW9uLXo0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgbWQtcmlwcGxlIFttZFJpcHBsZURpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxCZWZvcmVcXFwiIFtjbGFzcy5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWRpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxCZWZvcmVcXFwiIChjbGljayk9XFxcIl9zY3JvbGxIZWFkZXIoJ2JlZm9yZScpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb25cXFwiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGFiZWwtY29udGFpbmVyXFxcIiAjdGFiTGlzdENvbnRhaW5lciAoa2V5ZG93bik9XFxcIl9oYW5kbGVLZXlkb3duKCRldmVudClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGlzdFxcXCIgI3RhYkxpc3Qgcm9sZT1cXFwidGFibGlzdFxcXCIgKGNka09ic2VydmVDb250ZW50KT1cXFwiX29uQ29udGVudENoYW5nZXMoKVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1sYWJlbHNcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48bWQtaW5rLWJhcj48L21kLWluay1iYXI+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbiBtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyIG1hdC1lbGV2YXRpb24tejRcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlRGlzYWJsZWRdPVxcXCJfZGlzYWJsZVNjcm9sbEFmdGVyXFxcIiBbY2xhc3MubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1kaXNhYmxlZF09XFxcIl9kaXNhYmxlU2Nyb2xsQWZ0ZXJcXFwiIChjbGljayk9XFxcIl9zY3JvbGxIZWFkZXIoJ2FmdGVyJylcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvblxcXCI+PC9kaXY+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdGFiLWhlYWRlcntkaXNwbGF5OmZsZXg7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtc2hyaW5rOjB9Lm1hdC10YWItbGFiZWx7bGluZS1oZWlnaHQ6NDhweDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTJweDtmb250LXNpemU6MTRweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjUwMDtjdXJzb3I6cG9pbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6Y3VycmVudENvbG9yO29wYWNpdHk6LjY7bWluLXdpZHRoOjE2MHB4O3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtdGFiLWxhYmVsOmZvY3Vze291dGxpbmU6MDtvcGFjaXR5OjF9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxhYmVse21pbi13aWR0aDo3MnB4fX0ubWF0LWluay1iYXJ7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7aGVpZ2h0OjJweDt0cmFuc2l0aW9uOi41cyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpfS5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlciAubWF0LWluay1iYXJ7Ym90dG9tOmF1dG87dG9wOjB9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb257cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpub25lO2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO21pbi13aWR0aDozMnB4O2N1cnNvcjpwb2ludGVyO3otaW5kZXg6Mn0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jb250cm9scy1lbmFibGVkIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLC5tYXQtdGFiLWxhYmVsc3tkaXNwbGF5OmZsZXh9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYmVmb3JlLC5tYXQtdGFiLWhlYWRlci1ydGwgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYWZ0ZXJ7cGFkZGluZy1sZWZ0OjRweH0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbiwubWF0LXRhYi1oZWFkZXItcnRsIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVyIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb257dHJhbnNmb3JtOnJvdGF0ZSgtMTM1ZGVnKX0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlciwubWF0LXRhYi1oZWFkZXItcnRsIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZXtwYWRkaW5nLXJpZ2h0OjRweH0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlciAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9uLC5tYXQtdGFiLWhlYWRlci1ydGwgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYmVmb3JlIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb257dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbntib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOjJweCAycHggMCAwO2NvbnRlbnQ6Jyc7aGVpZ2h0OjhweDt3aWR0aDo4cHh9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tZGlzYWJsZWR7Ym94LXNoYWRvdzpub25lO2N1cnNvcjpkZWZhdWx0fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWRpc2FibGVkIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb257Ym9yZGVyLWNvbG9yOiNjY2N9Lm1hdC10YWItbGFiZWwtY29udGFpbmVye2Rpc3BsYXk6ZmxleDtmbGV4LWdyb3c6MTtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDoxfS5tYXQtdGFiLWxpc3R7ZmxleC1ncm93OjE7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtdGFiLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNvbnRyb2xzLWVuYWJsZWRdJzogJ19zaG93UGFnaW5hdGlvbkNvbnRyb2xzJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItaGVhZGVyLXJ0bF0nOiBcIl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAncnRsJ1wiLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQxMygyLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgRGlyXSlcbiAgICBdLCBNZFRhYkhlYWRlcik7XG4gICAgcmV0dXJuIE1kVGFiSGVhZGVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNTcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRCdzIGZvciBlYWNoIHRhYiBjb21wb25lbnQgKi9cbnZhciBuZXh0SWQkMiA9IDA7XG4vKiogQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgb24gZm9jdXMgb3Igc2VsZWN0aW9uIGNoYW5nZXMuICovXG52YXIgTWRUYWJDaGFuZ2VFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJDaGFuZ2VFdmVudCgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kVGFiQ2hhbmdlRXZlbnQ7XG59KCkpO1xuLyoqXG4gKiBNYXRlcmlhbCBkZXNpZ24gdGFiLWdyb3VwIGNvbXBvbmVudC4gIFN1cHBvcnRzIGJhc2ljIHRhYiBwYWlycyAobGFiZWwgKyBjb250ZW50KSBhbmQgaW5jbHVkZXNcbiAqIGFuaW1hdGVkIGluay1iYXIsIGtleWJvYXJkIG5hdmlnYXRpb24sIGFuZCBzY3JlZW4gcmVhZGVyLlxuICogU2VlOiBodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvdGFicy5odG1sXG4gKi9cbnZhciBNZFRhYkdyb3VwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYkdyb3VwKF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyBjb21wb25lbnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuICovXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRoZSB0YWIgaW5kZXggdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQgYWZ0ZXIgdGhlIGNvbnRlbnQgaGFzIGJlZW4gY2hlY2tlZC4gKi9cbiAgICAgICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9IDA7XG4gICAgICAgIC8qKiBTbmFwc2hvdCBvZiB0aGUgaGVpZ2h0IG9mIHRoZSB0YWIgYm9keSB3cmFwcGVyIGJlZm9yZSBhbm90aGVyIHRhYiBpcyBhY3RpdmF0ZWQuICovXG4gICAgICAgIHRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHRhYiBncm91cCBzaG91bGQgZ3JvdyB0byB0aGUgc2l6ZSBvZiB0aGUgYWN0aXZlIHRhYiAqL1xuICAgICAgICB0aGlzLl9keW5hbWljSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBudWxsO1xuICAgICAgICAvKiogUG9zaXRpb24gb2YgdGhlIHRhYiBoZWFkZXIuICovXG4gICAgICAgIHRoaXMuaGVhZGVyUG9zaXRpb24gPSAnYWJvdmUnO1xuICAgICAgICB0aGlzLl9vbkZvY3VzQ2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX29uU2VsZWN0Q2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKHRydWUpO1xuICAgICAgICB0aGlzLl9ncm91cElkID0gbmV4dElkJDIrKztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcImR5bmFtaWNIZWlnaHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2R5bmFtaWNIZWlnaHQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2R5bmFtaWNIZWlnaHQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiX2R5bmFtaWNIZWlnaHREZXByZWNhdGVkXCIsIHtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZHluYW1pY0hlaWdodDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZHluYW1pY0hlaWdodCA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbmRleDsgfSxcbiAgICAgICAgLyoqIFRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHRhYi4gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5faW5kZXhUb1NlbGVjdCA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleENoYW5nZVwiLCB7XG4gICAgICAgIC8qKiBPdXRwdXQgdG8gZW5hYmxlIHN1cHBvcnQgZm9yIHR3by13YXkgYmluZGluZyBvbiBgc2VsZWN0ZWRJbmRleGAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0Q2hhbmdlLm1hcChmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmluZGV4OyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcImZvY3VzQ2hhbmdlXCIsIHtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiBmb2N1cyBoYXMgY2hhbmdlZCB3aXRoaW4gYSB0YWIgZ3JvdXAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uRm9jdXNDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RDaGFuZ2VcIiwge1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB0YWIgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vblNlbGVjdENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGNvbnRlbnQgaXMgY2hlY2tlZCwgdGhpcyBjb21wb25lbnQga25vd3Mgd2hhdCB0YWJzIGhhdmUgYmVlbiBkZWZpbmVkXG4gICAgICogYW5kIHdoYXQgdGhlIHNlbGVjdGVkIGluZGV4IHNob3VsZCBiZS4gVGhpcyBpcyB3aGVyZSB3ZSBjYW4ga25vdyBleGFjdGx5IHdoYXQgcG9zaXRpb25cbiAgICAgKiBlYWNoIHRhYiBzaG91bGQgYmUgaW4gYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2VsZWN0ZWQgaW5kZXgsIGFuZCBhZGRpdGlvbmFsbHkgd2Uga25vdyBob3dcbiAgICAgKiBhIG5ldyBzZWxlY3RlZCB0YWIgc2hvdWxkIHRyYW5zaXRpb24gaW4gKGZyb20gdGhlIGxlZnQgb3IgcmlnaHQpLlxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ2xhbXAgdGhlIG5leHQgc2VsZWN0ZWQgaW5kZXggdG8gdGhlIGJvdW5kcyBvZiAwIGFuZCB0aGUgdGFicyBsZW5ndGguIE5vdGUgdGhlIGB8fCAwYCwgd2hpY2hcbiAgICAgICAgLy8gZW5zdXJlcyB0aGF0IHZhbHVlcyBsaWtlIE5hTiBjYW4ndCBnZXQgdGhyb3VnaCBhbmQgd2hpY2ggd291bGQgb3RoZXJ3aXNlIHRocm93IHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgaW50byBhbiBpbmZpbml0ZSBsb29wIChzaW5jZSBNYXRoLm1heChOYU4sIDApID09PSBOYU4pLlxuICAgICAgICB0aGlzLl9pbmRleFRvU2VsZWN0ID1cbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMuX3RhYnMubGVuZ3RoIC0gMSwgTWF0aC5tYXgodGhpcy5faW5kZXhUb1NlbGVjdCB8fCAwLCAwKSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgY2hhbmdlIGluIHNlbGVjdGVkIGluZGV4LCBlbWl0IGEgY2hhbmdlIGV2ZW50LiBTaG91bGQgbm90IHRyaWdnZXIgaWZcbiAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGluZGV4IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4ICE9IHRoaXMuX2luZGV4VG9TZWxlY3QgJiYgdGhpcy5fc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9vblNlbGVjdENoYW5nZS5lbWl0KHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KHRoaXMuX2luZGV4VG9TZWxlY3QpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXR1cCB0aGUgcG9zaXRpb24gZm9yIGVhY2ggdGFiIGFuZCBvcHRpb25hbGx5IHNldHVwIGFuIG9yaWdpbiBvbiB0aGUgbmV4dCBzZWxlY3RlZCB0YWIuXG4gICAgICAgIHRoaXMuX3RhYnMuZm9yRWFjaChmdW5jdGlvbiAodGFiLCBpbmRleCkge1xuICAgICAgICAgICAgdGFiLnBvc2l0aW9uID0gaW5kZXggLSBfdGhpcy5faW5kZXhUb1NlbGVjdDtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBzZWxlY3RlZCB0YWIsIHRoZW4gc2V0IHVwIGFuIG9yaWdpbiBmb3IgdGhlIG5leHQgc2VsZWN0ZWQgdGFiXG4gICAgICAgICAgICAvLyBpZiBpdCBkb2Vzbid0IGhhdmUgb25lIGFscmVhZHkuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3NlbGVjdGVkSW5kZXggIT0gbnVsbCAmJiB0YWIucG9zaXRpb24gPT0gMCAmJiAhdGFiLm9yaWdpbikge1xuICAgICAgICAgICAgICAgIHRhYi5vcmlnaW4gPSBfdGhpcy5faW5kZXhUb1NlbGVjdCAtIF90aGlzLl9zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IHRoaXMuX2luZGV4VG9TZWxlY3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYWl0cyBvbmUgZnJhbWUgZm9yIHRoZSB2aWV3IHRvIHVwZGF0ZSwgdGhlbiB1cGRhdGVzIHRoZSBpbmsgYmFyXG4gICAgICogTm90ZTogVGhpcyBtdXN0IGJlIHJ1biBvdXRzaWRlIG9mIHRoZSB6b25lIG9yIGl0IHdpbGwgY3JlYXRlIGFuIGluZmluaXRlIGNoYW5nZSBkZXRlY3Rpb24gbG9vcC5cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX2ZvY3VzQ2hhbmdlZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLl9vbkZvY3VzQ2hhbmdlLmVtaXQodGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoaW5kZXgpKTtcbiAgICB9O1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9jcmVhdGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTWRUYWJDaGFuZ2VFdmVudDtcbiAgICAgICAgZXZlbnQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKHRoaXMuX3RhYnMgJiYgdGhpcy5fdGFicy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhYiA9IHRoaXMuX3RhYnMudG9BcnJheSgpW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIHVuaXF1ZSBpZCBmb3IgZWFjaCB0YWIgbGFiZWwgZWxlbWVudCAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9nZXRUYWJMYWJlbElkID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIFwibWQtdGFiLWxhYmVsLVwiICsgdGhpcy5fZ3JvdXBJZCArIFwiLVwiICsgaTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgdW5pcXVlIGlkIGZvciBlYWNoIHRhYiBjb250ZW50IGVsZW1lbnQgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5fZ2V0VGFiQ29udGVudElkID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIFwibWQtdGFiLWNvbnRlbnQtXCIgKyB0aGlzLl9ncm91cElkICsgXCItXCIgKyBpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBib2R5IHdyYXBwZXIgdG8gdGhlIGhlaWdodCBvZiB0aGUgYWN0aXZhdGluZyB0YWIgaWYgZHluYW1pY1xuICAgICAqIGhlaWdodCBwcm9wZXJ0eSBpcyB0cnVlLlxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9zZXRUYWJCb2R5V3JhcHBlckhlaWdodCA9IGZ1bmN0aW9uICh0YWJIZWlnaHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9keW5hbWljSGVpZ2h0IHx8ICF0aGlzLl90YWJCb2R5V3JhcHBlckhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl90YWJCb2R5V3JhcHBlci5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdGhpcy5fdGFiQm9keVdyYXBwZXJIZWlnaHQgKyAncHgnKTtcbiAgICAgICAgLy8gVGhpcyBjb25kaXRpb25hbCBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcGFpbnQgdGhlIGhlaWdodCBzbyB0aGF0XG4gICAgICAgIC8vIHRoZSBhbmltYXRpb24gdG8gdGhlIG5ldyBoZWlnaHQgY2FuIGhhdmUgYW4gb3JpZ2luLlxuICAgICAgICBpZiAodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl90YWJCb2R5V3JhcHBlci5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdGFiSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSZW1vdmVzIHRoZSBoZWlnaHQgb2YgdGhlIHRhYiBib2R5IHdyYXBwZXIuICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX3JlbW92ZVRhYkJvZHlXcmFwcGVySGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YWJCb2R5V3JhcHBlckhlaWdodCA9IHRoaXMuX3RhYkJvZHlXcmFwcGVyLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsICcnKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZFRhYiksIFxuICAgICAgICBfX21ldGFkYXRhJDU3KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl90YWJzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKCd0YWJCb2R5V3JhcHBlcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiX3RhYkJvZHlXcmFwcGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJkeW5hbWljSGVpZ2h0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZC1keW5hbWljLWhlaWdodCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl9keW5hbWljSGVpZ2h0RGVwcmVjYXRlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnR5cGUnLCBOdW1iZXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnBhcmFtdHlwZXMnLCBbTnVtYmVyXSlcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDU3KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJoZWFkZXJQb3NpdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnR5cGUnLCByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZSlcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4Q2hhbmdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnR5cGUnLCByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZSlcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJmb2N1c0NoYW5nZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0Q2hhbmdlXCIsIG51bGwpO1xuICAgIE1kVGFiR3JvdXAgPSBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdGFiLWdyb3VwLCBtYXQtdGFiLWdyb3VwJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxtZC10YWItaGVhZGVyIFtzZWxlY3RlZEluZGV4XT1cXFwic2VsZWN0ZWRJbmRleFxcXCIgI3RhYkhlYWRlciAoaW5kZXhGb2N1c2VkKT1cXFwiX2ZvY3VzQ2hhbmdlZCgkZXZlbnQpXFxcIiAoc2VsZWN0Rm9jdXNlZEluZGV4KT1cXFwic2VsZWN0ZWRJbmRleCA9ICRldmVudFxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1sYWJlbFxcXCIgcm9sZT1cXFwidGFiXFxcIiBtZC10YWItbGFiZWwtd3JhcHBlciBtZC1yaXBwbGUgKm5nRm9yPVxcXCJsZXQgdGFiIG9mIF90YWJzOyBsZXQgaSA9IGluZGV4XFxcIiBbaWRdPVxcXCJfZ2V0VGFiTGFiZWxJZChpKVxcXCIgW3RhYkluZGV4XT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpID8gMCA6IC0xXFxcIiBbYXR0ci5hcmlhLWNvbnRyb2xzXT1cXFwiX2dldFRhYkNvbnRlbnRJZChpKVxcXCIgW2F0dHIuYXJpYS1zZWxlY3RlZF09XFxcInNlbGVjdGVkSW5kZXggPT0gaVxcXCIgW2NsYXNzLm1hdC10YWItbGFiZWwtYWN0aXZlXT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpXFxcIiBbZGlzYWJsZWRdPVxcXCJ0YWIuZGlzYWJsZWRcXFwiIChjbGljayk9XFxcInRhYkhlYWRlci5mb2N1c0luZGV4ID0gc2VsZWN0ZWRJbmRleCA9IGlcXFwiPjx0ZW1wbGF0ZSBbbmdJZl09XFxcInRhYi50ZW1wbGF0ZUxhYmVsXFxcIj48dGVtcGxhdGUgW2Nka1BvcnRhbEhvc3RdPVxcXCJ0YWIudGVtcGxhdGVMYWJlbFxcXCI+PC90ZW1wbGF0ZT48L3RlbXBsYXRlPjx0ZW1wbGF0ZSBbbmdJZl09XFxcIiF0YWIudGVtcGxhdGVMYWJlbFxcXCI+e3t0YWIudGV4dExhYmVsfX08L3RlbXBsYXRlPjwvZGl2PjwvbWQtdGFiLWhlYWRlcj48ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWJvZHktd3JhcHBlclxcXCIgI3RhYkJvZHlXcmFwcGVyPjxtZC10YWItYm9keSByb2xlPVxcXCJ0YWJwYW5lbFxcXCIgKm5nRm9yPVxcXCJsZXQgdGFiIG9mIF90YWJzOyBsZXQgaSA9IGluZGV4XFxcIiBbaWRdPVxcXCJfZ2V0VGFiQ29udGVudElkKGkpXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJfZ2V0VGFiTGFiZWxJZChpKVxcXCIgW2NsYXNzLm1hdC10YWItYm9keS1hY3RpdmVdPVxcXCJzZWxlY3RlZEluZGV4ID09IGlcXFwiIFtjb250ZW50XT1cXFwidGFiLmNvbnRlbnRcXFwiIFtwb3NpdGlvbl09XFxcInRhYi5wb3NpdGlvblxcXCIgW29yaWdpbl09XFxcInRhYi5vcmlnaW5cXFwiIChvbkNlbnRlcmVkKT1cXFwiX3JlbW92ZVRhYkJvZHlXcmFwcGVySGVpZ2h0KClcXFwiIChvbkNlbnRlcmluZyk9XFxcIl9zZXRUYWJCb2R5V3JhcHBlckhlaWdodCgkZXZlbnQpXFxcIj48L21kLXRhYi1ib2R5PjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWZ9Omhvc3QubWF0LXRhYi1ncm91cC1pbnZlcnRlZC1oZWFkZXJ7ZmxleC1kaXJlY3Rpb246Y29sdW1uLXJldmVyc2V9Lm1hdC10YWItbGFiZWx7bGluZS1oZWlnaHQ6NDhweDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTJweDtmb250LXNpemU6MTRweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjUwMDtjdXJzb3I6cG9pbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6Y3VycmVudENvbG9yO29wYWNpdHk6LjY7bWluLXdpZHRoOjE2MHB4O3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtdGFiLWxhYmVsOmZvY3Vze291dGxpbmU6MDtvcGFjaXR5OjF9QG1lZGlhIChtYXgtd2lkdGg6NjAwcHgpey5tYXQtdGFiLWxhYmVse21pbi13aWR0aDo3MnB4fX06aG9zdFttYXQtc3RyZXRjaC10YWJzXSAubWF0LXRhYi1sYWJlbCw6aG9zdFttZC1zdHJldGNoLXRhYnNdIC5tYXQtdGFiLWxhYmVse2ZsZXgtYmFzaXM6MDtmbGV4LWdyb3c6MX0ubWF0LXRhYi1ib2R5LXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO2Rpc3BsYXk6ZmxleDt0cmFuc2l0aW9uOmhlaWdodCAuNXMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX0ubWF0LXRhYi1ib2R5e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVufS5tYXQtdGFiLWJvZHkubWF0LXRhYi1ib2R5LWFjdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdy14OmhpZGRlbjtvdmVyZmxvdy15OmF1dG87ei1pbmRleDoxO2ZsZXgtZ3JvdzoxfTpob3N0Lm1hdC10YWItZ3JvdXAtZHluYW1pYy1oZWlnaHQgLm1hdC10YWItYm9keS5tYXQtdGFiLWJvZHktYWN0aXZle292ZXJmbG93LXk6aGlkZGVufS5tYXQtdGFiLWRpc2FibGVke2N1cnNvcjpkZWZhdWx0O3BvaW50ZXItZXZlbnRzOm5vbmV9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1ncm91cC1keW5hbWljLWhlaWdodF0nOiAnZHluYW1pY0hlaWdodCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlcl0nOiAnaGVhZGVyUG9zaXRpb24gPT09IFwiYmVsb3dcIicsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlcl0pXG4gICAgXSwgTWRUYWJHcm91cCk7XG4gICAgcmV0dXJuIE1kVGFiR3JvdXA7XG59KCkpO1xudmFyIE1kVGFic01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJzTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFRhYnNNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFRhYnNNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFRhYnNNb2R1bGUgPSBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZSwgUG9ydGFsTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgT2JzZXJ2ZUNvbnRlbnRNb2R1bGVdLFxuICAgICAgICAgICAgLy8gRG9uJ3QgZXhwb3J0IGFsbCBjb21wb25lbnRzIGJlY2F1c2Ugc29tZSBhcmUgb25seSB0byBiZSB1c2VkIGludGVybmFsbHkuXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRUYWJHcm91cCwgTWRUYWJMYWJlbCwgTWRUYWIsIE1kVGFiTmF2QmFyLCBNZFRhYkxpbmssIE1kVGFiTGlua1JpcHBsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFRhYkdyb3VwLCBNZFRhYkxhYmVsLCBNZFRhYiwgTWRJbmtCYXIsIE1kVGFiTGFiZWxXcmFwcGVyLFxuICAgICAgICAgICAgICAgIE1kVGFiTmF2QmFyLCBNZFRhYkxpbmssIE1kVGFiQm9keSwgTWRUYWJMaW5rUmlwcGxlLCBNZFRhYkhlYWRlcl0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtWSUVXUE9SVF9SVUxFUl9QUk9WSURFUiwgU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRUYWJzTW9kdWxlKTtcbiAgICByZXR1cm4gTWRUYWJzTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNjUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZFRvb2xiYXJSb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVG9vbGJhclJvdygpIHtcbiAgICB9XG4gICAgTWRUb29sYmFyUm93ID0gX19kZWNvcmF0ZSQ2NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtdG9vbGJhci1yb3csIG1hdC10b29sYmFyLXJvdycsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdG9vbGJhci1yb3ddJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDY1KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kVG9vbGJhclJvdyk7XG4gICAgcmV0dXJuIE1kVG9vbGJhclJvdztcbn0oKSk7XG52YXIgTWRUb29sYmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRvb2xiYXIoZWxlbWVudFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sYmFyLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHRvb2xiYXIuIENhbiBiZSBwcmltYXJ5LCBhY2NlbnQsIG9yIHdhcm4uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFRvb2xiYXIucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIE1kVG9vbGJhci5wcm90b3R5cGUuX3NldEVsZW1lbnRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwgJiYgY29sb3IgIT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yLCBpc0FkZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNjUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDY1KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFRvb2xiYXIucHJvdG90eXBlLCBcImNvbG9yXCIsIG51bGwpO1xuICAgIE1kVG9vbGJhciA9IF9fZGVjb3JhdGUkNjUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC10b29sYmFyLCBtYXQtdG9vbGJhcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdG9vbGJhci1sYXlvdXRcXFwiPjxtZC10b29sYmFyLXJvdz48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9tZC10b29sYmFyLXJvdz48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXRvb2xiYXItcm93LCBtYXQtdG9vbGJhci1yb3dcXFwiPjwvbmctY29udGVudD48L2Rpdj5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC10b29sYmFyLC5tYXQtdG9vbGJhciAubWF0LXRvb2xiYXItcm93e2Rpc3BsYXk6ZmxleDtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MTAwJX0ubWF0LXRvb2xiYXJ7Zm9udC1zaXplOjIwcHg7Zm9udC13ZWlnaHQ6NTAwO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7cGFkZGluZzowIDE2cHg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO21pbi1oZWlnaHQ6NjRweH0ubWF0LXRvb2xiYXIgLm1hdC10b29sYmFyLXJvd3tmbGV4LWRpcmVjdGlvbjpyb3c7YWxpZ24taXRlbXM6Y2VudGVyO3doaXRlLXNwYWNlOm5vd3JhcH0ubWF0LXRvb2xiYXItcm93e2hlaWdodDo2NHB4fUBtZWRpYSAobWF4LXdpZHRoOjYwMHB4KSBhbmQgKG9yaWVudGF0aW9uOnBvcnRyYWl0KXsubWF0LXRvb2xiYXJ7bWluLWhlaWdodDo1NnB4fS5tYXQtdG9vbGJhci1yb3d7aGVpZ2h0OjU2cHh9fUBtZWRpYSAobWF4LXdpZHRoOjk2MHB4KSBhbmQgKG9yaWVudGF0aW9uOmxhbmRzY2FwZSl7Lm1hdC10b29sYmFye21pbi1oZWlnaHQ6NDhweH0ubWF0LXRvb2xiYXItcm93e2hlaWdodDo0OHB4fX1cIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdG9vbGJhcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAndG9vbGJhcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFRvb2xiYXIpO1xuICAgIHJldHVybiBNZFRvb2xiYXI7XG59KCkpO1xudmFyIE1kVG9vbGJhck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sYmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFRvb2xiYXJNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFRvb2xiYXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFRvb2xiYXJNb2R1bGUgPSBfX2RlY29yYXRlJDY1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRUb29sYmFyLCBNZFRvb2xiYXJSb3csIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRUb29sYmFyLCBNZFRvb2xiYXJSb3ddLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRUb29sYmFyTW9kdWxlKTtcbiAgICByZXR1cm4gTWRUb29sYmFyTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQyMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhIHRvb2x0aXAgaGFzIGFuIGludmFsaWQgcG9zaXRpb24uXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIwKE1kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yKHBvc2l0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiVG9vbHRpcCBwb3NpdGlvbiBcXFwiXCIgKyBwb3NpdGlvbiArIFwiXFxcIiBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yO1xufShNZEVycm9yKSk7XG5cbnZhciBfX2RlY29yYXRlJDY2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxNCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKiBUaW1lIGluIG1zIHRvIGRlbGF5IGJlZm9yZSBjaGFuZ2luZyB0aGUgdG9vbHRpcCB2aXNpYmlsaXR5IHRvIGhpZGRlbiAqL1xudmFyIFRPVUNIRU5EX0hJREVfREVMQVkgPSAxNTAwO1xuLyoqIFRpbWUgaW4gbXMgdG8gdGhyb3R0bGUgcmVwb3NpdGlvbmluZyBhZnRlciBzY3JvbGwgZXZlbnRzLiAqL1xudmFyIFNDUk9MTF9USFJPVFRMRV9NUyA9IDIwO1xuLyoqXG4gKiBEaXJlY3RpdmUgdGhhdCBhdHRhY2hlcyBhIG1hdGVyaWFsIGRlc2lnbiB0b29sdGlwIHRvIHRoZSBob3N0IGVsZW1lbnQuIEFuaW1hdGVzIHRoZSBzaG93aW5nIGFuZFxuICogaGlkaW5nIG9mIGEgdG9vbHRpcCBwcm92aWRlZCBwb3NpdGlvbiAoZGVmYXVsdHMgdG8gYmVsb3cgdGhlIGVsZW1lbnQpLlxuICpcbiAqIGh0dHBzOi8vbWF0ZXJpYWwuZ29vZ2xlLmNvbS9jb21wb25lbnRzL3Rvb2x0aXBzLmh0bWxcbiAqL1xudmFyIE1kVG9vbHRpcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sdGlwKF9vdmVybGF5LCBfc2Nyb2xsRGlzcGF0Y2hlciwgX2VsZW1lbnRSZWYsIF92aWV3Q29udGFpbmVyUmVmLCBfbmdab25lLCBfZGlyKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRGlzcGF0Y2hlciA9IF9zY3JvbGxEaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAnYmVsb3cnO1xuICAgICAgICAvKiogVGhlIGRlZmF1bHQgZGVsYXkgaW4gbXMgYmVmb3JlIHNob3dpbmcgdGhlIHRvb2x0aXAgYWZ0ZXIgc2hvdyBpcyBjYWxsZWQgKi9cbiAgICAgICAgdGhpcy5zaG93RGVsYXkgPSAwO1xuICAgICAgICAvKiogVGhlIGRlZmF1bHQgZGVsYXkgaW4gbXMgYmVmb3JlIGhpZGluZyB0aGUgdG9vbHRpcCBhZnRlciBoaWRlIGlzIGNhbGxlZCAqL1xuICAgICAgICB0aGlzLmhpZGVEZWxheSA9IDA7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHtcbiAgICAgICAgLyoqIEFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgZWxlbWVudCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmRyZXdqcyk6IFdoZW4gdGhlIG92ZXJsYXkncyBwb3NpdGlvbiBjYW4gYmUgZHluYW1pY2FsbHkgY2hhbmdlZCwgZG8gbm90IGRlc3Ryb3lcbiAgICAgICAgICAgICAgICAvLyB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfcG9zaXRpb25EZXByZWNhdGVkXCIsIHtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb247IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAvKiogVGhlIG1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRUb29sdGlwTWVzc2FnZSh0aGlzLl9tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRNZXNzYWdlXCIsIHtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMubWVzc2FnZSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRNZXNzYWdlXCIsIHtcbiAgICAgICAgLy8gUHJvcGVydGllcyB3aXRoIGBtYXQtYCBwcmVmaXggZm9yIG5vY29uZmxpY3QgbW9kZS5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lc3NhZ2U7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5tZXNzYWdlID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX21hdFBvc2l0aW9uXCIsIHtcbiAgICAgICAgLy8gUHJvcGVydGllcyB3aXRoIGBtYXQtYCBwcmVmaXggZm9yIG5vY29uZmxpY3QgbW9kZS5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBvc2l0aW9uOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMucG9zaXRpb24gPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0SGlkZURlbGF5XCIsIHtcbiAgICAgICAgLy8gUHJvcGVydGllcyB3aXRoIGBtYXQtYCBwcmVmaXggZm9yIG5vY29uZmxpY3QgbW9kZS5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmhpZGVEZWxheTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLmhpZGVEZWxheSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRTaG93RGVsYXlcIiwge1xuICAgICAgICAvLyBQcm9wZXJ0aWVzIHdpdGggYG1hdC1gIHByZWZpeCBmb3Igbm9jb25mbGljdCBtb2RlLlxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc2hvd0RlbGF5OyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuc2hvd0RlbGF5ID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV2hlbiBhIHNjcm9sbCBvbiB0aGUgcGFnZSBvY2N1cnMsIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gY2FzZSB0aGlzIHRvb2x0aXAgbmVlZHNcbiAgICAgICAgLy8gdG8gYmUgcmVwb3NpdGlvbmVkLlxuICAgICAgICB0aGlzLnNjcm9sbFN1YnNjcmlwdGlvbiA9IHRoaXMuX3Njcm9sbERpc3BhdGNoZXIuc2Nyb2xsZWQoU0NST0xMX1RIUk9UVExFX01TKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSB0b29sdGlwIHdoZW4gZGVzdHJveWVkLlxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIC8qKiBTaG93cyB0aGUgdG9vbHRpcCBhZnRlciB0aGUgZGVsYXkgaW4gbXMsIGRlZmF1bHRzIHRvIHRvb2x0aXAtZGVsYXktc2hvdyBvciAwbXMgaWYgbm8gaW5wdXQgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSB0aGlzLnNob3dEZWxheTsgfVxuICAgICAgICBpZiAoIXRoaXMuX21lc3NhZ2UgfHwgIXRoaXMuX21lc3NhZ2UudHJpbSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRvb2x0aXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRUb29sdGlwTWVzc2FnZSh0aGlzLl9tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLnNob3codGhpcy5fcG9zaXRpb24sIGRlbGF5KTtcbiAgICB9O1xuICAgIC8qKiBIaWRlcyB0aGUgdG9vbHRpcCBhZnRlciB0aGUgZGVsYXkgaW4gbXMsIGRlZmF1bHRzIHRvIHRvb2x0aXAtZGVsYXktaGlkZSBvciAwbXMgaWYgbm8gaW5wdXQgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSB0aGlzLmhpZGVEZWxheTsgfVxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuaGlkZShkZWxheSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBTaG93cy9oaWRlcyB0aGUgdG9vbHRpcCAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc1Rvb2x0aXBWaXNpYmxlKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9vbHRpcCBpcyBjdXJyZW50bHkgdmlzaWJsZSB0byB0aGUgdXNlciAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2lzVG9vbHRpcFZpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b29sdGlwSW5zdGFuY2UgJiYgdGhpcy5fdG9vbHRpcEluc3RhbmNlLmlzVmlzaWJsZSgpO1xuICAgIH07XG4gICAgLyoqIENyZWF0ZSB0aGUgdG9vbHRpcCB0byBkaXNwbGF5ICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fY3JlYXRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB2YXIgcG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChUb29sdGlwQ29tcG9uZW50LCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlID0gdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2gocG9ydGFsKS5pbnN0YW5jZTtcbiAgICAgICAgLy8gRGlzcG9zZSB0aGUgb3ZlcmxheSB3aGVuIGZpbmlzaGVkIHRoZSBzaG93biB0b29sdGlwLlxuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuYWZ0ZXJIaWRkZW4oKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgaWYgdGhlIHRvb2x0aXAgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIHRocm91Z2ggdGhpcyBjb21wb25lbnRzIGRlc3Ryb3kuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlVG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBDcmVhdGUgdGhlIG92ZXJsYXkgY29uZmlnIGFuZCBwb3NpdGlvbiBzdHJhdGVneSAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW4oKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0T3ZlcmxheVBvc2l0aW9uKCk7XG4gICAgICAgIC8vIENyZWF0ZSBjb25uZWN0ZWQgcG9zaXRpb24gc3RyYXRlZ3kgdGhhdCBsaXN0ZW5zIGZvciBzY3JvbGwgZXZlbnRzIHRvIHJlcG9zaXRpb24uXG4gICAgICAgIC8vIEFmdGVyIHBvc2l0aW9uIGNoYW5nZXMgb2NjdXIgYW5kIHRoZSBvdmVybGF5IGlzIGNsaXBwZWQgYnkgYSBwYXJlbnQgc2Nyb2xsYWJsZSB0aGVuXG4gICAgICAgIC8vIGNsb3NlIHRoZSB0b29sdGlwLlxuICAgICAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudFJlZiwgb3JpZ2luLCBwb3NpdGlvbik7XG4gICAgICAgIHN0cmF0ZWd5LndpdGhTY3JvbGxhYmxlQ29udGFpbmVycyh0aGlzLl9zY3JvbGxEaXNwYXRjaGVyLmdldFNjcm9sbENvbnRhaW5lcnModGhpcy5fZWxlbWVudFJlZikpO1xuICAgICAgICBzdHJhdGVneS5vblBvc2l0aW9uQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLnNjcm9sbGFibGVWaWV3UHJvcGVydGllcy5pc092ZXJsYXlDbGlwcGVkICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZSAmJiBfdGhpcy5fdG9vbHRpcEluc3RhbmNlLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb25maWcgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuICAgIH07XG4gICAgLyoqIERpc3Bvc2VzIHRoZSBjdXJyZW50IHRvb2x0aXAgYW5kIHRoZSBvdmVybGF5IGl0IGlzIGF0dGFjaGVkIHRvICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZGlzcG9zZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBvcmlnaW4gcG9zaXRpb24gYmFzZWQgb24gdGhlIHVzZXIncyBwb3NpdGlvbiBwcmVmZXJlbmNlICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZ2V0T3JpZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnYWJvdmUnIHx8IHRoaXMucG9zaXRpb24gPT0gJ2JlbG93Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6IHRoaXMucG9zaXRpb24gPT0gJ2Fib3ZlJyA/ICd0b3AnIDogJ2JvdHRvbScgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNEaXJlY3Rpb25MdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2xlZnQnIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmIGlzRGlyZWN0aW9uTHRyIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdhZnRlcicgJiYgIWlzRGlyZWN0aW9uTHRyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdyaWdodCcgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiBpc0RpcmVjdGlvbkx0ciB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYmVmb3JlJyAmJiAhaXNEaXJlY3Rpb25MdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcih0aGlzLnBvc2l0aW9uKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBvdmVybGF5IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB1c2VyJ3MgcHJlZmVyZW5jZSAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2dldE92ZXJsYXlQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2Fib3ZlJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ2JvdHRvbScgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnYmVsb3cnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAndG9wJyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0x0ciA9ICF0aGlzLl9kaXIgfHwgdGhpcy5fZGlyLnZhbHVlID09ICdsdHInO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAnbGVmdCcgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2JlZm9yZScgJiYgaXNMdHIgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiAhaXNMdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdjZW50ZXInIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ3JpZ2h0JyB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYWZ0ZXInICYmIGlzTHRyIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmICFpc0x0cikge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcih0aGlzLnBvc2l0aW9uKTtcbiAgICB9O1xuICAgIC8qKiBVcGRhdGVzIHRoZSB0b29sdGlwIG1lc3NhZ2UgYW5kIHJlcG9zaXRpb25zIHRoZSBvdmVybGF5IGFjY29yZGluZyB0byB0aGUgbmV3IG1lc3NhZ2UgbGVuZ3RoICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fc2V0VG9vbHRpcE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBNdXN0IHdhaXQgZm9yIHRoZSBtZXNzYWdlIHRvIGJlIHBhaW50ZWQgdG8gdGhlIHRvb2x0aXAgc28gdGhhdCB0aGUgb3ZlcmxheSBjYW4gcHJvcGVybHlcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHRoZSBzaXplIG9mIHRoZSB0ZXh0LlxuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRUb29sdGlwUG9zaXRpb24nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kVG9vbHRpcC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ3Rvb2x0aXAtcG9zaXRpb24nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX3Bvc2l0aW9uRGVwcmVjYXRlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRUb29sdGlwU2hvd0RlbGF5JyksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcInNob3dEZWxheVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFRvb2x0aXBIaWRlRGVsYXknKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiaGlkZURlbGF5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kVG9vbHRpcCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUb29sdGlwLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZC10b29sdGlwJyksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9kZXByZWNhdGVkTWVzc2FnZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWF0VG9vbHRpcCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0TWVzc2FnZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWF0VG9vbHRpcFBvc2l0aW9uJyksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRQb3NpdGlvblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWF0VG9vbHRpcEhpZGVEZWxheScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0SGlkZURlbGF5XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtYXRUb29sdGlwU2hvd0RlbGF5JyksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRTaG93RGVsYXlcIiwgbnVsbCk7XG4gICAgTWRUb29sdGlwID0gX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXRvb2x0aXBdLCBbbWRUb29sdGlwXSwgW21hdC10b29sdGlwXSwgW21hdFRvb2x0aXBdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnKGxvbmdwcmVzcyknOiAnc2hvdygpJyxcbiAgICAgICAgICAgICAgICAnKHRvdWNoZW5kKSc6ICdoaWRlKCcgKyBUT1VDSEVORF9ISURFX0RFTEFZICsgJyknLFxuICAgICAgICAgICAgICAgICcobW91c2VlbnRlciknOiAnc2hvdygpJyxcbiAgICAgICAgICAgICAgICAnKG1vdXNlbGVhdmUpJzogJ2hpZGUoKScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZFRvb2x0aXAnLFxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQxNCg1LCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnBhcmFtdHlwZXMnLCBbT3ZlcmxheSwgU2Nyb2xsRGlzcGF0Y2hlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIF9hbmd1bGFyX2NvcmUuTmdab25lLCBEaXJdKVxuICAgIF0sIE1kVG9vbHRpcCk7XG4gICAgcmV0dXJuIE1kVG9vbHRpcDtcbn0oKSk7XG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHRoZSB0b29sdGlwJ3MgY29udGVudC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFRvb2x0aXBDb21wb25lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvb2x0aXBDb21wb25lbnQoX2RpciwgX2NoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICAvKiogUHJvcGVydHkgd2F0Y2hlZCBieSB0aGUgYW5pbWF0aW9uIGZyYW1ld29yayB0byBzaG93IG9yIGhpZGUgdGhlIHRvb2x0aXAgKi9cbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eSA9ICdpbml0aWFsJztcbiAgICAgICAgLyoqIFdoZXRoZXIgaW50ZXJhY3Rpb25zIG9uIHRoZSBwYWdlIHNob3VsZCBjbG9zZSB0aGUgdG9vbHRpcCAqL1xuICAgICAgICB0aGlzLl9jbG9zZU9uSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqIFRoZSB0cmFuc2Zvcm0gb3JpZ2luIHVzZWQgaW4gdGhlIGFuaW1hdGlvbiBmb3Igc2hvd2luZyBhbmQgaGlkaW5nIHRoZSB0b29sdGlwICovXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdib3R0b20nO1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoYXQgdGhlIHRvb2x0aXAgaGFzIGJlZW4gaGlkZGVuIGZyb20gdGhlIHZpZXcgKi9cbiAgICAgICAgdGhpcy5fb25IaWRlID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSB0b29sdGlwIHdpdGggYW4gYW5pbWF0aW9uIG9yaWdpbmF0aW5nIGZyb20gdGhlIHByb3ZpZGVkIG9yaWdpblxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBQb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0gZGVsYXkgQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZGVsYXkgc2hvd2luZyB0aGUgdG9vbHRpcC5cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkZWxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGRlbGF5ZWQgaGlkZSBpZiBpdCBpcyBzY2hlZHVsZWRcbiAgICAgICAgaWYgKHRoaXMuX2hpZGVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCb2R5IGludGVyYWN0aW9ucyBzaG91bGQgY2FuY2VsIHRoZSB0b29sdGlwIGlmIHRoZXJlIGlzIGEgZGVsYXkgaW4gc2hvd2luZy5cbiAgICAgICAgdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtT3JpZ2luKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Zpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBzZXQgdG8gdHJ1ZSBpbW1lZGlhdGVseSwgdGhlbiBhIGJvZHkgY2xpY2sgdGhhdCB0cmlnZ2VycyBzaG93KCkgd291bGRcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgaW50ZXJhY3Rpb24gYW5kIGNsb3NlIHRoZSB0b29sdGlwIHJpZ2h0IGFmdGVyIGl0IHdhcyBkaXNwbGF5ZWQuXG4gICAgICAgICAgICBfdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBNYXJrIGZvciBjaGVjayBzbyBpZiBhbnkgcGFyZW50IGNvbXBvbmVudCBoYXMgc2V0IHRoZVxuICAgICAgICAgICAgLy8gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgdG8gT25QdXNoIGl0IHdpbGwgYmUgY2hlY2tlZCBhbnl3YXlzXG4gICAgICAgICAgICBfdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgX3RoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IHRydWU7IH0sIDApO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCZWdpbnMgdGhlIGFuaW1hdGlvbiB0byBoaWRlIHRoZSB0b29sdGlwIGFmdGVyIHRoZSBwcm92aWRlZCBkZWxheSBpbiBtcy5cbiAgICAgKiBAcGFyYW0gZGVsYXkgQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBzaG93aW5nIHRoZSB0b29sdGlwLlxuICAgICAqL1xuICAgIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWxheWVkIHNob3cgaWYgaXQgaXMgc2NoZWR1bGVkXG4gICAgICAgIGlmICh0aGlzLl9zaG93VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGlkZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Zpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIF90aGlzLl9jbG9zZU9uSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIE1hcmsgZm9yIGNoZWNrIHNvIGlmIGFueSBwYXJlbnQgY29tcG9uZW50IGhhcyBzZXQgdGhlXG4gICAgICAgICAgICAvLyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB0byBPblB1c2ggaXQgd2lsbCBiZSBjaGVja2VkIGFueXdheXNcbiAgICAgICAgICAgIF90aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgbm90aWZpZXMgd2hlbiB0aGUgdG9vbHRpcCBoYXMgYmVlbiBoaWRkZW4gZnJvbSB2aWV3XG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuYWZ0ZXJIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkhpZGUuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0b29sdGlwIGlzIGJlaW5nIGRpc3BsYXllZFxuICAgICAqL1xuICAgIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2liaWxpdHkgPT09ICd2aXNpYmxlJztcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSB0b29sdGlwIHRyYW5zZm9ybSBvcmlnaW4gYWNjb3JkaW5nIHRvIHRoZSB0b29sdGlwIHBvc2l0aW9uICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuX3NldFRyYW5zZm9ybU9yaWdpbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaXNMdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSBpc0x0ciA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZnRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gaXNMdHIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhYm92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiZWxvdyc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ3RvcCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgTWRUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5fYWZ0ZXJWaXNpYmlsaXR5QW5pbWF0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdGF0ZSA9PT0gJ2hpZGRlbicgJiYgIXRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uSGlkZS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVyYWN0aW9ucyBvbiB0aGUgSFRNTCBib2R5IHNob3VsZCBjbG9zZSB0aGUgdG9vbHRpcCBpbW1lZGlhdGVseSBhcyBkZWZpbmVkIGluIHRoZVxuICAgICAqIG1hdGVyaWFsIGRlc2lnbiBzcGVjLlxuICAgICAqIGh0dHBzOi8vbWF0ZXJpYWwuZ29vZ2xlLmNvbS9jb21wb25lbnRzL3Rvb2x0aXBzLmh0bWwjdG9vbHRpcHMtaW50ZXJhY3Rpb25cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5faGFuZGxlQm9keUludGVyYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VPbkludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXBDb21wb25lbnQgPSBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdG9vbHRpcC1jb21wb25lbnQsIG1hdC10b29sdGlwLWNvbXBvbmVudCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdG9vbHRpcFxcXCIgW3N0eWxlLnRyYW5zZm9ybS1vcmlnaW5dPVxcXCJfdHJhbnNmb3JtT3JpZ2luXFxcIiBbQHN0YXRlXT1cXFwiX3Zpc2liaWxpdHlcXFwiIChAc3RhdGUuZG9uZSk9XFxcIl9hZnRlclZpc2liaWxpdHlBbmltYXRpb24oJGV2ZW50KVxcXCI+e3ttZXNzYWdlfX08L2Rpdj5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7cG9pbnRlci1ldmVudHM6bm9uZX0ubWF0LXRvb2x0aXB7Y29sb3I6I2ZmZjtwYWRkaW5nOjZweCA4cHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXNpemU6MTBweDttYXJnaW46MTRweDttYXgtd2lkdGg6MjUwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC10b29sdGlwe291dGxpbmU6c29saWQgMXB4fX1cIl0sXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS50cmlnZ2VyKCdzdGF0ZScsIFtcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgndm9pZCcsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdpbml0aWFsJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ3Zpc2libGUnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMSknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnaGlkZGVuJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbignKiA9PiB2aXNpYmxlJywgX2FuZ3VsYXJfY29yZS5hbmltYXRlKCcxNTBtcyBjdWJpYy1iZXppZXIoMC4wLCAwLjAsIDAuMiwgMSknKSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbignKiA9PiBoaWRkZW4nLCBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoJzE1MG1zIGN1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSknKSksXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJyhib2R5OmNsaWNrKSc6ICd0aGlzLl9oYW5kbGVCb2R5SW50ZXJhY3Rpb24oKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMTQoMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0RpciwgX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZl0pXG4gICAgXSwgVG9vbHRpcENvbXBvbmVudCk7XG4gICAgcmV0dXJuIFRvb2x0aXBDb21wb25lbnQ7XG59KCkpO1xudmFyIE1kVG9vbHRpcE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sdGlwTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFRvb2x0aXBNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFRvb2x0aXBNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFRvb2x0aXBNb2R1bGUgPSBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbT3ZlcmxheU1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRUb29sdGlwLCBUb29sdGlwQ29tcG9uZW50LCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kVG9vbHRpcCwgVG9vbHRpcENvbXBvbmVudF0sXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtUb29sdGlwQ29tcG9uZW50XSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kVG9vbHRpcE1vZHVsZSk7XG4gICAgcmV0dXJuIE1kVG9vbHRpcE1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMjEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gbWVudSB0cmlnZ2VyIGRvZXNuJ3QgaGF2ZSBhIHZhbGlkIG1kLW1lbnUgaW5zdGFuY2VcbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTWVudU1pc3NpbmdFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIxKE1kTWVudU1pc3NpbmdFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZE1lbnVNaXNzaW5nRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwibWQtbWVudS10cmlnZ2VyOiBtdXN0IHBhc3MgaW4gYW4gbWQtbWVudSBpbnN0YW5jZS5cXG5cXG4gICAgRXhhbXBsZTpcXG4gICAgICA8bWQtbWVudSAjbWVudT1cXFwibWRNZW51XFxcIj48L21kLW1lbnU+XFxuICAgICAgPGJ1dHRvbiBbbWRNZW51VHJpZ2dlckZvcl09XFxcIm1lbnVcXFwiPjwvYnV0dG9uPlxcbiAgICBcIik7XG4gICAgfVxuICAgIHJldHVybiBNZE1lbnVNaXNzaW5nRXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIG1lbnUncyB4LXBvc2l0aW9uIHZhbHVlIGlzbid0IHZhbGlkLlxuICogSW4gb3RoZXIgd29yZHMsIGl0IGRvZXNuJ3QgbWF0Y2ggJ2JlZm9yZScgb3IgJ2FmdGVyJy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTWVudUludmFsaWRQb3NpdGlvblggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyMShNZE1lbnVJbnZhbGlkUG9zaXRpb25YLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kTWVudUludmFsaWRQb3NpdGlvblgoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwieC1wb3NpdGlvbiB2YWx1ZSBtdXN0IGJlIGVpdGhlciAnYmVmb3JlJyBvciBhZnRlcicuXFxuICAgICAgRXhhbXBsZTogPG1kLW1lbnUgeC1wb3NpdGlvbj1cXFwiYmVmb3JlXFxcIiAjbWVudT1cXFwibWRNZW51XFxcIj48L21kLW1lbnU+XFxuICAgIFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kTWVudUludmFsaWRQb3NpdGlvblg7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIG1lbnUncyB5LXBvc2l0aW9uIHZhbHVlIGlzbid0IHZhbGlkLlxuICogSW4gb3RoZXIgd29yZHMsIGl0IGRvZXNuJ3QgbWF0Y2ggJ2Fib3ZlJyBvciAnYmVsb3cnLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRNZW51SW52YWxpZFBvc2l0aW9uWSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIxKE1kTWVudUludmFsaWRQb3NpdGlvblksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRNZW51SW52YWxpZFBvc2l0aW9uWSgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJ5LXBvc2l0aW9uIHZhbHVlIG11c3QgYmUgZWl0aGVyICdhYm92ZScgb3IgYmVsb3cnLlxcbiAgICAgIEV4YW1wbGU6IDxtZC1tZW51IHktcG9zaXRpb249XFxcImFib3ZlXFxcIiAjbWVudT1cXFwibWRNZW51XFxcIj48L21kLW1lbnU+XFxuICAgIFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kTWVudUludmFsaWRQb3NpdGlvblk7XG59KE1kRXJyb3IpKTtcblxudmFyIF9fZGVjb3JhdGUkNjkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbnNpZGUgYW4gbWQtbWVudSB0YWcuXG4gKiBJdCBleGlzdHMgbW9zdGx5IHRvIHNldCB0aGUgcm9sZSBhdHRyaWJ1dGUuXG4gKi9cbnZhciBNZE1lbnVJdGVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE1lbnVJdGVtKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgTWRNZW51SXRlbS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnVJdGVtLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnQgYW5jaG9yc1xuICAgICAgICAvKiogV2hldGhlciB0aGUgbWVudSBpdGVtIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpID8gbnVsbCA6IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnVJdGVtLnByb3RvdHlwZSwgXCJpc0FyaWFEaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBTZXRzIHRoZSBhcmlhLWRpc2FibGVkIHByb3BlcnR5IG9uIHRoZSBtZW51IGl0ZW0uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyaW5nKCEhdGhpcy5kaXNhYmxlZCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnVJdGVtLnByb3RvdHlwZSwgXCJfdGFiaW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAnLTEnIDogJzAnOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZE1lbnVJdGVtLnByb3RvdHlwZS5fZ2V0SG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICBNZE1lbnVJdGVtLnByb3RvdHlwZS5fY2hlY2tEaXNhYmxlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDY5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5kaXNhYmxlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDY5KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRNZW51SXRlbS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kaXNhYmxlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRNZW51SXRlbS5wcm90b3R5cGUsIFwiaXNBcmlhRGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRNZW51SXRlbSA9IF9fZGVjb3JhdGUkNjkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdbbWQtbWVudS1pdGVtXSwgW21hdC1tZW51LWl0ZW1dJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdtZW51aXRlbScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbWVudS1pdGVtXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfY2hlY2tEaXNhYmxlZCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIudGFiaW5kZXhdJzogJ190YWJpbmRleCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LW1lbnUtcmlwcGxlXFxcIiAqbmdJZj1cXFwiIWRpc2FibGVkXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRNZW51SXRlbSdcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDY5KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kTWVudUl0ZW0pO1xuICAgIHJldHVybiBNZE1lbnVJdGVtO1xufSgpKTtcblxuLyoqXG4gKiBCZWxvdyBhcmUgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgbWQtbWVudSBjb21wb25lbnQuXG4gKiBBbmltYXRpb24gZHVyYXRpb24gYW5kIHRpbWluZyB2YWx1ZXMgYXJlIGJhc2VkIG9uIEFuZ3VsYXJKUyBNYXRlcmlhbC5cbiAqL1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiBjb250cm9scyB0aGUgbWVudSBwYW5lbCdzIGVudHJ5IGFuZCBleGl0IGZyb20gdGhlIHBhZ2UuXG4gKlxuICogV2hlbiB0aGUgbWVudSBwYW5lbCBpcyBhZGRlZCB0byB0aGUgRE9NLCBpdCBzY2FsZXMgaW4gYW5kIGZhZGVzIGluIGl0cyBib3JkZXIuXG4gKlxuICogV2hlbiB0aGUgbWVudSBwYW5lbCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSwgaXQgc2ltcGx5IGZhZGVzIG91dCBhZnRlciBhIGJyaWVmXG4gKiBkZWxheSB0byBkaXNwbGF5IHRoZSByaXBwbGUuXG4gKi9cbi8vIFRPRE8oa2FyYSk6IHN3aXRjaCB0byA6ZW50ZXIgYW5kIDpsZWF2ZSBvbmNlIE1vYmlsZSBTYWZhcmkgaXMgc29ydGVkIG91dC5cbnZhciB0cmFuc2Zvcm1NZW51ID0gX2FuZ3VsYXJfY29yZS50cmlnZ2VyKCd0cmFuc2Zvcm1NZW51JywgW1xuICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ3Nob3dpbmcnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCJcbiAgICB9KSksXG4gICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuc3R5bGUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwKVwiXG4gICAgICAgIH0pLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoXCIyMDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKVwiKVxuICAgIF0pLFxuICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoJzUwbXMgMTAwbXMgbGluZWFyJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gICAgXSlcbl0pO1xuLyoqXG4gKiBUaGlzIGFuaW1hdGlvbiBmYWRlcyBpbiB0aGUgYmFja2dyb3VuZCBjb2xvciBhbmQgY29udGVudCBvZiB0aGUgbWVudSBwYW5lbFxuICogYWZ0ZXIgaXRzIGNvbnRhaW5pbmcgZWxlbWVudCBpcyBzY2FsZWQgaW4uXG4gKi9cbnZhciBmYWRlSW5JdGVtcyA9IF9hbmd1bGFyX2NvcmUudHJpZ2dlcignZmFkZUluSXRlbXMnLCBbXG4gICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnc2hvd2luZycsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyBvcGFjaXR5OiAxIH0pKSxcbiAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuYW5pbWF0ZShcIjIwMG1zIDEwMG1zIGN1YmljLWJlemllcigwLjU1LCAwLCAwLjU1LCAwLjIpXCIpXG4gICAgXSlcbl0pO1xuXG4vLyBUT0RPKGthcmEpOiBwcmV2ZW50LWNsb3NlIGZ1bmN0aW9uYWxpdHlcbnZhciBfX2RlY29yYXRlJDY4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxNSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBNZE1lbnUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWVudShwb3NYLCBwb3NZKSB7XG4gICAgICAgIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBtZW51J3MgbmdDbGFzcyAqL1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3QgPSB7fTtcbiAgICAgICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBtZW51IGluIHRoZSBYIGF4aXMuICovXG4gICAgICAgIHRoaXMucG9zaXRpb25YID0gJ2FmdGVyJztcbiAgICAgICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBtZW51IGluIHRoZSBZIGF4aXMuICovXG4gICAgICAgIHRoaXMucG9zaXRpb25ZID0gJ2JlbG93JztcbiAgICAgICAgdGhpcy5vdmVybGFwVHJpZ2dlciA9IHRydWU7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG1lbnUgaXMgY2xvc2VkLiAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGlmIChwb3NYKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvblgocG9zWCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc1kpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uWShwb3NZKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3Nlcyh0aGlzLnBvc2l0aW9uWCwgdGhpcy5wb3NpdGlvblkpO1xuICAgIH1cbiAgICBNZE1lbnUucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIodGhpcy5pdGVtcykud2l0aFdyYXAoKTtcbiAgICAgICAgdGhpcy5fdGFiU3Vic2NyaXB0aW9uID0gdGhpcy5fa2V5TWFuYWdlci50YWJPdXQuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9lbWl0Q2xvc2VFdmVudCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1kTWVudS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhYlN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudS5wcm90b3R5cGUsIFwiY2xhc3NMaXN0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG1kLW1lbnUgZWxlbWVudCBhbmQgYXBwbGllcyB0aGVtIG9uIHRoZVxuICAgICAgICAgKiBtZW51IHRlbXBsYXRlIHRoYXQgZGlzcGxheXMgaW4gdGhlIG92ZXJsYXkgY29udGFpbmVyLiAgT3RoZXJ3aXNlLCBpdCdzIGRpZmZpY3VsdFxuICAgICAgICAgKiB0byBzdHlsZSB0aGUgY29udGFpbmluZyBtZW51IGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBAcGFyYW0gY2xhc3NlcyBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc0xpc3QgPSBjbGFzc2VzLnNwbGl0KCcgJykucmVkdWNlKGZ1bmN0aW9uIChvYmosIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIG9ialtjbGFzc05hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXModGhpcy5wb3NpdGlvblgsIHRoaXMucG9zaXRpb25ZKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRm9jdXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIG1lbnUuIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIG1lbnUgdHJpZ2dlclxuICAgICAqIHRvIGZvY3VzIHRoZSBmaXJzdCBpdGVtIHdoZW4gdGhlIG1lbnUgaXMgb3BlbmVkIGJ5IHRoZSBFTlRFUiBrZXkuXG4gICAgICovXG4gICAgTWRNZW51LnByb3RvdHlwZS5mb2N1c0ZpcnN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZW1pdHMgYSBjbG9zZSBldmVudCB0byB3aGljaCB0aGUgdHJpZ2dlciBpcyBzdWJzY3JpYmVkLiBXaGVuIGVtaXR0ZWQsIHRoZVxuICAgICAqIHRyaWdnZXIgd2lsbCBjbG9zZSB0aGUgbWVudS5cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLl9lbWl0Q2xvc2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbG9zZS5lbWl0KCk7XG4gICAgfTtcbiAgICBNZE1lbnUucHJvdG90eXBlLl9zZXRQb3NpdGlvblggPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgIT09ICdiZWZvcmUnICYmIHBvcyAhPT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kTWVudUludmFsaWRQb3NpdGlvblgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvc2l0aW9uWCA9IHBvcztcbiAgICB9O1xuICAgIE1kTWVudS5wcm90b3R5cGUuX3NldFBvc2l0aW9uWSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyAhPT0gJ2Fib3ZlJyAmJiBwb3MgIT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZE1lbnVJbnZhbGlkUG9zaXRpb25ZKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3NpdGlvblkgPSBwb3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdCdzIG5lY2Vzc2FyeSB0byBzZXQgcG9zaXRpb24tYmFzZWQgY2xhc3NlcyB0byBlbnN1cmUgdGhlIG1lbnUgcGFuZWwgYW5pbWF0aW9uXG4gICAgICogZm9sZHMgb3V0IGZyb20gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUuc2V0UG9zaXRpb25DbGFzc2VzID0gZnVuY3Rpb24gKHBvc1gsIHBvc1kpIHtcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1iZWZvcmUnXSA9IHBvc1ggPT0gJ2JlZm9yZSc7XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnbWF0LW1lbnUtYWZ0ZXInXSA9IHBvc1ggPT0gJ2FmdGVyJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1hYm92ZSddID0gcG9zWSA9PSAnYWJvdmUnO1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ21hdC1tZW51LWJlbG93J10gPSBwb3NZID09ICdiZWxvdyc7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDY4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiksIFxuICAgICAgICBfX21ldGFkYXRhJDY4KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYpXG4gICAgXSwgTWRNZW51LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZE1lbnVJdGVtKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjgoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRNZW51LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDY4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZE1lbnUucHJvdG90eXBlLCBcIm92ZXJsYXBUcmlnZ2VyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2NsYXNzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDY4KCdkZXNpZ246dHlwZScsIFN0cmluZyksIFxuICAgICAgICBfX21ldGFkYXRhJDY4KCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmddKVxuICAgIF0sIE1kTWVudS5wcm90b3R5cGUsIFwiY2xhc3NMaXN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNjgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51LnByb3RvdHlwZSwgXCJjbG9zZVwiLCB2b2lkIDApO1xuICAgIE1kTWVudSA9IF9fZGVjb3JhdGUkNjgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1tZW51LCBtYXQtbWVudScsXG4gICAgICAgICAgICBob3N0OiB7ICdyb2xlJzogJ21lbnUnIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8dGVtcGxhdGU+PGRpdiBjbGFzcz1cXFwibWF0LW1lbnUtcGFuZWxcXFwiIFtuZ0NsYXNzXT1cXFwiX2NsYXNzTGlzdFxcXCIgKGtleWRvd24pPVxcXCJfa2V5TWFuYWdlci5vbktleWRvd24oJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiX2VtaXRDbG9zZUV2ZW50KClcXFwiIFtAdHJhbnNmb3JtTWVudV09XFxcIidzaG93aW5nJ1xcXCI+PGRpdiBjbGFzcz1cXFwibWF0LW1lbnUtY29udGVudFxcXCIgW0BmYWRlSW5JdGVtc109XFxcIidzaG93aW5nJ1xcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PjwvZGl2PjwvdGVtcGxhdGU+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtbWVudS1wYW5lbHtib3gtc2hhZG93OjAgNXB4IDVweCAtM3B4IHJnYmEoMCwwLDAsLjIpLDAgOHB4IDEwcHggMXB4IHJnYmEoMCwwLDAsLjE0KSwwIDNweCAxNHB4IDJweCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjExMnB4O21heC13aWR0aDoyODBweDtvdmVyZmxvdzphdXRvOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO21heC1oZWlnaHQ6Y2FsYygxMDB2aCArIDQ4cHgpfS5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1hZnRlci5tYXQtbWVudS1iZWxvd3t0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgdG9wfS5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1hZnRlci5tYXQtbWVudS1hYm92ZXt0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgYm90dG9tfS5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1iZWZvcmUubWF0LW1lbnUtYmVsb3d7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCB0b3B9Lm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWJlZm9yZS5tYXQtbWVudS1hYm92ZXt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0IGJvdHRvbX1bZGlyPXJ0bF0gLm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWFmdGVyLm1hdC1tZW51LWJlbG93e3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wfVtkaXI9cnRsXSAubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYWZ0ZXIubWF0LW1lbnUtYWJvdmV7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCBib3R0b219W2Rpcj1ydGxdIC5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1iZWZvcmUubWF0LW1lbnUtYmVsb3d7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcH1bZGlyPXJ0bF0gLm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWJlZm9yZS5tYXQtbWVudS1hYm92ZXt0cmFuc2Zvcm0tb3JpZ2luOmxlZnQgYm90dG9tfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtbWVudS1wYW5lbHtvdXRsaW5lOnNvbGlkIDFweH19Lm1hdC1tZW51LWNvbnRlbnR7cGFkZGluZy10b3A6OHB4O3BhZGRpbmctYm90dG9tOjhweH0ubWF0LW1lbnUtaXRlbXtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7b3V0bGluZTowO2JvcmRlcjpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdy14OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2Rpc3BsYXk6YmxvY2s7bGluZS1oZWlnaHQ6NDhweDtoZWlnaHQ6NDhweDtwYWRkaW5nOjAgMTZweDtmb250LXNpemU6MTZweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO3RleHQtYWxpZ246c3RhcnQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1tZW51LWl0ZW1bZGlzYWJsZWRde2N1cnNvcjpkZWZhdWx0fS5tYXQtbWVudS1pdGVtIC5tYXQtaWNvbnttYXJnaW4tcmlnaHQ6MTZweH1bZGlyPXJ0bF0gLm1hdC1tZW51LWl0ZW0gLm1hdC1pY29ue21hcmdpbi1sZWZ0OjE2cHh9YnV0dG9uLm1hdC1tZW51LWl0ZW17d2lkdGg6MTAwJX0ubWF0LW1lbnUtcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtib3R0b206MDtyaWdodDowfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1NZW51LFxuICAgICAgICAgICAgICAgIGZhZGVJbkl0ZW1zXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZE1lbnUnXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDE1KDAsIF9hbmd1bGFyX2NvcmUuQXR0cmlidXRlKCd4LXBvc2l0aW9uJykpLFxuICAgICAgICBfX3BhcmFtJDE1KDEsIF9hbmd1bGFyX2NvcmUuQXR0cmlidXRlKCd5LXBvc2l0aW9uJykpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nLCBTdHJpbmddKVxuICAgIF0sIE1kTWVudSk7XG4gICAgcmV0dXJuIE1kTWVudTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDcwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxNiA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuIG1kLW1lbnUgdGFnLiAgSXQgaXNcbiAqIHJlc3BvbnNpYmxlIGZvciB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiB0aGUgcHJvdmlkZWQgbWVudSBpbnN0YW5jZS5cbiAqIFRPRE8oYW5kcmV3c2VndWluKTogUmVtb3ZlIHRoZSBrZWJhYiB2ZXJzaW9ucyBpbiBmYXZvciBvZiBjYW1lbENhc2VkIGF0dHJpYnV0ZSBzZWxlY3RvcnNcbiAqL1xudmFyIE1kTWVudVRyaWdnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWVudVRyaWdnZXIoX292ZXJsYXksIF9lbGVtZW50LCBfdmlld0NvbnRhaW5lclJlZiwgX3JlbmRlcmVyLCBfZGlyKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA9IGZhbHNlO1xuICAgICAgICAvLyB0cmFja2luZyBpbnB1dCB0eXBlIGlzIG5lY2Vzc2FyeSBzbyBpdCdzIHBvc3NpYmxlIHRvIG9ubHkgYXV0by1mb2N1c1xuICAgICAgICAvLyB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgbGlzdCB3aGVuIHRoZSBtZW51IGlzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkXG4gICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBtZW51IGlzIG9wZW5lZC4gKi9cbiAgICAgICAgdGhpcy5vbk1lbnVPcGVuID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgbWVudSBpcyBjbG9zZWQuICovXG4gICAgICAgIHRoaXMub25NZW51Q2xvc2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIl9kZXByZWNhdGVkTWRNZW51VHJpZ2dlckZvclwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVudTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lbnUgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRNYXRNZW51VHJpZ2dlckZvclwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVudTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lbnUgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiX21hdE1lbnVUcmlnZ2VyRm9yXCIsIHtcbiAgICAgICAgLy8gVHJpZ2dlciBpbnB1dCBmb3IgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZW51OyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMubWVudSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2hlY2tNZW51KCk7XG4gICAgICAgIHRoaXMubWVudS5jbG9zZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2xvc2VNZW51KCk7IH0pO1xuICAgIH07XG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZGVzdHJveU1lbnUoKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwibWVudU9wZW5cIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgbWVudSBpcyBvcGVuLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lbnVPcGVuOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogVG9nZ2xlcyB0aGUgbWVudSBiZXR3ZWVuIHRoZSBvcGVuIGFuZCBjbG9zZWQgc3RhdGVzLiAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLnRvZ2dsZU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZW51T3BlbiA/IHRoaXMuY2xvc2VNZW51KCkgOiB0aGlzLm9wZW5NZW51KCk7XG4gICAgfTtcbiAgICAvKiogT3BlbnMgdGhlIG1lbnUuICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUub3Blbk1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWVudU9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0JhY2tkcm9wKCk7XG4gICAgICAgICAgICB0aGlzLl9pbml0TWVudSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQ2xvc2VzIHRoZSBtZW51LiAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLmNsb3NlTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSZW1vdmVzIHRoZSBtZW51IGZyb20gdGhlIERPTS4gKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5kZXN0cm95TWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jbGVhblVwU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRm9jdXNlcyB0aGUgbWVudSB0cmlnZ2VyLiAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiZGlyXCIsIHtcbiAgICAgICAgLyoqIFRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpciAmJiB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnID8gJ3J0bCcgOiAnbHRyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGF0IHRoZSBtZW51IGNsb3NlcyB3aGVuIHRoZSBvdmVybGF5IGJhY2tkcm9wIGlzIGNsaWNrZWQuXG4gICAgICogV2UgZG8gbm90IHVzZSBmaXJzdCgpIGhlcmUgYmVjYXVzZSBkb2luZyBzbyB3b3VsZCBub3QgY2F0Y2ggY2xpY2tzIGZyb20gd2l0aGluXG4gICAgICogdGhlIG1lbnUsIGFuZCBpdCB3b3VsZCBmYWlsIHRvIHVuc3Vic2NyaWJlIHByb3Blcmx5LiBJbnN0ZWFkLCB3ZSB1bnN1YnNjcmliZVxuICAgICAqIGV4cGxpY2l0bHkgd2hlbiB0aGUgbWVudSBpcyBjbG9zZWQgb3IgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9zdWJzY3JpYmVUb0JhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZU1lbnUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBtZW51IHN0YXRlIHRvIG9wZW4gYW5kIGZvY3VzZXMgdGhlIGZpcnN0IGl0ZW0gaWZcbiAgICAgKiB0aGUgbWVudSB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2luaXRNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZXRJc01lbnVPcGVuKHRydWUpO1xuICAgICAgICAvLyBTaG91bGQgb25seSBzZXQgZm9jdXMgaWYgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQsIHNvIGtleWJvYXJkIHVzZXJzIGNhblxuICAgICAgICAvLyBjYW4gZWFzaWx5IG5hdmlnYXRlIG1lbnUgaXRlbXMuIEFjY29yZGluZyB0byBzcGVjLCBtb3VzZSB1c2VycyBzaG91bGQgbm90XG4gICAgICAgIC8vIHNlZSB0aGUgZm9jdXMgc3R5bGUuXG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkQnlNb3VzZSkge1xuICAgICAgICAgICAgdGhpcy5tZW51LmZvY3VzRmlyc3RJdGVtKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgbWVudSB3aGVuIGl0J3MgY2xvc2VkLCBtb3N0IGltcG9ydGFudGx5IHJlc3RvcmluZ1xuICAgICAqIGZvY3VzIHRvIHRoZSBtZW51IHRyaWdnZXIgaWYgdGhlIG1lbnUgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9yZXNldE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldElzTWVudU9wZW4oZmFsc2UpO1xuICAgICAgICAvLyBGb2N1cyBvbmx5IG5lZWRzIHRvIGJlIHJlc2V0IHRvIHRoZSBob3N0IGVsZW1lbnQgaWYgdGhlIG1lbnUgd2FzIG9wZW5lZFxuICAgICAgICAvLyBieSB0aGUga2V5Ym9hcmQgYW5kIG1hbnVhbGx5IHNoaWZ0ZWQgdG8gdGhlIGZpcnN0IG1lbnUgaXRlbS5cbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWRCeU1vdXNlKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbmVkQnlNb3VzZSA9IGZhbHNlO1xuICAgIH07XG4gICAgLy8gc2V0IHN0YXRlIHJhdGhlciB0aGFuIHRvZ2dsZSB0byBzdXBwb3J0IHRyaWdnZXJzIHNoYXJpbmcgYSBtZW51XG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX3NldElzTWVudU9wZW4gPSBmdW5jdGlvbiAoaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuX21lbnVPcGVuID0gaXNPcGVuO1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA/IHRoaXMub25NZW51T3Blbi5lbWl0KCkgOiB0aGlzLm9uTWVudUNsb3NlLmVtaXQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBUaGlzIG1ldGhvZCBjaGVja3MgdGhhdCBhIHZhbGlkIGluc3RhbmNlIG9mIE1kTWVudSBoYXMgYmVlbiBwYXNzZWQgaW50b1xuICAgICAqICBtZE1lbnVUcmlnZ2VyRm9yLiBJZiBub3QsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2NoZWNrTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZE1lbnVNaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogIFRoaXMgbWV0aG9kIGNyZWF0ZXMgdGhlIG92ZXJsYXkgZnJvbSB0aGUgcHJvdmlkZWQgbWVudSdzIHRlbXBsYXRlIGFuZCBzYXZlcyBpdHNcbiAgICAgKiAgT3ZlcmxheVJlZiBzbyB0aGF0IGl0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIHdoZW4gb3Blbk1lbnUgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLm1lbnUudGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX2dldE92ZXJsYXlDb25maWcoKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25zKGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5KTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG5lZWRlZCB0byBjcmVhdGUgdGhlIG92ZXJsYXksIHRoZSBPdmVybGF5U3RhdGUuXG4gICAgICogQHJldHVybnMgT3ZlcmxheVN0YXRlXG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2dldE92ZXJsYXlDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fZ2V0UG9zaXRpb24oKVxuICAgICAgICAgICAgLndpdGhEaXJlY3Rpb24odGhpcy5kaXIpO1xuICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICBvdmVybGF5U3RhdGUuYmFja2Ryb3BDbGFzcyA9ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCc7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Nlc1xuICAgICAqIG9uIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBuZXcgcG9zaXRpb24uIFRoaXMgZW5zdXJlcyB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBhbHdheXNcbiAgICAgKiBjb3JyZWN0LCBldmVuIGlmIGEgZmFsbGJhY2sgcG9zaXRpb24gaXMgdXNlZCBmb3IgdGhlIG92ZXJsYXkuXG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvUG9zaXRpb25zID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uID0gcG9zaXRpb24ub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIHBvc1ggPSBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3JpZ2luWCA9PT0gJ3N0YXJ0JyA/ICdhZnRlcicgOiAnYmVmb3JlJztcbiAgICAgICAgICAgIHZhciBwb3NZID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm9yaWdpblkgPT09ICd0b3AnID8gJ2JlbG93JyA6ICdhYm92ZSc7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm1lbnUub3ZlcmxhcFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICBwb3NZID0gcG9zWSA9PT0gJ2JlbG93JyA/ICdhYm92ZScgOiAnYmVsb3cnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubWVudS5zZXRQb3NpdGlvbkNsYXNzZXMocG9zWCwgcG9zWSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBwb3NpdGlvbiBzdHJhdGVneSBmb3IgdGhlIG92ZXJsYXksIHNvIHRoZSBtZW51IGlzIHByb3Blcmx5IGNvbm5lY3RlZFxuICAgICAqIHRvIHRoZSB0cmlnZ2VyLlxuICAgICAqIEByZXR1cm5zIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3lcbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMubWVudS5wb3NpdGlvblggPT09ICdiZWZvcmUnID8gWydlbmQnLCAnc3RhcnQnXSA6IFsnc3RhcnQnLCAnZW5kJ10sIHBvc1ggPSBfYVswXSwgZmFsbGJhY2tYID0gX2FbMV07XG4gICAgICAgIHZhciBfYiA9IHRoaXMubWVudS5wb3NpdGlvblkgPT09ICdhYm92ZScgPyBbJ2JvdHRvbScsICd0b3AnXSA6IFsndG9wJywgJ2JvdHRvbSddLCBvdmVybGF5WSA9IF9iWzBdLCBmYWxsYmFja092ZXJsYXlZID0gX2JbMV07XG4gICAgICAgIHZhciBvcmlnaW5ZID0gb3ZlcmxheVk7XG4gICAgICAgIHZhciBmYWxsYmFja09yaWdpblkgPSBmYWxsYmFja092ZXJsYXlZO1xuICAgICAgICBpZiAoIXRoaXMubWVudS5vdmVybGFwVHJpZ2dlcikge1xuICAgICAgICAgICAgb3JpZ2luWSA9IG92ZXJsYXlZID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgICAgICBmYWxsYmFja09yaWdpblkgPSBmYWxsYmFja092ZXJsYXlZID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnQsIHsgb3JpZ2luWDogcG9zWCwgb3JpZ2luWTogb3JpZ2luWSB9LCB7IG92ZXJsYXlYOiBwb3NYLCBvdmVybGF5WTogb3ZlcmxheVkgfSlcbiAgICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogb3JpZ2luWSB9LCB7IG92ZXJsYXlYOiBmYWxsYmFja1gsIG92ZXJsYXlZOiBvdmVybGF5WSB9KVxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKHsgb3JpZ2luWDogcG9zWCwgb3JpZ2luWTogZmFsbGJhY2tPcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IHBvc1gsIG92ZXJsYXlZOiBmYWxsYmFja092ZXJsYXlZIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiBmYWxsYmFja1gsIG9yaWdpblk6IGZhbGxiYWNrT3JpZ2luWSB9LCB7IG92ZXJsYXlYOiBmYWxsYmFja1gsIG92ZXJsYXlZOiBmYWxsYmFja092ZXJsYXlZIH0pO1xuICAgIH07XG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2NsZWFuVXBTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5faGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlcihldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDcwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWQtbWVudS10cmlnZ2VyLWZvcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRNZE1lbnVUcmlnZ2VyRm9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNzAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtYXQtbWVudS10cmlnZ2VyLWZvcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRNYXRNZW51VHJpZ2dlckZvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDcwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWF0TWVudVRyaWdnZXJGb3InKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIl9tYXRNZW51VHJpZ2dlckZvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDcwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRNZW51VHJpZ2dlckZvcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwibWVudVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNzAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwib25NZW51T3BlblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNzAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwib25NZW51Q2xvc2VcIiwgdm9pZCAwKTtcbiAgICBNZE1lbnVUcmlnZ2VyID0gX19kZWNvcmF0ZSQ3MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBcIlttZC1tZW51LXRyaWdnZXItZm9yXSwgW21hdC1tZW51LXRyaWdnZXItZm9yXSwgXFxuICAgICAgICAgICAgIFttZE1lbnVUcmlnZ2VyRm9yXSwgW21hdE1lbnVUcmlnZ2VyRm9yXVwiLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICcobW91c2Vkb3duKSc6ICdfaGFuZGxlTW91c2Vkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ3RvZ2dsZU1lbnUoKScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZE1lbnVUcmlnZ2VyJ1xuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQxNig0LCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT3ZlcmxheSwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIERpcl0pXG4gICAgXSwgTWRNZW51VHJpZ2dlcik7XG4gICAgcmV0dXJuIE1kTWVudVRyaWdnZXI7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ2NyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2NyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kTWVudU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRNZW51TW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZE1lbnVNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZE1lbnVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRNZW51TW9kdWxlID0gX19kZWNvcmF0ZSQ2NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW092ZXJsYXlNb2R1bGUsIF9hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIE1kUmlwcGxlTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZE1lbnUsIE1kTWVudUl0ZW0sIE1kTWVudVRyaWdnZXIsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRNZW51LCBNZE1lbnVJdGVtLCBNZE1lbnVUcmlnZ2VyXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDY3KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTWVudU1vZHVsZSk7XG4gICAgcmV0dXJuIE1kTWVudU1vZHVsZTtcbn0oKSk7XG5cbi8vIFRPRE8oamVsYm91cm4pOiByZXNpemluZ1xuLy8gVE9ETyhqZWxib3Vybik6IGFmdGVyT3BlbiBhbmQgYmVmb3JlQ2xvc2Vcbi8qKlxuICogUmVmZXJlbmNlIHRvIGEgZGlhbG9nIG9wZW5lZCB2aWEgdGhlIE1kRGlhbG9nIHNlcnZpY2UuXG4gKi9cbnZhciBNZERpYWxvZ1JlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dSZWYoX292ZXJsYXlSZWYsIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gX292ZXJsYXlSZWY7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgdGhlIGRpYWxvZyBoYXMgZmluaXNoZWQgY2xvc2luZy4gKi9cbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQgPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGRpYWxvZy5cbiAgICAgKiBAcGFyYW0gZGlhbG9nUmVzdWx0IE9wdGlvbmFsIHJlc3VsdCB0byByZXR1cm4gdG8gdGhlIGRpYWxvZyBvcGVuZXIuXG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGRpYWxvZ1Jlc3VsdCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQubmV4dChkaWFsb2dSZXN1bHQpO1xuICAgICAgICB0aGlzLl9hZnRlckNsb3NlZC5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgZGlhbG9nIGlzIGZpbmlzaGVkIGNsb3NpbmcuXG4gICAgICovXG4gICAgTWREaWFsb2dSZWYucHJvdG90eXBlLmFmdGVyQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWZ0ZXJDbG9zZWQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWREaWFsb2dSZWY7XG59KCkpO1xuXG52YXIgTURfRElBTE9HX0RBVEEgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTWREaWFsb2dEYXRhJyk7XG4vKiogQ3VzdG9tIGluamVjdG9yIHR5cGUgc3BlY2lmaWNhbGx5IGZvciBpbnN0YW50aWF0aW5nIGNvbXBvbmVudHMgd2l0aCBhIGRpYWxvZy4gKi9cbnZhciBEaWFsb2dJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlhbG9nSW5qZWN0b3IoX3BhcmVudEluamVjdG9yLCBfZGlhbG9nUmVmLCBfZGF0YSkge1xuICAgICAgICB0aGlzLl9wYXJlbnRJbmplY3RvciA9IF9wYXJlbnRJbmplY3RvcjtcbiAgICAgICAgdGhpcy5fZGlhbG9nUmVmID0gX2RpYWxvZ1JlZjtcbiAgICAgICAgdGhpcy5fZGF0YSA9IF9kYXRhO1xuICAgIH1cbiAgICBEaWFsb2dJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gTWREaWFsb2dSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFsb2dSZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSBNRF9ESUFMT0dfREFUQSAmJiB0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50SW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBEaWFsb2dJbmplY3Rvcjtcbn0oKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3Igb3BlbmluZyBhIG1vZGFsIGRpYWxvZyB3aXRoIHRoZSBNZERpYWxvZyBzZXJ2aWNlLlxuICovXG52YXIgTWREaWFsb2dDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ29uZmlnKCkge1xuICAgICAgICAvKiogVGhlIEFSSUEgcm9sZSBvZiB0aGUgZGlhbG9nIGVsZW1lbnQuICovXG4gICAgICAgIHRoaXMucm9sZSA9ICdkaWFsb2cnO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgdXNlciBjYW4gdXNlIGVzY2FwZSBvciBjbGlja2luZyBvdXRzaWRlIHRvIGNsb3NlIGEgbW9kYWwuICovXG4gICAgICAgIHRoaXMuZGlzYWJsZUNsb3NlID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaWR0aCBvZiB0aGUgZGlhbG9nLiAqL1xuICAgICAgICB0aGlzLndpZHRoID0gJyc7XG4gICAgICAgIC8qKiBIZWlnaHQgb2YgdGhlIGRpYWxvZy4gKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIE1kRGlhbG9nQ29uZmlnO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQyMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhIENvbXBvbmVudFBvcnRhbCBpcyBhdHRhY2hlZCB0byBhIERvbVBvcnRhbEhvc3Qgd2l0aG91dCBhbiBvcmlnaW4uXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIzKE1kRGlhbG9nQ29udGVudEFscmVhZHlBdHRhY2hlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ29udGVudEFscmVhZHlBdHRhY2hlZEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0ZW1wdGluZyB0byBhdHRhY2ggZGlhbG9nIGNvbnRlbnQgYWZ0ZXIgY29udGVudCBpcyBhbHJlYWR5IGF0dGFjaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcjtcbn0oTWRFcnJvcikpO1xuXG52YXIgX19leHRlbmRzJDIyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDczID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDczID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHVzZXItcHJvdmlkZWQgZGlhbG9nIGNvbnRlbnQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZERpYWxvZ0NvbnRhaW5lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIyKE1kRGlhbG9nQ29udGFpbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ29udGFpbmVyKF9uZ1pvbmUsIF9yZW5kZXJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKiBFbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBkaWFsb2cgd2FzIG9wZW5lZC4gU2F2ZSB0aGlzIHRvIHJlc3RvcmUgdXBvbiBjbG9zZS4gKi9cbiAgICAgICAgdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVEaWFsb2dXYXNPcGVuZWQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBDb21wb25lbnRQb3J0YWwgYXMgY29udGVudCB0byB0aGlzIGRpYWxvZyBjb250YWluZXIuXG4gICAgICogQHBhcmFtIHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQgYXMgdGhlIGRpYWxvZyBjb250ZW50LlxuICAgICAqL1xuICAgIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRhY2hSZXN1bHQgPSB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgICAgICB0aGlzLl90cmFwRm9jdXMoKTtcbiAgICAgICAgcmV0dXJuIGF0dGFjaFJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIFRlbXBsYXRlUG9ydGFsIGFzIGNvbnRlbnQgdG8gdGhpcyBkaWFsb2cgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSBwb3J0YWwgUG9ydGFsIHRvIGJlIGF0dGFjaGVkIGFzIHRoZSBkaWFsb2cgY29udGVudC5cbiAgICAgKi9cbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuYXR0YWNoVGVtcGxhdGVQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRhY2hlZFJlc3VsdCA9IHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoVGVtcGxhdGVQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgdGhpcy5fdHJhcEZvY3VzKCk7XG4gICAgICAgIHJldHVybiBhdHRhY2hlZFJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyBpbnNpZGUgdGhlIGZvY3VzIHRyYXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuX3RyYXBGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgd2VyZSB0byBhdHRlbXB0IHRvIGZvY3VzIGltbWVkaWF0ZWx5LCB0aGVuIHRoZSBjb250ZW50IG9mIHRoZSBkaWFsb2cgd291bGQgbm90IHlldCBiZVxuICAgICAgICAvLyByZWFkeSBpbiBpbnN0YW5jZXMgd2hlcmUgY2hhbmdlIGRldGVjdGlvbiBoYXMgdG8gcnVuIGZpcnN0LiBUbyBkZWFsIHdpdGggdGhpcywgd2Ugc2ltcGx5XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZW1wdHkuXG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBfdGhpcy5fZm9jdXNUcmFwLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdoZW4gdGhlIGRpYWxvZyBpcyBkZXN0cm95ZWQsIHJldHVybiBmb2N1cyB0byB0aGUgZWxlbWVudCB0aGF0IG9yaWdpbmFsbHkgaGFkIGl0IGJlZm9yZVxuICAgICAgICAvLyB0aGUgZGlhbG9nIHdhcyBvcGVuZWQuIFdhaXQgZm9yIHRoZSBET00gdG8gZmluaXNoIHNldHRsaW5nIGJlZm9yZSBjaGFuZ2luZyB0aGUgZm9jdXMgc29cbiAgICAgICAgLy8gdGhhdCBpdCBkb2Vzbid0IGVuZCB1cCBiYWNrIG9uIHRoZSA8Ym9keT4uIEFsc28gbm90ZSB0aGF0IHdlIG5lZWQgdGhlIGV4dHJhIGNoZWNrLCBiZWNhdXNlXG4gICAgICAgIC8vIElFIGNhbiBzZXQgdGhlIGBhY3RpdmVFbGVtZW50YCB0byBudWxsIGluIHNvbWUgY2FzZXMuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKF90aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZCwgJ2ZvY3VzJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ3MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKFBvcnRhbEhvc3REaXJlY3RpdmUpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MygnZGVzaWduOnR5cGUnLCBQb3J0YWxIb3N0RGlyZWN0aXZlKVxuICAgIF0sIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZSwgXCJfcG9ydGFsSG9zdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZChGb2N1c1RyYXApLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MygnZGVzaWduOnR5cGUnLCBGb2N1c1RyYXApXG4gICAgXSwgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLCBcIl9mb2N1c1RyYXBcIiwgdm9pZCAwKTtcbiAgICBNZERpYWxvZ0NvbnRhaW5lciA9IF9fZGVjb3JhdGUkNzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1kaWFsb2ctY29udGFpbmVyLCBtYXQtZGlhbG9nLWNvbnRhaW5lcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8Y2RrLWZvY3VzLXRyYXA+PHRlbXBsYXRlIGNka1BvcnRhbEhvc3Q+PC90ZW1wbGF0ZT48L2Nkay1mb2N1cy10cmFwPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWRpYWxvZy1jb250YWluZXJ7Ym94LXNoYWRvdzowIDExcHggMTVweCAtN3B4IHJnYmEoMCwwLDAsLjIpLDAgMjRweCAzOHB4IDNweCByZ2JhKDAsMCwwLC4xNCksMCA5cHggNDZweCA4cHggcmdiYSgwLDAsMCwuMTIpO2Rpc3BsYXk6YmxvY2s7cGFkZGluZzoyNHB4O2JvcmRlci1yYWRpdXM6MnB4O2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzphdXRvO21heC13aWR0aDo4MHZ3O3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Lm1hdC1kaWFsb2ctY29udGFpbmVye291dGxpbmU6c29saWQgMXB4fX0ubWF0LWRpYWxvZy1jb250ZW50e2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjAgLTI0cHg7cGFkZGluZzowIDI0cHg7bWF4LWhlaWdodDo2NXZoO292ZXJmbG93OmF1dG99Lm1hdC1kaWFsb2ctdGl0bGV7Zm9udC1zaXplOjIwcHg7Zm9udC13ZWlnaHQ6NzAwO21hcmdpbjowIDAgMjBweDtkaXNwbGF5OmJsb2NrfS5tYXQtZGlhbG9nLWFjdGlvbnN7cGFkZGluZzoxMnB4IDA7ZGlzcGxheTpmbGV4fS5tYXQtZGlhbG9nLWFjdGlvbnM6bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOi0yNHB4fS5tYXQtZGlhbG9nLWFjdGlvbnNbYWxpZ249ZW5kXXtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9Lm1hdC1kaWFsb2ctYWN0aW9uc1thbGlnbj1jZW50ZXJde2p1c3RpZnktY29udGVudDpjZW50ZXJ9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpYWxvZy1jb250YWluZXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5yb2xlXSc6ICdkaWFsb2dDb25maWc/LnJvbGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDczKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLk5nWm9uZSwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlcl0pXG4gICAgXSwgTWREaWFsb2dDb250YWluZXIpO1xuICAgIHJldHVybiBNZERpYWxvZ0NvbnRhaW5lcjtcbn0oQmFzZVBvcnRhbEhvc3QpKTtcblxudmFyIF9fZGVjb3JhdGUkNzIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDE3ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLy8gVE9ETyhqZWxib3Vybik6IGFuaW1hdGlvbnNcbi8qKlxuICogU2VydmljZSB0byBvcGVuIE1hdGVyaWFsIERlc2lnbiBtb2RhbCBkaWFsb2dzLlxuICovXG52YXIgTWREaWFsb2cgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nKF9vdmVybGF5LCBfaW5qZWN0b3IsIF9wYXJlbnREaWFsb2cpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgdGhpcy5fcGFyZW50RGlhbG9nID0gX3BhcmVudERpYWxvZztcbiAgICAgICAgdGhpcy5fb3BlbkRpYWxvZ3NBdFRoaXNMZXZlbCA9IFtdO1xuICAgICAgICB0aGlzLl9hZnRlckFsbENsb3NlZEF0VGhpc0xldmVsID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2FmdGVyT3BlbkF0VGhpc0xldmVsID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2JvdW5kS2V5ZG93biA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgLyoqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gYSBkaWFsb2cgaGFzIGJlZW4gb3BlbmVkLiAqL1xuICAgICAgICB0aGlzLmFmdGVyT3BlbiA9IHRoaXMuX2FmdGVyT3Blbi5hc09ic2VydmFibGUoKTtcbiAgICAgICAgLyoqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gYWxsIG9wZW4gZGlhbG9nIGhhdmUgZmluaXNoZWQgY2xvc2luZy4gKi9cbiAgICAgICAgdGhpcy5hZnRlckFsbENsb3NlZCA9IHRoaXMuX2FmdGVyQWxsQ2xvc2VkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREaWFsb2cucHJvdG90eXBlLCBcIl9vcGVuRGlhbG9nc1wiLCB7XG4gICAgICAgIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudGx5LW9wZW4gZGlhbG9ncy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50RGlhbG9nID8gdGhpcy5fcGFyZW50RGlhbG9nLl9vcGVuRGlhbG9ncyA6IHRoaXMuX29wZW5EaWFsb2dzQXRUaGlzTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERpYWxvZy5wcm90b3R5cGUsIFwiX2FmdGVyT3BlblwiLCB7XG4gICAgICAgIC8qKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCBhbGwgb3BlbiBkaWFsb2dzIGhhdmUgZmluaXNoZWQgY2xvc2luZy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50RGlhbG9nID8gdGhpcy5fcGFyZW50RGlhbG9nLl9hZnRlck9wZW4gOiB0aGlzLl9hZnRlck9wZW5BdFRoaXNMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGlhbG9nLnByb3RvdHlwZSwgXCJfYWZ0ZXJBbGxDbG9zZWRcIiwge1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgYSBkaWFsb2cgaGFzIG9wZW5lZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50RGlhbG9nID9cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnREaWFsb2cuX2FmdGVyQWxsQ2xvc2VkIDogdGhpcy5fYWZ0ZXJBbGxDbG9zZWRBdFRoaXNMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBtb2RhbCBkaWFsb2cgY29udGFpbmluZyB0aGUgZ2l2ZW4gY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRPclRlbXBsYXRlUmVmIFR5cGUgb2YgdGhlIGNvbXBvbmVudCB0byBsb2FkIGludG8gdGhlIGRpYWxvZyxcbiAgICAgKiAgICAgb3IgYSBUZW1wbGF0ZVJlZiB0byBpbnN0YW50aWF0ZSBhcyB0aGUgZGlhbG9nIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIGNvbmZpZyBFeHRyYSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMgUmVmZXJlbmNlIHRvIHRoZSBuZXdseS1vcGVuZWQgZGlhbG9nLlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25maWcgPSBfYXBwbHlDb25maWdEZWZhdWx0cyQxKGNvbmZpZyk7XG4gICAgICAgIHZhciBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheShjb25maWcpO1xuICAgICAgICB2YXIgZGlhbG9nQ29udGFpbmVyID0gdGhpcy5fYXR0YWNoRGlhbG9nQ29udGFpbmVyKG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIHZhciBkaWFsb2dSZWYgPSB0aGlzLl9hdHRhY2hEaWFsb2dDb250ZW50KGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIGRpYWxvZ0NvbnRhaW5lciwgb3ZlcmxheVJlZiwgY29uZmlnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuRGlhbG9ncy5sZW5ndGggJiYgIXRoaXMuX3BhcmVudERpYWxvZykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kS2V5ZG93bik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbkRpYWxvZ3MucHVzaChkaWFsb2dSZWYpO1xuICAgICAgICBkaWFsb2dSZWYuYWZ0ZXJDbG9zZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3JlbW92ZU9wZW5EaWFsb2coZGlhbG9nUmVmKTsgfSk7XG4gICAgICAgIHRoaXMuX2FmdGVyT3Blbi5uZXh0KGRpYWxvZ1JlZik7XG4gICAgICAgIHJldHVybiBkaWFsb2dSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIG9mIHRoZSBjdXJyZW50bHktb3BlbiBkaWFsb2dzLlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5jbG9zZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9vcGVuRGlhbG9ncy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIFRoZSBgX29wZW5EaWFsb2dzYCBwcm9wZXJ0eSBpc24ndCB1cGRhdGVkIGFmdGVyIGNsb3NlIHVudGlsIHRoZSByeGpzIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgLy8gcnVucyBvbiB0aGUgbmV4dCBtaWNyb3Rhc2ssIGluIGFkZGl0aW9uIHRvIG1vZGlmeWluZyB0aGUgYXJyYXkgYXMgd2UncmUgZ29pbmdcbiAgICAgICAgICAgIC8vIHRocm91Z2ggaXQuIFdlIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlbSBhbmQgY2FsbCBjbG9zZSB3aXRob3V0IGFzc3VtaW5nIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZXknbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0IGluc3RhbnRhbmVvdXNseS5cbiAgICAgICAgICAgIHRoaXMuX29wZW5EaWFsb2dzW2ldLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG92ZXJsYXkgaW50byB3aGljaCB0aGUgZGlhbG9nIHdpbGwgYmUgbG9hZGVkLlxuICAgICAqIEBwYXJhbSBkaWFsb2dDb25maWcgVGhlIGRpYWxvZyBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIE92ZXJsYXlSZWYgZm9yIHRoZSBjcmVhdGVkIG92ZXJsYXkuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKGRpYWxvZ0NvbmZpZykge1xuICAgICAgICB2YXIgb3ZlcmxheVN0YXRlID0gdGhpcy5fZ2V0T3ZlcmxheVN0YXRlKGRpYWxvZ0NvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LmNyZWF0ZShvdmVybGF5U3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gTWREaWFsb2dDb250YWluZXIgdG8gYSBkaWFsb2cncyBhbHJlYWR5LWNyZWF0ZWQgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheSBSZWZlcmVuY2UgdG8gdGhlIGRpYWxvZydzIHVuZGVybHlpbmcgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBkaWFsb2cgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgQ29tcG9uZW50UmVmIGZvciB0aGUgYXR0YWNoZWQgY29udGFpbmVyLlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5fYXR0YWNoRGlhbG9nQ29udGFpbmVyID0gZnVuY3Rpb24gKG92ZXJsYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IGNvbmZpZyA/IGNvbmZpZy52aWV3Q29udGFpbmVyUmVmIDogbnVsbDtcbiAgICAgICAgdmFyIGNvbnRhaW5lclBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoTWREaWFsb2dDb250YWluZXIsIHZpZXdDb250YWluZXIpO1xuICAgICAgICB2YXIgY29udGFpbmVyUmVmID0gb3ZlcmxheS5hdHRhY2goY29udGFpbmVyUG9ydGFsKTtcbiAgICAgICAgY29udGFpbmVyUmVmLmluc3RhbmNlLmRpYWxvZ0NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lclJlZi5pbnN0YW5jZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSB1c2VyLXByb3ZpZGVkIGNvbXBvbmVudCB0byB0aGUgYWxyZWFkeS1jcmVhdGVkIE1kRGlhbG9nQ29udGFpbmVyLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRPclRlbXBsYXRlUmVmIFRoZSB0eXBlIG9mIGNvbXBvbmVudCBiZWluZyBsb2FkZWQgaW50byB0aGUgZGlhbG9nLFxuICAgICAqICAgICBvciBhIFRlbXBsYXRlUmVmIHRvIGluc3RhbnRpYXRlIGFzIHRoZSBjb250ZW50LlxuICAgICAqIEBwYXJhbSBkaWFsb2dDb250YWluZXIgUmVmZXJlbmNlIHRvIHRoZSB3cmFwcGluZyBNZERpYWxvZ0NvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheVJlZiBSZWZlcmVuY2UgdG8gdGhlIG92ZXJsYXkgaW4gd2hpY2ggdGhlIGRpYWxvZyByZXNpZGVzLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGRpYWxvZyBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIE1kRGlhbG9nUmVmIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkIHRvIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5fYXR0YWNoRGlhbG9nQ29udGVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRPclRlbXBsYXRlUmVmLCBkaWFsb2dDb250YWluZXIsIG92ZXJsYXlSZWYsIGNvbmZpZykge1xuICAgICAgICAvLyBDcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIGRpYWxvZyB3ZSdyZSBjcmVhdGluZyBpbiBvcmRlciB0byBnaXZlIHRoZSB1c2VyIGEgaGFuZGxlXG4gICAgICAgIC8vIHRvIG1vZGlmeSBhbmQgY2xvc2UgaXQuXG4gICAgICAgIHZhciBkaWFsb2dSZWYgPSBuZXcgTWREaWFsb2dSZWYob3ZlcmxheVJlZiwgY29uZmlnKTtcbiAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUNsb3NlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBkaWFsb2cgYmFja2Ryb3AgaXMgY2xpY2tlZCwgd2Ugd2FudCB0byBjbG9zZSBpdC5cbiAgICAgICAgICAgIG92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpYWxvZ1JlZi5jbG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGRpYWxvZ1JlZiB0byB0aGUgY29udGFpbmVyIHNvIHRoYXQgaXQgY2FuIHVzZSB0aGUgcmVmIHRvIGNsb3NlIHRoZSBkaWFsb2cuXG4gICAgICAgIGRpYWxvZ0NvbnRhaW5lci5kaWFsb2dSZWYgPSBkaWFsb2dSZWY7XG4gICAgICAgIC8vIFdlIGNyZWF0ZSBhbiBpbmplY3RvciBzcGVjaWZpY2FsbHkgZm9yIHRoZSBjb21wb25lbnQgd2UncmUgaW5zdGFudGlhdGluZyBzbyB0aGF0IGl0IGNhblxuICAgICAgICAvLyBpbmplY3QgdGhlIE1kRGlhbG9nUmVmLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCBsb2FkZWQgaW5zaWRlIG9mIGEgZGlhbG9nIHRvIGNsb3NlIGl0c2VsZlxuICAgICAgICAvLyBhbmQsIG9wdGlvbmFsbHksIHRvIHJldHVybiBhIHZhbHVlLlxuICAgICAgICB2YXIgdXNlckluamVjdG9yID0gY29uZmlnICYmIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmICYmIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmLmluamVjdG9yO1xuICAgICAgICB2YXIgZGlhbG9nSW5qZWN0b3IgPSBuZXcgRGlhbG9nSW5qZWN0b3IodXNlckluamVjdG9yIHx8IHRoaXMuX2luamVjdG9yLCBkaWFsb2dSZWYsIGNvbmZpZy5kYXRhKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICBkaWFsb2dDb250YWluZXIuYXR0YWNoVGVtcGxhdGVQb3J0YWwobmV3IFRlbXBsYXRlUG9ydGFsKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50UmVmID0gZGlhbG9nQ29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChuZXcgQ29tcG9uZW50UG9ydGFsKGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIG51bGwsIGRpYWxvZ0luamVjdG9yKSk7XG4gICAgICAgICAgICBkaWFsb2dSZWYuY29tcG9uZW50SW5zdGFuY2UgPSBjb250ZW50UmVmLmluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWFsb2dSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgc3RhdGUgZnJvbSBhIGRpYWxvZyBjb25maWcuXG4gICAgICogQHBhcmFtIGRpYWxvZ0NvbmZpZyBUaGUgZGlhbG9nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybnMgVGhlIG92ZXJsYXkgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2dldE92ZXJsYXlTdGF0ZSA9IGZ1bmN0aW9uIChkaWFsb2dDb25maWcpIHtcbiAgICAgICAgdmFyIHN0YXRlJCQxID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuZ2xvYmFsKCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGRpYWxvZ0NvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUkJDEuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICBzdGF0ZSQkMS5wb3NpdGlvblN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiAocG9zaXRpb24ubGVmdCB8fCBwb3NpdGlvbi5yaWdodCkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPyBzdHJhdGVneS5sZWZ0KHBvc2l0aW9uLmxlZnQpIDogc3RyYXRlZ3kucmlnaHQocG9zaXRpb24ucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyYXRlZ3kuY2VudGVySG9yaXpvbnRhbGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uICYmIChwb3NpdGlvbi50b3AgfHwgcG9zaXRpb24uYm90dG9tKSkge1xuICAgICAgICAgICAgcG9zaXRpb24udG9wID8gc3RyYXRlZ3kudG9wKHBvc2l0aW9uLnRvcCkgOiBzdHJhdGVneS5ib3R0b20ocG9zaXRpb24uYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmF0ZWd5LmNlbnRlclZlcnRpY2FsbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJhdGVneS53aWR0aChkaWFsb2dDb25maWcud2lkdGgpLmhlaWdodChkaWFsb2dDb25maWcuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlJCQxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGRpYWxvZyBmcm9tIHRoZSBhcnJheSBvZiBvcGVuIGRpYWxvZ3MuXG4gICAgICogQHBhcmFtIGRpYWxvZ1JlZiBEaWFsb2cgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX3JlbW92ZU9wZW5EaWFsb2cgPSBmdW5jdGlvbiAoZGlhbG9nUmVmKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX29wZW5EaWFsb2dzLmluZGV4T2YoZGlhbG9nUmVmKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZW5EaWFsb2dzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBubyBvcGVuIGRpYWxvZ3MgYXJlIGxlZnQsIGNhbGwgbmV4dCBvbiBhZnRlckFsbENsb3NlZCBTdWJqZWN0XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29wZW5EaWFsb2dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FmdGVyQWxsQ2xvc2VkLm5leHQoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRLZXlkb3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBnbG9iYWwga2V5IHByZXNzZXMgd2hpbGUgdGhlcmUgYXJlIG9wZW4gZGlhbG9ncy4gQ2xvc2VzIHRoZVxuICAgICAqIHRvcCBkaWFsb2cgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGVzY2FwZS5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRvcERpYWxvZyA9IHRoaXMuX29wZW5EaWFsb2dzW3RoaXMuX29wZW5EaWFsb2dzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFICYmIHRvcERpYWxvZyAmJiAhdG9wRGlhbG9nLmNvbmZpZy5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgIHRvcERpYWxvZy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZERpYWxvZyA9IF9fZGVjb3JhdGUkNzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSxcbiAgICAgICAgX19wYXJhbSQxNygyLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtJDE3KDIsIF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDcyKCdkZXNpZ246cGFyYW10eXBlcycsIFtPdmVybGF5LCBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCBNZERpYWxvZ10pXG4gICAgXSwgTWREaWFsb2cpO1xuICAgIHJldHVybiBNZERpYWxvZztcbn0oKSk7XG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBkaWFsb2cgY29uZmlnLlxuICogQHBhcmFtIGRpYWxvZ0NvbmZpZyBDb25maWcgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcmV0dXJucyBUaGUgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfYXBwbHlDb25maWdEZWZhdWx0cyQxKGRpYWxvZ0NvbmZpZykge1xuICAgIHJldHVybiBleHRlbmRPYmplY3QobmV3IE1kRGlhbG9nQ29uZmlnKCksIGRpYWxvZ0NvbmZpZyk7XG59XG5cbnZhciBfX2RlY29yYXRlJDc0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDc0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEJ1dHRvbiB0aGF0IHdpbGwgY2xvc2UgdGhlIGN1cnJlbnQgZGlhbG9nLlxuICovXG52YXIgTWREaWFsb2dDbG9zZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dDbG9zZShkaWFsb2dSZWYpIHtcbiAgICAgICAgdGhpcy5kaWFsb2dSZWYgPSBkaWFsb2dSZWY7XG4gICAgICAgIC8qKiBTY3JlZW5yZWFkZXIgbGFiZWwgZm9yIHRoZSBidXR0b24uICovXG4gICAgICAgIHRoaXMuYXJpYUxhYmVsID0gJ0Nsb3NlIGRpYWxvZyc7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUkNzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLWxhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDc0KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZERpYWxvZ0Nsb3NlLnByb3RvdHlwZSwgXCJhcmlhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBNZERpYWxvZ0Nsb3NlID0gX19kZWNvcmF0ZSQ3NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uW21kLWRpYWxvZy1jbG9zZV0sIGJ1dHRvblttYXQtZGlhbG9nLWNsb3NlXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJyhjbGljayknOiAnZGlhbG9nUmVmLmNsb3NlKCknLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdhcmlhTGFiZWwnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2J1dHRvbicsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbTWREaWFsb2dSZWZdKVxuICAgIF0sIE1kRGlhbG9nQ2xvc2UpO1xuICAgIHJldHVybiBNZERpYWxvZ0Nsb3NlO1xufSgpKTtcbi8qKlxuICogVGl0bGUgb2YgYSBkaWFsb2cgZWxlbWVudC4gU3RheXMgZml4ZWQgdG8gdGhlIHRvcCBvZiB0aGUgZGlhbG9nIHdoZW4gc2Nyb2xsaW5nLlxuICovXG52YXIgTWREaWFsb2dUaXRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dUaXRsZSgpIHtcbiAgICB9XG4gICAgTWREaWFsb2dUaXRsZSA9IF9fZGVjb3JhdGUkNzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1kaWFsb2ctdGl0bGVdLCBbbWF0LWRpYWxvZy10aXRsZV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpYWxvZy10aXRsZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDc0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kRGlhbG9nVGl0bGUpO1xuICAgIHJldHVybiBNZERpYWxvZ1RpdGxlO1xufSgpKTtcbi8qKlxuICogU2Nyb2xsYWJsZSBjb250ZW50IGNvbnRhaW5lciBvZiBhIGRpYWxvZy5cbiAqL1xudmFyIE1kRGlhbG9nQ29udGVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dDb250ZW50KCkge1xuICAgIH1cbiAgICBNZERpYWxvZ0NvbnRlbnQgPSBfX2RlY29yYXRlJDc0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtZGlhbG9nLWNvbnRlbnRdLCBtZC1kaWFsb2ctY29udGVudCwgW21hdC1kaWFsb2ctY29udGVudF0sIG1hdC1kaWFsb2ctY29udGVudCcsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZGlhbG9nLWNvbnRlbnRdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZERpYWxvZ0NvbnRlbnQpO1xuICAgIHJldHVybiBNZERpYWxvZ0NvbnRlbnQ7XG59KCkpO1xuLyoqXG4gKiBDb250YWluZXIgZm9yIHRoZSBib3R0b20gYWN0aW9uIGJ1dHRvbnMgaW4gYSBkaWFsb2cuXG4gKiBTdGF5cyBmaXhlZCB0byB0aGUgYm90dG9tIHdoZW4gc2Nyb2xsaW5nLlxuICovXG52YXIgTWREaWFsb2dBY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0FjdGlvbnMoKSB7XG4gICAgfVxuICAgIE1kRGlhbG9nQWN0aW9ucyA9IF9fZGVjb3JhdGUkNzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1kaWFsb2ctYWN0aW9uc10sIG1kLWRpYWxvZy1hY3Rpb25zLCBbbWF0LWRpYWxvZy1hY3Rpb25zXSwgbWF0LWRpYWxvZy1hY3Rpb25zJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kaWFsb2ctYWN0aW9uc10nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDc0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kRGlhbG9nQWN0aW9ucyk7XG4gICAgcmV0dXJuIE1kRGlhbG9nQWN0aW9ucztcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDcxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcxID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWREaWFsb2dNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZERpYWxvZ01vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kRGlhbG9nTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kRGlhbG9nTW9kdWxlID0gX19kZWNvcmF0ZSQ3MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgUG9ydGFsTW9kdWxlLFxuICAgICAgICAgICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTWREaWFsb2dDb250YWluZXIsXG4gICAgICAgICAgICAgICAgTWREaWFsb2dDbG9zZSxcbiAgICAgICAgICAgICAgICBNZERpYWxvZ1RpdGxlLFxuICAgICAgICAgICAgICAgIE1kRGlhbG9nQ29udGVudCxcbiAgICAgICAgICAgICAgICBNZERpYWxvZ0FjdGlvbnMsXG4gICAgICAgICAgICAgICAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBNZERpYWxvZ0NvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBNZERpYWxvZ0Nsb3NlLFxuICAgICAgICAgICAgICAgIE1kRGlhbG9nVGl0bGUsXG4gICAgICAgICAgICAgICAgTWREaWFsb2dBY3Rpb25zLFxuICAgICAgICAgICAgICAgIE1kRGlhbG9nQ29udGVudCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBNZERpYWxvZyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtNZERpYWxvZ0NvbnRhaW5lcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZERpYWxvZ01vZHVsZSk7XG4gICAgcmV0dXJuIE1kRGlhbG9nTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNzYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQXV0b2NvbXBsZXRlIElEcyBuZWVkIHRvIGJlIHVuaXF1ZSBhY3Jvc3MgY29tcG9uZW50cywgc28gdGhpcyBjb3VudGVyIGV4aXN0cyBvdXRzaWRlIG9mXG4gKiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uXG4gKi9cbnZhciBfdW5pcXVlQXV0b2NvbXBsZXRlSWRDb3VudGVyID0gMDtcbnZhciBNZEF1dG9jb21wbGV0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRBdXRvY29tcGxldGUoKSB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgZGlzcGxheXMgYWJvdmUgb3IgYmVsb3cgaXRzIHRyaWdnZXIuICovXG4gICAgICAgIHRoaXMucG9zaXRpb25ZID0gJ2JlbG93JztcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCBzaG91bGQgYmUgdmlzaWJsZSwgZGVwZW5kaW5nIG9uIG9wdGlvbiBsZW5ndGguICovXG4gICAgICAgIHRoaXMuc2hvd1BhbmVsID0gZmFsc2U7XG4gICAgICAgIC8qKiBVbmlxdWUgSUQgdG8gYmUgdXNlZCBieSBhdXRvY29tcGxldGUgdHJpZ2dlcidzIFwiYXJpYS1vd25zXCIgcHJvcGVydHkuICovXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLWF1dG9jb21wbGV0ZS1cIiArIF91bmlxdWVBdXRvY29tcGxldGVJZENvdW50ZXIrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcGFuZWwgc2Nyb2xsVG9wLiBUaGlzIGFsbG93cyB1cyB0byBtYW51YWxseSBzY3JvbGwgdG8gZGlzcGxheVxuICAgICAqIG9wdGlvbnMgYmVsb3cgdGhlIGZvbGQsIGFzIHRoZXkgYXJlIG5vdCBhY3R1YWxseSBiZWluZyBmb2N1c2VkIHdoZW4gYWN0aXZlLlxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZS5fc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHNjcm9sbFRvcCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbCkge1xuICAgICAgICAgICAgdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFBhbmVsIHNob3VsZCBoaWRlIGl0c2VsZiB3aGVuIHRoZSBvcHRpb24gbGlzdCBpcyBlbXB0eS4gKi9cbiAgICBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX3NldFZpc2liaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2hvd1BhbmVsID0gISFfdGhpcy5vcHRpb25zLmxlbmd0aDsgfSk7XG4gICAgfTtcbiAgICAvKiogU2V0cyBhIGNsYXNzIG9uIHRoZSBwYW5lbCBiYXNlZCBvbiBpdHMgcG9zaXRpb24gKHVzZWQgdG8gc2V0IHktb2Zmc2V0KS4gKi9cbiAgICBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX2dldENsYXNzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdtYXQtYXV0b2NvbXBsZXRlLXBhbmVsLWJlbG93JzogdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycsXG4gICAgICAgICAgICAnbWF0LWF1dG9jb21wbGV0ZS1wYW5lbC1hYm92ZSc6IHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnLFxuICAgICAgICAgICAgJ21hdC1hdXRvY29tcGxldGUtdmlzaWJsZSc6IHRoaXMuc2hvd1BhbmVsLFxuICAgICAgICAgICAgJ21hdC1hdXRvY29tcGxldGUtaGlkZGVuJzogIXRoaXMuc2hvd1BhbmVsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDc2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiksIFxuICAgICAgICBfX21ldGFkYXRhJDc2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYpXG4gICAgXSwgTWRBdXRvY29tcGxldGUucHJvdG90eXBlLCBcInRlbXBsYXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ3NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKCdwYW5lbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NignZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYpXG4gICAgXSwgTWRBdXRvY29tcGxldGUucHJvdG90eXBlLCBcInBhbmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ3NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kT3B0aW9uKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzYoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRBdXRvY29tcGxldGUucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDc2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NignZGVzaWduOnR5cGUnLCBGdW5jdGlvbilcbiAgICBdLCBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUsIFwiZGlzcGxheVdpdGhcIiwgdm9pZCAwKTtcbiAgICBNZEF1dG9jb21wbGV0ZSA9IF9fZGVjb3JhdGUkNzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1hdXRvY29tcGxldGUsIG1hdC1hdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRlbXBsYXRlPjxkaXYgY2xhc3M9XFxcIm1hdC1hdXRvY29tcGxldGUtcGFuZWxcXFwiIHJvbGU9XFxcImxpc3Rib3hcXFwiIFtpZF09XFxcImlkXFxcIiBbbmdDbGFzc109XFxcIl9nZXRDbGFzc0xpc3QoKVxcXCIgI3BhbmVsPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48L3RlbXBsYXRlPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWF1dG9jb21wbGV0ZS1wYW5lbHtib3gtc2hhZG93OjAgNXB4IDVweCAtM3B4IHJnYmEoMCwwLDAsLjIpLDAgOHB4IDEwcHggMXB4IHJnYmEoMCwwLDAsLjE0KSwwIDNweCAxNHB4IDJweCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjExMnB4O21heC13aWR0aDoyODBweDtvdmVyZmxvdzphdXRvOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO3Zpc2liaWxpdHk6aGlkZGVuO21heC1oZWlnaHQ6MjU2cHg7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1hdXRvY29tcGxldGUtcGFuZWwubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC1iZWxvd3t0b3A6NnB4fS5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLm1hdC1hdXRvY29tcGxldGUtcGFuZWwtYWJvdmV7dG9wOi0yNHB4fS5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLm1hdC1hdXRvY29tcGxldGUtdmlzaWJsZXt2aXNpYmlsaXR5OnZpc2libGV9Lm1hdC1hdXRvY29tcGxldGUtcGFuZWwubWF0LWF1dG9jb21wbGV0ZS1oaWRkZW57dmlzaWJpbGl0eTpoaWRkZW59XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZEF1dG9jb21wbGV0ZScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYXV0b2NvbXBsZXRlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRBdXRvY29tcGxldGUpO1xuICAgIHJldHVybiBNZEF1dG9jb21wbGV0ZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMjQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMjQoQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIoaXRlbXMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaXRlbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgaXRlbSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIEl0IGFsc28gYWRkcyBhY3RpdmUgc3R5bGVzIHRvIHRoZSBuZXdseSBhY3RpdmUgaXRlbSBhbmQgcmVtb3ZlcyBhY3RpdmVcbiAgICAgKiBzdHlsZXMgZnJvbSB0aGUgcHJldmlvdXNseSBhY3RpdmUgaXRlbS5cbiAgICAgKi9cbiAgICBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0uc2V0SW5hY3RpdmVTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0uY2FsbCh0aGlzLCBpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS5zZXRBY3RpdmVTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyO1xufShMaXN0S2V5TWFuYWdlcikpO1xuXG52YXIgX19kZWNvcmF0ZSQ3NyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3NyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTggPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgc3R5bGUgY29uc3RhbnRzIGFyZSBuZWNlc3NhcnkgdG8gc2F2ZSBoZXJlIGluIG9yZGVyXG4gKiB0byBwcm9wZXJseSBjYWxjdWxhdGUgdGhlIHNjcm9sbFRvcCBvZiB0aGUgcGFuZWwuIEJlY2F1c2Ugd2UgYXJlIG5vdFxuICogYWN0dWFsbHkgZm9jdXNpbmcgdGhlIGFjdGl2ZSBpdGVtLCBzY3JvbGwgbXVzdCBiZSBoYW5kbGVkIG1hbnVhbGx5LlxuICovXG4vKiogVGhlIGhlaWdodCBvZiBlYWNoIGF1dG9jb21wbGV0ZSBvcHRpb24uICovXG52YXIgQVVUT0NPTVBMRVRFX09QVElPTl9IRUlHSFQgPSA0ODtcbi8qKiBUaGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBhdXRvY29tcGxldGUgcGFuZWwuICovXG52YXIgQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVCA9IDI1Njtcbi8qKlxuICogUHJvdmlkZXIgdGhhdCBhbGxvd3MgdGhlIGF1dG9jb21wbGV0ZSB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IF9hbmd1bGFyX2Zvcm1zLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRBdXRvY29tcGxldGVUcmlnZ2VyOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBNZEF1dG9jb21wbGV0ZVRyaWdnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcihfZWxlbWVudCwgX292ZXJsYXksIF92aWV3Q29udGFpbmVyUmVmLCBfZGlyLCBfem9uZSwgX2lucHV0Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5faW5wdXRDb250YWluZXIgPSBfaW5wdXRDb250YWluZXI7XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICAvKiogU3RyZWFtIG9mIGJsdXIgZXZlbnRzIHRoYXQgc2hvdWxkIGNsb3NlIHRoZSBwYW5lbC4gKi9cbiAgICAgICAgdGhpcy5fYmx1clN0cmVhbSA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICAvKiogVmlldyAtPiBtb2RlbCBjYWxsYmFjayBjYWxsZWQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIC8qKiBWaWV3IC0+IG1vZGVsIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGF1dG9jb21wbGV0ZSBoYXMgYmVlbiB0b3VjaGVkICovXG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwiX21hdEF1dG9jb21wbGV0ZVwiLCB7XG4gICAgICAgIC8qKiBQcm9wZXJ0eSB3aXRoIG1hdC0gcHJlZml4IGZvciBuby1jb25mbGljdCBtb2RlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9jb21wbGV0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXV0b2NvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZSA9IGF1dG9jb21wbGV0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIgPSBuZXcgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIodGhpcy5hdXRvY29tcGxldGUub3B0aW9ucykud2l0aFdyYXAoKTtcbiAgICB9O1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5lbFBvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lbFBvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVzdHJveVBhbmVsKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZSwgXCJwYW5lbE9wZW5cIiwge1xuICAgICAgICAvKiBXaGV0aGVyIG9yIG5vdCB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsIGlzIG9wZW4uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsT3BlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIE9wZW5zIHRoZSBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbiBwYW5lbC4gKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLm9wZW5QYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0Nsb3NpbmdBY3Rpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFuZWxPcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZmxvYXRQbGFjZWhvbGRlcignYWx3YXlzJyk7XG4gICAgfTtcbiAgICAvKiogQ2xvc2VzIHRoZSBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbiBwYW5lbC4gKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLmNsb3NlUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmICYmIHRoaXMuX292ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYW5lbE9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmxvYXRQbGFjZWhvbGRlcignYXV0bycpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwicGFuZWxDbG9zaW5nQWN0aW9uc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmVhbSBvZiBhY3Rpb25zIHRoYXQgc2hvdWxkIGNsb3NlIHRoZSBhdXRvY29tcGxldGUgcGFuZWwsIGluY2x1ZGluZ1xuICAgICAgICAgKiB3aGVuIGFuIG9wdGlvbiBpcyBzZWxlY3RlZCwgb24gYmx1ciwgYW5kIHdoZW4gVEFCIGlzIHByZXNzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5tZXJnZS5hcHBseShyeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZSwgdGhpcy5vcHRpb25TZWxlY3Rpb25zLmNvbmNhdChbdGhpcy5fYmx1clN0cmVhbS5hc09ic2VydmFibGUoKSwgdGhpcy5fa2V5TWFuYWdlci50YWJPdXRdKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcIm9wdGlvblNlbGVjdGlvbnNcIiwge1xuICAgICAgICAvKiogU3RyZWFtIG9mIGF1dG9jb21wbGV0ZSBvcHRpb24gc2VsZWN0aW9ucy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvY29tcGxldGUub3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikgeyByZXR1cm4gb3B0aW9uLm9uU2VsZWN0OyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwiYWN0aXZlT3B0aW9uXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50bHkgYWN0aXZlIG9wdGlvbiwgY29lcmNlZCB0byBNZE9wdGlvbiB0eXBlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGF1dG9jb21wbGV0ZSdzIHZhbHVlLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2VcbiAgICAgKiByZXF1aXJlZCB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2V0VHJpZ2dlclZhbHVlKHZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgYXV0b2NvbXBsZXRlJ3MgdmFsdWVcbiAgICAgKiBjaGFuZ2VzIGZyb20gdXNlciBpbnB1dC4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGF1dG9jb21wbGV0ZSBpcyBibHVycmVkXG4gICAgICogYnkgdGhlIHVzZXIuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSByZXF1aXJlZFxuICAgICAqIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiBDYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHRvdWNoZWQuXG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlT3B0aW9uICYmIGV2ZW50LmtleUNvZGUgPT09IEVOVEVSKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbi5fc2VsZWN0VmlhSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBVUF9BUlJPVyB8fCBldmVudC5rZXlDb2RlID09PSBET1dOX0FSUk9XKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuUGFuZWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxUb09wdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9oYW5kbGVJbnB1dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMub3BlblBhbmVsKCk7XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9oYW5kbGVCbHVyID0gZnVuY3Rpb24gKG5ld2x5Rm9jdXNlZFRhZykge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQoKTtcbiAgICAgICAgLy8gT25seSBlbWl0IGJsdXIgZXZlbnQgaWYgdGhlIG5ldyBmb2N1cyBpcyAqbm90KiBvbiBhbiBvcHRpb24uXG4gICAgICAgIGlmIChuZXdseUZvY3VzZWRUYWcgIT09ICdNRC1PUFRJT04nKSB7XG4gICAgICAgICAgICB0aGlzLl9ibHVyU3RyZWFtLm5leHQobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluIFwiYXV0b1wiIG1vZGUsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGFuaW1hdGUgZG93biBhcyBzb29uIGFzIGZvY3VzIGlzIGxvc3QuXG4gICAgICogVGhpcyBjYXVzZXMgdGhlIHZhbHVlIHRvIGp1bXAgd2hlbiBzZWxlY3RpbmcgYW4gb3B0aW9uIHdpdGggdGhlIG1vdXNlLlxuICAgICAqIFRoaXMgbWV0aG9kIG1hbnVhbGx5IGZsb2F0cyB0aGUgcGxhY2Vob2xkZXIgdW50aWwgdGhlIHBhbmVsIGNhbiBiZSBjbG9zZWQuXG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZmxvYXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChzdGF0ZSQkMSkge1xuICAgICAgICBpZiAodGhpcy5faW5wdXRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0Q29udGFpbmVyLmZsb2F0UGxhY2Vob2xkZXIgPSBzdGF0ZSQkMTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhhdCB3ZSBhcmUgbm90IGFjdHVhbGx5IGZvY3VzaW5nIGFjdGl2ZSBvcHRpb25zLCB3ZSBtdXN0IG1hbnVhbGx5IGFkanVzdCBzY3JvbGxcbiAgICAgKiB0byByZXZlYWwgb3B0aW9ucyBiZWxvdyB0aGUgZm9sZC4gRmlyc3QsIHdlIGZpbmQgdGhlIG9mZnNldCBvZiB0aGUgb3B0aW9uIGZyb20gdGhlIHRvcFxuICAgICAqIG9mIHRoZSBwYW5lbC4gVGhlIG5ldyBzY3JvbGxUb3Agd2lsbCBiZSB0aGF0IG9mZnNldCAtIHRoZSBwYW5lbCBoZWlnaHQgKyB0aGUgb3B0aW9uXG4gICAgICogaGVpZ2h0LCBzbyB0aGUgYWN0aXZlIG9wdGlvbiB3aWxsIGJlIGp1c3QgdmlzaWJsZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYW5lbC5cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9zY3JvbGxUb09wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbk9mZnNldCA9IHRoaXMuX2tleU1hbmFnZXIuYWN0aXZlSXRlbUluZGV4ICogQVVUT0NPTVBMRVRFX09QVElPTl9IRUlHSFQ7XG4gICAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSBNYXRoLm1heCgwLCBvcHRpb25PZmZzZXQgLSBBVVRPQ09NUExFVEVfUEFORUxfSEVJR0hUICsgQVVUT0NPTVBMRVRFX09QVElPTl9IRUlHSFQpO1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5fc2V0U2Nyb2xsVG9wKG5ld1Njcm9sbFRvcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBsaXN0ZW5zIHRvIGEgc3RyZWFtIG9mIHBhbmVsIGNsb3NpbmcgYWN0aW9ucyBhbmQgcmVzZXRzIHRoZVxuICAgICAqIHN0cmVhbSBldmVyeSB0aW1lIHRoZSBvcHRpb24gbGlzdCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvQ2xvc2luZ0FjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdoZW4gdGhlIHpvbmUgaXMgc3RhYmxlIGluaXRpYWxseSwgYW5kIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGNoYW5nZXMuLi5cbiAgICAgICAgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUubWVyZ2UodGhpcy5fem9uZS5vblN0YWJsZS5maXJzdCgpLCB0aGlzLmF1dG9jb21wbGV0ZS5vcHRpb25zLmNoYW5nZXMpXG4gICAgICAgICAgICAuc3dpdGNoTWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNldFBhbmVsKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucGFuZWxDbG9zaW5nQWN0aW9ucztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuX3NldFZhbHVlQW5kQ2xvc2UoZXZlbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBEZXN0cm95cyB0aGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb24gcGFuZWwuICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZGVzdHJveVBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9zZXRUcmlnZ2VyVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LnZhbHVlID1cbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLmRpc3BsYXlXaXRoID8gdGhpcy5hdXRvY29tcGxldGUuZGlzcGxheVdpdGgodmFsdWUpIDogdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAqIFRoaXMgbWV0aG9kIGNsb3NlcyB0aGUgcGFuZWwsIGFuZCBpZiBhIHZhbHVlIGlzIHNwZWNpZmllZCwgYWxzbyBzZXRzIHRoZSBhc3NvY2lhdGVkXG4gICAgKiBjb250cm9sIHRvIHRoYXQgdmFsdWUuIEl0IHdpbGwgYWxzbyBtYXJrIHRoZSBjb250cm9sIGFzIGRpcnR5IGlmIHRoaXMgaW50ZXJhY3Rpb25cbiAgICAqIHN0ZW1tZWQgZnJvbSB0aGUgdXNlci5cbiAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3NldFZhbHVlQW5kQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUcmlnZ2VyVmFsdWUoZXZlbnQuc291cmNlLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKGV2ZW50LnNvdXJjZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5hdXRvY29tcGxldGUudGVtcGxhdGUsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUodGhpcy5fZ2V0T3ZlcmxheUNvbmZpZygpKTtcbiAgICB9O1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2dldE92ZXJsYXlDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fZ2V0T3ZlcmxheVBvc2l0aW9uKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS53aWR0aCA9IHRoaXMuX2dldEhvc3RXaWR0aCgpO1xuICAgICAgICBvdmVybGF5U3RhdGUuZGlyZWN0aW9uID0gdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlIDogJ2x0cic7XG4gICAgICAgIHJldHVybiBvdmVybGF5U3RhdGU7XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9nZXRPdmVybGF5UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudCwgeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAnYm90dG9tJyB9LCB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ3RvcCcgfSlcbiAgICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICd0b3AnIH0sIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9KTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Qb3NpdGlvbkNoYW5nZXModGhpcy5fcG9zaXRpb25TdHJhdGVneSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblN0cmF0ZWd5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc3Vic2NyaWJlcyB0byBwb3NpdGlvbiBjaGFuZ2VzIGluIHRoZSBhdXRvY29tcGxldGUgcGFuZWwsIHNvIHRoZSBwYW5lbCdzXG4gICAgICogeS1vZmZzZXQgY2FuIGJlIGFkanVzdGVkIHRvIG1hdGNoIHRoZSBuZXcgcG9zaXRpb24uXG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fc3Vic2NyaWJlVG9Qb3NpdGlvbkNoYW5nZXMgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcGFuZWxQb3NpdGlvblN1YnNjcmlwdGlvbiA9IHN0cmF0ZWd5Lm9uUG9zaXRpb25DaGFuZ2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIF90aGlzLmF1dG9jb21wbGV0ZS5wb3NpdGlvblkgPSBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3JpZ2luWSA9PT0gJ3RvcCcgPyAnYWJvdmUnIDogJ2JlbG93JztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGlucHV0IGVsZW1lbnQsIHNvIHRoZSBwYW5lbCB3aWR0aCBjYW4gbWF0Y2ggaXQuICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZ2V0SG9zdFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIH07XG4gICAgLyoqIFJlc2V0IGFjdGl2ZSBpdGVtIHRvIG51bGwgc28gYXJyb3cgZXZlbnRzIHdpbGwgYWN0aXZhdGUgdGhlIGNvcnJlY3Qgb3B0aW9ucy4qL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3Jlc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBhY3RpdmUgaXRlbSBhbmQgcmUtY2FsY3VsYXRlcyBhbGlnbm1lbnQgb2YgdGhlIHBhbmVsIGluIGNhc2UgaXRzIHNpemVcbiAgICAgKiBoYXMgY2hhbmdlZCBkdWUgdG8gZmV3ZXIgb3IgZ3JlYXRlciBudW1iZXIgb2Ygb3B0aW9ucy5cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9yZXNldFBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZXNldEFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25TdHJhdGVneS5yZWNhbGN1bGF0ZUxhc3RQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5fc2V0VmlzaWJpbGl0eSgpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ3NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kQXV0b2NvbXBsZXRlJyksIFxuICAgICAgICBfX21ldGFkYXRhJDc3KCdkZXNpZ246dHlwZScsIE1kQXV0b2NvbXBsZXRlKVxuICAgIF0sIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwiYXV0b2NvbXBsZXRlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ3NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21hdEF1dG9jb21wbGV0ZScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NygnZGVzaWduOnR5cGUnLCBNZEF1dG9jb21wbGV0ZSlcbiAgICBdLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcIl9tYXRBdXRvY29tcGxldGVcIiwgbnVsbCk7XG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyID0gX19kZWNvcmF0ZSQ3NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbbWRBdXRvY29tcGxldGVdLCBpbnB1dFttYXRBdXRvY29tcGxldGVdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdjb21ib2JveCcsXG4gICAgICAgICAgICAgICAgJ2F1dG9jb21wbGV0ZSc6ICdvZmYnLFxuICAgICAgICAgICAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICAnYXJpYS1tdWx0aWxpbmUnOiAnZmFsc2UnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdJzogJ2FjdGl2ZU9wdGlvbj8uaWQnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdwYW5lbE9wZW4udG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtb3duc10nOiAnYXV0b2NvbXBsZXRlPy5pZCcsXG4gICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnb3BlblBhbmVsKCknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX2hhbmRsZUJsdXIoJGV2ZW50LnJlbGF0ZWRUYXJnZXQ/LnRhZ05hbWUpJyxcbiAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdfaGFuZGxlSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICcoa2V5ZG93biknOiAnX2hhbmRsZUtleWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQxOCgzLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtJDE4KDUsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kMTgoNSwgX2FuZ3VsYXJfY29yZS5Ib3N0KCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBPdmVybGF5LCBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIERpciwgX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIE1kSW5wdXRDb250YWluZXJdKVxuICAgIF0sIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcik7XG4gICAgcmV0dXJuIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDc1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDc1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRBdXRvY29tcGxldGVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQXV0b2NvbXBsZXRlTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZEF1dG9jb21wbGV0ZU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kQXV0b2NvbXBsZXRlTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbT1ZFUkxBWV9QUk9WSURFUlNdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZU1vZHVsZSA9IF9fZGVjb3JhdGUkNzUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtNZE9wdGlvbk1vZHVsZSwgT3ZlcmxheU1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZSwgX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRBdXRvY29tcGxldGUsIE1kT3B0aW9uTW9kdWxlLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXIsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRBdXRvY29tcGxldGUsIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEF1dG9jb21wbGV0ZU1vZHVsZSk7XG4gICAgcmV0dXJuIE1kQXV0b2NvbXBsZXRlTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMzAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNQVRFUklBTF9NT0RVTEVTID0gW1xuICAgIE1kQXV0b2NvbXBsZXRlTW9kdWxlLFxuICAgIE1kQnV0dG9uTW9kdWxlLFxuICAgIE1kQnV0dG9uVG9nZ2xlTW9kdWxlLFxuICAgIE1kQ2FyZE1vZHVsZSxcbiAgICBNZENoaXBzTW9kdWxlLFxuICAgIE1kQ2hlY2tib3hNb2R1bGUsXG4gICAgTWREaWFsb2dNb2R1bGUsXG4gICAgTWRHcmlkTGlzdE1vZHVsZSxcbiAgICBNZEljb25Nb2R1bGUsXG4gICAgTWRJbnB1dE1vZHVsZSxcbiAgICBNZExpc3RNb2R1bGUsXG4gICAgTWRNZW51TW9kdWxlLFxuICAgIE1kUHJvZ3Jlc3NCYXJNb2R1bGUsXG4gICAgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUsXG4gICAgTWRSYWRpb01vZHVsZSxcbiAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICBNZFNlbGVjdE1vZHVsZSxcbiAgICBNZFNpZGVuYXZNb2R1bGUsXG4gICAgTWRTbGlkZXJNb2R1bGUsXG4gICAgTWRTbGlkZVRvZ2dsZU1vZHVsZSxcbiAgICBNZFNuYWNrQmFyTW9kdWxlLFxuICAgIE1kVGFic01vZHVsZSxcbiAgICBNZFRvb2xiYXJNb2R1bGUsXG4gICAgTWRUb29sdGlwTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgUG9ydGFsTW9kdWxlLFxuICAgIFJ0bE1vZHVsZSxcbiAgICBTdHlsZU1vZHVsZSxcbiAgICBBMTF5TW9kdWxlLFxuICAgIFBsYXRmb3JtTW9kdWxlLFxuICAgIFByb2plY3Rpb25Nb2R1bGUsXG4gICAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgICBPYnNlcnZlQ29udGVudE1vZHVsZVxuXTtcbnZhciBNYXRlcmlhbFJvb3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsUm9vdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWF0ZXJpYWxSb290TW9kdWxlID0gX19kZWNvcmF0ZSQzMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgIE1kQXV0b2NvbXBsZXRlTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZEJ1dHRvbk1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRDYXJkTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZENoaXBzTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZENoZWNrYm94TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZEdyaWRMaXN0TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZElucHV0TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZExpc3RNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kUHJvZ3Jlc3NCYXJNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFJpcHBsZU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRTZWxlY3RNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kU2lkZW5hdk1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRUYWJzTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFRvb2xiYXJNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIFBvcnRhbE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgUHJvamVjdGlvbk1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgUnRsTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBPYnNlcnZlQ29udGVudE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgbW9kdWxlcyBpbmNsdWRlIHByb3ZpZGVycy5cbiAgICAgICAgICAgICAgICBBMTF5TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZEJ1dHRvblRvZ2dsZU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWREaWFsb2dNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kSWNvbk1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRNZW51TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFJhZGlvTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFNsaWRlck1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRTbGlkZVRvZ2dsZU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRTbmFja0Jhck1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRUb29sdGlwTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBQbGF0Zm9ybU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgT3ZlcmxheU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgQ29tcGF0aWJpbGl0eU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogTUFURVJJQUxfTU9EVUxFUyxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1hdGVyaWFsUm9vdE1vZHVsZSk7XG4gICAgcmV0dXJuIE1hdGVyaWFsUm9vdE1vZHVsZTtcbn0oKSk7XG52YXIgTWF0ZXJpYWxNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNYXRlcmlhbE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBuZ01vZHVsZTogTWF0ZXJpYWxSb290TW9kdWxlIH07XG4gICAgfTtcbiAgICBNYXRlcmlhbE1vZHVsZSA9IF9fZGVjb3JhdGUkMzAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IE1BVEVSSUFMX01PRFVMRVMsXG4gICAgICAgICAgICBleHBvcnRzOiBNQVRFUklBTF9NT0RVTEVTLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWF0ZXJpYWxNb2R1bGUpO1xuICAgIHJldHVybiBNYXRlcmlhbE1vZHVsZTtcbn0oKSk7XG5cbmV4cG9ydHMuTWRDb3JlTW9kdWxlID0gTWRDb3JlTW9kdWxlO1xuZXhwb3J0cy5EaXIgPSBEaXI7XG5leHBvcnRzLlJ0bE1vZHVsZSA9IFJ0bE1vZHVsZTtcbmV4cG9ydHMuT2JzZXJ2ZUNvbnRlbnRNb2R1bGUgPSBPYnNlcnZlQ29udGVudE1vZHVsZTtcbmV4cG9ydHMuT2JzZXJ2ZUNvbnRlbnQgPSBPYnNlcnZlQ29udGVudDtcbmV4cG9ydHMuTWRPcHRpb25Nb2R1bGUgPSBNZE9wdGlvbk1vZHVsZTtcbmV4cG9ydHMuTWRPcHRpb24gPSBNZE9wdGlvbjtcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5CYXNlUG9ydGFsSG9zdCA9IEJhc2VQb3J0YWxIb3N0O1xuZXhwb3J0cy5Db21wb25lbnRQb3J0YWwgPSBDb21wb25lbnRQb3J0YWw7XG5leHBvcnRzLlRlbXBsYXRlUG9ydGFsID0gVGVtcGxhdGVQb3J0YWw7XG5leHBvcnRzLlBvcnRhbEhvc3REaXJlY3RpdmUgPSBQb3J0YWxIb3N0RGlyZWN0aXZlO1xuZXhwb3J0cy5UZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSA9IFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlO1xuZXhwb3J0cy5Qb3J0YWxNb2R1bGUgPSBQb3J0YWxNb2R1bGU7XG5leHBvcnRzLkRvbVBvcnRhbEhvc3QgPSBEb21Qb3J0YWxIb3N0O1xuZXhwb3J0cy5NZFBsYXRmb3JtID0gUGxhdGZvcm07XG5leHBvcnRzLk92ZXJsYXkgPSBPdmVybGF5O1xuZXhwb3J0cy5PVkVSTEFZX1BST1ZJREVSUyA9IE9WRVJMQVlfUFJPVklERVJTO1xuZXhwb3J0cy5PdmVybGF5Q29udGFpbmVyID0gT3ZlcmxheUNvbnRhaW5lcjtcbmV4cG9ydHMuRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIgPSBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lcjtcbmV4cG9ydHMuT3ZlcmxheVJlZiA9IE92ZXJsYXlSZWY7XG5leHBvcnRzLk92ZXJsYXlTdGF0ZSA9IE92ZXJsYXlTdGF0ZTtcbmV4cG9ydHMuQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSA9IENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmU7XG5leHBvcnRzLk92ZXJsYXlPcmlnaW4gPSBPdmVybGF5T3JpZ2luO1xuZXhwb3J0cy5PdmVybGF5TW9kdWxlID0gT3ZlcmxheU1vZHVsZTtcbmV4cG9ydHMuU2Nyb2xsRGlzcGF0Y2hlciA9IFNjcm9sbERpc3BhdGNoZXI7XG5leHBvcnRzLkdlc3R1cmVDb25maWcgPSBHZXN0dXJlQ29uZmlnO1xuZXhwb3J0cy5NZFJpcHBsZSA9IE1kUmlwcGxlO1xuZXhwb3J0cy5NZFJpcHBsZU1vZHVsZSA9IE1kUmlwcGxlTW9kdWxlO1xuZXhwb3J0cy5MaXZlQW5ub3VuY2VyID0gTGl2ZUFubm91bmNlcjtcbmV4cG9ydHMuTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTiA9IExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU47XG5leHBvcnRzLkxJVkVfQU5OT1VOQ0VSX1BST1ZJREVSID0gTElWRV9BTk5PVU5DRVJfUFJPVklERVI7XG5leHBvcnRzLk1kTGl2ZUFubm91bmNlciA9IExpdmVBbm5vdW5jZXI7XG5leHBvcnRzLkZvY3VzVHJhcCA9IEZvY3VzVHJhcDtcbmV4cG9ydHMuSW50ZXJhY3Rpdml0eUNoZWNrZXIgPSBJbnRlcmFjdGl2aXR5Q2hlY2tlcjtcbmV4cG9ydHMuaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlciA9IGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXI7XG5leHBvcnRzLkExMXlNb2R1bGUgPSBBMTF5TW9kdWxlO1xuZXhwb3J0cy5VbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyID0gVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcjtcbmV4cG9ydHMuVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSID0gVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSO1xuZXhwb3J0cy5NZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIgPSBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyO1xuZXhwb3J0cy5NZExpbmVNb2R1bGUgPSBNZExpbmVNb2R1bGU7XG5leHBvcnRzLk1kTGluZSA9IE1kTGluZTtcbmV4cG9ydHMuTWRMaW5lU2V0dGVyID0gTWRMaW5lU2V0dGVyO1xuZXhwb3J0cy5NZEVycm9yID0gTWRFcnJvcjtcbmV4cG9ydHMuY29lcmNlQm9vbGVhblByb3BlcnR5ID0gY29lcmNlQm9vbGVhblByb3BlcnR5O1xuZXhwb3J0cy5jb2VyY2VOdW1iZXJQcm9wZXJ0eSA9IGNvZXJjZU51bWJlclByb3BlcnR5O1xuZXhwb3J0cy5Db21wYXRpYmlsaXR5TW9kdWxlID0gQ29tcGF0aWJpbGl0eU1vZHVsZTtcbmV4cG9ydHMuTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUgPSBOb0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuRG9tUHJvamVjdGlvbkhvc3QgPSBEb21Qcm9qZWN0aW9uSG9zdDtcbmV4cG9ydHMuRG9tUHJvamVjdGlvbiA9IERvbVByb2plY3Rpb247XG5leHBvcnRzLlByb2plY3Rpb25Nb2R1bGUgPSBQcm9qZWN0aW9uTW9kdWxlO1xuZXhwb3J0cy5QbGF0Zm9ybU1vZHVsZSA9IFBsYXRmb3JtTW9kdWxlO1xuZXhwb3J0cy5QbGF0Zm9ybSA9IFBsYXRmb3JtO1xuZXhwb3J0cy5nZXRTdXBwb3J0ZWRJbnB1dFR5cGVzID0gZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcztcbmV4cG9ydHMuQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSA9IENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG5leHBvcnRzLkNvbm5lY3Rpb25Qb3NpdGlvblBhaXIgPSBDb25uZWN0aW9uUG9zaXRpb25QYWlyO1xuZXhwb3J0cy5TY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMgPSBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXM7XG5leHBvcnRzLkNvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZSA9IENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZTtcbmV4cG9ydHMuU2VsZWN0aW9uTW9kZWwgPSBTZWxlY3Rpb25Nb2RlbDtcbmV4cG9ydHMuU2VsZWN0aW9uQ2hhbmdlID0gU2VsZWN0aW9uQ2hhbmdlO1xuZXhwb3J0cy5TdHlsZU1vZHVsZSA9IFN0eWxlTW9kdWxlO1xuZXhwb3J0cy5UT1VDSF9CVUZGRVJfTVMgPSBUT1VDSF9CVUZGRVJfTVM7XG5leHBvcnRzLkZvY3VzT3JpZ2luTW9uaXRvciA9IEZvY3VzT3JpZ2luTW9uaXRvcjtcbmV4cG9ydHMuQ2RrRm9jdXNDbGFzc2VzID0gQ2RrRm9jdXNDbGFzc2VzO1xuZXhwb3J0cy5GT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUl9GQUNUT1JZID0gRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVJfRkFDVE9SWTtcbmV4cG9ydHMuRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVIgPSBGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUjtcbmV4cG9ydHMuYXBwbHlDc3NUcmFuc2Zvcm0gPSBhcHBseUNzc1RyYW5zZm9ybTtcbmV4cG9ydHMuVVBfQVJST1cgPSBVUF9BUlJPVztcbmV4cG9ydHMuRE9XTl9BUlJPVyA9IERPV05fQVJST1c7XG5leHBvcnRzLlJJR0hUX0FSUk9XID0gUklHSFRfQVJST1c7XG5leHBvcnRzLkxFRlRfQVJST1cgPSBMRUZUX0FSUk9XO1xuZXhwb3J0cy5QQUdFX1VQID0gUEFHRV9VUDtcbmV4cG9ydHMuUEFHRV9ET1dOID0gUEFHRV9ET1dOO1xuZXhwb3J0cy5IT01FID0gSE9NRTtcbmV4cG9ydHMuRU5EID0gRU5EO1xuZXhwb3J0cy5FTlRFUiA9IEVOVEVSO1xuZXhwb3J0cy5TUEFDRSA9IFNQQUNFO1xuZXhwb3J0cy5UQUIgPSBUQUI7XG5leHBvcnRzLkVTQ0FQRSA9IEVTQ0FQRTtcbmV4cG9ydHMuQkFDS1NQQUNFID0gQkFDS1NQQUNFO1xuZXhwb3J0cy5ERUxFVEUgPSBERUxFVEU7XG5leHBvcnRzLk1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSA9IE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERTtcbmV4cG9ydHMuTUFUX0VMRU1FTlRTX1NFTEVDVE9SID0gTUFUX0VMRU1FTlRTX1NFTEVDVE9SO1xuZXhwb3J0cy5NRF9FTEVNRU5UU19TRUxFQ1RPUiA9IE1EX0VMRU1FTlRTX1NFTEVDVE9SO1xuZXhwb3J0cy5NYXRQcmVmaXhSZWplY3RvciA9IE1hdFByZWZpeFJlamVjdG9yO1xuZXhwb3J0cy5NZFByZWZpeFJlamVjdG9yID0gTWRQcmVmaXhSZWplY3RvcjtcbmV4cG9ydHMuQW5pbWF0aW9uQ3VydmVzID0gQW5pbWF0aW9uQ3VydmVzO1xuZXhwb3J0cy5BbmltYXRpb25EdXJhdGlvbnMgPSBBbmltYXRpb25EdXJhdGlvbnM7XG5leHBvcnRzLk1kU2VsZWN0aW9uTW9kdWxlID0gTWRTZWxlY3Rpb25Nb2R1bGU7XG5leHBvcnRzLk1kUHNldWRvQ2hlY2tib3ggPSBNZFBzZXVkb0NoZWNrYm94O1xuZXhwb3J0cy5NYXRlcmlhbFJvb3RNb2R1bGUgPSBNYXRlcmlhbFJvb3RNb2R1bGU7XG5leHBvcnRzLk1hdGVyaWFsTW9kdWxlID0gTWF0ZXJpYWxNb2R1bGU7XG5leHBvcnRzLk1kQXV0b2NvbXBsZXRlTW9kdWxlID0gTWRBdXRvY29tcGxldGVNb2R1bGU7XG5leHBvcnRzLk1kQXV0b2NvbXBsZXRlID0gTWRBdXRvY29tcGxldGU7XG5leHBvcnRzLkFVVE9DT01QTEVURV9PUFRJT05fSEVJR0hUID0gQVVUT0NPTVBMRVRFX09QVElPTl9IRUlHSFQ7XG5leHBvcnRzLkFVVE9DT01QTEVURV9QQU5FTF9IRUlHSFQgPSBBVVRPQ09NUExFVEVfUEFORUxfSEVJR0hUO1xuZXhwb3J0cy5NRF9BVVRPQ09NUExFVEVfVkFMVUVfQUNDRVNTT1IgPSBNRF9BVVRPQ09NUExFVEVfVkFMVUVfQUNDRVNTT1I7XG5leHBvcnRzLk1kQXV0b2NvbXBsZXRlVHJpZ2dlciA9IE1kQXV0b2NvbXBsZXRlVHJpZ2dlcjtcbmV4cG9ydHMuTWRCdXR0b25Dc3NNYXRTdHlsZXIgPSBNZEJ1dHRvbkNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIgPSBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyID0gTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZEZhYkNzc01hdFN0eWxlciA9IE1kRmFiQ3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZE1pbmlGYWJDc3NNYXRTdHlsZXIgPSBNZE1pbmlGYWJDc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kQnV0dG9uID0gTWRCdXR0b247XG5leHBvcnRzLk1kQW5jaG9yID0gTWRBbmNob3I7XG5leHBvcnRzLk1kQnV0dG9uTW9kdWxlID0gTWRCdXR0b25Nb2R1bGU7XG5leHBvcnRzLk1EX0JVVFRPTl9UT0dHTEVfR1JPVVBfVkFMVUVfQUNDRVNTT1IgPSBNRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZUNoYW5nZSA9IE1kQnV0dG9uVG9nZ2xlQ2hhbmdlO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZUdyb3VwID0gTWRCdXR0b25Ub2dnbGVHcm91cDtcbmV4cG9ydHMuTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZSA9IE1kQnV0dG9uVG9nZ2xlO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZU1vZHVsZSA9IE1kQnV0dG9uVG9nZ2xlTW9kdWxlO1xuZXhwb3J0cy5NZENhcmRDb250ZW50ID0gTWRDYXJkQ29udGVudDtcbmV4cG9ydHMuTWRDYXJkVGl0bGUgPSBNZENhcmRUaXRsZTtcbmV4cG9ydHMuTWRDYXJkU3VidGl0bGUgPSBNZENhcmRTdWJ0aXRsZTtcbmV4cG9ydHMuTWRDYXJkQWN0aW9ucyA9IE1kQ2FyZEFjdGlvbnM7XG5leHBvcnRzLk1kQ2FyZEZvb3RlciA9IE1kQ2FyZEZvb3RlcjtcbmV4cG9ydHMuTWRDYXJkU21JbWFnZSA9IE1kQ2FyZFNtSW1hZ2U7XG5leHBvcnRzLk1kQ2FyZE1kSW1hZ2UgPSBNZENhcmRNZEltYWdlO1xuZXhwb3J0cy5NZENhcmRMZ0ltYWdlID0gTWRDYXJkTGdJbWFnZTtcbmV4cG9ydHMuTWRDYXJkSW1hZ2UgPSBNZENhcmRJbWFnZTtcbmV4cG9ydHMuTWRDYXJkWGxJbWFnZSA9IE1kQ2FyZFhsSW1hZ2U7XG5leHBvcnRzLk1kQ2FyZEF2YXRhciA9IE1kQ2FyZEF2YXRhcjtcbmV4cG9ydHMuTWRDYXJkID0gTWRDYXJkO1xuZXhwb3J0cy5NZENhcmRIZWFkZXIgPSBNZENhcmRIZWFkZXI7XG5leHBvcnRzLk1kQ2FyZFRpdGxlR3JvdXAgPSBNZENhcmRUaXRsZUdyb3VwO1xuZXhwb3J0cy5NZENhcmRNb2R1bGUgPSBNZENhcmRNb2R1bGU7XG5leHBvcnRzLk1kQ2hpcExpc3QgPSBNZENoaXBMaXN0O1xuZXhwb3J0cy5NZENoaXBzTW9kdWxlID0gTWRDaGlwc01vZHVsZTtcbmV4cG9ydHMuTWRDaGlwID0gTWRDaGlwO1xuZXhwb3J0cy5NRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SID0gTURfQ0hFQ0tCT1hfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjtcbmV4cG9ydHMuTWRDaGVja2JveENoYW5nZSA9IE1kQ2hlY2tib3hDaGFuZ2U7XG5leHBvcnRzLk1kQ2hlY2tib3ggPSBNZENoZWNrYm94O1xuZXhwb3J0cy5NZENoZWNrYm94TW9kdWxlID0gTWRDaGVja2JveE1vZHVsZTtcbmV4cG9ydHMuTWREaWFsb2dNb2R1bGUgPSBNZERpYWxvZ01vZHVsZTtcbmV4cG9ydHMuTURfRElBTE9HX0RBVEEgPSBNRF9ESUFMT0dfREFUQTtcbmV4cG9ydHMuTWREaWFsb2cgPSBNZERpYWxvZztcbmV4cG9ydHMuTWREaWFsb2dDb250YWluZXIgPSBNZERpYWxvZ0NvbnRhaW5lcjtcbmV4cG9ydHMuTWREaWFsb2dDbG9zZSA9IE1kRGlhbG9nQ2xvc2U7XG5leHBvcnRzLk1kRGlhbG9nVGl0bGUgPSBNZERpYWxvZ1RpdGxlO1xuZXhwb3J0cy5NZERpYWxvZ0NvbnRlbnQgPSBNZERpYWxvZ0NvbnRlbnQ7XG5leHBvcnRzLk1kRGlhbG9nQWN0aW9ucyA9IE1kRGlhbG9nQWN0aW9ucztcbmV4cG9ydHMuTWREaWFsb2dDb25maWcgPSBNZERpYWxvZ0NvbmZpZztcbmV4cG9ydHMuTWREaWFsb2dSZWYgPSBNZERpYWxvZ1JlZjtcbmV4cG9ydHMuTWRHcmlkTGlzdCA9IE1kR3JpZExpc3Q7XG5leHBvcnRzLk1kR3JpZExpc3RNb2R1bGUgPSBNZEdyaWRMaXN0TW9kdWxlO1xuZXhwb3J0cy5NZEljb25JbnZhbGlkTmFtZUVycm9yID0gTWRJY29uSW52YWxpZE5hbWVFcnJvcjtcbmV4cG9ydHMuTWRJY29uID0gTWRJY29uO1xuZXhwb3J0cy5JQ09OX1JFR0lTVFJZX1BST1ZJREVSX0ZBQ1RPUlkgPSBJQ09OX1JFR0lTVFJZX1BST1ZJREVSX0ZBQ1RPUlk7XG5leHBvcnRzLklDT05fUkVHSVNUUllfUFJPVklERVIgPSBJQ09OX1JFR0lTVFJZX1BST1ZJREVSO1xuZXhwb3J0cy5NZEljb25Nb2R1bGUgPSBNZEljb25Nb2R1bGU7XG5leHBvcnRzLk1kSWNvblJlZ2lzdHJ5ID0gTWRJY29uUmVnaXN0cnk7XG5leHBvcnRzLk1kSW5wdXRNb2R1bGUgPSBNZElucHV0TW9kdWxlO1xuZXhwb3J0cy5NZFRleHRhcmVhQXV0b3NpemUgPSBNZFRleHRhcmVhQXV0b3NpemU7XG5leHBvcnRzLk1kUGxhY2Vob2xkZXIgPSBNZFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5NZEhpbnQgPSBNZEhpbnQ7XG5leHBvcnRzLk1kSW5wdXREaXJlY3RpdmUgPSBNZElucHV0RGlyZWN0aXZlO1xuZXhwb3J0cy5NZElucHV0Q29udGFpbmVyID0gTWRJbnB1dENvbnRhaW5lcjtcbmV4cG9ydHMuTWRJbnB1dENvbnRhaW5lclBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvciA9IE1kSW5wdXRDb250YWluZXJQbGFjZWhvbGRlckNvbmZsaWN0RXJyb3I7XG5leHBvcnRzLk1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvciA9IE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvcjtcbmV4cG9ydHMuTWRJbnB1dENvbnRhaW5lckR1cGxpY2F0ZWRIaW50RXJyb3IgPSBNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvcjtcbmV4cG9ydHMuTWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3IgPSBNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvcjtcbmV4cG9ydHMuTWRMaXN0RGl2aWRlciA9IE1kTGlzdERpdmlkZXI7XG5leHBvcnRzLk1kTGlzdCA9IE1kTGlzdDtcbmV4cG9ydHMuTWRMaXN0Q3NzTWF0U3R5bGVyID0gTWRMaXN0Q3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZE5hdkxpc3RDc3NNYXRTdHlsZXIgPSBNZE5hdkxpc3RDc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kRGl2aWRlckNzc01hdFN0eWxlciA9IE1kRGl2aWRlckNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyID0gTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZExpc3RJY29uQ3NzTWF0U3R5bGVyID0gTWRMaXN0SWNvbkNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyID0gTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZExpc3RJdGVtID0gTWRMaXN0SXRlbTtcbmV4cG9ydHMuTWRMaXN0TW9kdWxlID0gTWRMaXN0TW9kdWxlO1xuZXhwb3J0cy5NZE1lbnVUcmlnZ2VyID0gTWRNZW51VHJpZ2dlcjtcbmV4cG9ydHMuZmFkZUluSXRlbXMgPSBmYWRlSW5JdGVtcztcbmV4cG9ydHMudHJhbnNmb3JtTWVudSA9IHRyYW5zZm9ybU1lbnU7XG5leHBvcnRzLk1kTWVudSA9IE1kTWVudTtcbmV4cG9ydHMuTWRNZW51SXRlbSA9IE1kTWVudUl0ZW07XG5leHBvcnRzLk1kTWVudU1vZHVsZSA9IE1kTWVudU1vZHVsZTtcbmV4cG9ydHMuTWRQcm9ncmVzc0JhciA9IE1kUHJvZ3Jlc3NCYXI7XG5leHBvcnRzLk1kUHJvZ3Jlc3NCYXJNb2R1bGUgPSBNZFByb2dyZXNzQmFyTW9kdWxlO1xuZXhwb3J0cy5NZFByb2dyZXNzQ2lyY2xlID0gTWRQcm9ncmVzc1NwaW5uZXI7XG5leHBvcnRzLk1kUHJvZ3Jlc3NDaXJjbGVNb2R1bGUgPSBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZTtcbmV4cG9ydHMuTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIgPSBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlciA9IE1kUHJvZ3Jlc3NDaXJjbGVDc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kUHJvZ3Jlc3NTcGlubmVyID0gTWRQcm9ncmVzc1NwaW5uZXI7XG5leHBvcnRzLk1kU3Bpbm5lciA9IE1kU3Bpbm5lcjtcbmV4cG9ydHMuTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUgPSBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZTtcbmV4cG9ydHMuTURfUkFESU9fR1JPVVBfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUiA9IE1EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I7XG5leHBvcnRzLk1kUmFkaW9DaGFuZ2UgPSBNZFJhZGlvQ2hhbmdlO1xuZXhwb3J0cy5NZFJhZGlvR3JvdXAgPSBNZFJhZGlvR3JvdXA7XG5leHBvcnRzLk1kUmFkaW9CdXR0b24gPSBNZFJhZGlvQnV0dG9uO1xuZXhwb3J0cy5NZFJhZGlvTW9kdWxlID0gTWRSYWRpb01vZHVsZTtcbmV4cG9ydHMuTWRTZWxlY3RNb2R1bGUgPSBNZFNlbGVjdE1vZHVsZTtcbmV4cG9ydHMuZmFkZUluQ29udGVudCA9IGZhZGVJbkNvbnRlbnQ7XG5leHBvcnRzLnRyYW5zZm9ybVBhbmVsID0gdHJhbnNmb3JtUGFuZWw7XG5leHBvcnRzLnRyYW5zZm9ybVBsYWNlaG9sZGVyID0gdHJhbnNmb3JtUGxhY2Vob2xkZXI7XG5leHBvcnRzLlNFTEVDVF9PUFRJT05fSEVJR0hUID0gU0VMRUNUX09QVElPTl9IRUlHSFQ7XG5leHBvcnRzLlNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUID0gU0VMRUNUX1BBTkVMX01BWF9IRUlHSFQ7XG5leHBvcnRzLlNFTEVDVF9NQVhfT1BUSU9OU19ESVNQTEFZRUQgPSBTRUxFQ1RfTUFYX09QVElPTlNfRElTUExBWUVEO1xuZXhwb3J0cy5TRUxFQ1RfVFJJR0dFUl9IRUlHSFQgPSBTRUxFQ1RfVFJJR0dFUl9IRUlHSFQ7XG5leHBvcnRzLlNFTEVDVF9PUFRJT05fSEVJR0hUX0FESlVTVE1FTlQgPSBTRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UO1xuZXhwb3J0cy5TRUxFQ1RfUEFORUxfUEFERElOR19YID0gU0VMRUNUX1BBTkVMX1BBRERJTkdfWDtcbmV4cG9ydHMuU0VMRUNUX1BBTkVMX1BBRERJTkdfWSA9IFNFTEVDVF9QQU5FTF9QQURESU5HX1k7XG5leHBvcnRzLlNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HID0gU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkc7XG5leHBvcnRzLk1kU2VsZWN0Q2hhbmdlID0gTWRTZWxlY3RDaGFuZ2U7XG5leHBvcnRzLk1kU2VsZWN0ID0gTWRTZWxlY3Q7XG5leHBvcnRzLk1kRHVwbGljYXRlZFNpZGVuYXZFcnJvciA9IE1kRHVwbGljYXRlZFNpZGVuYXZFcnJvcjtcbmV4cG9ydHMuTWRTaWRlbmF2VG9nZ2xlUmVzdWx0ID0gTWRTaWRlbmF2VG9nZ2xlUmVzdWx0O1xuZXhwb3J0cy5NZFNpZGVuYXYgPSBNZFNpZGVuYXY7XG5leHBvcnRzLk1kU2lkZW5hdkNvbnRhaW5lciA9IE1kU2lkZW5hdkNvbnRhaW5lcjtcbmV4cG9ydHMuTWRTaWRlbmF2TW9kdWxlID0gTWRTaWRlbmF2TW9kdWxlO1xuZXhwb3J0cy5NRF9TTElERVJfVkFMVUVfQUNDRVNTT1IgPSBNRF9TTElERVJfVkFMVUVfQUNDRVNTT1I7XG5leHBvcnRzLk1kU2xpZGVyQ2hhbmdlID0gTWRTbGlkZXJDaGFuZ2U7XG5leHBvcnRzLk1kU2xpZGVyID0gTWRTbGlkZXI7XG5leHBvcnRzLlNsaWRlclJlbmRlcmVyID0gU2xpZGVyUmVuZGVyZXI7XG5leHBvcnRzLk1kU2xpZGVyTW9kdWxlID0gTWRTbGlkZXJNb2R1bGU7XG5leHBvcnRzLk1EX1NMSURFX1RPR0dMRV9WQUxVRV9BQ0NFU1NPUiA9IE1EX1NMSURFX1RPR0dMRV9WQUxVRV9BQ0NFU1NPUjtcbmV4cG9ydHMuTWRTbGlkZVRvZ2dsZUNoYW5nZSA9IE1kU2xpZGVUb2dnbGVDaGFuZ2U7XG5leHBvcnRzLk1kU2xpZGVUb2dnbGUgPSBNZFNsaWRlVG9nZ2xlO1xuZXhwb3J0cy5NZFNsaWRlVG9nZ2xlTW9kdWxlID0gTWRTbGlkZVRvZ2dsZU1vZHVsZTtcbmV4cG9ydHMuTWRTbmFja0Jhck1vZHVsZSA9IE1kU25hY2tCYXJNb2R1bGU7XG5leHBvcnRzLk1kU25hY2tCYXIgPSBNZFNuYWNrQmFyO1xuZXhwb3J0cy5TSE9XX0FOSU1BVElPTiA9IFNIT1dfQU5JTUFUSU9OO1xuZXhwb3J0cy5ISURFX0FOSU1BVElPTiA9IEhJREVfQU5JTUFUSU9OO1xuZXhwb3J0cy5NZFNuYWNrQmFyQ29udGFpbmVyID0gTWRTbmFja0JhckNvbnRhaW5lcjtcbmV4cG9ydHMuTWRTbmFja0JhckNvbmZpZyA9IE1kU25hY2tCYXJDb25maWc7XG5leHBvcnRzLk1kU25hY2tCYXJSZWYgPSBNZFNuYWNrQmFyUmVmO1xuZXhwb3J0cy5TaW1wbGVTbmFja0JhciA9IFNpbXBsZVNuYWNrQmFyO1xuZXhwb3J0cy5NZElua0JhciA9IE1kSW5rQmFyO1xuZXhwb3J0cy5NZFRhYkJvZHkgPSBNZFRhYkJvZHk7XG5leHBvcnRzLk1kVGFiSGVhZGVyID0gTWRUYWJIZWFkZXI7XG5leHBvcnRzLk1kVGFiTGFiZWxXcmFwcGVyID0gTWRUYWJMYWJlbFdyYXBwZXI7XG5leHBvcnRzLk1kVGFiID0gTWRUYWI7XG5leHBvcnRzLk1kVGFiTGFiZWwgPSBNZFRhYkxhYmVsO1xuZXhwb3J0cy5NZFRhYkNoYW5nZUV2ZW50ID0gTWRUYWJDaGFuZ2VFdmVudDtcbmV4cG9ydHMuTWRUYWJHcm91cCA9IE1kVGFiR3JvdXA7XG5leHBvcnRzLk1kVGFic01vZHVsZSA9IE1kVGFic01vZHVsZTtcbmV4cG9ydHMuTWRUYWJOYXZCYXIgPSBNZFRhYk5hdkJhcjtcbmV4cG9ydHMuTWRUYWJMaW5rID0gTWRUYWJMaW5rO1xuZXhwb3J0cy5NZFRhYkxpbmtSaXBwbGUgPSBNZFRhYkxpbmtSaXBwbGU7XG5leHBvcnRzLk1kVG9vbGJhclJvdyA9IE1kVG9vbGJhclJvdztcbmV4cG9ydHMuTWRUb29sYmFyID0gTWRUb29sYmFyO1xuZXhwb3J0cy5NZFRvb2xiYXJNb2R1bGUgPSBNZFRvb2xiYXJNb2R1bGU7XG5leHBvcnRzLlRPVUNIRU5EX0hJREVfREVMQVkgPSBUT1VDSEVORF9ISURFX0RFTEFZO1xuZXhwb3J0cy5TQ1JPTExfVEhST1RUTEVfTVMgPSBTQ1JPTExfVEhST1RUTEVfTVM7XG5leHBvcnRzLk1kVG9vbHRpcCA9IE1kVG9vbHRpcDtcbmV4cG9ydHMuVG9vbHRpcENvbXBvbmVudCA9IFRvb2x0aXBDb21wb25lbnQ7XG5leHBvcnRzLk1kVG9vbHRpcE1vZHVsZSA9IE1kVG9vbHRpcE1vZHVsZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9tYXRlcmlhbC9idW5kbGVzL21hdGVyaWFsLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL21hcCcpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInKSwgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdyeGpzL0JlaGF2aW9yU3ViamVjdCcpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwJywgJ3J4anMvYWRkL29wZXJhdG9yL2ZpbHRlcicsICdAYW5ndWxhci9jb3JlJywgJ3J4anMvQmVoYXZpb3JTdWJqZWN0JywgJ0Bhbmd1bGFyL2NvbW1vbiddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmZsZXhMYXlvdXQgPSBnbG9iYWwubmcuZmxleExheW91dCB8fCB7fSksZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwubmcuY29yZSxnbG9iYWwuUngsZ2xvYmFsLm5nLmNvbW1vbikpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMscnhqc19hZGRfb3BlcmF0b3JfbWFwLHJ4anNfYWRkX29wZXJhdG9yX2ZpbHRlcixfYW5ndWxhcl9jb3JlLHJ4anNfQmVoYXZpb3JTdWJqZWN0LF9hbmd1bGFyX2NvbW1vbikgeyAndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBBcHBsaWVzIENTUyBwcmVmaXhlcyB0byBhcHByb3ByaWF0ZSBzdHlsZSBrZXlzLiovXG5mdW5jdGlvbiBhcHBseUNzc1ByZWZpeGVzKHRhcmdldCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdkaXNwbGF5JzpcbiAgICAgICAgICAgICAgICB0YXJnZXRbJ2Rpc3BsYXknXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGFsc28gbmVlZCAnZGlzcGxheSA6IC13ZWJraXQtYm94JyBhbmQgJ2Rpc3BsYXkgOiAtbXMtZmxleGJveDsnXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmbGV4JzpcbiAgICAgICAgICAgICAgICB0YXJnZXRbJy1tcy1mbGV4J10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbJy13ZWJraXQtYm94LWZsZXgnXSA9IHZhbHVlLnNwbGl0KFwiIFwiKVswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZsZXgtZGlyZWN0aW9uJzpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IFwicm93XCI7XG4gICAgICAgICAgICAgICAgdGFyZ2V0WydmbGV4LWRpcmVjdGlvbiddID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGFyZ2V0WyctbXMtZmxleC1kaXJlY3Rpb24nXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRhcmdldFsnLXdlYmtpdC1ib3gtb3JpZW50J10gPSB0b0JveE9yaWVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Wyctd2Via2l0LWJveC1kaXJlY3Rpb24nXSA9IHRvQm94RGlyZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZsZXgtd3JhcCc6XG4gICAgICAgICAgICAgICAgdGFyZ2V0WyctbXMtZmxleC13cmFwJ10gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29yZGVyJzpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFsnb3JkZXInXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRhcmdldFsnLW1zLWZsZXgtb3JkZXInXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRhcmdldFsnLXdlYmtpdC1ib3gtb3JkaW5hbC1ncm91cCddID0gdG9Cb3hPcmRpbmFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2p1c3RpZnktY29udGVudCc6XG4gICAgICAgICAgICAgICAgdGFyZ2V0WyctbXMtZmxleC1wYWNrJ10gPSB0b0JveFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbJy13ZWJraXQtYm94LXBhY2snXSA9IHRvQm94VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxpZ24taXRlbXMnOlxuICAgICAgICAgICAgICAgIHRhcmdldFsnLW1zLWZsZXgtYWxpZ24nXSA9IHRvQm94VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRhcmdldFsnLXdlYmtpdC1ib3gtYWxpZ24nXSA9IHRvQm94VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxpZ24tc2VsZic6XG4gICAgICAgICAgICAgICAgdGFyZ2V0WyctbXMtZmxleC1pdGVtLWFsaWduJ10gPSB0b0JveFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FsaWduLWNvbnRlbnQnOlxuICAgICAgICAgICAgICAgIHRhcmdldFsnLW1zLWFsaWduLWNvbnRlbnQnXSA9IHRvQWxpZ25Db250ZW50VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRhcmdldFsnLW1zLWZsZXgtbGluZS1wYWNrJ10gPSB0b0FsaWduQ29udGVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gdG9BbGlnbkNvbnRlbnRWYWx1ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInNwYWNlLWJldHdlZW5cIjpcbiAgICAgICAgICAgIHJldHVybiBcImp1c3RpZnlcIjtcbiAgICAgICAgY2FzZSBcInNwYWNlLWFyb3VuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZGlzdHJpYnV0ZVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRvQm94VmFsdWUodmFsdWUpO1xuICAgIH1cbn1cbi8qKiBDb252ZXJ0IGZsZXggdmFsdWVzIGZsZXgtc3RhcnQsIGZsZXgtZW5kIHRvIHN0YXJ0LCBlbmQuICovXG5mdW5jdGlvbiB0b0JveFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBcIlwiOyB9XG4gICAgcmV0dXJuICh2YWx1ZSA9PSAnZmxleC1zdGFydCcpID8gJ3N0YXJ0JyA6ICgodmFsdWUgPT0gJ2ZsZXgtZW5kJykgPyAnZW5kJyA6IHZhbHVlKTtcbn1cbi8qKiBDb252ZXJ0IGZsZXggRGlyZWN0aW9uIHRvIEJveCBvcmllbnRhdGlvbiAqL1xuZnVuY3Rpb24gdG9Cb3hPcmllbnQoZmxleERpcmVjdGlvbikge1xuICAgIGlmIChmbGV4RGlyZWN0aW9uID09PSB2b2lkIDApIHsgZmxleERpcmVjdGlvbiA9ICdyb3cnOyB9XG4gICAgcmV0dXJuIGZsZXhEaXJlY3Rpb24uaW5kZXhPZignY29sdW1uJykgPT09IC0xID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbn1cbi8qKiBDb252ZXJ0IGZsZXggRGlyZWN0aW9uIHRvIEJveCBkaXJlY3Rpb24gdHlwZSAqL1xuZnVuY3Rpb24gdG9Cb3hEaXJlY3Rpb24oZmxleERpcmVjdGlvbikge1xuICAgIGlmIChmbGV4RGlyZWN0aW9uID09PSB2b2lkIDApIHsgZmxleERpcmVjdGlvbiA9ICdyb3cnOyB9XG4gICAgcmV0dXJuIGZsZXhEaXJlY3Rpb24uaW5kZXhPZigncmV2ZXJzZScpICE9PSAtMSA/ICdyZXZlcnNlJyA6ICdub3JtYWwnO1xufVxuLyoqIENvbnZlcnQgZmxleCBvcmRlciB0byBCb3ggb3JkaW5hbCBncm91cCAqL1xuZnVuY3Rpb24gdG9Cb3hPcmRpbmFsKG9yZGVyKSB7XG4gICAgaWYgKG9yZGVyID09PSB2b2lkIDApIHsgb3JkZXIgPSAnMCc7IH1cbiAgICB2YXIgdmFsdWUgPSBvcmRlciA/IHBhcnNlSW50KG9yZGVyKSArIDEgOiAxO1xuICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBcIjBcIiA6IHZhbHVlLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRXh0ZW5kcyBhbiBvYmplY3Qgd2l0aCB0aGUgKmVudW1lcmFibGUqIGFuZCAqb3duKiBwcm9wZXJ0aWVzIG9mIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzLFxuICogc2ltaWxhciB0byBPYmplY3QuYXNzaWduLlxuICpcbiAqIEBwYXJhbSBkZXN0IFRoZSBvYmplY3Qgd2hpY2ggd2lsbCBoYXZlIHByb3BlcnRpZXMgY29waWVkIHRvIGl0LlxuICogQHBhcmFtIHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzIGZyb20gd2hpY2ggcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kT2JqZWN0KGRlc3QpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChkZXN0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCBzb3VyY2VzXzEgPSBzb3VyY2VzOyBfYSA8IHNvdXJjZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNfMVtfYV07XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbnZhciBLZXlPcHRpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLZXlPcHRpb25zKGJhc2VLZXksIGRlZmF1bHRWYWx1ZSwgaW5wdXRLZXlzKSB7XG4gICAgICAgIHRoaXMuYmFzZUtleSA9IGJhc2VLZXk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzLmlucHV0S2V5cyA9IGlucHV0S2V5cztcbiAgICB9XG4gICAgcmV0dXJuIEtleU9wdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBSZXNwb25zaXZlQWN0aXZhdGlvbiBhY3RzIGFzIGEgcHJveHkgYmV0d2VlbiB0aGUgTW9uaXRvck1lZGlhIHNlcnZpY2UgKHdoaWNoIGVtaXRzIG1lZGlhUXVlcnlcbiAqIGNoYW5nZXMpIGFuZCB0aGUgZnggQVBJIGRpcmVjdGl2ZXMuIFRoZSBNUUEgcHJveGllcyBtZWRpYVF1ZXJ5IGNoYW5nZSBldmVudHMgYW5kIG5vdGlmaWVzIHRoZVxuICogZGlyZWN0aXZlIHZpYSB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrLlxuICpcbiAqIC0gVGhlIE1RQSBhbHNvIGRldGVybWluZXMgd2hpY2ggZGlyZWN0aXZlIHByb3BlcnR5IHNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAqICAgY3VycmVudCBjaGFuZ2UgJ3ZhbHVlJy4uLiBCRUZPUkUgdGhlIG9yaWdpbmFsIGBvbk1lZGlhUXVlcnlDaGFuZ2VzKClgIG1ldGhvZCBpcyBjYWxsZWQuXG4gKiAtIFRoZSBgbmdPbkRlc3Ryb3koKWAgbWV0aG9kIGlzIGFsc28gaGVhZC1ob29rZWQgdG8gZW5hYmxlIGF1dG8tdW5zdWJzY3JpYmUgZnJvbSB0aGVcbiAqICAgTWVkaWFRdWVyeVNlcnZpY2VzLlxuICpcbiAqIE5PVEU6IHRoZXNlIGludGVyY2VwdGlvbnMgZW5hYmxlcyB0aGUgbG9naWMgaW4gdGhlIGZ4IEFQSSBkaXJlY3RpdmVzIHRvIHJlbWFpbiB0ZXJzZSBhbmQgY2xlYW4uXG4gKi9cbnZhciBSZXNwb25zaXZlQWN0aXZhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXNwb25zaXZlQWN0aXZhdGlvbihfb3B0aW9ucywgX21lZGlhTW9uaXRvciwgX29uTWVkaWFDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICAgICAgdGhpcy5fbWVkaWFNb25pdG9yID0gX21lZGlhTW9uaXRvcjtcbiAgICAgICAgdGhpcy5fb25NZWRpYUNoYW5nZXMgPSBfb25NZWRpYUNoYW5nZXM7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gdGhpcy5fY29uZmlndXJlQ2hhbmdlT2JzZXJ2ZXJzKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlQWN0aXZhdGlvbi5wcm90b3R5cGUsIFwibWVkaWFNb25pdG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjY2Vzc29yIHRvIHRoZSBESSdlZCBkaXJlY3RpdmUgcHJvcGVydHlcbiAgICAgICAgICogRWFjaCBkaXJlY3RpdmUgaW5zdGFuY2UgaGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBNZWRpYU1vbml0b3Igd2hpY2ggaXNcbiAgICAgICAgICogdXNlZCBIRVJFIHRvIHN1YnNjcmliZSB0byBtZWRpYVF1ZXJ5IGNoYW5nZSBub3RpZmljYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFNb25pdG9yO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzcG9uc2l2ZUFjdGl2YXRpb24ucHJvdG90eXBlLCBcImFjdGl2YXRlZElucHV0S2V5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSB3aGljaCBkaXJlY3RpdmUgQElucHV0KCkgcHJvcGVydHkgaXMgY3VycmVudGx5IGFjdGl2ZSAoZm9yIHRoZSB2aWV3cG9ydCBzaXplKTpcbiAgICAgICAgICogVGhlIGtleSBtdXN0IGJlIGRlZmluZWQgKGluIHVzZSkgb3IgZmFsbGJhY2sgdG8gdGhlICdjbG9zZXN0JyBvdmVybGFwcGluZyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICogdGhhdCBpcyBkZWZpbmVkOyBvdGhlcndpc2UgdGhlIGRlZmF1bHQgcHJvcGVydHkga2V5IHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICogZS5nLlxuICAgICAgICAgKiAgICAgIGlmIGA8ZGl2IGZ4SGlkZSBmeEhpZGUuZ3Qtc209XCJmYWxzZVwiPmAgaXMgdXNlZCBidXQgdGhlIGN1cnJlbnQgYWN0aXZhdGVkIG1lZGlhUXVlcnkgYWxpYXNcbiAgICAgICAgICogICAgICBrZXkgaXMgYC5tZGAgdGhlbiBgLmd0LXNtYCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmF0ZWRJbnB1dEtleSB8fCB0aGlzLl9vcHRpb25zLmJhc2VLZXk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlQWN0aXZhdGlvbi5wcm90b3R5cGUsIFwiYWN0aXZhdGVkSW5wdXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZhdGVkIEBJbnB1dCB2YWx1ZSBvciB0aGUgZmFsbGJhY2sgZGVmYXVsdCBASW5wdXQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuYWN0aXZhdGVkSW5wdXRLZXk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNLZXlWYWx1ZShrZXkpID8gdGhpcy5fbG9va3VwS2V5VmFsdWUoa2V5KSA6IHRoaXMuX29wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGYXN0IHZhbGlkYXRvciBmb3IgcHJlc2VuY2Ugb2YgYXR0cmlidXRlIG9uIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgKi9cbiAgICBSZXNwb25zaXZlQWN0aXZhdGlvbi5wcm90b3R5cGUuaGFzS2V5VmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29wdGlvbnMuaW5wdXRLZXlzW2tleV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGludGVyY2VwdG9ycywgcmVzdG9yZSBvcmlnaW5hbCBmdW5jdGlvbnMsIGFuZCBmb3J3YXJkIHRoZSBvbkRlc3Ryb3koKSBjYWxsXG4gICAgICovXG4gICAgUmVzcG9uc2l2ZUFjdGl2YXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3IgZWFjaCAqZGVmaW5lZCogQVBJIHByb3BlcnR5LCByZWdpc3RlciBhIGNhbGxiYWNrIHRvIGBfb25Nb25pdG9yRXZlbnRzKCApYFxuICAgICAqIENhY2hlIDEuLm4gc3Vic2NyaXB0aW9ucyBmb3IgaW50ZXJuYWwgYXV0by11bnN1YnNjcmliZXMgd2hlbiB0aGUgdGhlIGRpcmVjdGl2ZSBkZXN0cnVjdHNcbiAgICAgKi9cbiAgICBSZXNwb25zaXZlQWN0aXZhdGlvbi5wcm90b3R5cGUuX2NvbmZpZ3VyZUNoYW5nZU9ic2VydmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fYnVpbGRSZWdpc3RyeU1hcCgpLmZvckVhY2goZnVuY3Rpb24gKGJwKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2tleUluVXNlKGJwLmtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbmplY3QgZGlyZWN0aXZlIGRlZmF1bHQgcHJvcGVydHkga2V5IG5hbWU6IHRvIGxldCBvbk1lZGlhQ2hhbmdlKCkgY2FsbHNcbiAgICAgICAgICAgICAgICAvLyBrbm93IHdoaWNoIHByb3BlcnR5IGlzIGJlaW5nIHRyaWdnZXJlZC4uLlxuICAgICAgICAgICAgICAgIHZhciBidWlsZENoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcm9wZXJ0eSA9IF90aGlzLl9vcHRpb25zLmJhc2VLZXk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goX3RoaXMubWVkaWFNb25pdG9yLm9ic2VydmUoYnAuYWxpYXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYnVpbGRDaGFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uTW9uaXRvckV2ZW50cyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVpbGQgbWVkaWFRdWVyeSBrZXktaGFzaG1hcDsgb25seSBmb3IgdGhlIGRpcmVjdGl2ZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGFjdHVhbGx5IGRlZmluZWQvdXNlZFxuICAgICAqIGluIHRoZSBIVE1MIG1hcmt1cFxuICAgICAqL1xuICAgIFJlc3BvbnNpdmVBY3RpdmF0aW9uLnByb3RvdHlwZS5fYnVpbGRSZWdpc3RyeU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFNb25pdG9yLmJyZWFrcG9pbnRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChicCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZE9iamVjdCh7fSwgYnAsIHtcbiAgICAgICAgICAgICAgICBiYXNlS2V5OiBfdGhpcy5fb3B0aW9ucy5iYXNlS2V5LFxuICAgICAgICAgICAgICAgIGtleTogX3RoaXMuX29wdGlvbnMuYmFzZUtleSArIGJwLnN1ZmZpeCAvLyBlLmcuICBsYXlvdXRHdFNtLCBsYXlvdXRNZCwgbGF5b3V0R3RMZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChicCkgeyByZXR1cm4gX3RoaXMuX2tleUluVXNlKGJwLmtleSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3luY2hyb25pemVzIGNoYW5nZSBub3RpZmljYXRpb25zIHdpdGggdGhlIGN1cnJlbnQgbXEtYWN0aXZhdGVkIEBJbnB1dCBhbmQgY2FsY3VsYXRlcyB0aGVcbiAgICAgKiBtcS1hY3RpdmF0ZWQgaW5wdXQgdmFsdWUgb3IgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgKi9cbiAgICBSZXNwb25zaXZlQWN0aXZhdGlvbi5wcm90b3R5cGUuX29uTW9uaXRvckV2ZW50cyA9IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5wcm9wZXJ0eSA9PSB0aGlzLl9vcHRpb25zLmJhc2VLZXkpIHtcbiAgICAgICAgICAgIGNoYW5nZS52YWx1ZSA9IHRoaXMuX2NhbGN1bGF0ZUFjdGl2YXRlZFZhbHVlKGNoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLl9vbk1lZGlhQ2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYXMgdGhlIGtleSBiZWVuIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBtYXJrdXAgYW5kIHRodXMgaXMgaW50ZW5kZWRcbiAgICAgKiB0byBwYXJ0aWNpcGF0ZSBpbiBhY3RpdmF0aW9uIHByb2Nlc3Nlcy5cbiAgICAgKi9cbiAgICBSZXNwb25zaXZlQWN0aXZhdGlvbi5wcm90b3R5cGUuX2tleUluVXNlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9va3VwS2V5VmFsdWUoa2V5KSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogIE1hcCBpbnB1dCBrZXkgYXNzb2NpYXRlZCB3aXRoIG1lZGlhUXVlcnkgYWN0aXZhdGlvbiB0byBjbG9zZXN0IGRlZmluZWQgaW5wdXQga2V5XG4gICAgICogIHRoZW4gcmV0dXJuIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0YXJnZXRlZCBpbnB1dCBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogICEhIGNoYW5nZSBldmVudHMgbWF5IGFycml2ZSBvdXQtb2Ytb3JkZXIgKGFjdGl2YXRlIGJlZm9yZSBkZWFjdGl2YXRlKVxuICAgICAqICAgICBzbyBtYWtlIHN1cmUgdGhlIGRlYWN0aXZhdGUgaXMgdXNlZCBPTkxZIHdoZW4gdGhlIGtleXMgbWF0Y2hcbiAgICAgKiAgICAgKHNpbmNlIGEgZGlmZmVyZW50IGFjdGl2YXRlIG1heSBiZSBpbiB1c2UpXG4gICAgICovXG4gICAgUmVzcG9uc2l2ZUFjdGl2YXRpb24ucHJvdG90eXBlLl9jYWxjdWxhdGVBY3RpdmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0gdGhpcy5fb3B0aW9ucy5iYXNlS2V5ICsgY3VycmVudC5zdWZmaXg7IC8vIGUuZy4gc3VmZml4ID09ICdHdFNtJyxcbiAgICAgICAgdmFyIG5ld0tleSA9IHRoaXMuX2FjdGl2YXRlZElucHV0S2V5OyAvLyBlLmcuIG5ld0tleSA9PSBoaWRlR3RTbVxuICAgICAgICBuZXdLZXkgPSBjdXJyZW50Lm1hdGNoZXMgPyBjdXJyZW50S2V5IDogKChuZXdLZXkgPT0gY3VycmVudEtleSkgPyBudWxsIDogbmV3S2V5KTtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGVkSW5wdXRLZXkgPSB0aGlzLl92YWxpZGF0ZUlucHV0S2V5KG5ld0tleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlZElucHV0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBzcGVjaWZpZWQgaW5wdXQgcHJvcGVydHkga2V5LCB2YWxpZGF0ZSBpdCBpcyBkZWZpbmVkICh1c2VkIGluIHRoZSBtYXJrdXApXG4gICAgICogSWYgbm90IHNlZSBpZiBhIG92ZXJsYXBwaW5nIG1lZGlhUXVlcnktcmVsYXRlZCBpbnB1dCBrZXkgZmFsbGJhY2sgaGFzIGJlZW4gZGVmaW5lZFxuICAgICAqXG4gICAgICogTk9URTogc2NhbnMgaW4gdGhlIG9yZGVyIGRlZmluZWQgYnkgYWN0aXZlT3ZlckxhcHMgKGxhcmdlc3Qgdmlld3BvcnQgcmFuZ2VzIC0+IHNtYWxsZXN0IHJhbmdlcylcbiAgICAgKi9cbiAgICBSZXNwb25zaXZlQWN0aXZhdGlvbi5wcm90b3R5cGUuX3ZhbGlkYXRlSW5wdXRLZXkgPSBmdW5jdGlvbiAoaW5wdXRLZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5tZWRpYU1vbml0b3IuYWN0aXZlT3ZlcmxhcHM7XG4gICAgICAgIHZhciBpc01pc3NpbmdLZXkgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhX3RoaXMuX2tleUluVXNlKGtleSk7IH07XG4gICAgICAgIGlmIChpc01pc3NpbmdLZXkoaW5wdXRLZXkpKSB7XG4gICAgICAgICAgICBpdGVtcy5zb21lKGZ1bmN0aW9uIChicCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfdGhpcy5fb3B0aW9ucy5iYXNlS2V5ICsgYnAuc3VmZml4O1xuICAgICAgICAgICAgICAgIGlmICghaXNNaXNzaW5nS2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBleGl0IC5zb21lKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0S2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSAoaWYgYW55KSBmb3IgdGhlIGRpcmVjdGl2ZSBpbnN0YW5jZXMgQElucHV0IHByb3BlcnR5IChha2Ega2V5KVxuICAgICAqL1xuICAgIFJlc3BvbnNpdmVBY3RpdmF0aW9uLnByb3RvdHlwZS5fbG9va3VwS2V5VmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmlucHV0S2V5c1trZXldO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3BvbnNpdmVBY3RpdmF0aW9uO1xufSgpKTtcblxuLyoqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRoZSBMYXlvdXQgQVBJIHN0eWxpbmcgZGlyZWN0aXZlcy4gKi9cbnZhciBCYXNlRnhEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gQmFzZUZ4RGlyZWN0aXZlKF9tZWRpYU1vbml0b3IsIF9lbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFNb25pdG9yID0gX21lZGlhTW9uaXRvcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBEaWN0aW9uYXJ5IG9mIGlucHV0IGtleXMgd2l0aCBhc3NvY2lhdGVkIHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5wdXRNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5fZGlzcGxheSA9IHRoaXMuX2dldERpc3BsYXlTdHlsZSgpO1xuICAgIH1cbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBBY2Nlc3NvciBNZXRob2RzXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRoZSBjdXJyZW50IHZhbHVlIChpZiBhbnkpIG9mIHRoZSBASW5wdXQgcHJvcGVydHkuXG4gICAgICovXG4gICAgQmFzZUZ4RGlyZWN0aXZlLnByb3RvdHlwZS5fcXVlcnlJbnB1dCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0TWFwW2tleV07XG4gICAgfTtcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBMaWZlY3ljbGUgTWV0aG9kc1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIEJhc2VGeERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX21xQWN0aXZhdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVkaWFNb25pdG9yID0gbnVsbDtcbiAgICB9O1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vIFByb3RlY3RlZCBNZXRob2RzXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLyoqXG4gICAgICogV2FzIHRoZSBkaXJlY3RpdmUncyBkZWZhdWx0IHNlbGVjdG9yIHVzZWQgP1xuICAgICAqIElmIG5vdCwgdXNlIHRoZSBmYWxsYmFjayB2YWx1ZSFcbiAgICAgKi9cbiAgICBCYXNlRnhEaXJlY3RpdmUucHJvdG90eXBlLl9nZXREZWZhdWx0VmFsID0gZnVuY3Rpb24gKGtleSwgZmFsbGJhY2tWYWwpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuX3F1ZXJ5SW5wdXQoa2V5KTtcbiAgICAgICAgdmFyIGhhc0RlZmF1bHRWYWwgPSAodmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsKTtcbiAgICAgICAgcmV0dXJuIChoYXNEZWZhdWx0VmFsICYmIHZhbCAhPT0gJycpID8gdmFsIDogZmFsbGJhY2tWYWw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBRdWljayBhY2Nlc3NvciB0byB0aGUgY3VycmVudCBIVE1MRWxlbWVudCdzIGBkaXNwbGF5YCBzdHlsZVxuICAgICAqIE5vdGU6IHRoaXMgYWxsb3dzIHVzZSB0byBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc3R5bGVcbiAgICAgKiBhbmQgb3B0aW9uYWwgcmVzdG9yZSBpdCB3aGVuIHRoZSBtZWRpYVF1ZXJpZXMgZGVhY3RpdmF0ZVxuICAgICAqL1xuICAgIEJhc2VGeERpcmVjdGl2ZS5wcm90b3R5cGUuX2dldERpc3BsYXlTdHlsZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzb3VyY2UgfHwgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LnN0eWxlWydkaXNwbGF5J10gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVsnZGlzcGxheSddO1xuICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBzdHlsZXMgZ2l2ZW4gdmlhIHN0cmluZyBwYWlyIG9yIG9iamVjdCBtYXAgdG8gdGhlIGRpcmVjdGl2ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIEJhc2VGeERpcmVjdGl2ZS5wcm90b3R5cGUuX2FwcGx5U3R5bGVUb0VsZW1lbnQgPSBmdW5jdGlvbiAoc3R5bGUsIHZhbHVlLCBuYXRpdmVFbGVtZW50KSB7XG4gICAgICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBuYXRpdmVFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0eWxlc1tzdHlsZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHN0eWxlID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlcyA9IGFwcGx5Q3NzUHJlZml4ZXMoc3R5bGUpO1xuICAgICAgICAvLyBJdGVyYXRlIGFsbCBwcm9wZXJ0aWVzIGluIGhhc2hNYXAgYW5kIHNldCBzdHlsZXNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIGtleSwgc3R5bGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHN0eWxlcyBnaXZlbiB2aWEgc3RyaW5nIHBhaXIgb3Igb2JqZWN0IG1hcCB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQuXG4gICAgICovXG4gICAgQmFzZUZ4RGlyZWN0aXZlLnByb3RvdHlwZS5fYXBwbHlTdHlsZVRvRWxlbWVudHMgPSBmdW5jdGlvbiAoc3R5bGUsIGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdHlsZXMgPSBhcHBseUNzc1ByZWZpeGVzKHN0eWxlKTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgYWxsIHByb3BlcnRpZXMgaW4gaGFzaE1hcCBhbmQgc2V0IHN0eWxlc1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUoZWwsIGtleSwgc3R5bGVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBTYXZlIHRoZSBwcm9wZXJ0eSB2YWx1ZTsgd2hpY2ggbWF5IGJlIGEgY29tcGxleCBvYmplY3QuXG4gICAgICogIENvbXBsZXggb2JqZWN0cyBzdXBwb3J0IHByb3BlcnR5IGNoYWluc1xuICAgICAqL1xuICAgIEJhc2VGeERpcmVjdGl2ZS5wcm90b3R5cGUuX2NhY2hlSW5wdXQgPSBmdW5jdGlvbiAoa2V5LCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0TWFwW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5wdXRNYXBba2V5XSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogIEJ1aWxkIGEgUmVzcG9uc2l2ZUFjdGl2YXRpb24gb2JqZWN0IHVzZWQgdG8gbWFuYWdlIHN1YnNjcmlwdGlvbnMgdG8gbWVkaWFDaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICAgICAqICBhbmQgaW50ZWxsaWdlbnQgbG9va3VwIG9mIHRoZSBkaXJlY3RpdmUncyBwcm9wZXJ0eSB2YWx1ZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoYXQgbWVkaWFRdWVyeVxuICAgICAqICAob3IgY2xvc2VzdCBtYXRjaCkuXG4gICAgICovXG4gICAgQmFzZUZ4RGlyZWN0aXZlLnByb3RvdHlwZS5fbGlzdGVuRm9yTWVkaWFRdWVyeUNoYW5nZXMgPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUsIG9uTWVkaWFRdWVyeUNoYW5nZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIga2V5T3B0aW9ucyA9IG5ldyBLZXlPcHRpb25zKGtleSwgZGVmYXVsdFZhbHVlLCB0aGlzLl9pbnB1dE1hcCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tcUFjdGl2YXRpb24gPSBuZXcgUmVzcG9uc2l2ZUFjdGl2YXRpb24oa2V5T3B0aW9ucywgdGhpcy5fbWVkaWFNb25pdG9yLCBmdW5jdGlvbiAoY2hhbmdlKSB7IHJldHVybiBvbk1lZGlhUXVlcnlDaGFuZ2UuY2FsbChfdGhpcywgY2hhbmdlKTsgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUZ4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjaGlsZHJlbk5vZGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpYWwgYWNjZXNzb3IgdG8gcXVlcnkgZm9yIGFsbCBjaGlsZCAnZWxlbWVudCcgbm9kZXMgcmVnYXJkbGVzcyBvZiB0eXBlLCBjbGFzcywgZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGJhY2t3YXJkcyBlbnN1cmluZyB0aGF0IGxlbmd0aCBpcyBhbiBVSW50MzJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRmFzdCB2YWxpZGF0b3IgZm9yIHByZXNlbmNlIG9mIGF0dHJpYnV0ZSBvbiB0aGUgaG9zdCBlbGVtZW50XG4gICAgICovXG4gICAgQmFzZUZ4RGlyZWN0aXZlLnByb3RvdHlwZS5oYXNLZXlWYWx1ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21xQWN0aXZhdGlvbi5oYXNLZXlWYWx1ZShrZXkpO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VGeERpcmVjdGl2ZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBZGFwdGVyIHRvIHRoZSBCYXNlRnhEaXJlY3RpdmUgYWJzdHJhY3QgY2xhc3Mgc28gaXQgY2FuIGJlIHVzZWQgdmlhIGNvbXBvc2l0aW9uLlxuICogQHNlZSBCYXNlRnhEaXJlY3RpdmVcbiAqL1xudmFyIEJhc2VGeERpcmVjdGl2ZUFkYXB0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlRnhEaXJlY3RpdmVBZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VGeERpcmVjdGl2ZUFkYXB0ZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUZ4RGlyZWN0aXZlQWRhcHRlci5wcm90b3R5cGUsIFwiaW5wdXRNYXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dE1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VGeERpcmVjdGl2ZUFkYXB0ZXIucHJvdG90eXBlLCBcIm1xQWN0aXZhdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIEJhc2VGeERpcmVjdGl2ZS5fbXFBY3RpdmF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tcUFjdGl2YXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBzZWUgQmFzZUZ4RGlyZWN0aXZlLl9xdWVyeUlucHV0XG4gICAgICovXG4gICAgQmFzZUZ4RGlyZWN0aXZlQWRhcHRlci5wcm90b3R5cGUucXVlcnlJbnB1dCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5SW5wdXQoa2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBTYXZlIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBCYXNlRnhEaXJlY3RpdmVBZGFwdGVyLnByb3RvdHlwZS5jYWNoZUlucHV0ID0gZnVuY3Rpb24gKGtleSwgc291cmNlLCBjYWNoZVJhdykge1xuICAgICAgICBpZiAoY2FjaGVSYXcgPT09IHZvaWQgMCkgeyBjYWNoZVJhdyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChjYWNoZVJhdykge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dFJhdyhrZXksIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0QXJyYXkoa2V5LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0T2JqZWN0KGtleSwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dFN0cmluZyhrZXksIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2xhc3MgdmFsdWUgcHJvdmlkZWQuIERpZCB5b3Ugd2FudCB0byBjYWNoZSB0aGUgcmF3IHZhbHVlPycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAc2VlIEJhc2VGeERpcmVjdGl2ZS5fbGlzdGVuRm9yTWVkaWFRdWVyeUNoYW5nZXNcbiAgICAgKi9cbiAgICBCYXNlRnhEaXJlY3RpdmVBZGFwdGVyLnByb3RvdHlwZS5saXN0ZW5Gb3JNZWRpYVF1ZXJ5Q2hhbmdlcyA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSwgb25NZWRpYVF1ZXJ5Q2hhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5Gb3JNZWRpYVF1ZXJ5Q2hhbmdlcyhrZXksIGRlZmF1bHRWYWx1ZSwgb25NZWRpYVF1ZXJ5Q2hhbmdlKTtcbiAgICB9O1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vIFByb3RlY3RlZCBNZXRob2RzXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLyoqXG4gICAgICogTm8gaW1wbGljaXQgdHJhbnNmb3JtcyBvZiB0aGUgc291cmNlLlxuICAgICAqIFJlcXVpcmVkIHdoZW4gY2FjaGluZyB2YWx1ZXMgZXhwZWN0ZWQgbGF0ZXIgZm9yIEtleVZhbHVlRGlmZmVyc1xuICAgICAqL1xuICAgIEJhc2VGeERpcmVjdGl2ZUFkYXB0ZXIucHJvdG90eXBlLl9jYWNoZUlucHV0UmF3ID0gZnVuY3Rpb24gKGtleSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuX2lucHV0TWFwW2tleV0gPSBzb3VyY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAgU2F2ZSB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIEFycmF5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBCYXNlRnhEaXJlY3RpdmVBZGFwdGVyLnByb3RvdHlwZS5fY2FjaGVJbnB1dEFycmF5ID0gZnVuY3Rpb24gKGtleSwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuX2lucHV0TWFwW2tleV0gPSBzb3VyY2Uuam9pbignICcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogIFNhdmUgdGhlIHByb3BlcnR5IHZhbHVlIGZvciBrZXkvdmFsdWUgcGFpciB2YWx1ZXMuXG4gICAgICovXG4gICAgQmFzZUZ4RGlyZWN0aXZlQWRhcHRlci5wcm90b3R5cGUuX2NhY2hlSW5wdXRPYmplY3QgPSBmdW5jdGlvbiAoa2V5LCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghIXNvdXJjZVtwcm9wXSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnB1dE1hcFtrZXldID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAgU2F2ZSB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIHN0cmluZyB2YWx1ZXMuXG4gICAgICovXG4gICAgQmFzZUZ4RGlyZWN0aXZlQWRhcHRlci5wcm90b3R5cGUuX2NhY2hlSW5wdXRTdHJpbmcgPSBmdW5jdGlvbiAoa2V5LCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5faW5wdXRNYXBba2V5XSA9IHNvdXJjZTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlRnhEaXJlY3RpdmVBZGFwdGVyO1xufShCYXNlRnhEaXJlY3RpdmUpKTtcblxudmFyIFJFU1BPTlNJVkVfQUxJQVNFUyA9IFtcbiAgICAneHMnLCAnZ3QteHMnLCAnc20nLCAnZ3Qtc20nLCAnbWQnLCAnZ3QtbWQnLCAnbGcnLCAnZ3QtbGcnLCAneGwnXG5dO1xudmFyIFJBV19ERUZBVUxUUyA9IFtcbiAgICB7XG4gICAgICAgIGFsaWFzOiAneHMnLFxuICAgICAgICBzdWZmaXg6ICdYcycsXG4gICAgICAgIG92ZXJsYXBwaW5nOiBmYWxzZSxcbiAgICAgICAgbWVkaWFRdWVyeTogJ3NjcmVlbiBhbmQgKG1heC13aWR0aDogNTk5cHgpJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBhbGlhczogJ2d0LXhzJyxcbiAgICAgICAgc3VmZml4OiAnR3RYcycsXG4gICAgICAgIG92ZXJsYXBwaW5nOiB0cnVlLFxuICAgICAgICBtZWRpYVF1ZXJ5OiAnc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2MDBweCknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFsaWFzOiAnc20nLFxuICAgICAgICBzdWZmaXg6ICdTbScsXG4gICAgICAgIG92ZXJsYXBwaW5nOiBmYWxzZSxcbiAgICAgICAgbWVkaWFRdWVyeTogJ3NjcmVlbiBhbmQgKG1pbi13aWR0aDogNjAwcHgpIGFuZCAobWF4LXdpZHRoOiA5NTlweCknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFsaWFzOiAnZ3Qtc20nLFxuICAgICAgICBzdWZmaXg6ICdHdFNtJyxcbiAgICAgICAgb3ZlcmxhcHBpbmc6IHRydWUsXG4gICAgICAgIG1lZGlhUXVlcnk6ICdzY3JlZW4gYW5kIChtaW4td2lkdGg6IDk2MHB4KSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYWxpYXM6ICdtZCcsXG4gICAgICAgIHN1ZmZpeDogJ01kJyxcbiAgICAgICAgb3ZlcmxhcHBpbmc6IGZhbHNlLFxuICAgICAgICBtZWRpYVF1ZXJ5OiAnc2NyZWVuIGFuZCAobWluLXdpZHRoOiA5NjBweCkgYW5kIChtYXgtd2lkdGg6IDEyNzlweCknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFsaWFzOiAnZ3QtbWQnLFxuICAgICAgICBzdWZmaXg6ICdHdE1kJyxcbiAgICAgICAgb3ZlcmxhcHBpbmc6IHRydWUsXG4gICAgICAgIG1lZGlhUXVlcnk6ICdzY3JlZW4gYW5kIChtaW4td2lkdGg6IDEyODBweCknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFsaWFzOiAnbGcnLFxuICAgICAgICBzdWZmaXg6ICdMZycsXG4gICAgICAgIG92ZXJsYXBwaW5nOiBmYWxzZSxcbiAgICAgICAgbWVkaWFRdWVyeTogJ3NjcmVlbiBhbmQgKG1pbi13aWR0aDogMTI4MHB4KSBhbmQgKG1heC13aWR0aDogMTkxOXB4KSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYWxpYXM6ICdndC1sZycsXG4gICAgICAgIHN1ZmZpeDogJ0d0TGcnLFxuICAgICAgICBvdmVybGFwcGluZzogdHJ1ZSxcbiAgICAgICAgbWVkaWFRdWVyeTogJ3NjcmVlbiBhbmQgKG1pbi13aWR0aDogMTkyMHB4KSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYWxpYXM6ICd4bCcsXG4gICAgICAgIHN1ZmZpeDogJ1hsJyxcbiAgICAgICAgb3ZlcmxhcHBpbmc6IGZhbHNlLFxuICAgICAgICBtZWRpYVF1ZXJ5OiAnc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxOTIwcHgpIGFuZCAobWF4LXdpZHRoOiA1MDAwcHgpJ1xuICAgIH1cbl07XG4vKipcbiAqICBPcGFxdWUgVG9rZW4gdW5pcXVlIHRvIHRoZSBmbGV4LWxheW91dCBsaWJyYXJ5LlxuICogIFVzZSB0aGlzIHRva2VuIHdoZW4gYnVpbGQgYSBjdXN0b20gcHJvdmlkZXIgKHNlZSBiZWxvdykuXG4gKi9cbnZhciBCUkVBS1BPSU5UUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdmeFJhd0JyZWFrcG9pbnRzJyk7XG4vKipcbiAqICBQcm92aWRlciB0byByZXR1cm4gb2JzZXJ2YWJsZSB0byBBTEwga25vd24gQnJlYWtQb2ludChzKVxuICogIERldmVsb3BlcnMgc2hvdWxkIGJ1aWxkIGN1c3RvbSBwcm92aWRlcnMgdG8gb3ZlcnJpZGVcbiAqICB0aGlzIGRlZmF1bHQgQnJlYWtQb2ludFJlZ2lzdHJ5IGRhdGFzZXQgcHJvdmlkZXJcbiAqICBOT1RFOiAhISBjdXN0b20gYnJlYWtwb2ludHMgbGlzdHMgTVVTVCBjb250YWluIHRoZSBmb2xsb3dpbmcgYWxpYXNlcyAmIHN1ZmZpeGVzOlxuICogICAgICAgIFt4cywgZ3QteHMsIHNtLCBndC1zbSwgbWQsIGd0LW1kLCBsZywgZ3QtbGcsIHhsXVxuICovXG52YXIgQnJlYWtQb2ludHNQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiBCUkVBS1BPSU5UUyxcbiAgICB1c2VWYWx1ZTogUkFXX0RFRkFVTFRTXG59O1xuXG52YXIgX19kZWNvcmF0ZSQyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBSZWdpc3RyeSBvZiAxLi5uIE1lZGlhUXVlcnkgYnJlYWtwb2ludCByYW5nZXNcbiAqIFRoaXMgaXMgcHVibGlzaGVkIGFzIGEgcHJvdmlkZXIgYW5kIG1heSBiZSBvdmVycmlkZW4gZnJvbSBjdXN0b20sIGFwcGxpY2F0aW9uLXNwZWNpZmljIHJhbmdlc1xuICpcbiAqL1xudmFyIEJyZWFrUG9pbnRSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJlYWtQb2ludFJlZ2lzdHJ5KF9yZWdpc3RyeSkge1xuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IF9yZWdpc3RyeTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyZWFrUG9pbnRSZWdpc3RyeS5wcm90b3R5cGUsIFwiaXRlbXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQWNjZXNzb3IgdG8gcmF3IGxpc3RcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5LnNsaWNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCBicmVha3BvaW50cyBieSBhbGlhcyAoZS5nLiBndC14cylcbiAgICAgKi9cbiAgICBCcmVha1BvaW50UmVnaXN0cnkucHJvdG90eXBlLmZpbmRCeUFsaWFzID0gZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RyeS5maW5kKGZ1bmN0aW9uIChicCkgeyByZXR1cm4gYnAuYWxpYXMgPT0gYWxpYXM7IH0pO1xuICAgIH07XG4gICAgQnJlYWtQb2ludFJlZ2lzdHJ5LnByb3RvdHlwZS5maW5kQnlRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnkuZmluZChmdW5jdGlvbiAoYnApIHsgcmV0dXJuIGJwLm1lZGlhUXVlcnkgPT0gcXVlcnk7IH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyZWFrUG9pbnRSZWdpc3RyeS5wcm90b3R5cGUsIFwib3ZlcmxhcHBpbmdzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgdGhlIGJyZWFrcG9pbnRzIHdob3NlIHJhbmdlcyBjb3VsZCBvdmVybGFwcGluZyBgbm9ybWFsYCByYW5nZXM7XG4gICAgICAgICAqIGUuZy4gZ3Qtc20gb3ZlcmxhcHMgbWQsIGxnLCBhbmQgeGxcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5LmZpbHRlcihmdW5jdGlvbiAoaXQpIHsgcmV0dXJuIGl0Lm92ZXJsYXBwaW5nID09IHRydWU7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJlYWtQb2ludFJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJhbGlhc2VzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBsaXN0IG9mIGFsbCByZWdpc3RlcmVkIChub24tZW1wdHkpIGJyZWFrcG9pbnQgYWxpYXNlc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnkubWFwKGZ1bmN0aW9uIChpdCkgeyByZXR1cm4gaXQuYWxpYXM7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJlYWtQb2ludFJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJzdWZmaXhlc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhc2VzIGFyZSBtYXBwZWQgdG8gcHJvcGVydGllcyB1c2luZyBzdWZmaXhlc1xuICAgICAgICAgKiBlLmcuICAnZ3Qtc20nIGZvciBwcm9wZXJ0eSAnbGF5b3V0JyAgdXNlcyBzdWZmaXggJ0d0U20nXG4gICAgICAgICAqIGZvciBwcm9wZXJ0eSBsYXlvdXRHdFNNLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnkubWFwKGZ1bmN0aW9uIChpdCkgeyByZXR1cm4gaXQuc3VmZml4OyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQnJlYWtQb2ludFJlZ2lzdHJ5ID0gX19kZWNvcmF0ZSQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksXG4gICAgICAgIF9fcGFyYW0oMCwgX2FuZ3VsYXJfY29yZS5JbmplY3QoQlJFQUtQT0lOVFMpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMignZGVzaWduOnBhcmFtdHlwZXMnLCBbQXJyYXldKVxuICAgIF0sIEJyZWFrUG9pbnRSZWdpc3RyeSk7XG4gICAgcmV0dXJuIEJyZWFrUG9pbnRSZWdpc3RyeTtcbn0oKSk7XG5cbi8qKlxuICogQ2xhc3MgaW5zdGFuY2VzIGVtaXR0ZWQgW3RvIG9ic2VydmVyc10gZm9yIGVhY2ggbXFsIG5vdGlmaWNhdGlvblxuICovXG52YXIgTWVkaWFDaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lZGlhQ2hhbmdlKG1hdGNoZXMsIC8vIElzIHRoZSBtcSBjdXJyZW50bHkgYWN0aXZhdGVkXG4gICAgICAgIG1lZGlhUXVlcnksIC8vIGUuZy4gICAobWluLXdpZHRoOiA2MDBweCkgYW5kIChtYXgtd2lkdGg6IDk1OXB4KVxuICAgICAgICBtcUFsaWFzLCAvLyBlLmcuICAgZ3Qtc20sIG1kLCBndC1sZ1xuICAgICAgICBzdWZmaXggLy8gZS5nLiAgIEd0U00sIE1kLCBHdExnXG4gICAgICAgICkge1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdm9pZCAwKSB7IG1hdGNoZXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAobWVkaWFRdWVyeSA9PT0gdm9pZCAwKSB7IG1lZGlhUXVlcnkgPSAnYWxsJzsgfVxuICAgICAgICBpZiAobXFBbGlhcyA9PT0gdm9pZCAwKSB7IG1xQWxpYXMgPSAnJzsgfVxuICAgICAgICBpZiAoc3VmZml4ID09PSB2b2lkIDApIHsgc3VmZml4ID0gJyc7IH1cbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICAgICAgdGhpcy5tZWRpYVF1ZXJ5ID0gbWVkaWFRdWVyeTtcbiAgICAgICAgdGhpcy5tcUFsaWFzID0gbXFBbGlhcztcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgfVxuICAgIHJldHVybiBNZWRpYUNoYW5nZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBNZWRpYU1vbml0b3IgY29uZmlndXJlcyBsaXN0ZW5lcnMgdG8gbWVkaWFRdWVyeSBjaGFuZ2VzIGFuZCBwdWJsaXNoZXMgYW4gT2JzZXJ2YWJsZSBmYWNhZGUgdG9cbiAqIGNvbnZlcnQgbWVkaWFRdWVyeSBjaGFuZ2UgY2FsbGJhY2tzIHRvIHN1YnNjcmliZXIgbm90aWZpY2F0aW9ucy4gVGhlc2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlXG4gKiBwZXJmb3JtZWQgd2l0aGluIHRoZSBuZyBab25lIHRvIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbnMgYW5kIGNvbXBvbmVudCB1cGRhdGVzLlxuICpcbiAqIE5PVEU6IGJvdGggbWVkaWFRdWVyeSBhY3RpdmF0aW9ucyBhbmQgZGUtYWN0aXZhdGlvbnMgYXJlIGFubm91bmNlZCBpbiBub3RpZmljYXRpb25zXG4gKi9cbnZhciBNYXRjaE1lZGlhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRjaE1lZGlhKF96b25lKSB7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IG5ldyByeGpzX0JlaGF2aW9yU3ViamVjdC5CZWhhdmlvclN1YmplY3QobmV3IE1lZGlhQ2hhbmdlKHRydWUpKTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZSQgPSB0aGlzLl9zb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgc3BlY2lmaWVkIG1lZGlhUXVlcnk/XG4gICAgICovXG4gICAgTWF0Y2hNZWRpYS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAodGhpcy5fcmVnaXN0cnkuaGFzKG1lZGlhUXVlcnkpKSB7XG4gICAgICAgICAgICB2YXIgbXFsID0gdGhpcy5fcmVnaXN0cnkuZ2V0KG1lZGlhUXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIG1xbC5tYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4dGVybmFsIG9ic2VydmVycyBjYW4gd2F0Y2ggZm9yIGFsbCAob3IgYSBzcGVjaWZpYykgbXFsIGNoYW5nZXMuXG4gICAgICogVHlwaWNhbGx5IHVzZWQgYnkgdGhlIE1lZGlhUXVlcnlBZGFwdG9yOyBvcHRpb25hbGx5IGF2YWlsYWJsZSB0byBjb21wb25lbnRzXG4gICAgICogd2hvIHdpc2ggdG8gdXNlIHRoZSBNZWRpYU1vbml0b3IgYXMgbWVkaWFNb25pdG9yJCBvYnNlcnZhYmxlIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBOT1RFOiBpZiBhIG1lZGlhUXVlcnkgaXMgbm90IHNwZWNpZmllZCwgdGhlbiBBTEwgbWVkaWFRdWVyeSBhY3RpdmF0aW9ucyB3aWxsXG4gICAgICogICAgICAgYmUgYW5ub3VuY2VkLlxuICAgICAqL1xuICAgIE1hdGNoTWVkaWEucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAobWVkaWFRdWVyeSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUXVlcnkobWVkaWFRdWVyeSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZhYmxlJC5maWx0ZXIoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lZGlhUXVlcnkgPyAoY2hhbmdlLm1lZGlhUXVlcnkgPT09IG1lZGlhUXVlcnkpIDogdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgQnJlYWtQb2ludFJlZ2lzdHJ5IHByb3ZpZGVyLCByZWdpc3RlciBpbnRlcm5hbCBsaXN0ZW5lcnMgZm9yIGVhY2ggdW5pcXVlXG4gICAgICogbWVkaWFRdWVyeS4gRWFjaCBsaXN0ZW5lciBlbWl0cyBzcGVjaWZpYyBNZWRpYUNoYW5nZSBkYXRhIHRvIG9ic2VydmVyc1xuICAgICAqL1xuICAgIE1hdGNoTWVkaWEucHJvdG90eXBlLnJlZ2lzdGVyUXVlcnkgPSBmdW5jdGlvbiAobWVkaWFRdWVyeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgdmFyIG1xbCA9IHRoaXMuX3JlZ2lzdHJ5LmdldChtZWRpYVF1ZXJ5KTtcbiAgICAgICAgICAgIHZhciBvbk1RTEV2ZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gbmV3IE1lZGlhQ2hhbmdlKGUubWF0Y2hlcywgbWVkaWFRdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zb3VyY2UubmV4dChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghbXFsKSB7XG4gICAgICAgICAgICAgICAgbXFsID0gdGhpcy5fYnVpbGRNUUwobWVkaWFRdWVyeSk7XG4gICAgICAgICAgICAgICAgbXFsLmFkZExpc3RlbmVyKG9uTVFMRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdHJ5LnNldChtZWRpYVF1ZXJ5LCBtcWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1xbC5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgb25NUUxFdmVudChtcWwpOyAvLyBBbm5vdW5jZSBhY3RpdmF0ZSByYW5nZSBmb3IgaW5pdGlhbCBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsIHdpbmRvdy5tYXRjaE1lZGlhKCkgdG8gYnVpbGQgYSBNZWRpYVF1ZXJ5TGlzdDsgd2hpY2hcbiAgICAgKiBzdXBwb3J0cyAwLi5uIGxpc3RlbmVycyBmb3IgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb25cbiAgICAgKi9cbiAgICBNYXRjaE1lZGlhLnByb3RvdHlwZS5fYnVpbGRNUUwgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcHJlcGFyZVF1ZXJ5Q1NTKHF1ZXJ5KTtcbiAgICAgICAgdmFyIGNhbkxpc3RlbiA9ICEhd2luZG93Lm1hdGNoTWVkaWEoJ2FsbCcpLmFkZExpc3RlbmVyO1xuICAgICAgICByZXR1cm4gY2FuTGlzdGVuID8gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpIDoge1xuICAgICAgICAgICAgbWF0Y2hlczogcXVlcnkgPT09ICdhbGwnIHx8IHF1ZXJ5ID09PSAnJyxcbiAgICAgICAgICAgIG1lZGlhOiBxdWVyeSxcbiAgICAgICAgICAgIGFkZExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1hdGNoTWVkaWEgPSBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5OZ1pvbmVdKVxuICAgIF0sIE1hdGNoTWVkaWEpO1xuICAgIHJldHVybiBNYXRjaE1lZGlhO1xufSgpKTtcbi8qKlxuICogUHJpdmF0ZSBnbG9iYWwgcmVnaXN0cnkgZm9yIGFsbCBkeW5hbWljYWxseS1jcmVhdGVkLCBpbmplY3RlZCBzdHlsZSB0YWdzXG4gKiBAc2VlIHByZXBhcmUocXVlcnkpXG4gKi9cbnZhciBBTExfU1RZTEVTID0ge307XG4vKipcbiAqIEZvciBXZWJraXQgZW5naW5lcyB0aGF0IG9ubHkgdHJpZ2dlciB0aGUgTWVkaWFRdWVyeUxpc3RMaXN0ZW5lclxuICogd2hlbiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgQ1NTIHNlbGVjdG9yIGZvciB0aGUgcmVzcGVjdGl2ZSBtZWRpYSBxdWVyeS5cbiAqXG4gKiBAcGFyYW0gcXVlcnkgc3RyaW5nIFRoZSBtZWRpYVF1ZXJ5IHVzZWQgdG8gY3JlYXRlIGEgZmF1eCBDU1Mgc2VsZWN0b3JcbiAqXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVRdWVyeUNTUyhxdWVyeSkge1xuICAgIGlmICghQUxMX1NUWUxFU1txdWVyeV0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgICAgIGlmICghc3R5bGVbJ3N0eWxlU2hlZXQnXSkge1xuICAgICAgICAgICAgICAgIHZhciBjc3NUZXh0ID0gXCJAbWVkaWEgXCIgKyBxdWVyeSArIFwiIHsuZngtcXVlcnktdGVzdHsgfX1cIjtcbiAgICAgICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgIC8vIFN0b3JlIGluIHByaXZhdGUgZ2xvYmFsIHJlZ2lzdHJ5XG4gICAgICAgICAgICBBTExfU1RZTEVTW3F1ZXJ5XSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEZvciB0aGUgc3BlY2lmaWVkIE1lZGlhQ2hhbmdlLCBtYWtlIHN1cmUgaXQgY29udGFpbnMgdGhlIGJyZWFrcG9pbnQgYWxpYXNcbiAqIGFuZCBzdWZmaXggKGlmIGF2YWlsYWJsZSkuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQWxpYXMoZGVzdCwgc291cmNlKSB7XG4gICAgcmV0dXJuIGV4dGVuZE9iamVjdChkZXN0LCBzb3VyY2UgPyB7XG4gICAgICAgIG1xQWxpYXM6IHNvdXJjZS5hbGlhcyxcbiAgICAgICAgc3VmZml4OiBzb3VyY2Uuc3VmZml4XG4gICAgfSA6IHt9KTtcbn1cblxudmFyIF9fZGVjb3JhdGUkMSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIE1lZGlhTW9uaXRvciB1c2VzIHRoZSBNYXRjaE1lZGlhIHNlcnZpY2UgdG8gb2JzZXJ2ZSBtZWRpYVF1ZXJ5IGNoYW5nZXMgKGJvdGggYWN0aXZhdGlvbnMgYW5kXG4gKiBkZWFjdGl2YXRpb25zKS4gVGhlc2UgY2hhbmdlcyBhcmUgYXJlIHB1Ymxpc2hlZCBhcyBNZWRpYUNoYW5nZSBub3RpZmljYXRpb25zLlxuICpcbiAqIE5vdGU6IGFsbCBub3RpZmljYXRpb25zIHdpbGwgYmUgcGVyZm9ybWVkIHdpdGhpbiB0aGVcbiAqIG5nIFpvbmUgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9ucyBhbmQgY29tcG9uZW50IHVwZGF0ZXMuXG4gKlxuICogSXQgaXMgdGhlIE1lZGlhTW9uaXRvciB0aGF0OlxuICogIC0gYXV0byByZWdpc3RlcnMgYWxsIGtub3duIGJyZWFrcG9pbnRzXG4gKiAgLSBpbmplY3RzIGFsaWFzIGluZm9ybWF0aW9uIGludG8gZWFjaCByYXcgTWVkaWFDaGFuZ2UgZXZlbnRcbiAqICAtIHByb3ZpZGVzIGFjY2Vzc29yIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIEJyZWFrUG9pbnRcbiAqICAtIHB1Ymxpc2ggbGlzdCBvZiBvdmVybGFwcGluZyBCcmVha1BvaW50KHMpOyB1c2VkIGJ5IFJlc3BvbnNpdmVBY3RpdmF0aW9uXG4gKi9cbnZhciBNZWRpYU1vbml0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lZGlhTW9uaXRvcihfYnJlYWtwb2ludHMsIF9tYXRjaE1lZGlhKSB7XG4gICAgICAgIHRoaXMuX2JyZWFrcG9pbnRzID0gX2JyZWFrcG9pbnRzO1xuICAgICAgICB0aGlzLl9tYXRjaE1lZGlhID0gX21hdGNoTWVkaWE7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQnJlYWtwb2ludHMoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhTW9uaXRvci5wcm90b3R5cGUsIFwiYnJlYWtwb2ludHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVhZC1vbmx5IGFjY2Vzc29yIHRvIHRoZSBsaXN0IG9mIGJyZWFrcG9pbnRzIGNvbmZpZ3VyZWQgaW4gdGhlIEJyZWFrUG9pbnRSZWdpc3RyeSBwcm92aWRlclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtwb2ludHMuaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhTW9uaXRvci5wcm90b3R5cGUsIFwiYWN0aXZlT3ZlcmxhcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLl9icmVha3BvaW50cy5vdmVybGFwcGluZ3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoYnApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hdGNoTWVkaWEuaXNBY3RpdmUoYnAubWVkaWFRdWVyeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhTW9uaXRvci5wcm90b3R5cGUsIFwiYWN0aXZlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gbnVsbCwgaXRlbXMgPSB0aGlzLmJyZWFrcG9pbnRzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGJwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJwLmFsaWFzICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kICYmIF90aGlzLl9tYXRjaE1lZGlhLmlzQWN0aXZlKGJwLm1lZGlhUXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGJwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSB0aGlzLmJyZWFrcG9pbnRzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8ICh0aGlzLl9tYXRjaE1lZGlhLmlzQWN0aXZlKGZpcnN0Lm1lZGlhUXVlcnkpID8gZmlyc3QgOiBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBzcGVjaWZpZWQgbWVkaWFRdWVyeSBhbGlhcywgaXMgdGhlIG1lZGlhUXVlcnkgcmFuZ2UgYWN0aXZlP1xuICAgICAqL1xuICAgIE1lZGlhTW9uaXRvci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgdmFyIGJwID0gdGhpcy5fYnJlYWtwb2ludHMuZmluZEJ5QWxpYXMoYWxpYXMpIHx8IHRoaXMuX2JyZWFrcG9pbnRzLmZpbmRCeVF1ZXJ5KGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoTWVkaWEuaXNBY3RpdmUoYnAgPyBicC5tZWRpYVF1ZXJ5IDogYWxpYXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWwgb2JzZXJ2ZXJzIGNhbiB3YXRjaCBmb3IgYWxsIChvciBhIHNwZWNpZmljKSBtcWwgY2hhbmdlcy5cbiAgICAgKiBJZiBzcGVjaWZpYyBicmVha3BvaW50IGlzIG9ic2VydmVkLCBvbmx5IHJldHVybiAqYWN0aXZhdGVkKiBldmVudHNcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGFsbCBldmVudHMgZm9yIEJPVEggYWN0aXZhdGVkICsgZGVhY3RpdmF0ZWQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBNZWRpYU1vbml0b3IucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgdmFyIGJwID0gdGhpcy5fYnJlYWtwb2ludHMuZmluZEJ5QWxpYXMoYWxpYXMpIHx8IHRoaXMuX2JyZWFrcG9pbnRzLmZpbmRCeVF1ZXJ5KGFsaWFzKTtcbiAgICAgICAgdmFyIGhhc0FsaWFzID0gZnVuY3Rpb24gKGNoYW5nZSkgeyByZXR1cm4gKGJwID8gY2hhbmdlLm1xQWxpYXMgIT09IFwiXCIgOiB0cnVlKTsgfTtcbiAgICAgICAgLy8gTm90ZTogdGhlIHJhdyBNZWRpYUNoYW5nZSBldmVudHMgW2Zyb20gTWF0Y2hNZWRpYV0gZG8gbm90IGNvbnRhaW4gaW1wb3J0YW50IGFsaWFzIGluZm9ybWF0aW9uXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRjaE1lZGlhXG4gICAgICAgICAgICAub2JzZXJ2ZShicCA/IGJwLm1lZGlhUXVlcnkgOiBhbGlhcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNoYW5nZSkgeyByZXR1cm4gbWVyZ2VBbGlhcyhjaGFuZ2UsIGJwKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoaGFzQWxpYXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlIGNhbGxzIHRvIG1hdGNoTWVkaWEoKSB0byBlc3RhYmxpc2ggbGlzdGVuZXJzXG4gICAgICogYW5kIHByZXBhcmUgZm9yIGltbWVkaWF0ZSBzdWJzY3JpcHRpb24gbm90aWZpY2F0aW9uc1xuICAgICAqL1xuICAgIE1lZGlhTW9uaXRvci5wcm90b3R5cGUuX3JlZ2lzdGVyQnJlYWtwb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JyZWFrcG9pbnRzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGJwKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWF0Y2hNZWRpYS5yZWdpc3RlclF1ZXJ5KGJwLm1lZGlhUXVlcnkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1lZGlhTW9uaXRvciA9IF9fZGVjb3JhdGUkMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxKCdkZXNpZ246cGFyYW10eXBlcycsIFtCcmVha1BvaW50UmVnaXN0cnksIE1hdGNoTWVkaWFdKVxuICAgIF0sIE1lZGlhTW9uaXRvcik7XG4gICAgcmV0dXJuIE1lZGlhTW9uaXRvcjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBNZWRpYVNlcnZpY2UgYW5kIHBzZXVkby10b2tlbiBmb3JcbiAqL1xudmFyIE9ic2VydmFibGVNZWRpYSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZU1lZGlhKCkge1xuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2YWJsZU1lZGlhO1xufSgpKTtcbi8qKlxuICogQ2xhc3MgaW50ZXJuYWxpemVzIGEgTWF0Y2hNZWRpYSBzZXJ2aWNlIGFuZCBleHBvc2VzIGFuIFN1YnNjcmliYWJsZSBhbmQgT2JzZXJ2YWJsZSBpbnRlcmZhY2UuXG5cbiAqIFRoaXMgYW4gT2JzZXJ2YWJsZSB3aXRoIHRoYXQgZXhwb3NlcyBhIGZlYXR1cmUgdG8gc3Vic2NyaWJlIHRvIG1lZGlhUXVlcnlcbiAqIGNoYW5nZXMgYW5kIGEgdmFsaWRhdG9yIG1ldGhvZCAoYGlzQWN0aXZlKDxhbGlhcz4pYCkgdG8gdGVzdCBpZiBhIG1lZGlhUXVlcnkgKG9yIGFsaWFzKSBpc1xuICogY3VycmVudGx5IGFjdGl2ZS5cbiAqXG4gKiAhISBPbmx5IG1lZGlhQ2hhbmdlIGFjdGl2YXRpb25zIChub3QgZGUtYWN0aXZhdGlvbnMpIGFyZSBhbm5vdW5jZWQgYnkgdGhlIE9ic2VydmFibGVNZWRpYVxuICpcbiAqIFRoaXMgY2xhc3MgdXNlcyB0aGUgQnJlYWtQb2ludCBSZWdpc3RyeSB0byBpbmplY3QgYWxpYXMgaW5mb3JtYXRpb24gaW50byB0aGUgcmF3IE1lZGlhQ2hhbmdlXG4gKiBub3RpZmljYXRpb24uIEZvciBjdXN0b20gbWVkaWFRdWVyeSBub3RpZmljYXRpb25zLCBhbGlhcyBpbmZvcm1hdGlvbiB3aWxsIG5vdCBiZSBpbmplY3RlZCBhbmRcbiAqIHRob3NlIGZpZWxkcyB3aWxsIGJlICcnLlxuICpcbiAqICEhIFRoaXMgaXMgbm90IGFuIGFjdHVhbCBPYnNlcnZhYmxlLiBJdCBpcyBhIHdyYXBwZXIgb2YgYW4gT2JzZXJ2YWJsZSB1c2VkIHRvIHB1Ymxpc2ggYWRkaXRpb25hbFxuICogbWV0aG9kcyBsaWtlIGBpc0FjdGl2ZSg8YWxpYXM+KS4gVG8gYWNjZXNzIHRoZSBPYnNlcnZhYmxlIGFuZCB1c2UgUnhKUyBvcGVyYXRvcnMsIHVzZVxuICogYC5hc09ic2VydmFibGUoKWAgd2l0aCBzeW50YXggbGlrZSBtZWRpYS5hc09ic2VydmFibGUoKS5tYXAoLi4uLikuXG4gKlxuICogIEB1c2FnZVxuICpcbiAqICAvLyBSeEpTXG4gKiAgaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInO1xuICogIGltcG9ydCB7IE9ic2VydmFibGVNZWRpYSB9IGZyb20gJ0Bhbmd1bGFyL2ZsZXgtbGF5b3V0JztcbiAqXG4gKiAgQENvbXBvbmVudCh7IC4uLiB9KVxuICogIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgc3RhdHVzIDogc3RyaW5nID0gJyc7XG4gKlxuICogICAgY29uc3RydWN0b3IoICBtZWRpYTpPYnNlcnZhYmxlTWVkaWEgKSB7XG4gKiAgICAgIGxldCBvbkNoYW5nZSA9IChjaGFuZ2U6TWVkaWFDaGFuZ2UpID0+IHtcbiAqICAgICAgICB0aGlzLnN0YXR1cyA9IGNoYW5nZSA/IGAnJHtjaGFuZ2UubXFBbGlhc30nID0gKCR7Y2hhbmdlLm1lZGlhUXVlcnl9KWAgOiBcIlwiO1xuICogICAgICB9O1xuICpcbiAqICAgICAgLy8gU3Vic2NyaWJlIGRpcmVjdGx5IG9yIGFjY2VzcyBvYnNlcnZhYmxlIHRvIHVzZSBmaWx0ZXIvbWFwIG9wZXJhdG9yc1xuICogICAgICAvLyBlLmcuXG4gKiAgICAgIC8vICAgICAgbWVkaWEuc3Vic2NyaWJlKG9uQ2hhbmdlKTtcbiAqXG4gKiAgICAgIG1lZGlhLmFzT2JzZXJ2YWJsZSgpXG4gKiAgICAgICAgLmZpbHRlcigoY2hhbmdlOk1lZGlhQ2hhbmdlKSA9PiB0cnVlKSAgIC8vIHNpbGx5IG5vb3AgZmlsdGVyXG4gKiAgICAgICAgLnN1YnNjcmliZShvbkNoYW5nZSk7XG4gKiAgICB9XG4gKiAgfVxuICovXG52YXIgTWVkaWFTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZWRpYVNlcnZpY2UobWVkaWFXYXRjaGVyLCBicmVha3BvaW50cykge1xuICAgICAgICB0aGlzLm1lZGlhV2F0Y2hlciA9IG1lZGlhV2F0Y2hlcjtcbiAgICAgICAgdGhpcy5icmVha3BvaW50cyA9IGJyZWFrcG9pbnRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHdlIGFubm91bmNlIGd0LTx4eHg+IGJyZWFrcG9pbnQgYWN0aXZhdGlvbnMgP1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJPdmVybGFwcyA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSQgPSB0aGlzLl9idWlsZE9ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJCcmVha1BvaW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHNwZWNpZmllZCBxdWVyeS9hbGlhcyBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgTWVkaWFTZXJ2aWNlLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl90b01lZGlhUXVlcnkoYWxpYXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVdhdGNoZXIuaXNBY3RpdmUocXVlcnkpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUHJveHkgdG8gdGhlIE9ic2VydmFibGUgc3Vic2NyaWJlIG1ldGhvZFxuICAgICAqL1xuICAgIE1lZGlhU2VydmljZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlJC5zdWJzY3JpYmUobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0byBvYnNlcnZhYmxlIGZvciB1c2Ugd2l0aCBvcGVyYXRvcnMgbGlrZVxuICAgICAqIC5maWx0ZXIoKSwgLm1hcCgpLCBldGMuXG4gICAgICovXG4gICAgTWVkaWFTZXJ2aWNlLnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmFibGUkO1xuICAgIH07XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gSW50ZXJuYWwgTWV0aG9kc1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFsbCB0aGUgbWVkaWFRdWVyaWVzIHJlZ2lzdGVyZWQgaW4gdGhlIEJyZWFrUG9pbnRSZWdpc3RyeVxuICAgICAqIFRoaXMgaXMgbmVlZGVkIHNvIHN1YnNjcmliZXJzIGNhbiBiZSBhdXRvLW5vdGlmaWVkIG9mIGFsbCBzdGFuZGFyZCwgcmVnaXN0ZXJlZFxuICAgICAqIG1lZGlhUXVlcnkgYWN0aXZhdGlvbnNcbiAgICAgKi9cbiAgICBNZWRpYVNlcnZpY2UucHJvdG90eXBlLl9yZWdpc3RlckJyZWFrUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmJyZWFrcG9pbnRzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGJwKSB7XG4gICAgICAgICAgICBfdGhpcy5tZWRpYVdhdGNoZXIucmVnaXN0ZXJRdWVyeShicC5tZWRpYVF1ZXJ5KTtcbiAgICAgICAgICAgIHJldHVybiBicDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGludGVybmFsIG9ic2VydmFibGVcbiAgICAgKiBOT1RFOiB0aGUgcmF3IE1lZGlhQ2hhbmdlIGV2ZW50cyBbZnJvbSBNYXRjaE1lZGlhXSBkbyBub3QgY29udGFpbiBpbXBvcnRhbnQgYWxpYXMgaW5mb3JtYXRpb25cbiAgICAgKiB0aGVzZSBtdXN0IGJlIGluamVjdGVkIGludG8gdGhlIE1lZGlhQ2hhbmdlXG4gICAgICovXG4gICAgTWVkaWFTZXJ2aWNlLnByb3RvdHlwZS5fYnVpbGRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVdhdGNoZXIub2JzZXJ2ZSgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcGFzcy9hbm5vdW5jZSBhY3RpdmF0aW9ucyAobm90IGRlLWFjdGl2YXRpb25zKVxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZS5tYXRjaGVzID09PSB0cnVlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAvLyBJbmplY3QgYXNzb2NpYXRlZCAoaWYgYW55KSBhbGlhcyBpbmZvcm1hdGlvbiBpbnRvIHRoZSBNZWRpYUNoYW5nZSBldmVudFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlQWxpYXMoY2hhbmdlLCBfdGhpcy5fZmluZEJ5UXVlcnkoY2hhbmdlLm1lZGlhUXVlcnkpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIGJwID0gX3RoaXMuYnJlYWtwb2ludHMuZmluZEJ5UXVlcnkoY2hhbmdlLm1lZGlhUXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuICFicCA/IHRydWUgOiAhKF90aGlzLmZpbHRlck92ZXJsYXBzICYmIGJwLm92ZXJsYXBwaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCcmVha3BvaW50IGxvY2F0b3IgYnkgYWxpYXNcbiAgICAgKi9cbiAgICBNZWRpYVNlcnZpY2UucHJvdG90eXBlLl9maW5kQnlBbGlhcyA9IGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXR1cm4gdGhpcy5icmVha3BvaW50cy5maW5kQnlBbGlhcyhhbGlhcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCcmVha3BvaW50IGxvY2F0b3IgYnkgbWVkaWFRdWVyeVxuICAgICAqL1xuICAgIE1lZGlhU2VydmljZS5wcm90b3R5cGUuX2ZpbmRCeVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRzLmZpbmRCeVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIEZpbmQgYXNzb2NpYXRlZCBicmVha3BvaW50IChpZiBhbnkpXG4gICAgICovXG4gICAgTWVkaWFTZXJ2aWNlLnByb3RvdHlwZS5fdG9NZWRpYVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBicCA9IHRoaXMuX2ZpbmRCeUFsaWFzKHF1ZXJ5KSB8fCB0aGlzLl9maW5kQnlRdWVyeShxdWVyeSk7XG4gICAgICAgIHJldHVybiBicCA/IGJwLm1lZGlhUXVlcnkgOiBxdWVyeTtcbiAgICB9O1xuICAgIFxuICAgIE1lZGlhU2VydmljZSA9IF9fZGVjb3JhdGUkNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1KCdkZXNpZ246cGFyYW10eXBlcycsIFtNYXRjaE1lZGlhLCBCcmVha1BvaW50UmVnaXN0cnldKVxuICAgIF0sIE1lZGlhU2VydmljZSk7XG4gICAgcmV0dXJuIE1lZGlhU2VydmljZTtcbn0oKSk7XG4vKipcbiAqICBQcm92aWRlciB0byByZXR1cm4gb2JzZXJ2YWJsZSB0byBBTEwgTWVkaWFRdWVyeSBldmVudHNcbiAqICBEZXZlbG9wZXJzIHNob3VsZCBidWlsZCBjdXN0b20gcHJvdmlkZXJzIHRvIG92ZXJyaWRlIHRoaXMgZGVmYXVsdCBNZWRpYVF1ZXJ5IE9ic2VydmFibGVcbiAqL1xudmFyIE9ic2VydmFibGVNZWRpYVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6IE9ic2VydmFibGVNZWRpYSxcbiAgICB1c2VDbGFzczogTWVkaWFTZXJ2aWNlLFxuICAgIGRlcHM6IFtNYXRjaE1lZGlhLCBCcmVha1BvaW50UmVnaXN0cnldXG59O1xuXG52YXIgX19kZWNvcmF0ZSQ0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIERlZmluZSBtb2R1bGUgZm9yIHRoZSBNZWRpYVF1ZXJ5IEFQSVxuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqL1xudmFyIE1lZGlhUXVlcmllc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVkaWFRdWVyaWVzTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZWRpYVF1ZXJpZXNNb2R1bGUgPSBfX2RlY29yYXRlJDQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE1hdGNoTWVkaWEsXG4gICAgICAgICAgICAgICAgQnJlYWtQb2ludHNQcm92aWRlcixcbiAgICAgICAgICAgICAgICBCcmVha1BvaW50UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgTWVkaWFNb25pdG9yLFxuICAgICAgICAgICAgICAgIE9ic2VydmFibGVNZWRpYVByb3ZpZGVyIC8vIGVhc3kgc3Vic2NyaXB0aW9uIGluamVjdGFibGUgYG1lZGlhJGAgbWF0Y2hNZWRpYSBvYnNlcnZhYmxlXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1lZGlhUXVlcmllc01vZHVsZSk7XG4gICAgcmV0dXJuIE1lZGlhUXVlcmllc01vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBMQVlPVVRfVkFMVUVTID0gWydyb3cnLCAnY29sdW1uJywgJ3Jvdy1yZXZlcnNlJywgJ2NvbHVtbi1yZXZlcnNlJ107XG4vKipcbiAqICdsYXlvdXQnIGZsZXhib3ggc3R5bGluZyBkaXJlY3RpdmVcbiAqIERlZmluZXMgdGhlIHBvc2l0aW9uaW5nIGZsb3cgZGlyZWN0aW9uIGZvciB0aGUgY2hpbGQgZWxlbWVudHM6IHJvdyBvciBjb2x1bW5cbiAqIE9wdGlvbmFsIHZhbHVlczogY29sdW1uIG9yIHJvdyAoZGVmYXVsdClcbiAqIEBzZWUgaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9hbG1hbmFjL3Byb3BlcnRpZXMvZi9mbGV4LWRpcmVjdGlvbi9cbiAqXG4gKi9cbnZhciBMYXlvdXREaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyKExheW91dERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExheW91dERpcmVjdGl2ZShtb25pdG9yLCBlbFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VyID0gbmV3IHJ4anNfQmVoYXZpb3JTdWJqZWN0LkJlaGF2aW9yU3ViamVjdChcInJvd1wiKTtcbiAgICAgICAgdGhpcy5sYXlvdXQkID0gdGhpcy5fYW5ub3VuY2VyLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYXlvdXRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dChcImxheW91dFwiLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYXlvdXRYc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdsYXlvdXRYcycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dEd0WHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnbGF5b3V0R3RYcycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ2xheW91dFNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGF5b3V0R3RTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdsYXlvdXRHdFNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGF5b3V0TWRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnbGF5b3V0TWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYXlvdXRHdE1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ2xheW91dEd0TWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYXlvdXRMZ1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdsYXlvdXRMZycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dEd0TGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnbGF5b3V0R3RMZycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dFhsXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ2xheW91dFhsJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTGlmZWN5Y2xlIE1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2VzIHRvIGFueSBASW5wdXQgcHJvcGVydGllcy4uLlxuICAgICAqIERlZmF1bHQgdG8gdXNlIHRoZSBub24tcmVzcG9uc2l2ZSBJbnB1dCB2YWx1ZSAoJ2Z4TGF5b3V0JylcbiAgICAgKiBUaGVuIGNvbmRpdGlvbmFsbHkgb3ZlcnJpZGUgd2l0aCB0aGUgbXEtYWN0aXZhdGVkIElucHV0J3MgY3VycmVudCB2YWx1ZVxuICAgICAqL1xuICAgIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbGF5b3V0J10gIT0gbnVsbCB8fCB0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVdpdGhEaXJlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGluaXRpYWwgb25DaGFuZ2VzLCBidWlsZCBhbiBtcUFjdGl2YXRpb24gb2JqZWN0IHRoYXQgYnJpZGdlc1xuICAgICAqIG1xbCBjaGFuZ2UgZXZlbnRzIHRvIG9uTWVkaWFRdWVyeUNoYW5nZSBoYW5kbGVyc1xuICAgICAqL1xuICAgIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xpc3RlbkZvck1lZGlhUXVlcnlDaGFuZ2VzKCdsYXlvdXQnLCAncm93JywgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVXaXRoRGlyZWN0aW9uKGNoYW5nZXMudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2l0aERpcmVjdGlvbigpO1xuICAgIH07XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gUHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZGlyZWN0aW9uIHZhbHVlIGFuZCB0aGVuIHVwZGF0ZSB0aGUgaG9zdCdzIGlubGluZSBmbGV4Ym94IHN0eWxlc1xuICAgICAqL1xuICAgIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVdpdGhEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCB0aGlzLl9xdWVyeUlucHV0KFwibGF5b3V0XCIpIHx8ICdyb3cnO1xuICAgICAgICBpZiAodGhpcy5fbXFBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLl9tcUFjdGl2YXRpb24uYWN0aXZhdGVkSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlyZWN0aW9uID0gdGhpcy5fdmFsaWRhdGVWYWx1ZShkaXJlY3Rpb24pO1xuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIGFuZCBhbm5vdW5jZSB0byBzdWJzY3JpYmVycyB0aGUgKm5ldyogZGlyZWN0aW9uXG4gICAgICAgIHRoaXMuX2FwcGx5U3R5bGVUb0VsZW1lbnQodGhpcy5fYnVpbGRDU1MoZGlyZWN0aW9uKSk7XG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5uZXh0KGRpcmVjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCdWlsZCB0aGUgQ1NTIHRoYXQgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50IGluc3RhbmNlXG4gICAgICogQlVHOlxuICAgICAqXG4gICAgICogICAxKSBtaW4taGVpZ2h0IG9uIGEgY29sdW1uIGZsZXggY29udGFpbmVyIHdvbuKAmXQgYXBwbHkgdG8gaXRzIGZsZXggaXRlbSBjaGlsZHJlbiBpbiBJRSAxMC0xMS5cbiAgICAgKiAgICAgIFVzZSBoZWlnaHQgaW5zdGVhZCBpZiBwb3NzaWJsZTsgaGVpZ2h0IDogPHh4eD52aDtcbiAgICAgKlxuICAgICAqIEB0b2RvIC0gdXBkYXRlIGFsbCBjaGlsZCBjb250YWluZXJzIHRvIGhhdmUgXCJib3gtc2l6aW5nOiBib3JkZXItYm94XCJcbiAgICAgKiAgICAgICAgIFRoaXMgd2F5IGFueSBwYWRkaW5nIG9yIGJvcmRlciBzcGVjaWZpZWQgb24gdGhlIGNoaWxkIGVsZW1lbnRzIGFyZVxuICAgICAqICAgICAgICAgbGFpZCBvdXQgYW5kIGRyYXduIGluc2lkZSB0aGF0IGVsZW1lbnQncyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKlxuICAgICAqL1xuICAgIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUuX2J1aWxkQ1NTID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7ICdkaXNwbGF5JzogJ2ZsZXgnLCAnYm94LXNpemluZyc6ICdib3JkZXItYm94JywgJ2ZsZXgtZGlyZWN0aW9uJzogdmFsdWUgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSB2YWx1ZSB0byBiZSBvbmUgb2YgdGhlIGFjY2VwdGFibGUgdmFsdWUgb3B0aW9uc1xuICAgICAqIFVzZSBkZWZhdWx0IGZhbGxiYWNrIG9mIFwicm93XCJcbiAgICAgKi9cbiAgICBMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLl92YWxpZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICAgIHJldHVybiBMQVlPVVRfVkFMVUVTLmZpbmQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IHZhbHVlOyB9KSA/IHZhbHVlIDogTEFZT1VUX1ZBTFVFU1swXTsgLy8gXCJyb3dcIlxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGF5b3V0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0LnhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dFhzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0Lmd0LXhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dEd0WHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXQuc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGF5b3V0U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXQuZ3Qtc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGF5b3V0R3RTbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dC5tZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYXlvdXRNZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dC5ndC1tZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYXlvdXRHdE1kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0LmxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dExnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0Lmd0LWxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImxheW91dEd0TGdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXQueGwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGF5b3V0WGxcIiwgbnVsbCk7XG4gICAgTGF5b3V0RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogXCJcXG4gIFtmeExheW91dF0sXFxuICBbZnhMYXlvdXQueHNdLFxcbiAgW2Z4TGF5b3V0Lmd0LXhzXSxcXG4gIFtmeExheW91dC5zbV0sXFxuICBbZnhMYXlvdXQuZ3Qtc21dLFxcbiAgW2Z4TGF5b3V0Lm1kXSxcXG4gIFtmeExheW91dC5ndC1tZF0sXFxuICBbZnhMYXlvdXQubGddLFxcbiAgW2Z4TGF5b3V0Lmd0LWxnXSxcXG4gIFtmeExheW91dC54bF1cXG5cIiB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbTWVkaWFNb25pdG9yLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIExheW91dERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIExheW91dERpcmVjdGl2ZTtcbn0oQmFzZUZ4RGlyZWN0aXZlKSk7XG5cbnZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDIgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqICdsYXlvdXQtd3JhcCcgZmxleGJveCBzdHlsaW5nIGRpcmVjdGl2ZVxuICogRGVmaW5lcyB3cmFwcGluZyBvZiBjaGlsZCBlbGVtZW50cyBpbiBsYXlvdXQgY29udGFpbmVyXG4gKiBPcHRpb25hbCB2YWx1ZXM6IHJldmVyc2UsIHdyYXAtcmV2ZXJzZSwgbm9uZSwgbm93cmFwLCB3cmFwIChkZWZhdWx0KV1cbiAqIEBzZWUgaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9hbG1hbmFjL3Byb3BlcnRpZXMvZi9mbGV4LXdyYXAvXG4gKi9cbnZhciBMYXlvdXRXcmFwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMyhMYXlvdXRXcmFwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExheW91dFdyYXBEaXJlY3RpdmUobW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyLCBjb250YWluZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gJ3Jvdyc7IC8vIGRlZmF1bHQgZmxleC1kaXJlY3Rpb25cbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0V2F0Y2hlciA9IGNvbnRhaW5lci5sYXlvdXQkLnN1YnNjcmliZSh0aGlzLl9vbkxheW91dENoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KFwid3JhcFwiLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcFhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ3dyYXBYcycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwR3RYc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCd3cmFwR3RYcycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwU21cIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnd3JhcFNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dFdyYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIndyYXBHdFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ3dyYXBHdFNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dFdyYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIndyYXBNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCd3cmFwTWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcEd0TWRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnd3JhcEd0TWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcExnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ3dyYXBMZycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwR3RMZ1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCd3cmFwR3RMZycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwWGxcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnd3JhcFhsJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTGlmZWN5Y2xlIE1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWyd3cmFwJ10gIT0gbnVsbCB8fCB0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVdpdGhWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZnRlciB0aGUgaW5pdGlhbCBvbkNoYW5nZXMsIGJ1aWxkIGFuIG1xQWN0aXZhdGlvbiBvYmplY3QgdGhhdCBicmlkZ2VzXG4gICAgICogbXFsIGNoYW5nZSBldmVudHMgdG8gb25NZWRpYVF1ZXJ5Q2hhbmdlIGhhbmRsZXJzXG4gICAgICovXG4gICAgTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xpc3RlbkZvck1lZGlhUXVlcnlDaGFuZ2VzKCd3cmFwJywgJ3dyYXAnLCBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVdpdGhWYWx1ZShjaGFuZ2VzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdpdGhWYWx1ZSgpO1xuICAgIH07XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gUHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGUgcGFyZW50IGNvbnRhaW5lciAnZmxleC1kaXJlY3Rpb24nIGFuZCB1cGRhdGUgdGhlICdmbGV4JyBzdHlsZXNcbiAgICAgKi9cbiAgICBMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZS5fb25MYXlvdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IChkaXJlY3Rpb24gfHwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnLXJldmVyc2UnLCAnJyk7XG4gICAgICAgIGlmICghTEFZT1VUX1ZBTFVFUy5maW5kKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ID09PSBfdGhpcy5fbGF5b3V0OyB9KSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gJ3Jvdyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlV2l0aFZhbHVlKCk7XG4gICAgfTtcbiAgICBMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlV2l0aFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgfHwgdGhpcy5fcXVlcnlJbnB1dChcIndyYXBcIikgfHwgJ3dyYXAnO1xuICAgICAgICBpZiAodGhpcy5fbXFBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX21xQWN0aXZhdGlvbi5hY3RpdmF0ZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZhbGlkYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLl9hcHBseVN0eWxlVG9FbGVtZW50KHRoaXMuX2J1aWxkQ1NTKHZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCdWlsZCB0aGUgQ1NTIHRoYXQgc2hvdWxkIGJlIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUuX2J1aWxkQ1NTID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRPYmplY3QoeyAnZmxleC13cmFwJzogdmFsdWUgfSwge1xuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnZmxleCcsXG4gICAgICAgICAgICAnZmxleC1kaXJlY3Rpb24nOiB0aGlzLl9sYXlvdXQgfHwgJ3JvdydcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGxheW91dC13cmFwPVwiPHZhbHVlPlwiIHRvIGV4cGVjdGVkIGZsZXgtd3JhcCBzdHlsZVxuICAgICAqL1xuICAgIExheW91dFdyYXBEaXJlY3RpdmUucHJvdG90eXBlLl92YWxpZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAncmV2ZXJzZSc6XG4gICAgICAgICAgICBjYXNlICd3cmFwLXJldmVyc2UnOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gJ3dyYXAtcmV2ZXJzZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdubyc6XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgIGNhc2UgJ25vd3JhcCc6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnbm93cmFwJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEFsbCBvdGhlciB2YWx1ZXMgZmFsbGJhY2sgdG8gXCJ3cmFwXCJcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnd3JhcCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRXcmFwJyksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0V3JhcC54cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ4KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcFhzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0V3JhcC5ndC14cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ4KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcEd0WHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRXcmFwLnNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwU21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRXcmFwLmd0LXNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwR3RTbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dFdyYXAubWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ4KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dFdyYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIndyYXBNZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dFdyYXAuZ3QtbWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ4KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dFdyYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIndyYXBHdE1kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0V3JhcC5sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ4KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcExnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0V3JhcC5ndC1sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ4KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0V3JhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwid3JhcEd0TGdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRXcmFwLnhsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRXcmFwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ3cmFwWGxcIiwgbnVsbCk7XG4gICAgTGF5b3V0V3JhcERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6IFwiXFxuICBbZnhMYXlvdXRXcmFwXSxcXG4gIFtmeExheW91dFdyYXAueHNdLFxcbiAgW2Z4TGF5b3V0V3JhcC5ndC14c10sXFxuICBbZnhMYXlvdXRXcmFwLnNtXSxcXG4gIFtmeExheW91dFdyYXAuZ3Qtc21dLFxcbiAgW2Z4TGF5b3V0V3JhcC5tZF0sXFxuICBbZnhMYXlvdXRXcmFwLmd0LW1kXSxcXG4gIFtmeExheW91dFdyYXAubGddLFxcbiAgW2Z4TGF5b3V0V3JhcC5ndC1sZ10sXFxuICBbZnhMYXlvdXRXcmFwLnhsXVxcblwiIH0pLFxuICAgICAgICBfX3BhcmFtJDIoMywgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSQyKDMsIF9hbmd1bGFyX2NvcmUuU2VsZigpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbTWVkaWFNb25pdG9yLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIExheW91dERpcmVjdGl2ZV0pXG4gICAgXSwgTGF5b3V0V3JhcERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIExheW91dFdyYXBEaXJlY3RpdmU7XG59KEJhc2VGeERpcmVjdGl2ZSkpO1xuXG52YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgdG8gY29udHJvbCB0aGUgc2l6ZSBvZiBhIGZsZXggaXRlbSB1c2luZyBmbGV4LWJhc2lzLCBmbGV4LWdyb3csIGFuZCBmbGV4LXNocmluay5cbiAqIENvcnJlc3BvbmRzIHRvIHRoZSBjc3MgYGZsZXhgIHNob3J0aGFuZCBwcm9wZXJ0eS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc25pcHBldHMvY3NzL2EtZ3VpZGUtdG8tZmxleGJveC9cbiAqL1xudmFyIEZsZXhEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEZsZXhEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgLy8gRXhwbGljaXRseSBAU2tpcFNlbGYgb24gTGF5b3V0RGlyZWN0aXZlIGFuZCBMYXlvdXRXcmFwRGlyZWN0aXZlIGJlY2F1c2Ugd2Ugd2FudCB0aGVcbiAgICAvLyBwYXJlbnQgZmxleCBjb250YWluZXIgZm9yIHRoaXMgZmxleCBpdGVtLlxuICAgIGZ1bmN0aW9uIEZsZXhEaXJlY3RpdmUobW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyLCBfY29udGFpbmVyLCBfd3JhcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb25pdG9yLCBlbFJlZiwgcmVuZGVyZXIpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBfY29udGFpbmVyO1xuICAgICAgICB0aGlzLl93cmFwID0gX3dyYXA7XG4gICAgICAgIC8qKiBUaGUgZmxleC1kaXJlY3Rpb24gb2YgdGhpcyBlbGVtZW50J3MgZmxleCBjb250YWluZXIuIERlZmF1bHRzIHRvICdyb3cnLiAqL1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSAncm93JztcbiAgICAgICAgdGhpcy5fY2FjaGVJbnB1dChcImZsZXhcIiwgXCJcIik7XG4gICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoXCJzaHJpbmtcIiwgMSk7XG4gICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoXCJncm93XCIsIDEpO1xuICAgICAgICBpZiAoX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBmbGV4IGl0ZW0gaXMgaW5zaWRlIG9mIGEgZmxleCBjb250YWluZXIgbWFya2VkIHdpdGhcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byBsYXlvdXQgaW1tZWRpYXRlIHBhcmVudCBkaXJlY3Rpb24gY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0V2F0Y2hlciA9IF9jb250YWluZXIubGF5b3V0JC5zdWJzY3JpYmUoZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIGBkaXJlY3Rpb25gID09PSBudWxsIGlmIHBhcmVudCBjb250YWluZXIgZG9lcyBub3QgaGF2ZSBhIGBmeExheW91dGBcbiAgICAgICAgICAgICAgICBfdGhpcy5fb25MYXlvdXRDaGFuZ2UoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmbGV4XCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KFwiZmxleFwiLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hyaW5rXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KFwic2hyaW5rXCIsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJncm93XCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KFwiZ3Jvd1wiLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmxleFhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdmbGV4WHMnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmxleEd0WHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoJ2ZsZXhHdFhzJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImZsZXhTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnZmxleFNtJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImZsZXhHdFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdmbGV4R3RTbScsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmbGV4TWRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoJ2ZsZXhNZCcsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmbGV4R3RNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnZmxleEd0TWQnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmxleExnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdmbGV4TGcnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmxleEd0TGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoJ2ZsZXhHdExnJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImZsZXhYbFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnZmxleFhsJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogRm9yIEBJbnB1dCBjaGFuZ2VzIG9uIHRoZSBjdXJyZW50IG1xIGFjdGl2YXRpb24gcHJvcGVydHksIHNlZSBvbk1lZGlhUXVlcnlDaGFuZ2VzKClcbiAgICAgKi9cbiAgICBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydmbGV4J10gIT0gbnVsbCB8fCB0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX29uTGF5b3V0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBpbml0aWFsIG9uQ2hhbmdlcywgYnVpbGQgYW4gbXFBY3RpdmF0aW9uIG9iamVjdCB0aGF0IGJyaWRnZXNcbiAgICAgKiBtcWwgY2hhbmdlIGV2ZW50cyB0byBvbk1lZGlhUXVlcnlDaGFuZ2UgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGlzdGVuRm9yTWVkaWFRdWVyeUNoYW5nZXMoJ2ZsZXgnLCAnJywgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVTdHlsZShjaGFuZ2VzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uTGF5b3V0Q2hhbmdlKCk7XG4gICAgfTtcbiAgICBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fbGF5b3V0V2F0Y2hlcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0V2F0Y2hlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWNoZXMgdGhlIHBhcmVudCBjb250YWluZXIncyAnZmxleC1kaXJlY3Rpb24nIGFuZCB1cGRhdGVzIHRoZSBlbGVtZW50J3Mgc3R5bGUuXG4gICAgICogVXNlZCBhcyBhIGhhbmRsZXIgZm9yIGxheW91dCBjaGFuZ2UgZXZlbnRzIGZyb20gdGhlIHBhcmVudCBmbGV4IGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZS5fb25MYXlvdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IGRpcmVjdGlvbiB8fCB0aGlzLl9sYXlvdXQgfHwgXCJyb3dcIjtcbiAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGUoKTtcbiAgICB9O1xuICAgIEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZmxleEJhc2lzID0gdmFsdWUgfHwgdGhpcy5fcXVlcnlJbnB1dChcImZsZXhcIikgfHwgJyc7XG4gICAgICAgIGlmICh0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIGZsZXhCYXNpcyA9IHRoaXMuX21xQWN0aXZhdGlvbi5hY3RpdmF0ZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBseVN0eWxlVG9FbGVtZW50KHRoaXMuX3ZhbGlkYXRlVmFsdWUuYXBwbHkodGhpcywgdGhpcy5fcGFyc2VGbGV4UGFydHMoU3RyaW5nKGZsZXhCYXNpcykpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXNlZCB0aGUgc2hvcnQtZm9ybSBgZnhGbGV4PVwiMSAwIDM3JVwiYCwgdGhlbiBwYXJzZSB0aGUgcGFydHNcbiAgICAgKi9cbiAgICBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZS5fcGFyc2VGbGV4UGFydHMgPSBmdW5jdGlvbiAoYmFzaXMpIHtcbiAgICAgICAgYmFzaXMgPSBiYXNpcy5yZXBsYWNlKFwiO1wiLCBcIlwiKTtcbiAgICAgICAgdmFyIGhhc0NhbGMgPSBiYXNpcyAmJiBiYXNpcy5pbmRleE9mKFwiY2FsY1wiKSA+IC0xO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICFoYXNDYWxjID8gYmFzaXMuc3BsaXQoXCIgXCIpIDogdGhpcy5fZ2V0UGFydHNXaXRoQ2FsYyhiYXNpcy50cmltKCkpO1xuICAgICAgICByZXR1cm4gKG1hdGNoZXMubGVuZ3RoID09PSAzKSA/IG1hdGNoZXMgOiBbdGhpcy5fcXVlcnlJbnB1dChcImdyb3dcIiksXG4gICAgICAgICAgICB0aGlzLl9xdWVyeUlucHV0KFwic2hyaW5rXCIpLCBiYXNpc107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IG1vcmUgY29tcGxpY2F0ZWQgc2hvcnQtaGFuZCB2ZXJzaW9ucy5cbiAgICAgKiBlLmcuXG4gICAgICogZnhGbGV4PVwiMyAzIGNhbGMoMTVlbSArIDIwcHgpXCJcbiAgICAgKi9cbiAgICBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZS5fZ2V0UGFydHNXaXRoQ2FsYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBbdGhpcy5fcXVlcnlJbnB1dChcImdyb3dcIiksIHRoaXMuX3F1ZXJ5SW5wdXQoXCJzaHJpbmtcIiksIHZhbHVlXTtcbiAgICAgICAgdmFyIGogPSB2YWx1ZS5pbmRleE9mKCdjYWxjJyk7XG4gICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgcGFydHNbMl0gPSB2YWx1ZS5zdWJzdHJpbmcoaik7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHZhbHVlLnN1YnN0cigwLCBqKS50cmltKCkuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1swXSA9IG1hdGNoZXNbMF07XG4gICAgICAgICAgICAgICAgcGFydHNbMV0gPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSB2YWx1ZSB0byBiZSBvbmUgb2YgdGhlIGFjY2VwdGFibGUgdmFsdWUgb3B0aW9uc1xuICAgICAqIFVzZSBkZWZhdWx0IGZhbGxiYWNrIG9mIFwicm93XCJcbiAgICAgKi9cbiAgICBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZS5fdmFsaWRhdGVWYWx1ZSA9IGZ1bmN0aW9uIChncm93LCBzaHJpbmssIGJhc2lzKSB7XG4gICAgICAgIHZhciBjc3MsIGlzVmFsdWU7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAodGhpcy5fbGF5b3V0ID09PSAnY29sdW1uJykgfHwgKHRoaXMuX2xheW91dCA9PSAnY29sdW1uLXJldmVyc2UnKSA/XG4gICAgICAgICAgICAnY29sdW1uJyA6XG4gICAgICAgICAgICAncm93JztcbiAgICAgICAgaWYgKGdyb3cgPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIGdyb3cgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaHJpbmsgPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHNocmluayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmxleC1iYXNpcyBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIGluaXRpYWwvc3RhcnRpbmcgbWFpbi1heGlzIHNpemUgb2YgdGhlIGVsZW1lbnQsXG4gICAgICAgIC8vIGJlZm9yZSBhbnl0aGluZyBlbHNlIGlzIGNvbXB1dGVkLiBJdCBjYW4gZWl0aGVyIGJlIGEgcGVyY2VudGFnZSBvciBhbiBhYnNvbHV0ZSB2YWx1ZS5cbiAgICAgICAgLy8gSXQgaXMsIGhvd2V2ZXIsIG5vdCB0aGUgYnJlYWtpbmcgcG9pbnQgZm9yIGZsZXgtZ3Jvdy9zaHJpbmsgcHJvcGVydGllc1xuICAgICAgICAvL1xuICAgICAgICAvLyBmbGV4LWdyb3cgY2FuIGJlIHNlZW4gYXMgdGhpczpcbiAgICAgICAgLy8gICAwOiBEbyBub3Qgc3RyZXRjaC4gRWl0aGVyIHNpemUgdG8gZWxlbWVudCdzIGNvbnRlbnQgd2lkdGgsIG9yIG9iZXkgJ2ZsZXgtYmFzaXMnLlxuICAgICAgICAvLyAgIDE6IChEZWZhdWx0IHZhbHVlKS4gU3RyZXRjaDsgd2lsbCBiZSB0aGUgc2FtZSBzaXplIHRvIGFsbCBvdGhlciBmbGV4IGl0ZW1zIG9uXG4gICAgICAgIC8vICAgICAgIHRoZSBzYW1lIHJvdyBzaW5jZSB0aGV5IGhhdmUgYSBkZWZhdWx0IHZhbHVlIG9mIDEuXG4gICAgICAgIC8vICAg4omlMiAoaW50ZWdlciBuKTogU3RyZXRjaC4gV2lsbCBiZSBuIHRpbWVzIHRoZSBzaXplIG9mIG90aGVyIGVsZW1lbnRzXG4gICAgICAgIC8vICAgICAgd2l0aCAnZmxleC1ncm93OiAxJyBvbiB0aGUgc2FtZSByb3cuXG4gICAgICAgIC8vIFVzZSBgbnVsbGAgdG8gY2xlYXIgZXhpc3Rpbmcgc3R5bGVzLlxuICAgICAgICB2YXIgY2xlYXJTdHlsZXMgPSB7XG4gICAgICAgICAgICAnbWF4LXdpZHRoJzogbnVsbCxcbiAgICAgICAgICAgICdtYXgtaGVpZ2h0JzogbnVsbCxcbiAgICAgICAgICAgICdtaW4td2lkdGgnOiBudWxsLFxuICAgICAgICAgICAgJ21pbi1oZWlnaHQnOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAoYmFzaXMgfHwgJycpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICAgY3NzID0gZXh0ZW5kT2JqZWN0KGNsZWFyU3R5bGVzLCB7ICdmbGV4JzogJzEgMSAwLjAwMDAwMDAwMXB4JyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWwnOiAvLyBkZWZhdWx0XG4gICAgICAgICAgICBjYXNlICdub2dyb3cnOlxuICAgICAgICAgICAgICAgIGdyb3cgPSAwO1xuICAgICAgICAgICAgICAgIGNzcyA9IGV4dGVuZE9iamVjdChjbGVhclN0eWxlcywgeyAnZmxleCc6ICcwIDEgYXV0bycgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdncm93JzpcbiAgICAgICAgICAgICAgICBjc3MgPSBleHRlbmRPYmplY3QoY2xlYXJTdHlsZXMsIHsgJ2ZsZXgnOiAnMSAxIDEwMCUnIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9zaHJpbmsnOlxuICAgICAgICAgICAgICAgIHNocmluayA9IDA7XG4gICAgICAgICAgICAgICAgY3NzID0gZXh0ZW5kT2JqZWN0KGNsZWFyU3R5bGVzLCB7ICdmbGV4JzogJzEgMCBhdXRvJyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICAgICAgICAgIGNzcyA9IGV4dGVuZE9iamVjdChjbGVhclN0eWxlcywgeyAnZmxleCc6IGdyb3cgKyBcIiBcIiArIHNocmluayArIFwiIGF1dG9cIiB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIGdyb3cgPSAwO1xuICAgICAgICAgICAgICAgIHNocmluayA9IDA7XG4gICAgICAgICAgICAgICAgY3NzID0gZXh0ZW5kT2JqZWN0KGNsZWFyU3R5bGVzLCB7ICdmbGV4JzogJzAgMCBhdXRvJyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIGlzUGVyY2VudCA9IFN0cmluZyhiYXNpcykuaW5kZXhPZignJScpID4gLTE7XG4gICAgICAgICAgICAgICAgaXNWYWx1ZSA9IFN0cmluZyhiYXNpcykuaW5kZXhPZigncHgnKSA+IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIFN0cmluZyhiYXNpcykuaW5kZXhPZignY2FsYycpID4gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nKGJhc2lzKS5pbmRleE9mKCdlbScpID4gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nKGJhc2lzKS5pbmRleE9mKCd2dycpID4gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nKGJhc2lzKS5pbmRleE9mKCd2aCcpID4gLTE7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gcGVyY2VudGFnZSBzaXppbmcgdW5sZXNzIGBweGAgaXMgZXhwbGljaXRseSBzZXRcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsdWUgJiYgIWlzUGVyY2VudCAmJiAhaXNOYU4oYmFzaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzID0gYmFzaXMgKyAnJSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYXNpcyA9PT0gJzBweCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSAnMCUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXQgbWF4LXdpZHRoID0gYmFzaXMgaWYgdXNpbmcgbGF5b3V0LXdyYXBcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhpbGlwd2FsdG9uL2ZsZXhidWdzIzExLW1pbi1hbmQtbWF4LXNpemUtZGVjbGFyYXRpb25zLWFyZS1pZ25vcmVkLXdoZW4td3JhcHBpZmwtZmxleC1pdGVtc1xuICAgICAgICAgICAgICAgIGNzcyA9IGV4dGVuZE9iamVjdChjbGVhclN0eWxlcywge1xuICAgICAgICAgICAgICAgICAgICAnZmxleCc6IGdyb3cgKyBcIiBcIiArIHNocmluayArIFwiIFwiICsgKChpc1ZhbHVlIHx8IHRoaXMuX3dyYXApID8gYmFzaXMgOiAnMTAwJScpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXggPSAoZGlyZWN0aW9uID09PSAncm93JykgPyAnbWF4LXdpZHRoJyA6ICdtYXgtaGVpZ2h0JztcbiAgICAgICAgdmFyIG1pbiA9IChkaXJlY3Rpb24gPT09ICdyb3cnKSA/ICdtaW4td2lkdGgnIDogJ21pbi1oZWlnaHQnO1xuICAgICAgICB2YXIgdXNpbmdDYWxjID0gKFN0cmluZyhiYXNpcykuaW5kZXhPZignY2FsYycpID4gLTEpIHx8IChiYXNpcyA9PSAnYXV0bycpO1xuICAgICAgICB2YXIgaXNQeCA9IFN0cmluZyhiYXNpcykuaW5kZXhPZigncHgnKSA+IC0xIHx8IHVzaW5nQ2FsYztcbiAgICAgICAgLy8gbWFrZSBib3ggaW5mbGV4aWJsZSB3aGVuIHNocmluayBhbmQgZ3JvdyBhcmUgYm90aCB6ZXJvXG4gICAgICAgIC8vIHNob3VsZCBub3Qgc2V0IGEgbWluIHdoZW4gdGhlIGdyb3cgaXMgemVyb1xuICAgICAgICAvLyBzaG91bGQgbm90IHNldCBhIG1heCB3aGVuIHRoZSBzaHJpbmsgaXMgemVyb1xuICAgICAgICB2YXIgaXNGaXhlZCA9ICFncm93ICYmICFzaHJpbms7XG4gICAgICAgIGNzc1ttaW5dID0gKGJhc2lzID09ICcwJScpID8gMCA6IGlzRml4ZWQgfHwgKGlzUHggJiYgZ3JvdykgPyBiYXNpcyA6IG51bGw7XG4gICAgICAgIGNzc1ttYXhdID0gKGJhc2lzID09ICcwJScpID8gMCA6IGlzRml4ZWQgfHwgKCF1c2luZ0NhbGMgJiYgc2hyaW5rKSA/IGJhc2lzIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIGV4dGVuZE9iamVjdChjc3MsIHsgJ2JveC1zaXppbmcnOiAnYm9yZGVyLWJveCcgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEZsZXgnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImZsZXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhTaHJpbmsnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcInNocmlua1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEdyb3cnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImdyb3dcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4LnhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmbGV4WHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4Lmd0LXhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmbGV4R3RYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEZsZXguc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImZsZXhTbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEZsZXguZ3Qtc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImZsZXhHdFNtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleC5tZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmxleE1kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleC5ndC1tZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmxleEd0TWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4LmxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmbGV4TGdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4Lmd0LWxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmbGV4R3RMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEZsZXgueGwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhEaXJlY3RpdmUucHJvdG90eXBlLCBcImZsZXhYbFwiLCBudWxsKTtcbiAgICBGbGV4RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogXCJcXG4gIFtmeEZsZXhdLFxcbiAgW2Z4RmxleC54c10sXFxuICBbZnhGbGV4Lmd0LXhzXSxcXG4gIFtmeEZsZXguc21dLFxcbiAgW2Z4RmxleC5ndC1zbV0sXFxuICBbZnhGbGV4Lm1kXSxcXG4gIFtmeEZsZXguZ3QtbWRdLFxcbiAgW2Z4RmxleC5sZ10sXFxuICBbZnhGbGV4Lmd0LWxnXSxcXG4gIFtmeEZsZXgueGxdXFxuXCJcbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMSgzLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtJDEoMywgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpKSxcbiAgICAgICAgX19wYXJhbSQxKDQsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kMSg0LCBfYW5ndWxhcl9jb3JlLlNraXBTZWxmKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246cGFyYW10eXBlcycsIFtNZWRpYU1vbml0b3IsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgTGF5b3V0RGlyZWN0aXZlLCBMYXlvdXRXcmFwRGlyZWN0aXZlXSlcbiAgICBdLCBGbGV4RGlyZWN0aXZlKTtcbiAgICByZXR1cm4gRmxleERpcmVjdGl2ZTtcbn0oQmFzZUZ4RGlyZWN0aXZlKSk7XG5cbnZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDMgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgRkFMU1kgPSBbJ2ZhbHNlJywgZmFsc2UsIDBdO1xuLyoqXG4gKiBGb3IgZnhIaWRlIHNlbGVjdG9ycywgd2UgaW52ZXJ0IHRoZSAndmFsdWUnXG4gKiBhbmQgYXNzaWduIHRvIHRoZSBlcXVpdmFsZW50IGZ4U2hvdyBzZWxlY3RvciBjYWNoZVxuICogIC0gV2hlbiAnaGlkZScgPT09ICcnID09PSB0cnVlLCBkbyBOT1Qgc2hvdyB0aGUgZWxlbWVudFxuICogIC0gV2hlbiAnaGlkZScgPT09IGZhbHNlIG9yIDAuLi4gd2UgV0lMTCBzaG93IHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0aXZlT2YoaGlkZSkge1xuICAgIHJldHVybiAoaGlkZSA9PT0gXCJcIikgPyBmYWxzZSA6XG4gICAgICAgICgoaGlkZSA9PT0gXCJmYWxzZVwiKSB8fCAoaGlkZSA9PT0gMCkpID8gdHJ1ZSA6ICFoaWRlO1xufVxuLyoqXG4gKiAnc2hvdycgTGF5b3V0IEFQSSBkaXJlY3RpdmVcbiAqXG4gKi9cbnZhciBTaG93SGlkZURpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDQoU2hvd0hpZGVEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTaG93SGlkZURpcmVjdGl2ZShtb25pdG9yLCBfbGF5b3V0LCBlbFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gX2xheW91dDtcbiAgICAgICAgdGhpcy5lbFJlZiA9IGVsUmVmO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXkgPSB0aGlzLl9nZXREaXNwbGF5U3R5bGUoKTsgLy8gcmUtaW52b2tlIG92ZXJyaWRlIHRvIHVzZSBgdGhpcy5fbGF5b3V0YFxuICAgICAgICBpZiAoX2xheW91dCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgTGF5b3V0IGNhbiBzZXQgdGhlIGRpc3BsYXk6ZmxleCAoYW5kIGluY29ycmVjdGx5IGFmZmVjdCB0aGUgSGlkZS9TaG93IGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICAgKiBXaGVuZXZlciBMYXlvdXQgW29uIHRoZSBzYW1lIGVsZW1lbnRdIHJlc2V0cyBpdHMgQ1NTLCB0aGVuIHVwZGF0ZSB0aGUgSGlkZS9TaG93IENTU1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRXYXRjaGVyID0gX2xheW91dC5sYXlvdXQkLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlV2l0aFZhbHVlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dChcInNob3dcIiwgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoaWRlXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KFwic2hvd1wiLCBuZWdhdGl2ZU9mKHZhbCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInNob3dYc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd1hzJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoaWRlWHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoXCJzaG93WHNcIiwgbmVnYXRpdmVPZih2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93R3RYc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd0d0WHMnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVHdFhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93R3RYcycsIG5lZ2F0aXZlT2YodmFsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd1NtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93U20nLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd1NtJywgbmVnYXRpdmVPZih2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93R3RTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd0d0U20nLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVHdFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93R3RTbScsIG5lZ2F0aXZlT2YodmFsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd01kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93TWQnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd01kJywgbmVnYXRpdmVPZih2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93R3RNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd0d0TWQnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVHdE1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93R3RNZCcsIG5lZ2F0aXZlT2YodmFsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd0xnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93TGcnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVMZ1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd0xnJywgbmVnYXRpdmVPZih2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93R3RMZ1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd0d0TGcnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVHdExnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93R3RMZycsIG5lZ2F0aXZlT2YodmFsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd1hsXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdzaG93WGwnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVYbFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnc2hvd1hsJywgbmVnYXRpdmVPZih2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTGlmZWN5Y2xlIE1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBhY2Nlc3NvciB0byB0aGUgY3VycmVudCBIVE1MRWxlbWVudCdzIGBkaXNwbGF5YCBzdHlsZVxuICAgICAqIE5vdGU6IFNob3cvSGlkZSB3aWxsIG5vdCBjaGFuZ2UgdGhlIGRpc3BsYXkgdG8gJ2ZsZXgnIGJ1dCB3aWxsIHNldCBpdCB0byAnYmxvY2snXG4gICAgICogdW5sZXNzIGl0IHdhcyBhbHJlYWR5IGV4cGxpY2l0bHkgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUuX2dldERpc3BsYXlTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dCA/IFwiZmxleFwiIDogX3N1cGVyLnByb3RvdHlwZS5fZ2V0RGlzcGxheVN0eWxlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2VzIHRvIGFueSBASW5wdXQgcHJvcGVydGllcy4uLlxuICAgICAqIERlZmF1bHQgdG8gdXNlIHRoZSBub24tcmVzcG9uc2l2ZSBJbnB1dCB2YWx1ZSAoJ2Z4U2hvdycpXG4gICAgICogVGhlbiBjb25kaXRpb25hbGx5IG92ZXJyaWRlIHdpdGggdGhlIG1xLWFjdGl2YXRlZCBJbnB1dCdzIGN1cnJlbnQgdmFsdWVcbiAgICAgKi9cbiAgICBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snc2hvdyddICE9IG51bGwgfHwgdGhpcy5fbXFBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVXaXRoVmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGluaXRpYWwgb25DaGFuZ2VzLCBidWlsZCBhbiBtcUFjdGl2YXRpb24gb2JqZWN0IHRoYXQgYnJpZGdlc1xuICAgICAqIG1xbCBjaGFuZ2UgZXZlbnRzIHRvIG9uTWVkaWFRdWVyeUNoYW5nZSBoYW5kbGVyc1xuICAgICAqL1xuICAgIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0RGVmYXVsdFZhbChcInNob3dcIiwgdHJ1ZSk7XG4gICAgICAgIC8vIEJ1aWxkIF9tcUFjdGl2YXRpb24gY29udHJvbGxlclxuICAgICAgICB0aGlzLl9saXN0ZW5Gb3JNZWRpYVF1ZXJ5Q2hhbmdlcygnc2hvdycsIHZhbHVlLCBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVdpdGhWYWx1ZShjaGFuZ2VzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdpdGhWYWx1ZSgpO1xuICAgIH07XG4gICAgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25EZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9sYXlvdXRXYXRjaGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRXYXRjaGVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8vIFByb3RlY3RlZCBtZXRob2RzXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLyoqIFZhbGlkYXRlIHRoZSB2aXNpYmlsaXR5IHZhbHVlIGFuZCB0aGVuIHVwZGF0ZSB0aGUgaG9zdCdzIGlubGluZSBkaXNwbGF5IHN0eWxlICovXG4gICAgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVXaXRoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCB0aGlzLl9nZXREZWZhdWx0VmFsKFwic2hvd1wiLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuX21xQWN0aXZhdGlvbikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9tcUFjdGl2YXRpb24uYWN0aXZhdGVkSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZFNob3cgPSB0aGlzLl92YWxpZGF0ZVRydXRoeSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2FwcGx5U3R5bGVUb0VsZW1lbnQodGhpcy5fYnVpbGRDU1Moc2hvdWxkU2hvdykpO1xuICAgIH07XG4gICAgLyoqIEJ1aWxkIHRoZSBDU1MgdGhhdCBzaG91bGQgYmUgYXNzaWduZWQgdG8gdGhlIGVsZW1lbnQgaW5zdGFuY2UgKi9cbiAgICBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUuX2J1aWxkQ1NTID0gZnVuY3Rpb24gKHNob3cpIHtcbiAgICAgICAgcmV0dXJuIHsgJ2Rpc3BsYXknOiBzaG93ID8gdGhpcy5fZGlzcGxheSA6ICdub25lJyB9O1xuICAgIH07XG4gICAgLyoqICBWYWxpZGF0ZSB0aGUgdG8gYmUgbm90IEZBTFNZICovXG4gICAgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLl92YWxpZGF0ZVRydXRoeSA9IGZ1bmN0aW9uIChzaG93KSB7XG4gICAgICAgIHJldHVybiAoRkFMU1kuaW5kZXhPZihzaG93KSA9PSAtMSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeFNob3cnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4SGlkZScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhTaG93LnhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd1hzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4SGlkZS54cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeFNob3cuZ3QteHMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93R3RYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEhpZGUuZ3QteHMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoaWRlR3RYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeFNob3cuc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhIaWRlLnNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGlkZVNtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4U2hvdy5ndC1zbScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInNob3dHdFNtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4SGlkZS5ndC1zbScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVHdFNtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4U2hvdy5tZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInNob3dNZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEhpZGUubWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoaWRlTWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhTaG93Lmd0LW1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd0d0TWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhIaWRlLmd0LW1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGlkZUd0TWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhTaG93LmxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hvd0xnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4SGlkZS5sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU2hvd0hpZGVEaXJlY3RpdmUucHJvdG90eXBlLCBcImhpZGVMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeFNob3cuZ3QtbGcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93R3RMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeEhpZGUuZ3QtbGcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoaWRlR3RMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeFNob3cueGwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFNob3dIaWRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93WGxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhIaWRlLnhsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTaG93SGlkZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGlkZVhsXCIsIG51bGwpO1xuICAgIFNob3dIaWRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6IFwiXFxuICBbZnhTaG93XSxcXG4gIFtmeFNob3cueHNdLFtmeFNob3cuZ3QteHNdLFtmeFNob3cuc21dLFtmeFNob3cuZ3Qtc21dLFxcbiAgW2Z4U2hvdy5tZF0sW2Z4U2hvdy5ndC1tZF0sW2Z4U2hvdy5sZ10sW2Z4U2hvdy5ndC1sZ10sW2Z4U2hvdy54bF0sICBcXG4gIFtmeEhpZGVdLFxcbiAgW2Z4SGlkZS54c10sW2Z4SGlkZS5ndC14c10sW2Z4SGlkZS5zbV0sW2Z4SGlkZS5ndC1zbV0sXFxuICBbZnhIaWRlLm1kXSxbZnhIaWRlLmd0LW1kXSxbZnhIaWRlLmxnXSxbZnhIaWRlLmd0LWxnXSxbZnhIaWRlLnhsXSAgXFxuXCJcbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMygxLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtJDMoMSwgX2FuZ3VsYXJfY29yZS5TZWxmKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtNZWRpYU1vbml0b3IsIExheW91dERpcmVjdGl2ZSwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBTaG93SGlkZURpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIFNob3dIaWRlRGlyZWN0aXZlO1xufShCYXNlRnhEaXJlY3RpdmUpKTtcblxudmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDEwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqICdmbGV4LWFsaWduJyBmbGV4Ym94IHN0eWxpbmcgZGlyZWN0aXZlXG4gKiBBbGxvd3MgZWxlbWVudC1zcGVjaWZpYyBvdmVycmlkZXMgZm9yIGNyb3NzLWF4aXMgYWxpZ25tZW50cyBpbiBhIGxheW91dCBjb250YWluZXJcbiAqIEBzZWUgaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9hbG1hbmFjL3Byb3BlcnRpZXMvYS9hbGlnbi1zZWxmL1xuICovXG52YXIgRmxleEFsaWduRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkNShGbGV4QWxpZ25EaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmxleEFsaWduRGlyZWN0aXZlKG1vbml0b3IsIGVsUmVmLCByZW5kZXJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb25pdG9yLCBlbFJlZiwgcmVuZGVyZXIpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnblwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnYWxpZ24nLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnblhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnblhzJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdFhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnbkd0WHMnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnblNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnblNtJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnbkd0U20nLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbk1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnbk1kJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdE1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnbkd0TWQnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbkxnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnbkxnJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdExnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnbkd0TGcnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnblhsXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdhbGlnblhsJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTGlmZWN5Y2xlIE1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBGb3IgQElucHV0IGNoYW5nZXMgb24gdGhlIGN1cnJlbnQgbXEgYWN0aXZhdGlvbiBwcm9wZXJ0eSwgc2VlIG9uTWVkaWFRdWVyeUNoYW5nZXMoKVxuICAgICAqL1xuICAgIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snYWxpZ24nXSAhPSBudWxsIHx8IHRoaXMuX21xQWN0aXZhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlV2l0aFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBpbml0aWFsIG9uQ2hhbmdlcywgYnVpbGQgYW4gbXFBY3RpdmF0aW9uIG9iamVjdCB0aGF0IGJyaWRnZXNcbiAgICAgKiBtcWwgY2hhbmdlIGV2ZW50cyB0byBvbk1lZGlhUXVlcnlDaGFuZ2UgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBGbGV4QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saXN0ZW5Gb3JNZWRpYVF1ZXJ5Q2hhbmdlcygnYWxpZ24nLCAnc3RyZXRjaCcsIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlV2l0aFZhbHVlKGNoYW5nZXMudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2l0aFZhbHVlKCk7XG4gICAgfTtcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBQcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVdpdGhWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IHRoaXMuX3F1ZXJ5SW5wdXQoXCJhbGlnblwiKSB8fCAnc3RyZXRjaCc7XG4gICAgICAgIGlmICh0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fbXFBY3RpdmF0aW9uLmFjdGl2YXRlZElucHV0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcGx5U3R5bGVUb0VsZW1lbnQodGhpcy5fYnVpbGRDU1ModmFsdWUpKTtcbiAgICB9O1xuICAgIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2J1aWxkQ1NTID0gZnVuY3Rpb24gKGFsaWduKSB7XG4gICAgICAgIHZhciBjc3MgPSB7fTtcbiAgICAgICAgLy8gQ3Jvc3MtYXhpc1xuICAgICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgY3NzWydhbGlnbi1zZWxmJ10gPSAnZmxleC1zdGFydCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIGNzc1snYWxpZ24tc2VsZiddID0gJ2ZsZXgtZW5kJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY3NzWydhbGlnbi1zZWxmJ10gPSBhbGlnbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3NzO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleEFsaWduJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleEFsaWduLnhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25Yc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4QWxpZ24uZ3QteHMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbkd0WHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleEFsaWduLnNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25TbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4QWxpZ24uZ3Qtc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbkd0U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleEFsaWduLm1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25NZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4QWxpZ24uZ3QtbWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbkd0TWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleEFsaWduLmxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25MZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4QWxpZ24uZ3QtbGcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbkd0TGdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleEFsaWduLnhsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25YbFwiLCBudWxsKTtcbiAgICBGbGV4QWxpZ25EaXJlY3RpdmUgPSBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6IFwiXFxuICBbZnhGbGV4QWxpZ25dLFxcbiAgW2Z4RmxleEFsaWduLnhzXSxcXG4gIFtmeEZsZXhBbGlnbi5ndC14c10sXFxuICBbZnhGbGV4QWxpZ24uc21dLFxcbiAgW2Z4RmxleEFsaWduLmd0LXNtXSxcXG4gIFtmeEZsZXhBbGlnbi5tZF0sXFxuICBbZnhGbGV4QWxpZ24uZ3QtbWRdLFxcbiAgW2Z4RmxleEFsaWduLmxnXSxcXG4gIFtmeEZsZXhBbGlnbi5ndC1sZ10sXFxuICBbZnhGbGV4QWxpZ24ueGxdXFxuXCJcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtNZWRpYU1vbml0b3IsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlcl0pXG4gICAgXSwgRmxleEFsaWduRGlyZWN0aXZlKTtcbiAgICByZXR1cm4gRmxleEFsaWduRGlyZWN0aXZlO1xufShCYXNlRnhEaXJlY3RpdmUpKTtcblxudmFyIF9fZXh0ZW5kcyQ2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDExID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDExID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgRkxFWF9GSUxMX0NTUyA9IHtcbiAgICAnbWFyZ2luJzogMCxcbiAgICAnd2lkdGgnOiAnMTAwJScsXG4gICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAnbWluLXdpZHRoJzogJzEwMCUnLFxuICAgICdtaW4taGVpZ2h0JzogJzEwMCUnXG59O1xuLyoqXG4gKiAnZnhGaWxsJyBmbGV4Ym94IHN0eWxpbmcgZGlyZWN0aXZlXG4gKiAgTWF4aW1pemVzIHdpZHRoIGFuZCBoZWlnaHQgb2YgZWxlbWVudCBpbiBhIGxheW91dCBjb250YWluZXJcbiAqXG4gKiAgTk9URTogZnhGaWxsIGlzIE5PVCByZXNwb25zaXZlIEFQSSEhXG4gKi9cbnZhciBGbGV4RmlsbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDYoRmxleEZpbGxEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmxleEZpbGxEaXJlY3RpdmUobW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vbml0b3IsIGVsUmVmLCByZW5kZXJlcik7XG4gICAgICAgIHRoaXMuZWxSZWYgPSBlbFJlZjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLl9hcHBseVN0eWxlVG9FbGVtZW50KEZMRVhfRklMTF9DU1MpO1xuICAgIH1cbiAgICBGbGV4RmlsbERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkMTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiBcIlxcbiAgW2Z4RmlsbF0sXFxuICBbZnhGbGV4RmlsbF1cXG5cIiB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW01lZGlhTW9uaXRvciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBGbGV4RmlsbERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIEZsZXhGaWxsRGlyZWN0aXZlO1xufShCYXNlRnhEaXJlY3RpdmUpKTtcblxudmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDEyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqICdmbGV4LW9mZnNldCcgZmxleGJveCBzdHlsaW5nIGRpcmVjdGl2ZVxuICogQ29uZmlndXJlcyB0aGUgJ21hcmdpbi1sZWZ0JyBvZiB0aGUgZWxlbWVudCBpbiBhIGxheW91dCBjb250YWluZXJcbiAqL1xudmFyIEZsZXhPZmZzZXREaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ3KEZsZXhPZmZzZXREaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmxleE9mZnNldERpcmVjdGl2ZShtb25pdG9yLCBlbFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdvZmZzZXQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9mZnNldERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0WHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnb2Zmc2V0WHMnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9mZnNldERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0R3RYc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdvZmZzZXRHdFhzJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ29mZnNldFNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldEd0U21cIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnb2Zmc2V0R3RTbScsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdvZmZzZXRNZCcsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRHdE1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ29mZnNldEd0TWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9mZnNldERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0TGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnb2Zmc2V0TGcnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9mZnNldERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0R3RMZ1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdvZmZzZXRHdExnJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldFhsXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ29mZnNldFhsJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTGlmZWN5Y2xlIE1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBGb3IgQElucHV0IGNoYW5nZXMgb24gdGhlIGN1cnJlbnQgbXEgYWN0aXZhdGlvbiBwcm9wZXJ0eSwgc2VlIG9uTWVkaWFRdWVyeUNoYW5nZXMoKVxuICAgICAqL1xuICAgIEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ29mZnNldCddICE9IG51bGwgfHwgdGhpcy5fbXFBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVXaXRoVmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGluaXRpYWwgb25DaGFuZ2VzLCBidWlsZCBhbiBtcUFjdGl2YXRpb24gb2JqZWN0IHRoYXQgYnJpZGdlc1xuICAgICAqIG1xbCBjaGFuZ2UgZXZlbnRzIHRvIG9uTWVkaWFRdWVyeUNoYW5nZSBoYW5kbGVyc1xuICAgICAqL1xuICAgIEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saXN0ZW5Gb3JNZWRpYVF1ZXJ5Q2hhbmdlcygnb2Zmc2V0JywgMCwgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVXaXRoVmFsdWUoY2hhbmdlcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gUHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlV2l0aFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgfHwgdGhpcy5fcXVlcnlJbnB1dChcIm9mZnNldFwiKSB8fCAwO1xuICAgICAgICBpZiAodGhpcy5fbXFBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX21xQWN0aXZhdGlvbi5hY3RpdmF0ZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBseVN0eWxlVG9FbGVtZW50KHRoaXMuX2J1aWxkQ1NTKHZhbHVlKSk7XG4gICAgfTtcbiAgICBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZS5fYnVpbGRDU1MgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBpc1BlcmNlbnQgPSBTdHJpbmcob2Zmc2V0KS5pbmRleE9mKCclJykgPiAtMTtcbiAgICAgICAgdmFyIGlzUHggPSBTdHJpbmcob2Zmc2V0KS5pbmRleE9mKCdweCcpID4gLTE7XG4gICAgICAgIGlmICghaXNQeCAmJiAhaXNQZXJjZW50ICYmICFpc05hTihvZmZzZXQpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyAnJSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ21hcmdpbi1sZWZ0JzogXCJcIiArIG9mZnNldCB9O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQxMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9mZnNldCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9mZnNldC54cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T2Zmc2V0Lmd0LXhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldEd0WHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9mZnNldC5zbScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRTbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T2Zmc2V0Lmd0LXNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldEd0U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9mZnNldC5tZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRNZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T2Zmc2V0Lmd0LW1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldEd0TWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9mZnNldC5sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T2Zmc2V0Lmd0LWxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPZmZzZXREaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldEd0TGdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9mZnNldC54bCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBGbGV4T2Zmc2V0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRYbFwiLCBudWxsKTtcbiAgICBGbGV4T2Zmc2V0RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6IFwiXFxuICBbZnhGbGV4T2Zmc2V0XSxcXG4gIFtmeEZsZXhPZmZzZXQueHNdLFxcbiAgW2Z4RmxleE9mZnNldC5ndC14c10sXFxuICBbZnhGbGV4T2Zmc2V0LnNtXSxcXG4gIFtmeEZsZXhPZmZzZXQuZ3Qtc21dLFxcbiAgW2Z4RmxleE9mZnNldC5tZF0sXFxuICBbZnhGbGV4T2Zmc2V0Lmd0LW1kXSxcXG4gIFtmeEZsZXhPZmZzZXQubGddLFxcbiAgW2Z4RmxleE9mZnNldC5ndC1sZ10sXFxuICBbZnhGbGV4T2Zmc2V0LnhsXVxcblwiIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMignZGVzaWduOnBhcmFtdHlwZXMnLCBbTWVkaWFNb25pdG9yLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIEZsZXhPZmZzZXREaXJlY3RpdmUpO1xuICAgIHJldHVybiBGbGV4T2Zmc2V0RGlyZWN0aXZlO1xufShCYXNlRnhEaXJlY3RpdmUpKTtcblxudmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDEzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqICdmbGV4LW9yZGVyJyBmbGV4Ym94IHN0eWxpbmcgZGlyZWN0aXZlXG4gKiBDb25maWd1cmVzIHRoZSBwb3NpdGlvbmFsIG9yZGVyaW5nIG9mIHRoZSBlbGVtZW50IGluIGEgc29ydGVkIGxheW91dCBjb250YWluZXJcbiAqIEBzZWUgaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9hbG1hbmFjL3Byb3BlcnRpZXMvby9vcmRlci9cbiAqL1xudmFyIEZsZXhPcmRlckRpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDgoRmxleE9yZGVyRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZsZXhPcmRlckRpcmVjdGl2ZShtb25pdG9yLCBlbFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnb3JkZXInLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlclhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ29yZGVyWHMnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckd0WHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnb3JkZXJHdFhzJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdvcmRlclNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJHdFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ29yZGVyR3RTbScsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4T3JkZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9yZGVyTWRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnb3JkZXJNZCcsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGbGV4T3JkZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9yZGVyR3RNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdvcmRlckd0TWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckxnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ29yZGVyTGcnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckd0TGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnb3JkZXJHdExnJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJYbFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdvcmRlclhsJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTGlmZWN5Y2xlIE1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBGb3IgQElucHV0IGNoYW5nZXMgb24gdGhlIGN1cnJlbnQgbXEgYWN0aXZhdGlvbiBwcm9wZXJ0eSwgc2VlIG9uTWVkaWFRdWVyeUNoYW5nZXMoKVxuICAgICAqL1xuICAgIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snb3JkZXInXSAhPSBudWxsIHx8IHRoaXMuX21xQWN0aXZhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlV2l0aFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBpbml0aWFsIG9uQ2hhbmdlcywgYnVpbGQgYW4gbXFBY3RpdmF0aW9uIG9iamVjdCB0aGF0IGJyaWRnZXNcbiAgICAgKiBtcWwgY2hhbmdlIGV2ZW50cyB0byBvbk1lZGlhUXVlcnlDaGFuZ2UgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBGbGV4T3JkZXJEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saXN0ZW5Gb3JNZWRpYVF1ZXJ5Q2hhbmdlcygnb3JkZXInLCAnMCcsIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlV2l0aFZhbHVlKGNoYW5nZXMudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2l0aFZhbHVlKCk7XG4gICAgfTtcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBQcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVdpdGhWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IHRoaXMuX3F1ZXJ5SW5wdXQoXCJvcmRlclwiKSB8fCAnMCc7XG4gICAgICAgIGlmICh0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fbXFBY3RpdmF0aW9uLmFjdGl2YXRlZElucHV0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcGx5U3R5bGVUb0VsZW1lbnQodGhpcy5fYnVpbGRDU1ModmFsdWUpKTtcbiAgICB9O1xuICAgIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUuX2J1aWxkQ1NTID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgcmV0dXJuIHsgb3JkZXI6IGlzTmFOKHZhbHVlKSA/IDAgOiB2YWx1ZSB9O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQxMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9yZGVyJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9yZGVyLnhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T3JkZXIuZ3QteHMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckd0WHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9yZGVyLnNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJTbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T3JkZXIuZ3Qtc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckd0U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9yZGVyLm1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJNZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T3JkZXIuZ3QtbWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckd0TWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9yZGVyLmxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhGbGV4T3JkZXIuZ3QtbGcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgRmxleE9yZGVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckd0TGdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4RmxleE9yZGVyLnhsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIEZsZXhPcmRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3JkZXJYbFwiLCBudWxsKTtcbiAgICBGbGV4T3JkZXJEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDEzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogXCJcXG4gIFtmeEZsZXhPcmRlcl0sXFxuICBbZnhGbGV4T3JkZXIueHNdLFxcbiAgW2Z4RmxleE9yZGVyLmd0LXhzXSxcXG4gIFtmeEZsZXhPcmRlci5zbV0sXFxuICBbZnhGbGV4T3JkZXIuZ3Qtc21dLFxcbiAgW2Z4RmxleE9yZGVyLm1kXSxcXG4gIFtmeEZsZXhPcmRlci5ndC1tZF0sXFxuICBbZnhGbGV4T3JkZXIubGddLFxcbiAgW2Z4RmxleE9yZGVyLmd0LWxnXSxcXG4gIFtmeEZsZXhPcmRlci54bF1cXG5cIiB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW01lZGlhTW9uaXRvciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBGbGV4T3JkZXJEaXJlY3RpdmUpO1xuICAgIHJldHVybiBGbGV4T3JkZXJEaXJlY3RpdmU7XG59KEJhc2VGeERpcmVjdGl2ZSkpO1xuXG52YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkMTQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDQgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqICdsYXlvdXQtYWxpZ24nIGZsZXhib3ggc3R5bGluZyBkaXJlY3RpdmVcbiAqICBEZWZpbmVzIHBvc2l0aW9uaW5nIG9mIGNoaWxkIGVsZW1lbnRzIGFsb25nIG1haW4gYW5kIGNyb3NzIGF4aXMgaW4gYSBsYXlvdXQgY29udGFpbmVyXG4gKiAgT3B0aW9uYWwgdmFsdWVzOiB7bWFpbi1heGlzfSB2YWx1ZXMgb3Ige21haW4tYXhpcyBjcm9zcy1heGlzfSB2YWx1ZSBwYWlyc1xuICpcbiAqICBAc2VlIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vYWxtYW5hYy9wcm9wZXJ0aWVzL2ovanVzdGlmeS1jb250ZW50L1xuICogIEBzZWUgaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9hbG1hbmFjL3Byb3BlcnRpZXMvYS9hbGlnbi1pdGVtcy9cbiAqICBAc2VlIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vYWxtYW5hYy9wcm9wZXJ0aWVzL2EvYWxpZ24tY29udGVudC9cbiAqL1xudmFyIExheW91dEFsaWduRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkOShMYXlvdXRBbGlnbkRpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXlvdXRBbGlnbkRpcmVjdGl2ZShtb25pdG9yLCBlbFJlZiwgcmVuZGVyZXIsIGNvbnRhaW5lcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb25pdG9yLCBlbFJlZiwgcmVuZGVyZXIpO1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSAncm93JzsgLy8gZGVmYXVsdCBmbGV4LWRpcmVjdGlvblxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXRXYXRjaGVyID0gY29udGFpbmVyLmxheW91dCQuc3Vic2NyaWJlKHRoaXMuX29uTGF5b3V0Q2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25cIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnYWxpZ24nLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLCBcImFsaWduWHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnYWxpZ25YcycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdFhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ2FsaWduR3RYcycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25TbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdhbGlnblNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbkd0U21cIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnYWxpZ25HdFNtJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbk1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ2FsaWduTWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLCBcImFsaWduR3RNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdhbGlnbkd0TWQnLCB2YWwpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLCBcImFsaWduTGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fY2FjaGVJbnB1dCgnYWxpZ25MZycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdExnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7IHRoaXMuX2NhY2hlSW5wdXQoJ2FsaWduR3RMZycsIHZhbCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25YbFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkgeyB0aGlzLl9jYWNoZUlucHV0KCdhbGlnblhsJywgdmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gTGlmZWN5Y2xlIE1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snYWxpZ24nXSAhPSBudWxsIHx8IHRoaXMuX21xQWN0aXZhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlV2l0aFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBpbml0aWFsIG9uQ2hhbmdlcywgYnVpbGQgYW4gbXFBY3RpdmF0aW9uIG9iamVjdCB0aGF0IGJyaWRnZXNcbiAgICAgKiBtcWwgY2hhbmdlIGV2ZW50cyB0byBvbk1lZGlhUXVlcnlDaGFuZ2UgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xpc3RlbkZvck1lZGlhUXVlcnlDaGFuZ2VzKCdhbGlnbicsICdzdGFydCBzdHJldGNoJywgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVXaXRoVmFsdWUoY2hhbmdlcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVXaXRoVmFsdWUoKTtcbiAgICB9O1xuICAgIExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fbGF5b3V0V2F0Y2hlcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0V2F0Y2hlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBQcm90ZWN0ZWQgbWV0aG9kc1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgTGF5b3V0QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVXaXRoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCB0aGlzLl9xdWVyeUlucHV0KFwiYWxpZ25cIikgfHwgJ3N0YXJ0IHN0cmV0Y2gnO1xuICAgICAgICBpZiAodGhpcy5fbXFBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX21xQWN0aXZhdGlvbi5hY3RpdmF0ZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBseVN0eWxlVG9FbGVtZW50KHRoaXMuX2J1aWxkQ1NTKHZhbHVlKSk7XG4gICAgICAgIHRoaXMuX2FsbG93U3RyZXRjaGluZyh2YWx1ZSwgIXRoaXMuX2xheW91dCA/IFwicm93XCIgOiB0aGlzLl9sYXlvdXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FjaGUgdGhlIHBhcmVudCBjb250YWluZXIgJ2ZsZXgtZGlyZWN0aW9uJyBhbmQgdXBkYXRlIHRoZSAnZmxleCcgc3R5bGVzXG4gICAgICovXG4gICAgTGF5b3V0QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLl9vbkxheW91dENoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gKGRpcmVjdGlvbiB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCFMQVlPVVRfVkFMVUVTLmZpbmQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPT09IF90aGlzLl9sYXlvdXQ7IH0pKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXQgPSAncm93JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9xdWVyeUlucHV0KFwiYWxpZ25cIikgfHwgJ3N0YXJ0IHN0cmV0Y2gnO1xuICAgICAgICBpZiAodGhpcy5fbXFBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX21xQWN0aXZhdGlvbi5hY3RpdmF0ZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGxvd1N0cmV0Y2hpbmcodmFsdWUsIHRoaXMuX2xheW91dCB8fCBcInJvd1wiKTtcbiAgICB9O1xuICAgIExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZS5fYnVpbGRDU1MgPSBmdW5jdGlvbiAoYWxpZ24pIHtcbiAgICAgICAgdmFyIGNzcyA9IHt9LCBfYSA9IGFsaWduLnNwbGl0KCcgJyksIG1haW5fYXhpcyA9IF9hWzBdLCBjcm9zc19heGlzID0gX2FbMV07IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6dmFyaWFibGUtbmFtZVxuICAgICAgICBjc3NbJ2p1c3RpZnktY29udGVudCddID0gJ2ZsZXgtc3RhcnQnOyAvLyBkZWZhdWx0IG1haW4gYXhpc1xuICAgICAgICBjc3NbJ2FsaWduLWl0ZW1zJ10gPSAnc3RyZXRjaCc7IC8vIGRlZmF1bHQgY3Jvc3MgYXhpc1xuICAgICAgICBjc3NbJ2FsaWduLWNvbnRlbnQnXSA9ICdzdHJldGNoJzsgLy8gZGVmYXVsdCBjcm9zcyBheGlzXG4gICAgICAgIC8vIE1haW4gYXhpc1xuICAgICAgICBzd2l0Y2ggKG1haW5fYXhpcykge1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICBjc3NbJ2p1c3RpZnktY29udGVudCddID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzcGFjZS1hcm91bmQnOlxuICAgICAgICAgICAgICAgIGNzc1snanVzdGlmeS1jb250ZW50J10gPSAnc3BhY2UtYXJvdW5kJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlLWJldHdlZW4nOlxuICAgICAgICAgICAgICAgIGNzc1snanVzdGlmeS1jb250ZW50J10gPSAnc3BhY2UtYmV0d2Vlbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIGNzc1snanVzdGlmeS1jb250ZW50J10gPSAnZmxleC1lbmQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyb3NzLWF4aXNcbiAgICAgICAgc3dpdGNoIChjcm9zc19heGlzKSB7XG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgY3NzWydhbGlnbi1pdGVtcyddID0gY3NzWydhbGlnbi1jb250ZW50J10gPSAnZmxleC1zdGFydCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiYXNlbGluZSc6XG4gICAgICAgICAgICAgICAgY3NzWydhbGlnbi1pdGVtcyddID0gJ2Jhc2VsaW5lJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgY3NzWydhbGlnbi1pdGVtcyddID0gY3NzWydhbGlnbi1jb250ZW50J10gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgY3NzWydhbGlnbi1pdGVtcyddID0gY3NzWydhbGlnbi1jb250ZW50J10gPSAnZmxleC1lbmQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5kT2JqZWN0KGNzcywge1xuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnZmxleCcsXG4gICAgICAgICAgICAnZmxleC1kaXJlY3Rpb24nOiB0aGlzLl9sYXlvdXQgfHwgXCJyb3dcIixcbiAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbnRhaW5lciBlbGVtZW50IHRvICdzdHJldGNoJyBhcyBuZWVkZWQuLi5cbiAgICAgKiBOT1RFOiB0aGlzIGlzIG9ubHkgZG9uZSBpZiB0aGUgY3Jvc3NBeGlzIGlzIGV4cGxpY2l0bHkgc2V0IHRvICdzdHJldGNoJ1xuICAgICAqL1xuICAgIExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZS5fYWxsb3dTdHJldGNoaW5nID0gZnVuY3Rpb24gKGFsaWduLCBsYXlvdXQpIHtcbiAgICAgICAgdmFyIF9hID0gYWxpZ24uc3BsaXQoJyAnKSwgY3Jvc3NfYXhpcyA9IF9hWzFdOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOnZhcmlhYmxlLW5hbWVcbiAgICAgICAgaWYgKGNyb3NzX2F4aXMgPT0gJ3N0cmV0Y2gnKSB7XG4gICAgICAgICAgICAvLyBVc2UgYG51bGxgIHZhbHVlcyB0byByZW1vdmUgc3R5bGVcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVUb0VsZW1lbnQoe1xuICAgICAgICAgICAgICAgICdib3gtc2l6aW5nJzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgICAgICdtYXgtd2lkdGgnOiAobGF5b3V0ID09PSAnY29sdW1uJykgPyAnMTAwJScgOiBudWxsLFxuICAgICAgICAgICAgICAgICdtYXgtaGVpZ2h0JzogKGxheW91dCA9PT0gJ3JvdycpID8gJzEwMCUnIDogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMTQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEFsaWduJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRBbGlnbi54cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25Yc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRBbGlnbi5ndC14cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdFhzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEFsaWduLnNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnblNtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEFsaWduLmd0LXNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnbkd0U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0QWxpZ24ubWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLCBcImFsaWduTWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0QWxpZ24uZ3QtbWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0QWxpZ25EaXJlY3RpdmUucHJvdG90eXBlLCBcImFsaWduR3RNZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRBbGlnbi5sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25MZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRBbGlnbi5ndC1sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRBbGlnbkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWxpZ25HdExnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEFsaWduLnhsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dEFsaWduRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhbGlnblhsXCIsIG51bGwpO1xuICAgIExheW91dEFsaWduRGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6IFwiXFxuICBbZnhMYXlvdXRBbGlnbl0sXFxuICBbZnhMYXlvdXRBbGlnbi54c10sXFxuICBbZnhMYXlvdXRBbGlnbi5ndC14c10sXFxuICBbZnhMYXlvdXRBbGlnbi5zbV0sXFxuICBbZnhMYXlvdXRBbGlnbi5ndC1zbV0sXFxuICBbZnhMYXlvdXRBbGlnbi5tZF0sXFxuICBbZnhMYXlvdXRBbGlnbi5ndC1tZF0sXFxuICBbZnhMYXlvdXRBbGlnbi5sZ10sXFxuICBbZnhMYXlvdXRBbGlnbi5ndC1sZ10sXFxuICBbZnhMYXlvdXRBbGlnbi54bF1cXG5cIiB9KSxcbiAgICAgICAgX19wYXJhbSQ0KDMsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kNCgzLCBfYW5ndWxhcl9jb3JlLlNlbGYoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246cGFyYW10eXBlcycsIFtNZWRpYU1vbml0b3IsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgTGF5b3V0RGlyZWN0aXZlXSlcbiAgICBdLCBMYXlvdXRBbGlnbkRpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIExheW91dEFsaWduRGlyZWN0aXZlO1xufShCYXNlRnhEaXJlY3RpdmUpKTtcblxudmFyIF9fZXh0ZW5kcyQxMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQxNSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxNSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogJ2xheW91dC1wYWRkaW5nJyBzdHlsaW5nIGRpcmVjdGl2ZVxuICogIERlZmluZXMgcGFkZGluZyBvZiBjaGlsZCBlbGVtZW50cyBpbiBhIGxheW91dCBjb250YWluZXJcbiAqL1xudmFyIExheW91dEdhcERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEwKExheW91dEdhcERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXlvdXRHYXBEaXJlY3RpdmUobW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyLCBjb250YWluZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9uaXRvciwgZWxSZWYsIHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gJ3Jvdyc7IC8vIGRlZmF1bHQgZmxleC1kaXJlY3Rpb25cbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0V2F0Y2hlciA9IGNvbnRhaW5lci5sYXlvdXQkLnN1YnNjcmliZSh0aGlzLl9vbkxheW91dENoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoJ2dhcCcsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcFhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdnYXBYcycsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcEd0WHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoJ2dhcEd0WHMnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnZ2FwU20nLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBHdFNtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdnYXBHdFNtJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZ2FwTWRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoJ2dhcE1kJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZ2FwR3RNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnZ2FwR3RNZCcsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcExnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUlucHV0KCdnYXBMZycsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcEd0TGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5wdXQoJ2dhcEd0TGcnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBYbFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVJbnB1dCgnZ2FwWGwnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvLyBMaWZlY3ljbGUgTWV0aG9kc1xuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snZ2FwJ10gIT0gbnVsbCB8fCB0aGlzLl9tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVdpdGhWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZnRlciB0aGUgaW5pdGlhbCBvbkNoYW5nZXMsIGJ1aWxkIGFuIG1xQWN0aXZhdGlvbiBvYmplY3QgdGhhdCBicmlkZ2VzXG4gICAgICogbXFsIGNoYW5nZSBldmVudHMgdG8gb25NZWRpYVF1ZXJ5Q2hhbmdlIGhhbmRsZXJzXG4gICAgICovXG4gICAgTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3dhdGNoQ29udGVudENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuRm9yTWVkaWFRdWVyeUNoYW5nZXMoJ2dhcCcsICcwJywgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVXaXRoVmFsdWUoY2hhbmdlcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVXaXRoVmFsdWUoKTtcbiAgICB9O1xuICAgIExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2xheW91dFdhdGNoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dFdhdGNoZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gUHJvdGVjdGVkIG1ldGhvZHNcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAvKipcbiAgICAgKiBXYXRjaCBmb3IgY2hpbGQgbm9kZXMgdG8gYmUgYWRkZWQuLi4gYW5kIGFwcGx5IHRoZSBsYXlvdXQgZ2FwIHN0eWxlcyB0byBlYWNoLlxuICAgICAqIE5PVEU6IHRoaXMgZG9lcyBOT1QhIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB2aWV3Q2hpbGRyZW4gYW5kIGNvbnRlbnRDaGlsZHJlblxuICAgICAqL1xuICAgIExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUuX3dhdGNoQ29udGVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvbk11dGF0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdGVkQ2hhbmdlcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaXQuYWRkZWROb2RlcyAmJiBpdC5hZGRlZE5vZGVzLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGl0LnJlbW92ZWROb2RlcyAmJiBpdC5yZW1vdmVkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyB1cGRhdGUgZ2FwIHN0eWxlcyBvbmx5IGZvciBjaGlsZCAnYWRkZWQnIG9yICdyZW1vdmVkJyBldmVudHNcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbnMuZmlsdGVyKHZhbGlkYXRlZENoYW5nZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVXaXRoVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvbk11dGF0aW9uQ2FsbGJhY2spO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGUgcGFyZW50IGNvbnRhaW5lciAnZmxleC1kaXJlY3Rpb24nIGFuZCB1cGRhdGUgdGhlICdtYXJnaW4nIHN0eWxlc1xuICAgICAqL1xuICAgIExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUuX29uTGF5b3V0Q2hhbmdlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSAoZGlyZWN0aW9uIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIUxBWU9VVF9WQUxVRVMuZmluZChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gX3RoaXMuX2xheW91dDsgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dCA9ICdyb3cnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdpdGhWYWx1ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVXaXRoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCB0aGlzLl9xdWVyeUlucHV0KFwiZ2FwXCIpIHx8ICcwJztcbiAgICAgICAgaWYgKHRoaXMuX21xQWN0aXZhdGlvbikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9tcUFjdGl2YXRpb24uYWN0aXZhdGVkSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2F0aGVyIGFsbCBub24taGlkZGVuIEVsZW1lbnQgbm9kZXNcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5jaGlsZHJlbk5vZGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKGVsLm5vZGVUeXBlID09PSAxKTsgfSkgLy8gb25seSBFbGVtZW50IHR5cGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gX3RoaXMuX2dldERpc3BsYXlTdHlsZShlbCkgIT0gXCJub25lXCI7IH0pO1xuICAgICAgICB2YXIgbnVtSXRlbXMgPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1JdGVtcyA+IDEpIHtcbiAgICAgICAgICAgIHZhciBsYXN0SXRlbSA9IGl0ZW1zW251bUl0ZW1zIC0gMV07XG4gICAgICAgICAgICAvLyBGb3IgZWFjaCBgZWxlbWVudGAgY2hpbGRyZW4gRVhDRVBUIHRoZSBsYXN0LFxuICAgICAgICAgICAgLy8gc2V0IHRoZSBtYXJnaW4gcmlnaHQvYm90dG9tIHN0eWxlcy4uLlxuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGVsLCBqKSB7IHJldHVybiBqIDwgbnVtSXRlbXMgLSAxOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVUb0VsZW1lbnRzKHRoaXMuX2J1aWxkQ1NTKHZhbHVlKSwgaXRlbXMpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgYWxsIGdhcHMgZm9yIGFsbCB2aXNpYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlVG9FbGVtZW50cyh0aGlzLl9idWlsZENTUygpLCBbbGFzdEl0ZW1dKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBtYXJnaW4gQ1NTLCByZW1vdmUgYW55IHByZXZpb3VzIGV4cGxpY2l0bHlcbiAgICAgKiBhc3NpZ25lZCBtYXJnaW4gYXNzaWdubWVudHNcbiAgICAgKi9cbiAgICBMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLl9idWlsZENTUyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIGtleSwgbWFyZ2lucyA9IHtcbiAgICAgICAgICAgICdtYXJnaW4tbGVmdCc6IG51bGwsXG4gICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogbnVsbCxcbiAgICAgICAgICAgICdtYXJnaW4tdG9wJzogbnVsbCxcbiAgICAgICAgICAgICdtYXJnaW4tYm90dG9tJzogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xheW91dCkge1xuICAgICAgICAgICAgY2FzZSAnY29sdW1uJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbHVtbi1yZXZlcnNlJzpcbiAgICAgICAgICAgICAgICBrZXkgPSAnbWFyZ2luLWJvdHRvbSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm93XCI6XG4gICAgICAgICAgICBjYXNlICdyb3ctcmV2ZXJzZSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGtleSA9ICdtYXJnaW4tcmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hcmdpbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gbWFyZ2lucztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMTUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEdhcCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRHYXAueHMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRHYXAuZ3QteHMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBHdFhzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEdhcC5zbScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcFNtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEdhcC5ndC1zbScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcEd0U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0R2FwLm1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE1KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE1KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZ2FwTWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2Z4TGF5b3V0R2FwLmd0LW1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE1KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE1KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExheW91dEdhcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZ2FwR3RNZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRHYXAubGcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZnhMYXlvdXRHYXAuZ3QtbGcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTGF5b3V0R2FwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJnYXBHdExnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdmeExheW91dEdhcC54bCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBMYXlvdXRHYXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImdhcFhsXCIsIG51bGwpO1xuICAgIExheW91dEdhcERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkMTUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiBcIlxcbiAgW2Z4TGF5b3V0R2FwXSxcXG4gIFtmeExheW91dEdhcC54c10sXFxuICBbZnhMYXlvdXRHYXAuZ3QteHNdLFxcbiAgW2Z4TGF5b3V0R2FwLnNtXSxcXG4gIFtmeExheW91dEdhcC5ndC1zbV1cXG4gIFtmeExheW91dEdhcC5tZF0sXFxuICBbZnhMYXlvdXRHYXAuZ3QtbWRdXFxuICBbZnhMYXlvdXRHYXAubGddLFxcbiAgW2Z4TGF5b3V0R2FwLmd0LWxnXSxcXG4gIFtmeExheW91dEdhcC54bF1cXG5cIlxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ1KDMsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kNSgzLCBfYW5ndWxhcl9jb3JlLlNlbGYoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDE1KCdkZXNpZ246cGFyYW10eXBlcycsIFtNZWRpYU1vbml0b3IsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgTGF5b3V0RGlyZWN0aXZlXSlcbiAgICBdLCBMYXlvdXRHYXBEaXJlY3RpdmUpO1xuICAgIHJldHVybiBMYXlvdXRHYXBEaXJlY3RpdmU7XG59KEJhc2VGeERpcmVjdGl2ZSkpO1xuXG52YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDE2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIERpcmVjdGl2ZSB0byBhZGQgcmVzcG9uc2l2ZSBzdXBwb3J0IGZvciBuZ0NsYXNzLlxuICovXG52YXIgQ2xhc3NEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMShDbGFzc0RpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbGFzc0RpcmVjdGl2ZShtb25pdG9yLCBfYnBSZWdpc3RyeSwgX2l0ZXJhYmxlRGlmZmVycywgX2tleVZhbHVlRGlmZmVycywgX25nRWwsIF9yZW5kZXJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfaXRlcmFibGVEaWZmZXJzLCBfa2V5VmFsdWVEaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbW9uaXRvcjtcbiAgICAgICAgdGhpcy5fYnBSZWdpc3RyeSA9IF9icFJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9iYXNlID0gbmV3IEJhc2VGeERpcmVjdGl2ZUFkYXB0ZXIobW9uaXRvciwgX25nRWwsIF9yZW5kZXJlcik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2xhc3NYc1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZS5jYWNoZUlucHV0KCdjbGFzc1hzJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbGFzc0d0WHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2UuY2FjaGVJbnB1dCgnY2xhc3NHdFhzJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbGFzc1NtXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlLmNhY2hlSW5wdXQoJ2NsYXNzU20nLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3NEaXJlY3RpdmUucHJvdG90eXBlLCBcImNsYXNzR3RTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZS5jYWNoZUlucHV0KCdjbGFzc0d0U20nLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3NEaXJlY3RpdmUucHJvdG90eXBlLCBcImNsYXNzTWRcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2UuY2FjaGVJbnB1dCgnY2xhc3NNZCcsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2xhc3NHdE1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlLmNhY2hlSW5wdXQoJ2NsYXNzR3RNZCcsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2xhc3NMZ1wiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZS5jYWNoZUlucHV0KCdjbGFzc0xnJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbGFzc0d0TGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2UuY2FjaGVJbnB1dCgnY2xhc3NHdExnJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbGFzc1hsXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlLmNhY2hlSW5wdXQoJ2NsYXNzWGwnLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBGb3IgQElucHV0IGNoYW5nZXMgb24gdGhlIGN1cnJlbnQgbXEgYWN0aXZhdGlvbiBwcm9wZXJ0eSwgc2VlIG9uTWVkaWFRdWVyeUNoYW5nZXMoKVxuICAgICAqL1xuICAgIENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5fYnBSZWdpc3RyeS5pdGVtcy5zb21lKGZ1bmN0aW9uIChpdCkgeyByZXR1cm4gXCJjbGFzc1wiICsgaXQuc3VmZml4IGluIGNoYW5nZXM7IH0pO1xuICAgICAgICBpZiAoY2hhbmdlZCB8fCB0aGlzLl9iYXNlLm1xQWN0aXZhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGluaXRpYWwgb25DaGFuZ2VzLCBidWlsZCBhbiBtcUFjdGl2YXRpb24gb2JqZWN0IHRoYXQgYnJpZGdlc1xuICAgICAqIG1xbCBjaGFuZ2UgZXZlbnRzIHRvIG9uTWVkaWFRdWVyeUNoYW5nZSBoYW5kbGVyc1xuICAgICAqL1xuICAgIENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmFzZS5saXN0ZW5Gb3JNZWRpYVF1ZXJ5Q2hhbmdlcygnY2xhc3MnLCAnJywgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVTdHlsZShjaGFuZ2VzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlKCk7XG4gICAgfTtcbiAgICBDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2Jhc2UubmdPbkRlc3Ryb3koKTtcbiAgICB9O1xuICAgIENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNsYXp6ID0gdmFsdWUgfHwgdGhpcy5fYmFzZS5xdWVyeUlucHV0KFwiY2xhc3NcIikgfHwgJyc7XG4gICAgICAgIGlmICh0aGlzLl9iYXNlLm1xQWN0aXZhdGlvbikge1xuICAgICAgICAgICAgY2xhenogPSB0aGlzLl9iYXNlLm1xQWN0aXZhdGlvbi5hY3RpdmF0ZWRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxlZ2F0ZSBzdWJzZXF1ZW50IGFjdGl2aXR5IHRvIHRoZSBOZ0NsYXNzIGxvZ2ljXG4gICAgICAgIHRoaXMubmdDbGFzcyA9IGNsYXp6O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2NsYXNzLnhzJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbGFzc1hzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdjbGFzcy5ndC14cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2xhc3NHdFhzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdjbGFzcy5zbScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2xhc3NTbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnY2xhc3MuZ3Qtc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgQ2xhc3NEaXJlY3RpdmUucHJvdG90eXBlLCBcImNsYXNzR3RTbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnY2xhc3MubWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgQ2xhc3NEaXJlY3RpdmUucHJvdG90eXBlLCBcImNsYXNzTWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2NsYXNzLmd0LW1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbGFzc0d0TWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2NsYXNzLmxnJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIENsYXNzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbGFzc0xnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdjbGFzcy5ndC1sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2xhc3NHdExnXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdjbGFzcy54bCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBDbGFzc0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY2xhc3NYbFwiLCBudWxsKTtcbiAgICBDbGFzc0RpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkMTYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogXCJcXG4gICAgW2NsYXNzLnhzXSxcXG4gICAgW2NsYXNzLmd0LXhzXSxcXG4gICAgW2NsYXNzLnNtXSxcXG4gICAgW2NsYXNzLmd0LXNtXSxcXG4gICAgW2NsYXNzLm1kXSxcXG4gICAgW2NsYXNzLmd0LW1kXSxcXG4gICAgW2NsYXNzLmxnXSxcXG4gICAgW2NsYXNzLmd0LWxnXSxcXG4gICAgW2NsYXNzLnhsXVxcbiAgXCJcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246cGFyYW10eXBlcycsIFtNZWRpYU1vbml0b3IsIEJyZWFrUG9pbnRSZWdpc3RyeSwgX2FuZ3VsYXJfY29yZS5JdGVyYWJsZURpZmZlcnMsIF9hbmd1bGFyX2NvcmUuS2V5VmFsdWVEaWZmZXJzLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIENsYXNzRGlyZWN0aXZlKTtcbiAgICByZXR1cm4gQ2xhc3NEaXJlY3RpdmU7XG59KF9hbmd1bGFyX2NvbW1vbi5OZ0NsYXNzKSk7XG5cbnZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkMTcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogRGlyZWN0aXZlIHRvIGFkZCByZXNwb25zaXZlIHN1cHBvcnQgZm9yIG5nU3R5bGUuXG4gKlxuICovXG52YXIgU3R5bGVEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMihTdHlsZURpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0eWxlRGlyZWN0aXZlKG1vbml0b3IsIF9icFJlZ2lzdHJ5LCBfZGlmZmVycywgX25nRWwsIF9yZW5kZXJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfZGlmZmVycywgX25nRWwsIF9yZW5kZXJlcik7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgICAgIHRoaXMuX2JwUmVnaXN0cnkgPSBfYnBSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5fYmFzZSA9IG5ldyBCYXNlRnhEaXJlY3RpdmVBZGFwdGVyKG1vbml0b3IsIF9uZ0VsLCBfcmVuZGVyZXIpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0eWxlWHNcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2UuY2FjaGVJbnB1dCgnc3R5bGVYcycsIHZhbCwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3R5bGVHdFhzXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlLmNhY2hlSW5wdXQoJ3N0eWxlR3RYcycsIHZhbCwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3R5bGVTbVwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZS5jYWNoZUlucHV0KCdzdHlsZVNtJywgdmFsLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0eWxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdHlsZUd0U21cIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2UuY2FjaGVJbnB1dCgnc3R5bGVHdFNtJywgdmFsLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0eWxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdHlsZU1kXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlLmNhY2hlSW5wdXQoJ3N0eWxlTWQnLCB2YWwsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0eWxlR3RNZFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZS5jYWNoZUlucHV0KCdzdHlsZUd0TWQnLCB2YWwsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0eWxlTGdcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2UuY2FjaGVJbnB1dCgnc3R5bGVMZycsIHZhbCwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3R5bGVHdExnXCIsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXNlLmNhY2hlSW5wdXQoJ3N0eWxlR3RMZycsIHZhbCwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3R5bGVYbFwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZS5jYWNoZUlucHV0KCdzdHlsZVhsJywgdmFsLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgLyoqXG4gICAgICogRm9yIEBJbnB1dCBjaGFuZ2VzIG9uIHRoZSBjdXJyZW50IG1xIGFjdGl2YXRpb24gcHJvcGVydHksIHNlZSBvbk1lZGlhUXVlcnlDaGFuZ2VzKClcbiAgICAgKi9cbiAgICBTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2JwUmVnaXN0cnkuaXRlbXMuc29tZShmdW5jdGlvbiAoaXQpIHsgcmV0dXJuIFwic3R5bGVcIiArIGl0LnN1ZmZpeCBpbiBjaGFuZ2VzOyB9KTtcbiAgICAgICAgaWYgKGNoYW5nZWQgfHwgdGhpcy5fYmFzZS5tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBpbml0aWFsIG9uQ2hhbmdlcywgYnVpbGQgYW4gbXFBY3RpdmF0aW9uIG9iamVjdCB0aGF0IGJyaWRnZXNcbiAgICAgKiBtcWwgY2hhbmdlIGV2ZW50cyB0byBvbk1lZGlhUXVlcnlDaGFuZ2UgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2Jhc2UubGlzdGVuRm9yTWVkaWFRdWVyeUNoYW5nZXMoJ3N0eWxlJywgJycsIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlU3R5bGUoY2hhbmdlcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVTdHlsZSgpO1xuICAgIH07XG4gICAgU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iYXNlLm5nT25EZXN0cm95KCk7XG4gICAgfTtcbiAgICBTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHZhbHVlIHx8IHRoaXMuX2Jhc2UucXVlcnlJbnB1dChcInN0eWxlXCIpIHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5fYmFzZS5tcUFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIHN0eWxlID0gdGhpcy5fYmFzZS5tcUFjdGl2YXRpb24uYWN0aXZhdGVkSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZWdhdGUgc3Vic2VxdWVudCBhY3Rpdml0eSB0byB0aGUgTmdTdHlsZSBsb2dpY1xuICAgICAgICB0aGlzLm5nU3R5bGUgPSBzdHlsZTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdzdHlsZS54cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3R5bGVYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnc3R5bGUuZ3QteHMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0eWxlR3RYc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnc3R5bGUuc20nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0eWxlU21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ3N0eWxlLmd0LXNtJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE3KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE3KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFN0eWxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdHlsZUd0U21cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ3N0eWxlLm1kJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE3KCdkZXNpZ246dHlwZScsIE9iamVjdCksIFxuICAgICAgICBfX21ldGFkYXRhJDE3KCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIFN0eWxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdHlsZU1kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdzdHlsZS5ndC1tZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3R5bGVHdE1kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdzdHlsZS5sZycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBTdHlsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3R5bGVMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnc3R5bGUuZ3QtbGcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0eWxlR3RMZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnc3R5bGUueGwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgU3R5bGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0eWxlWGxcIiwgbnVsbCk7XG4gICAgU3R5bGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6IFwiXFxuICAgIFtzdHlsZS54c10sXFxuICAgIFtzdHlsZS5ndC14c10sXFxuICAgIFtzdHlsZS5zbV0sXFxuICAgIFtzdHlsZS5ndC1zbV0sXFxuICAgIFtzdHlsZS5tZF0sXFxuICAgIFtzdHlsZS5ndC1tZF0sXFxuICAgIFtzdHlsZS5sZ10sXFxuICAgIFtzdHlsZS5ndC1sZ10sXFxuICAgIFtzdHlsZS54bF1cXG4gIFwiXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbTWVkaWFNb25pdG9yLCBCcmVha1BvaW50UmVnaXN0cnksIF9hbmd1bGFyX2NvcmUuS2V5VmFsdWVEaWZmZXJzLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIFN0eWxlRGlyZWN0aXZlKTtcbiAgICByZXR1cm4gU3R5bGVEaXJlY3RpdmU7XG59KF9hbmd1bGFyX2NvbW1vbi5OZ1N0eWxlKSk7XG5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFNpbmNlIHRoZSBlcXVpdmFsZW50IHJlc3VsdHMgYXJlIGVhc2lseSBhY2hpZXZlZCB3aXRoIGEgY3NzIGNsYXNzIGF0dGFjaGVkIHRvIGVhY2hcbiAqIGxheW91dCBjaGlsZCwgdGhlc2UgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgQVBJLlxuICpcbiAqICBpbXBvcnQge0xheW91dFBhZGRpbmdEaXJlY3RpdmV9IGZyb20gJy4vYXBpL2xheW91dC1wYWRkaW5nJztcbiAqICBpbXBvcnQge0xheW91dE1hcmdpbkRpcmVjdGl2ZX0gZnJvbSAnLi9hcGkvbGF5b3V0LW1hcmdpbic7XG4gKi9cbnZhciBBTExfRElSRUNUSVZFUyA9IFtcbiAgICBMYXlvdXREaXJlY3RpdmUsXG4gICAgTGF5b3V0V3JhcERpcmVjdGl2ZSxcbiAgICBMYXlvdXRHYXBEaXJlY3RpdmUsXG4gICAgTGF5b3V0QWxpZ25EaXJlY3RpdmUsXG4gICAgRmxleERpcmVjdGl2ZSxcbiAgICBGbGV4T3JkZXJEaXJlY3RpdmUsXG4gICAgRmxleE9mZnNldERpcmVjdGl2ZSxcbiAgICBGbGV4RmlsbERpcmVjdGl2ZSxcbiAgICBGbGV4QWxpZ25EaXJlY3RpdmUsXG4gICAgU2hvd0hpZGVEaXJlY3RpdmUsXG4gICAgQ2xhc3NEaXJlY3RpdmUsXG4gICAgU3R5bGVEaXJlY3RpdmUsXG5dO1xuLyoqXG4gKlxuICovXG52YXIgRmxleExheW91dE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxleExheW91dE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgRmxleExheW91dE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEZsZXhMYXlvdXRNb2R1bGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEZsZXhMYXlvdXRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IEFMTF9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgaW1wb3J0czogW01lZGlhUXVlcmllc01vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWVkaWFRdWVyaWVzTW9kdWxlXS5jb25jYXQoQUxMX0RJUkVDVElWRVMpLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWVkaWFNb25pdG9yXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgRmxleExheW91dE1vZHVsZSk7XG4gICAgcmV0dXJuIEZsZXhMYXlvdXRNb2R1bGU7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmV4cG9ydHMuQmFzZUZ4RGlyZWN0aXZlID0gQmFzZUZ4RGlyZWN0aXZlO1xuZXhwb3J0cy5CYXNlRnhEaXJlY3RpdmVBZGFwdGVyID0gQmFzZUZ4RGlyZWN0aXZlQWRhcHRlcjtcbmV4cG9ydHMuS2V5T3B0aW9ucyA9IEtleU9wdGlvbnM7XG5leHBvcnRzLlJlc3BvbnNpdmVBY3RpdmF0aW9uID0gUmVzcG9uc2l2ZUFjdGl2YXRpb247XG5leHBvcnRzLkZsZXhMYXlvdXRNb2R1bGUgPSBGbGV4TGF5b3V0TW9kdWxlO1xuZXhwb3J0cy5CcmVha1BvaW50UmVnaXN0cnkgPSBCcmVha1BvaW50UmVnaXN0cnk7XG5leHBvcnRzLlJFU1BPTlNJVkVfQUxJQVNFUyA9IFJFU1BPTlNJVkVfQUxJQVNFUztcbmV4cG9ydHMuUkFXX0RFRkFVTFRTID0gUkFXX0RFRkFVTFRTO1xuZXhwb3J0cy5CUkVBS1BPSU5UUyA9IEJSRUFLUE9JTlRTO1xuZXhwb3J0cy5CcmVha1BvaW50c1Byb3ZpZGVyID0gQnJlYWtQb2ludHNQcm92aWRlcjtcbmV4cG9ydHMuT2JzZXJ2YWJsZU1lZGlhID0gT2JzZXJ2YWJsZU1lZGlhO1xuZXhwb3J0cy5NZWRpYVNlcnZpY2UgPSBNZWRpYVNlcnZpY2U7XG5leHBvcnRzLk9ic2VydmFibGVNZWRpYVByb3ZpZGVyID0gT2JzZXJ2YWJsZU1lZGlhUHJvdmlkZXI7XG5leHBvcnRzLk1hdGNoTWVkaWEgPSBNYXRjaE1lZGlhO1xuZXhwb3J0cy5NZWRpYUNoYW5nZSA9IE1lZGlhQ2hhbmdlO1xuZXhwb3J0cy5NZWRpYU1vbml0b3IgPSBNZWRpYU1vbml0b3I7XG5leHBvcnRzLk1lZGlhUXVlcmllc01vZHVsZSA9IE1lZGlhUXVlcmllc01vZHVsZTtcbmV4cG9ydHMuYXBwbHlDc3NQcmVmaXhlcyA9IGFwcGx5Q3NzUHJlZml4ZXM7XG5leHBvcnRzLnRvQWxpZ25Db250ZW50VmFsdWUgPSB0b0FsaWduQ29udGVudFZhbHVlO1xuZXhwb3J0cy50b0JveFZhbHVlID0gdG9Cb3hWYWx1ZTtcbmV4cG9ydHMudG9Cb3hPcmllbnQgPSB0b0JveE9yaWVudDtcbmV4cG9ydHMudG9Cb3hEaXJlY3Rpb24gPSB0b0JveERpcmVjdGlvbjtcbmV4cG9ydHMudG9Cb3hPcmRpbmFsID0gdG9Cb3hPcmRpbmFsO1xuZXhwb3J0cy5leHRlbmRPYmplY3QgPSBleHRlbmRPYmplY3Q7XG5leHBvcnRzLm1lcmdlQWxpYXMgPSBtZXJnZUFsaWFzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL2ZsZXgtbGF5b3V0L2J1bmRsZXMvZmxleC1sYXlvdXQudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG4vLyBpbXBvcnQgeyBSb3V0ZXJNb2R1bGUsIFJvdXRlcyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcbmltcG9ydCB7IE1hdGVyaWFsTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xyXG5pbXBvcnQgeyBGbGV4TGF5b3V0TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZmxleC1sYXlvdXQnO1xyXG5pbXBvcnQgeyBhcHBDb250ZW50Um91dGVzTW9kdWxlIH0gZnJvbSAnLi4vYXBwUm91dGVyTW9kdWxlL2FwcENvbnRlbnRSb3V0ZXIubW9kdWxlJ1xyXG5pbXBvcnQgeyBDb250ZW50Q29tcG9uZW50IH0gZnJvbSAnLi9jb250ZW50LmNvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBQdWJsaWNNb2R1bGUgfSBmcm9tICcuLi9hcHBQdWJsaWNNb2R1bGUvcHVibGljLm1vZHVsZSc7XHJcbmltcG9ydCB7UGVyc29uYWxDb21wb25lbnR9IGZyb20gJy4vY29tcG9uZW50L3BlcnNvbmFsL3BlcnNvbmFsLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7QXNzZXRzQ29tcG9uZW50fSBmcm9tICcuL2NvbXBvbmVudC9hc3NldHMvYXNzZXRzLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7QXVkaXRpbmdDb21wb25lbnR9IGZyb20gJy4vY29tcG9uZW50L2F1ZGl0aW5nL2F1ZGl0aW5nLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7TXlyZXNvdXJjZXNDb21wb25lbnR9IGZyb20gJy4vY29tcG9uZW50L215cmVzb3VyY2VzL215cmVzb3VyY2VzLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UGVyc29ubmVsQ29tcG9uZW50fSBmcm9tICcuL2NvbXBvbmVudC9wZXJzb25uZWwvcGVyc29ubmVsLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UHJlcGFyaW5nZXhhbXNDb21wb25lbnR9IGZyb20gJy4vY29tcG9uZW50L3ByZXBhcmluZ2V4YW1zL3ByZXBhcmluZ2V4YW1zLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UHJlcGFyaW5nbGVzc29uQ29tcG9uZW50fSBmcm9tICcuL2NvbXBvbmVudC9wcmVwYXJpbmdsZXNzb24vcHJlcGFyaW5nbGVzc29uLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UmVzb3VyY2VzQ29tcG9uZW50fSBmcm9tICcuL2NvbXBvbmVudC9yZXNvdXJjZXMvcmVzb3VyY2VzLmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG5cdGltcG9ydHM6IFtcclxuXHRcdE1hdGVyaWFsTW9kdWxlLmZvclJvb3QoKSxcclxuXHRcdEZsZXhMYXlvdXRNb2R1bGUuZm9yUm9vdCgpLFxyXG5cdFx0Q29tbW9uTW9kdWxlLFxyXG5cdFx0XHJcblx0XHRQdWJsaWNNb2R1bGUsXHJcblx0XHRhcHBDb250ZW50Um91dGVzTW9kdWxlLFxyXG5cdF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICBDb250ZW50Q29tcG9uZW50LFxyXG4gICAgICAgIFBlcnNvbmFsQ29tcG9uZW50LFxyXG4gICAgICAgIEFzc2V0c0NvbXBvbmVudCxcclxuICAgICAgICBBdWRpdGluZ0NvbXBvbmVudCxcclxuICAgICAgICBNeXJlc291cmNlc0NvbXBvbmVudCxcclxuICAgICAgICBQZXJzb25uZWxDb21wb25lbnQsXHJcbiAgICAgICAgUHJlcGFyaW5nbGVzc29uQ29tcG9uZW50LFxyXG4gICAgICAgIFByZXBhcmluZ2V4YW1zQ29tcG9uZW50LFxyXG4gICAgICAgIFJlc291cmNlc0NvbXBvbmVudCxcclxuICAgIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIGFwcENvbnRlbnRNb2R1bGUge31cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMC42LjJAYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbnRlbnQubW9kdWxlLnRzIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSAgICAgICAgICAgICBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGVyTW9kdWxlLCBSb3V0ZXMgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5cclxuaW1wb3J0IHtDb250ZW50Q29tcG9uZW50fSBmcm9tICcuLi9hcHBDb250ZW50TW9kdWxlL2NvbnRlbnQuY29tcG9uZW50JztcclxuXHJcbmltcG9ydCB7UGVyc29uYWxDb21wb25lbnR9IGZyb20gJy4uL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3BlcnNvbmFsL3BlcnNvbmFsLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7QXNzZXRzQ29tcG9uZW50fSBmcm9tICcuLi9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9hc3NldHMvYXNzZXRzLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7QXVkaXRpbmdDb21wb25lbnR9IGZyb20gJy4uL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L2F1ZGl0aW5nL2F1ZGl0aW5nLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7TXlyZXNvdXJjZXNDb21wb25lbnR9IGZyb20gJy4uL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L215cmVzb3VyY2VzL215cmVzb3VyY2VzLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UGVyc29ubmVsQ29tcG9uZW50fSBmcm9tICcuLi9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9wZXJzb25uZWwvcGVyc29ubmVsLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UHJlcGFyaW5nZXhhbXNDb21wb25lbnR9IGZyb20gJy4uL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3ByZXBhcmluZ2V4YW1zL3ByZXBhcmluZ2V4YW1zLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UHJlcGFyaW5nbGVzc29uQ29tcG9uZW50fSBmcm9tICcuLi9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9wcmVwYXJpbmdsZXNzb24vcHJlcGFyaW5nbGVzc29uLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7UmVzb3VyY2VzQ29tcG9uZW50fSBmcm9tICcuLi9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9yZXNvdXJjZXMvcmVzb3VyY2VzLmNvbXBvbmVudCc7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBhcHBDb250ZW50Um91dGVzOiBSb3V0ZXMgPSBbXHJcblxyXG4gICAgeyBcclxuICAgICAgcGF0aDogJ2NvbnRlbnQnLFxyXG4gICAgICBjb21wb25lbnQ6IENvbnRlbnRDb21wb25lbnQsXHJcbiAgICAgIGNoaWxkcmVuOiBbXHJcbiAgICAgIFx0eyBwYXRoOiAnJywgcmVkaXJlY3RUbzogJ3BlcnNvbmFsJywgIHBhdGhNYXRjaDogJ2Z1bGwnfSxcclxuICAgICAgICB7IHBhdGg6ICdwZXJzb25hbCcsIGNvbXBvbmVudDogUGVyc29uYWxDb21wb25lbnR9LFxyXG4gICAgICAgIHsgcGF0aDogJ2Fzc2V0cycsIGNvbXBvbmVudDogQXNzZXRzQ29tcG9uZW50fSxcclxuICAgICAgICB7IHBhdGg6ICdhdWRpdGluZycsIGNvbXBvbmVudDogQXVkaXRpbmdDb21wb25lbnR9LFxyXG4gICAgICAgIHsgcGF0aDogJ215cmVzb3VyY2VzJywgY29tcG9uZW50OiBNeXJlc291cmNlc0NvbXBvbmVudH0sXHJcbiAgICAgICAgeyBwYXRoOiAncGVyc29ubmVsJywgY29tcG9uZW50OiBQZXJzb25uZWxDb21wb25lbnR9LFxyXG4gICAgICAgIHsgcGF0aDogJ3ByZXBhcmluZ2V4YW1zJywgY29tcG9uZW50OiBQcmVwYXJpbmdleGFtc0NvbXBvbmVudH0sXHJcbiAgICAgICAgeyBwYXRoOiAncHJlcGFyaW5nbGVzc29uJywgY29tcG9uZW50OiBQcmVwYXJpbmdsZXNzb25Db21wb25lbnR9LFxyXG4gICAgICAgXHR7IHBhdGg6ICdyZXNvdXJjZXMnLCBjb21wb25lbnQ6IFJlc291cmNlc0NvbXBvbmVudH1cclxuICAgICAgXVxyXG4gICAgfVxyXG5dO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuLy8gICBpbXBvcnRzOiBbIFJvdXRlck1vZHVsZS5mb3JDaGlsZChhcHBDb250ZW50Um91dGVzKSBdLFxyXG4gIGV4cG9ydHM6IFsgUm91dGVyTW9kdWxlIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIGFwcENvbnRlbnRSb3V0ZXNNb2R1bGV7IH1cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwUm91dGVyTW9kdWxlL2FwcENvbnRlbnRSb3V0ZXIubW9kdWxlLnRzIiwiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge01lbnV9IGZyb20gJy4uLy4uL21vY2tEYXRhL21lbnUnO1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2NvbnRlbnQtY29udGFpbmVyJyxcclxuICB0ZW1wbGF0ZTogIHJlcXVpcmUoJy4vY29udGVudC5odG1sJyksXHJcbiAgLy8gZGlyZWN0aXZlczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDb250ZW50Q29tcG9uZW50IHtcclxuXHRtZW51OmFueSA9IFtdO1xyXG4gICAgbm90ZXM6YW55ID0gW107XHJcbiAgICBjb25zdHJ1Y3RvciAoKSB7XHJcbiAgICBcdHRoaXMubWVudSA9IE1lbnU7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMC42LjJAYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbnRlbnQuY29tcG9uZW50LnRzIiwiZXhwb3J0IGNvbnN0IE1lbnU6YW55ID0gW1xyXG5cdHtcclxuXHQgIG5hbWU6ICfkuKrkurrkuK3lv4MnLFxyXG5cdCAgaWNvbkZvbnQ6ICdwZXJzb24nLFxyXG4gICAgdXJsOidwZXJzb25hbCdcclxuXHR9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAn5oiR55qE6LWE5rqQJyxcclxuICAgICAgaWNvbkZvbnQ6ICd3b3JrJyxcclxuICAgICAgdXJsOidteXJlc291cmNlcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICfkurrkuovnrqHnkIYnLFxyXG4gICAgICBpY29uRm9udDogJ3BlcnNvbl9hZGQnLFxyXG4gICAgICB1cmw6J3BlcnNvbm5lbCdcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICfotYTmupDlrqHmoLgnLFxyXG4gICAgICBpY29uRm9udDogJ3Zpc2liaWxpdHknLFxyXG4gICAgICB1cmw6J2F1ZGl0aW5nJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ+i1hOa6kOS4reW/gycsXHJcbiAgICAgIGljb25Gb250OiAndmlld19tb2R1bGUnLFxyXG4gICAgICB1cmw6J3Jlc291cmNlcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICfmjpLor77ns7vnu58nLFxyXG4gICAgICBpY29uRm9udDogJ3RvdWNoX2FwcCcsXHJcbiAgICAgIHVybDoncGVyc29uYWwnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAn5aSH6K++5Lit5b+DJyxcclxuICAgICAgaWNvbkZvbnQ6ICdyZWNlaXB0JyxcclxuICAgICAgdXJsOidwcmVwYXJpbmdsZXNzb24nXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAn5aSH6ICD5Lit5b+DJyxcclxuICAgICAgaWNvbkZvbnQ6ICdhc3Nlc3NtZW50JyxcclxuICAgICAgdXJsOidwcmVwYXJpbmdleGFtcydcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICfotYTkuqfnrqHnkIYnLFxyXG4gICAgICBpY29uRm9udDogJ2FjY291bnRfYmFsYW5jZScsXHJcbiAgICAgIHVybDonYXNzZXRzJ1xyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ+e0oOadkOS4reW/gycsXHJcbiAgICAgIGljb25Gb250OiAnZmlsZV9kb3dubG9hZCcsXHJcbiAgICAgIHVybDoncGVyc29uYWwnXHJcbiAgICB9XHJcbiBdXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMC42LjJAYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL21vY2tEYXRhL21lbnUudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPG1kLXNpZGVuYXYtY29udGFpbmVyIGNsYXNzPVxcXCJjb250YWluZXJcXFwiIGNvbG9yPVxcXCJwcmltYXJ5XFxcIj5cXHJcXG4gIDxtZC1zaWRlbmF2ICNzaWRlbmF2IGNsYXNzPVxcXCJzaWRlbmF2XFxcIiBtb2RlPVxcXCJzaWRlXFxcIiA+XFxyXFxuXFx0PG1kLWxpc3Q+XFxyXFxuXFx0XFx0PGgzIG1kLXN1YmhlYWRlciAgZnhMYXlvdXQ9XFxcInJvd1xcXCIgZnhMYXlvdXRBbGlnbj1cXFwiIGNlbnRlclxcXCIgPjxtZC1pY29uIGNvbG9yPVxcXCJwcmltYXJ5XFxcIj5jbG91ZDwvbWQtaWNvbj48c3Bhbj4mbmJzcDvlrabmoKHnrqHnkIbns7vnu588L3NwYW4+PC9oMz5cXHJcXG5cXHRcXHQ8bWQtZGl2aWRlcj48L21kLWRpdmlkZXI+XFxyXFxuXFx0XFx0PGEgbWQtbWVudS1pdGVtIHJvdXRlckxpbms9XFxcInt7bWVudWl0ZW0udXJsfX1cXFwiICpuZ0Zvcj1cXFwibGV0IG1lbnVpdGVtIG9mIG1lbnVcXFwiPlxcclxcblxcdFxcdFxcdDxtZC1pY29uPnt7bWVudWl0ZW0uaWNvbkZvbnR9fTwvbWQtaWNvbj5cXHJcXG5cXHRcXHRcXHQ8c3Bhbj57e21lbnVpdGVtLm5hbWV9fTwvc3Bhbj5cXHJcXG5cXHRcXHQ8L2E+XFxyXFxuXFx0XFx0XFxyXFxuXFx0PC9tZC1saXN0PlxcclxcblxcclxcbiAgPC9tZC1zaWRlbmF2PlxcclxcblxcclxcbiAgPGRpdiBjbGFzcz1cXFwic2lkZW5hdi1jb250ZW50XFxcIiBmeExheW91dD1cXFwicm93XFxcIiBmeExheW91dEFsaWduPVxcXCJzcGFjZS1iZXR3ZWVuIGNlbnRlclxcXCIgPlxcclxcbiAgXFx0PG1kLXRvb2xiYXIgY29sb3I9XFxcInByaW1hcnlcXFwiPlxcclxcblxcdCAgPG1kLXRvb2xiYXItcm93PlxcclxcblxcdCAgICA8IS0tIDxzcGFuPlRoaXJkIExpbmU8L3NwYW4+IC0tPlxcclxcblxcdCAgICA8YnV0dG9uIG1kLWljb24tYnV0dG9uIChjbGljayk9XFxcInNpZGVuYXYudG9nZ2xlKClcXFwiPlxcclxcblxcdCAgICAgIDxtZC1pY29uID5tZW51aXRlbTwvbWQtaWNvbj5cXHJcXG5cXHQgICAgPC9idXR0b24+XFxyXFxuXFx0ICBcXHJcXG5cXHQgICBcXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzcGFjZXJcXFwiPjwvZGl2PlxcclxcblxcdFxcdDxidXR0b24gbWQtaWNvbi1idXR0b24gW21kTWVudVRyaWdnZXJGb3JdPVxcXCJtZW51YnRuXFxcIj5cXHJcXG5cXHRcXHQgICAgPG1kLWljb24+bW9yZV92ZXJ0PC9tZC1pY29uPlxcclxcblxcdFxcdDwvYnV0dG9uPlxcclxcblxcdFxcdDxtZC1tZW51ICNtZW51YnRuPVxcXCJtZE1lbnVcXFwiPlxcclxcblxcdFxcdCAgICA8YnV0dG9uIG1kLW1lbnUtaXRlbT5cXHJcXG5cXHRcXHQgICAgICAgIDxtZC1pY29uPmRpYWxwYWQ8L21kLWljb24+XFxyXFxuXFx0XFx0ICAgICAgICA8c3Bhbj5SZWRpYWw8L3NwYW4+XFxyXFxuXFx0XFx0ICAgIDwvYnV0dG9uPlxcclxcblxcdFxcdCAgICA8YnV0dG9uIG1kLW1lbnUtaXRlbSBkaXNhYmxlZD5cXHJcXG5cXHRcXHQgICAgICAgIDxtZC1pY29uPnZvaWNlbWFpbDwvbWQtaWNvbj5cXHJcXG5cXHRcXHQgICAgICAgIDxzcGFuPkNoZWNrIHZvaWNlbWFpbDwvc3Bhbj5cXHJcXG5cXHRcXHQgICAgPC9idXR0b24+XFxyXFxuXFx0XFx0ICAgIDxidXR0b24gbWQtbWVudS1pdGVtPlxcclxcblxcdFxcdCAgICAgICAgPG1kLWljb24+bm90aWZpY2F0aW9uc19vZmY8L21kLWljb24+XFxyXFxuXFx0XFx0ICAgICAgICA8c3Bhbj5EaXNhYmxlIGFsZXJ0czwvc3Bhbj5cXHJcXG5cXHRcXHQgICAgPC9idXR0b24+XFxyXFxuXFx0XFx0PC9tZC1tZW51PlxcclxcblxcclxcbiAgICBcXHJcXG5cXHQgIDwvbWQtdG9vbGJhci1yb3c+XFxyXFxuXFx0PC9tZC10b29sYmFyPlxcclxcbiAgICBcXHJcXG4gICAgXFxyXFxuICAgIFxcclxcbiAgPC9kaXY+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50LWNvbnRhaW5lclxcXCI+XFxyXFxuICBcXHQ8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XFxyXFxuICA8L2Rpdj5cXHJcXG5cXHJcXG48L21kLXNpZGVuYXYtY29udGFpbmVyPlxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbnRlbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcclxuaW1wb3J0IHsgRmxleExheW91dE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2ZsZXgtbGF5b3V0JztcclxuaW1wb3J0IHsgUHVibGlja0hlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vaGVhZGVyLmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG5cdGltcG9ydHM6IFtcclxuXHRcdC8vIE1hdGVyaWFsTW9kdWxlLmZvclJvb3QoKSxcclxuXHRcdC8vIEZsZXhMYXlvdXRNb2R1bGUuZm9yUm9vdCgpLFxyXG5cdF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICBQdWJsaWNrSGVhZGVyQ29tcG9uZW50XHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogW1xyXG5cdCAgICBQdWJsaWNrSGVhZGVyQ29tcG9uZW50XHJcblx0XSxcclxufSlcclxuZXhwb3J0IGNsYXNzIFB1YmxpY01vZHVsZSB7fVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+Ly4wLjYuMkBhbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcFB1YmxpY01vZHVsZS9wdWJsaWMubW9kdWxlLnRzIiwiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3B1YmxpYy1oZWFkZXInLFxyXG4gIHRlbXBsYXRlOiAgYDxkaXY+cHVibGljIGhlYWRlcjwvZGl2PmAsXHJcbiAgLy8gZGlyZWN0aXZlczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQdWJsaWNrSGVhZGVyQ29tcG9uZW50IHt9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwUHVibGljTW9kdWxlL2hlYWRlci5jb21wb25lbnQudHMiLCJpbXBvcnQge0NvbXBvbmVudH0gICAgIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ215LWFwcCcsXHJcbiAgICB0ZW1wbGF0ZTogIGA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+YCxcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwLmNvbXBvbmVudC50cyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2Fzc2V0cy9zdHlsZS9zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdwZXJzb25hbC1jb21wb25lbnQnLFxyXG4gIHRlbXBsYXRlOiAgcmVxdWlyZSgnLi9wZXJzb25hbC5jb21wb25lbnQuaHRtbCcpLFxyXG4gIC8vIGRpcmVjdGl2ZXM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUGVyc29uYWxDb21wb25lbnQge31cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMC42LjJAYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9wZXJzb25hbC9wZXJzb25hbC5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxucGVyc29uYWxcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvcGVyc29uYWwvcGVyc29uYWwuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDYzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2Fzc2V0cy1jb21wb25lbnQnLFxyXG4gIHRlbXBsYXRlOiAgcmVxdWlyZSgnLi9hc3NldHMuY29tcG9uZW50Lmh0bWwnKSxcclxuICAvLyBkaXJlY3RpdmVzOiBbXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIEFzc2V0c0NvbXBvbmVudCB7fVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+Ly4wLjYuMkBhbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L2Fzc2V0cy9hc3NldHMuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcclxcbmFzc2V0c1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9hc3NldHMvYXNzZXRzLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA2MzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdhdWRpdGluZy1jb21wb25lbnQnLFxyXG4gIHRlbXBsYXRlOiAgcmVxdWlyZSgnLi9hdWRpdGluZy5jb21wb25lbnQuaHRtbCcpLFxyXG4gIC8vIGRpcmVjdGl2ZXM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXVkaXRpbmdDb21wb25lbnQge31cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi8uMC42LjJAYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9hdWRpdGluZy9hdWRpdGluZy5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxuYXVkaXRpbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvYXVkaXRpbmcvYXVkaXRpbmcuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDYzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ215cmVzb3VyY2VzLWNvbXBvbmVudCcsXHJcbiAgdGVtcGxhdGU6ICByZXF1aXJlKCcuL215cmVzb3VyY2VzLmNvbXBvbmVudC5odG1sJyksXHJcbiAgLy8gZGlyZWN0aXZlczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNeXJlc291cmNlc0NvbXBvbmVudCB7fVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+Ly4wLjYuMkBhbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L215cmVzb3VyY2VzL215cmVzb3VyY2VzLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXHJcXG5teXJlc291cmNlc1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9teXJlc291cmNlcy9teXJlc291cmNlcy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNjM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAncGVyc29ubmVsLWNvbXBvbmVudCcsXHJcbiAgdGVtcGxhdGU6ICByZXF1aXJlKCcuL3BlcnNvbm5lbC5jb21wb25lbnQuaHRtbCcpLFxyXG4gIC8vIGRpcmVjdGl2ZXM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUGVyc29ubmVsQ29tcG9uZW50IHt9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvcGVyc29ubmVsL3BlcnNvbm5lbC5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxucGVyc29ubmVsXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3BlcnNvbm5lbC9wZXJzb25uZWwuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDY0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3ByZXBhcmluZ2V4YW1zLWNvbXBvbmVudCcsXHJcbiAgdGVtcGxhdGU6ICByZXF1aXJlKCcuL3ByZXBhcmluZ2V4YW1zLmNvbXBvbmVudC5odG1sJyksXHJcbiAgLy8gZGlyZWN0aXZlczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQcmVwYXJpbmdleGFtc0NvbXBvbmVudCB7fVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+Ly4wLjYuMkBhbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3ByZXBhcmluZ2V4YW1zL3ByZXBhcmluZ2V4YW1zLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCJcXHJcXG5wcmVwYXJpbmdleGFtc1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9wcmVwYXJpbmdleGFtcy9wcmVwYXJpbmdleGFtcy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAncHJlcGFyaW5nbGVzc29uLWNvbXBvbmVudCcsXHJcbiAgdGVtcGxhdGU6ICByZXF1aXJlKCcuL3ByZXBhcmluZ2xlc3Nvbi5jb21wb25lbnQuaHRtbCcpLFxyXG4gIC8vIGRpcmVjdGl2ZXM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUHJlcGFyaW5nbGVzc29uQ29tcG9uZW50IHt9XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vLjAuNi4yQGFuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwQ29udGVudE1vZHVsZS9jb21wb25lbnQvcHJlcGFyaW5nbGVzc29uL3ByZXBhcmluZ2xlc3Nvbi5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxyXFxucHJlcGFyaW5nbGVzc29uXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3ByZXBhcmluZ2xlc3Nvbi9wcmVwYXJpbmdsZXNzb24uY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDY0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3Jlc291cmNlcy1jb21wb25lbnQnLFxyXG4gIHRlbXBsYXRlOiAgcmVxdWlyZSgnLi9yZXNvdXJjZXMuY29tcG9uZW50Lmh0bWwnKSxcclxuICAvLyBkaXJlY3RpdmVzOiBbXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIFJlc291cmNlc0NvbXBvbmVudCB7fVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+Ly4wLjYuMkBhbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcENvbnRlbnRNb2R1bGUvY29tcG9uZW50L3Jlc291cmNlcy9yZXNvdXJjZXMuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcclxcbnJlc291cmNlc1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3NyYy9hcHBDb250ZW50TW9kdWxlL2NvbXBvbmVudC9yZXNvdXJjZXMvcmVzb3VyY2VzLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA2NDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==