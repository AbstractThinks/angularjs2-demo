webpackJsonp([0],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var platform_browser_dynamic_1 = __webpack_require__(1);
	var app_module_1 = __webpack_require__(23);
	platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);


/***/ },

/***/ 23:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var platform_browser_1 = __webpack_require__(21);
	var forms_1 = __webpack_require__(24);
	var http_1 = __webpack_require__(28);
	var appRouter_module_1 = __webpack_require__(81);
	var app_component_1 = __webpack_require__(98);
	__webpack_require__(99);
	// if (environment.production) {
	core_1.enableProdMode();
	// }
	var AppModule = (function () {
	    function AppModule() {
	    }
	    return AppModule;
	}());
	AppModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            forms_1.FormsModule,
	            platform_browser_1.BrowserModule,
	            http_1.HttpModule,
	            appRouter_module_1.AppRoutingModule,
	        ],
	        declarations: [
	            app_component_1.AppComponent,
	        ],
	        bootstrap: [app_component_1.AppComponent]
	    }),
	    __metadata("design:paramtypes", [])
	], AppModule);
	exports.AppModule = AppModule;


/***/ },

/***/ 24:
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.4.8
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3), __webpack_require__(25), __webpack_require__(6), __webpack_require__(7), __webpack_require__(26)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/operator/toPromise', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/observable/fromPromise'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.forms = global.ng.forms || {}),global.ng.core,global.Rx.Observable.prototype,global.Rx,global.Rx,global.Rx.Observable));
	}(this, function (exports,_angular_core,rxjs_operator_toPromise,rxjs_Subject,rxjs_Observable,rxjs_observable_fromPromise) { 'use strict';
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Base class for control directives.
	     *
	     * Only used internally in the forms module.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AbstractControlDirective = (function () {
	        function AbstractControlDirective() {
	        }
	        Object.defineProperty(AbstractControlDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw new Error('unimplemented'); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "value", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.value : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.valid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "invalid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.invalid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pending", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.pending : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "errors", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.errors : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.pristine : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.dirty : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "touched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.touched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.untouched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "disabled", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.disabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "enabled", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.enabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "statusChanges", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.statusChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valueChanges", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.valueChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.reset = function (value) {
	            if (value === void 0) { value = undefined; }
	            if (this.control)
	                this.control.reset(value);
	        };
	        /**
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.hasError(errorCode, path) : false;
	        };
	        /**
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.getError(errorCode, path) : null;
	        };
	        return AbstractControlDirective;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * A directive that contains multiple {\@link NgControl}s.
	     *
	     * Only used by the forms module.
	     *
	     * \@stable
	     */
	    var ControlContainer = (function (_super) {
	        __extends$1(ControlContainer, _super);
	        function ControlContainer() {
	            _super.apply(this, arguments);
	        }
	        Object.defineProperty(ControlContainer.prototype, "formDirective", {
	            /**
	             * Get the form to which this container belongs.
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ControlContainer.prototype, "path", {
	            /**
	             * Get the path to this container.
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        return ControlContainer;
	    }(AbstractControlDirective));
	
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }
	
	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} condition
	         * @return {?}
	         */
	        ListWrapper.findLast = function (arr, condition) {
	            for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {
	                if (condition(arr[i])) {
	                    return arr[i];
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} list
	         * @param {?} items
	         * @return {?}
	         */
	        ListWrapper.removeAll = function (list, items) {
	            for (var /** @type {?} */ i = 0; i < items.length; ++i) {
	                var /** @type {?} */ index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        /**
	         * @param {?} list
	         * @param {?} el
	         * @return {?}
	         */
	        ListWrapper.remove = function (list, el) {
	            var /** @type {?} */ index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} a
	         * @param {?} b
	         * @return {?}
	         */
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        /**
	         * @param {?} list
	         * @return {?}
	         */
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return ((flat)).concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());
	
	    var /** @type {?} */ isPromise = _angular_core.__core_private__.isPromise;
	    var /** @type {?} */ isObservable = _angular_core.__core_private__.isObservable;
	
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    function isEmptyInputValue(value) {
	        // we don't check for string here so it also works with arrays
	        return value == null || value.length === 0;
	    }
	    /**
	     * Providers for validators to be used for {@link FormControl}s in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * ### Example
	     *
	     * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	     * @stable
	     */
	    var /** @type {?} */ NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');
	    /**
	     * Providers for asynchronous validators to be used for {@link FormControl}s
	     * in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * See {@link NG_VALIDATORS} for more details.
	     *
	     * @stable
	     */
	    var /** @type {?} */ NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');
	    /**
	     * Provides a set of validators used by form controls.
	     *
	     * A validator is a function that processes a {\@link FormControl} or collection of
	     * controls and returns a map of errors. A null map means that validation has passed.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * var loginControl = new FormControl("", Validators.required)
	     * ```
	     *
	     * \@stable
	     */
	    var Validators = (function () {
	        function Validators() {
	        }
	        /**
	         * Validator that requires controls to have a non-empty value.
	         * @param {?} control
	         * @return {?}
	         */
	        Validators.required = function (control) {
	            return isEmptyInputValue(control.value) ? { 'required': true } : null;
	        };
	        /**
	         * Validator that requires control value to be true.
	         * @param {?} control
	         * @return {?}
	         */
	        Validators.requiredTrue = function (control) {
	            return control.value === true ? null : { 'required': true };
	        };
	        /**
	         * Validator that requires controls to have a value of a minimum length.
	         * @param {?} minLength
	         * @return {?}
	         */
	        Validators.minLength = function (minLength) {
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var /** @type {?} */ length = control.value ? control.value.length : 0;
	                return length < minLength ?
	                    { 'minlength': { 'requiredLength': minLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires controls to have a value of a maximum length.
	         * @param {?} maxLength
	         * @return {?}
	         */
	        Validators.maxLength = function (maxLength) {
	            return function (control) {
	                var /** @type {?} */ length = control.value ? control.value.length : 0;
	                return length > maxLength ?
	                    { 'maxlength': { 'requiredLength': maxLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires a control to match a regex to its value.
	         * @param {?} pattern
	         * @return {?}
	         */
	        Validators.pattern = function (pattern) {
	            if (!pattern)
	                return Validators.nullValidator;
	            var /** @type {?} */ regex;
	            var /** @type {?} */ regexStr;
	            if (typeof pattern === 'string') {
	                regexStr = "^" + pattern + "$";
	                regex = new RegExp(regexStr);
	            }
	            else {
	                regexStr = pattern.toString();
	                regex = pattern;
	            }
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var /** @type {?} */ value = control.value;
	                return regex.test(value) ? null :
	                    { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } };
	            };
	        };
	        /**
	         * No-op validator.
	         * @param {?} c
	         * @return {?}
	         */
	        Validators.nullValidator = function (c) { return null; };
	        /**
	         * Compose multiple validators into a single function that returns the union
	         * of the individual error maps.
	         * @param {?} validators
	         * @return {?}
	         */
	        Validators.compose = function (validators) {
	            if (!validators)
	                return null;
	            var /** @type {?} */ presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                return _mergeErrors(_executeValidators(control, presentValidators));
	            };
	        };
	        /**
	         * @param {?} validators
	         * @return {?}
	         */
	        Validators.composeAsync = function (validators) {
	            if (!validators)
	                return null;
	            var /** @type {?} */ presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                var /** @type {?} */ promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
	                return Promise.all(promises).then(_mergeErrors);
	            };
	        };
	        return Validators;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function _convertToPromise(obj) {
	        return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);
	    }
	    /**
	     * @param {?} control
	     * @param {?} validators
	     * @return {?}
	     */
	    function _executeValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    /**
	     * @param {?} control
	     * @param {?} validators
	     * @return {?}
	     */
	    function _executeAsyncValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    /**
	     * @param {?} arrayOfErrors
	     * @return {?}
	     */
	    function _mergeErrors(arrayOfErrors) {
	        var /** @type {?} */ res = arrayOfErrors.reduce(function (res, errors) {
	            return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
	        }, {});
	        return Object.keys(res).length === 0 ? null : res;
	    }
	
	    /**
	     * Used to provide a {@link ControlValueAccessor} for form controls.
	     *
	     * See {@link DefaultValueAccessor} for how to implement one.
	     * @stable
	     */
	    var /** @type {?} */ NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');
	
	    var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxControlValueAccessor; }),
	        multi: true,
	    };
	    /**
	     * The accessor for writing a value and listening to changes on a checkbox input element.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="checkbox" name="rememberLogin" ngModel>
	     *  ```
	     *
	     *  \@stable
	     */
	    var CheckboxControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function CheckboxControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        CheckboxControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
	                        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	                        providers: [CHECKBOX_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return CheckboxControlValueAccessor;
	    }());
	
	    var /** @type {?} */ DEFAULT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return DefaultValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The default accessor for writing a value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="text" name="searchQuery" ngModel>
	     *  ```
	     *
	     *  \@stable
	     */
	    var DefaultValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function DefaultValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.writeValue = function (value) {
	            var /** @type {?} */ normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        DefaultValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	                        // TODO: vsavkin replace the above selector with the one below it once
	                        // https://github.com/angular/angular/issues/3011 is implemented
	                        // selector: '[ngControl],[ngModel],[ngFormControl]',
	                        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [DEFAULT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        DefaultValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return DefaultValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function normalizeValidator(validator) {
	        if (((validator)).validate) {
	            return function (c) { return ((validator)).validate(c); };
	        }
	        else {
	            return (validator);
	        }
	    }
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function normalizeAsyncValidator(validator) {
	        if (((validator)).validate) {
	            return function (c) { return ((validator)).validate(c); };
	        }
	        else {
	            return (validator);
	        }
	    }
	
	    var /** @type {?} */ NUMBER_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return NumberValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a number value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="number" [(ngModel)]="age">
	     *  ```
	     */
	    var NumberValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function NumberValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.writeValue = function (value) {
	            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
	            var /** @type {?} */ normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        NumberValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [NUMBER_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        NumberValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return NumberValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @return {?}
	     */
	    function unimplemented() {
	        throw new Error('unimplemented');
	    }
	    /**
	     * A base class that all control directive extend.
	     * It binds a {\@link FormControl} object to a DOM element.
	     *
	     * Used internally by Angular forms.
	     *
	     * \@stable
	     * @abstract
	     */
	    var NgControl = (function (_super) {
	        __extends$2(NgControl, _super);
	        function NgControl() {
	            _super.apply(this, arguments);
	            /** @internal */
	            this._parent = null;
	            this.name = null;
	            this.valueAccessor = null;
	            /** @internal */
	            this._rawValidators = [];
	            /** @internal */
	            this._rawAsyncValidators = [];
	        }
	        Object.defineProperty(NgControl.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgControl.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @abstract
	         * @param {?} newValue
	         * @return {?}
	         */
	        NgControl.prototype.viewToModelUpdate = function (newValue) { };
	        return NgControl;
	    }(AbstractControlDirective));
	
	    var /** @type {?} */ RADIO_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RadioControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * Internal class used by Angular to uncheck radio buttons with the matching name.
	     */
	    var RadioControlRegistry = (function () {
	        function RadioControlRegistry() {
	            this._accessors = [];
	        }
	        /**
	         * @param {?} control
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.add = function (control, accessor) {
	            this._accessors.push([control, accessor]);
	        };
	        /**
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.remove = function (accessor) {
	            for (var /** @type {?} */ i = this._accessors.length - 1; i >= 0; --i) {
	                if (this._accessors[i][1] === accessor) {
	                    this._accessors.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        /**
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.select = function (accessor) {
	            var _this = this;
	            this._accessors.forEach(function (c) {
	                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                    c[1].fireUncheck(accessor.value);
	                }
	            });
	        };
	        /**
	         * @param {?} controlPair
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {
	            if (!controlPair[0].control)
	                return false;
	            return controlPair[0]._parent === accessor._control._parent &&
	                controlPair[1].name === accessor.name;
	        };
	        RadioControlRegistry.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        RadioControlRegistry.ctorParameters = function () { return []; };
	        return RadioControlRegistry;
	    }());
	    /**
	     * \@whatItDoes Writes radio control values and listens to radio control changes.
	     *
	     * Used by {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName}
	     * to keep the view synced with the {\@link FormControl} model.
	     *
	     * \@howToUse
	     *
	     * If you have imported the {\@link FormsModule} or the {\@link ReactiveFormsModule}, this
	     * value accessor will be active on any radio control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use radio buttons with form directives
	     *
	     * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons
	     * in the same group have the same `name` attribute.  Radio buttons with different `name`
	     * attributes do not affect each other.
	     *
	     * {\@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}
	     *
	     * When using radio buttons in a reactive form, radio buttons in the same group should have the
	     * same `formControlName`. You can also add a `name` attribute, but it's optional.
	     *
	     * {\@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
	     *
	     *  * **npm package**: `\@angular/forms`
	     *
	     *  \@stable
	     */
	    var RadioControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         * @param {?} _registry
	         * @param {?} _injector
	         */
	        function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this._registry = _registry;
	            this._injector = _injector;
	            this.onChange = function () { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.ngOnInit = function () {
	            this._control = this._injector.get(NgControl);
	            this._checkName();
	            this._registry.add(this._control, this);
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.writeValue = function (value) {
	            this._state = value === this.value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this._fn = fn;
	            this.onChange = function () {
	                fn(_this.value);
	                _this._registry.select(_this);
	            };
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.fireUncheck = function (value) { this.writeValue(value); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype._checkName = function () {
	            if (this.name && this.formControlName && this.name !== this.formControlName) {
	                this._throwNameError();
	            }
	            if (!this.name && this.formControlName)
	                this.name = this.formControlName;
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype._throwNameError = function () {
	            throw new Error("\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    ");
	        };
	        RadioControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
	                        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	                        providers: [RADIO_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RadioControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	            { type: RadioControlRegistry, },
	            { type: _angular_core.Injector, },
	        ]; };
	        RadioControlValueAccessor.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'formControlName': [{ type: _angular_core.Input },],
	            'value': [{ type: _angular_core.Input },],
	        };
	        return RadioControlValueAccessor;
	    }());
	
	    var /** @type {?} */ RANGE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RangeValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a range value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="range" [(ngModel)]="age" >
	     *  ```
	     */
	    var RangeValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function RangeValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', parseFloat(value));
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        RangeValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [RANGE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RangeValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return RangeValueAccessor;
	    }());
	
	    var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * @param {?} id
	     * @param {?} value
	     * @return {?}
	     */
	    function _buildValueString(id, value) {
	        if (id == null)
	            return "" + value;
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    /**
	     * @param {?} valueString
	     * @return {?}
	     */
	    function _extractId(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * \@whatItDoes Writes values and listens to changes on a select element.
	     *
	     * Used by {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName}
	     * to keep the view synced with the {\@link FormControl} model.
	     *
	     * \@howToUse
	     *
	     * If you have imported the {\@link FormsModule} or the {\@link ReactiveFormsModule}, this
	     * value accessor will be active on any select control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use select controls with form directives
	     *
	     * To use a select in a template-driven form, simply add an `ngModel` and a `name`
	     * attribute to the main `<select>` tag.
	     *
	     * If your option values are simple strings, you can bind to the normal `value` property
	     * on the option.  If your option values happen to be objects (and you'd like to save the
	     * selection in your form as an object), use `ngValue` instead:
	     *
	     * {\@example forms/ts/selectControl/select_control_example.ts region='Component'}
	     *
	     * In reactive forms, you'll also want to add your form directive (`formControlName` or
	     * `formControl`) on the main `<select>` tag. Like in the former example, you have the
	     * choice of binding to the  `value` or `ngValue` property on the select's options.
	     *
	     * {\@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
	     *
	     * Note: We listen to the 'change' event because 'input' events aren't fired
	     * for selects in Firefox and IE:
	     * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350
	     * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var SelectControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function SelectControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.writeValue = function (value) {
	            this.value = value;
	            var /** @type {?} */ id = this._getOptionId(value);
	            if (id == null) {
	                this._renderer.setElementProperty(this._elementRef.nativeElement, 'selectedIndex', -1);
	            }
	            var /** @type {?} */ valueString = _buildValueString(id, value);
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (valueString) {
	                _this.value = valueString;
	                fn(_this._getOptionValue(valueString));
	            };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id), value))
	                    return id;
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} valueString
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var /** @type {?} */ id = _extractId(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
	        };
	        SelectControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
	                        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return SelectControlValueAccessor;
	    }());
	    /**
	     * \@whatItDoes Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * \@howToUse
	     *
	     * See docs for {\@link SelectControlValueAccessor} for usage examples.
	     *
	     * \@stable
	     */
	    var NgSelectOption = (function () {
	        /**
	         * @param {?} _element
	         * @param {?} _renderer
	         * @param {?} _select
	         */
	        function NgSelectOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select)
	                this.id = this._select._registerOption();
	        }
	        Object.defineProperty(NgSelectOption.prototype, "ngValue", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._select._optionMap.set(this.id, value);
	                this._setElementValue(_buildValueString(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectOption.prototype, "value", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._setElementValue(value);
	                if (this._select)
	                    this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSelectOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /**
	         * @return {?}
	         */
	        NgSelectOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectOption.ctorParameters = function () { return [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ]; };
	        NgSelectOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectOption;
	    }());
	
	    var /** @type {?} */ SELECT_MULTIPLE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectMultipleControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * @param {?} id
	     * @param {?} value
	     * @return {?}
	     */
	    function _buildValueString$1(id, value) {
	        if (id == null)
	            return "" + value;
	        if (typeof value === 'string')
	            value = "'" + value + "'";
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    /**
	     * @param {?} valueString
	     * @return {?}
	     */
	    function _extractId$1(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * The accessor for writing a value and listening to changes on a select element.
	     *
	     * \@stable
	     */
	    var SelectMultipleControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {
	            var _this = this;
	            this.value = value;
	            var /** @type {?} */ optionSelectedStateSetter;
	            if (Array.isArray(value)) {
	                // convert values to ids
	                var /** @type {?} */ ids_1 = value.map(function (v) { return _this._getOptionId(v); });
	                optionSelectedStateSetter = function (opt, o) { opt._setSelected(ids_1.indexOf(o.toString()) > -1); };
	            }
	            else {
	                optionSelectedStateSetter = function (opt, o) { opt._setSelected(false); };
	            }
	            this._optionMap.forEach(optionSelectedStateSetter);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (_) {
	                var /** @type {?} */ selected = [];
	                if (_.hasOwnProperty('selectedOptions')) {
	                    var /** @type {?} */ options = _.selectedOptions;
	                    for (var /** @type {?} */ i = 0; i < options.length; i++) {
	                        var /** @type {?} */ opt = options.item(i);
	                        var /** @type {?} */ val = _this._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                }
	                else {
	                    var /** @type {?} */ options = (_.options);
	                    for (var /** @type {?} */ i = 0; i < options.length; i++) {
	                        var /** @type {?} */ opt = options.item(i);
	                        if (opt.selected) {
	                            var /** @type {?} */ val = _this._getOptionValue(opt.value);
	                            selected.push(val);
	                        }
	                    }
	                }
	                _this.value = selected;
	                fn(selected);
	            };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {
	            var /** @type {?} */ id = (this._idCounter++).toString();
	            this._optionMap.set(id, value);
	            return id;
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id)._value, value))
	                    return id;
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} valueString
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var /** @type {?} */ id = _extractId$1(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
	        };
	        SelectMultipleControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
	                        host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectMultipleControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return SelectMultipleControlValueAccessor;
	    }());
	    /**
	     * Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * ### Example
	     *
	     * ```
	     * <select multiple name="city" ngModel>
	     *   <option *ngFor="let c of cities" [value]="c"></option>
	     * </select>
	     * ```
	     */
	    var NgSelectMultipleOption = (function () {
	        /**
	         * @param {?} _element
	         * @param {?} _renderer
	         * @param {?} _select
	         */
	        function NgSelectMultipleOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select) {
	                this.id = this._select._registerOption(this);
	            }
	        }
	        Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._value = value;
	                this._setElementValue(_buildValueString$1(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select) {
	                    this._value = value;
	                    this._setElementValue(_buildValueString$1(this.id, value));
	                    this._select.writeValue(this._select.value);
	                }
	                else {
	                    this._setElementValue(value);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /**
	         * \@internal
	         * @param {?} selected
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype._setSelected = function (selected) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	        };
	        /**
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectMultipleOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectMultipleOption.ctorParameters = function () { return [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ]; };
	        NgSelectMultipleOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectMultipleOption;
	    }());
	
	    /**
	     * @param {?} name
	     * @param {?} parent
	     * @return {?}
	     */
	    function controlPath(name, parent) {
	        return parent.path.concat([name]);
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function setUpControl(control, dir) {
	        if (!control)
	            _throwError(dir, 'Cannot find control with');
	        if (!dir.valueAccessor)
	            _throwError(dir, 'No value accessor for form control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	        dir.valueAccessor.writeValue(control.value);
	        // view -> model
	        dir.valueAccessor.registerOnChange(function (newValue) {
	            dir.viewToModelUpdate(newValue);
	            control.markAsDirty();
	            control.setValue(newValue, { emitModelToViewChange: false });
	        });
	        // touched
	        dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
	        control.registerOnChange(function (newValue, emitModelEvent) {
	            // control -> view
	            dir.valueAccessor.writeValue(newValue);
	            // control -> ngModel
	            if (emitModelEvent)
	                dir.viewToModelUpdate(newValue);
	        });
	        if (dir.valueAccessor.setDisabledState) {
	            control.registerOnDisabledChange(function (isDisabled) { dir.valueAccessor.setDisabledState(isDisabled); });
	        }
	        // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
	        dir._rawValidators.forEach(function (validator) {
	            if (((validator)).registerOnValidatorChange)
	                ((validator)).registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (((validator)).registerOnValidatorChange)
	                ((validator)).registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function cleanUpControl(control, dir) {
	        dir.valueAccessor.registerOnChange(function () { return _noControlError(dir); });
	        dir.valueAccessor.registerOnTouched(function () { return _noControlError(dir); });
	        dir._rawValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        if (control)
	            control._clearChangeFns();
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function setUpFormContainer(control, dir) {
	        if (isBlank(control))
	            _throwError(dir, 'Cannot find control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    }
	    /**
	     * @param {?} dir
	     * @return {?}
	     */
	    function _noControlError(dir) {
	        return _throwError(dir, 'There is no FormControl instance attached to form control element with');
	    }
	    /**
	     * @param {?} dir
	     * @param {?} message
	     * @return {?}
	     */
	    function _throwError(dir, message) {
	        var /** @type {?} */ messageEnd;
	        if (dir.path.length > 1) {
	            messageEnd = "path: '" + dir.path.join(' -> ') + "'";
	        }
	        else if (dir.path[0]) {
	            messageEnd = "name: '" + dir.path + "'";
	        }
	        else {
	            messageEnd = 'unspecified name attribute';
	        }
	        throw new Error(message + " " + messageEnd);
	    }
	    /**
	     * @param {?} validators
	     * @return {?}
	     */
	    function composeValidators(validators) {
	        return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
	    }
	    /**
	     * @param {?} validators
	     * @return {?}
	     */
	    function composeAsyncValidators(validators) {
	        return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :
	            null;
	    }
	    /**
	     * @param {?} changes
	     * @param {?} viewModel
	     * @return {?}
	     */
	    function isPropertyUpdated(changes, viewModel) {
	        if (!changes.hasOwnProperty('model'))
	            return false;
	        var /** @type {?} */ change = changes['model'];
	        if (change.isFirstChange())
	            return true;
	        return !looseIdentical(viewModel, change.currentValue);
	    }
	    var /** @type {?} */ BUILTIN_ACCESSORS = [
	        CheckboxControlValueAccessor,
	        RangeValueAccessor,
	        NumberValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	    ];
	    /**
	     * @param {?} valueAccessor
	     * @return {?}
	     */
	    function isBuiltInAccessor(valueAccessor) {
	        return BUILTIN_ACCESSORS.some(function (a) { return valueAccessor.constructor === a; });
	    }
	    /**
	     * @param {?} dir
	     * @param {?} valueAccessors
	     * @return {?}
	     */
	    function selectValueAccessor(dir, valueAccessors) {
	        if (!valueAccessors)
	            return null;
	        var /** @type {?} */ defaultAccessor;
	        var /** @type {?} */ builtinAccessor;
	        var /** @type {?} */ customAccessor;
	        valueAccessors.forEach(function (v) {
	            if (v.constructor === DefaultValueAccessor) {
	                defaultAccessor = v;
	            }
	            else if (isBuiltInAccessor(v)) {
	                if (builtinAccessor)
	                    _throwError(dir, 'More than one built-in value accessor matches form control with');
	                builtinAccessor = v;
	            }
	            else {
	                if (customAccessor)
	                    _throwError(dir, 'More than one custom value accessor matches form control with');
	                customAccessor = v;
	            }
	        });
	        if (customAccessor)
	            return customAccessor;
	        if (builtinAccessor)
	            return builtinAccessor;
	        if (defaultAccessor)
	            return defaultAccessor;
	        _throwError(dir, 'No valid value accessor for form control with');
	        return null;
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * This is a base class for code shared between {\@link NgModelGroup} and {\@link FormGroupName}.
	     *
	     * \@stable
	     */
	    var AbstractFormGroupDirective = (function (_super) {
	        __extends(AbstractFormGroupDirective, _super);
	        function AbstractFormGroupDirective() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormGroup(this);
	        };
	        /**
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormGroup(this);
	            }
	        };
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "control", {
	            /**
	             * Get the {\@link FormGroup} backing this binding.
	             * @return {?}
	             */
	            get: function () { return this.formDirective.getFormGroup(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "path", {
	            /**
	             * Get the path to this control group.
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "formDirective", {
	            /**
	             * Get the {\@link Form} to which this group belongs.
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype._checkParentType = function () { };
	        return AbstractFormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var AbstractControlStatus = (function () {
	        /**
	         * @param {?} cd
	         */
	        function AbstractControlStatus(cd) {
	            this._cd = cd;
	        }
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassUntouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.untouched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassTouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.touched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPristine", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.pristine : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassDirty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.dirty : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassValid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.valid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassInvalid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.invalid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPending", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.pending : false; },
	            enumerable: true,
	            configurable: true
	        });
	        return AbstractControlStatus;
	    }());
	    var /** @type {?} */ ngControlStatusHost = {
	        '[class.ng-untouched]': 'ngClassUntouched',
	        '[class.ng-touched]': 'ngClassTouched',
	        '[class.ng-pristine]': 'ngClassPristine',
	        '[class.ng-dirty]': 'ngClassDirty',
	        '[class.ng-valid]': 'ngClassValid',
	        '[class.ng-invalid]': 'ngClassInvalid',
	        '[class.ng-pending]': 'ngClassPending',
	    };
	    /**
	     * Directive automatically applied to Angular form controls that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * \@stable
	     */
	    var NgControlStatus = (function (_super) {
	        __extends$3(NgControlStatus, _super);
	        /**
	         * @param {?} cd
	         */
	        function NgControlStatus(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatus.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost },] },
	        ];
	        /** @nocollapse */
	        NgControlStatus.ctorParameters = function () { return [
	            { type: NgControl, decorators: [{ type: _angular_core.Self },] },
	        ]; };
	        return NgControlStatus;
	    }(AbstractControlStatus));
	    /**
	     * Directive automatically applied to Angular form groups that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * \@stable
	     */
	    var NgControlStatusGroup = (function (_super) {
	        __extends$3(NgControlStatusGroup, _super);
	        /**
	         * @param {?} cd
	         */
	        function NgControlStatusGroup(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatusGroup.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
	                        host: ngControlStatusHost
	                    },] },
	        ];
	        /** @nocollapse */
	        NgControlStatusGroup.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Self },] },
	        ]; };
	        return NgControlStatusGroup;
	    }(AbstractControlStatus));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * \@Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   \@Output() open: EventEmitter<any> = new EventEmitter();
	     *   \@Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * \@stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$5(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         * @param {?=} isAsync
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        /**
	         * @param {?=} generatorOrNext
	         * @param {?=} error
	         * @param {?=} complete
	         * @return {?}
	         */
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var /** @type {?} */ schedulerFn;
	            var /** @type {?} */ errorFn = function (err) { return null; };
	            var /** @type {?} */ completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.
	     */
	    var /** @type {?} */ VALID = 'VALID';
	    /**
	     * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.
	     */
	    var /** @type {?} */ INVALID = 'INVALID';
	    /**
	     * Indicates that a FormControl is pending, i.e. that async validation is occurring and
	     * errors are not yet available for the input value.
	     */
	    var /** @type {?} */ PENDING = 'PENDING';
	    /**
	     * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor
	     * calculations of validity or value.
	     */
	    var /** @type {?} */ DISABLED = 'DISABLED';
	    /**
	     * @param {?} control
	     * @param {?} path
	     * @param {?} delimiter
	     * @return {?}
	     */
	    function _find(control, path, delimiter) {
	        if (path == null)
	            return null;
	        if (!(path instanceof Array)) {
	            path = ((path)).split(delimiter);
	        }
	        if (path instanceof Array && (path.length === 0))
	            return null;
	        return ((path)).reduce(function (v, name) {
	            if (v instanceof FormGroup) {
	                return v.controls[name] || null;
	            }
	            if (v instanceof FormArray) {
	                return v.at(/** @type {?} */ (name)) || null;
	            }
	            return null;
	        }, control);
	    }
	    /**
	     * @param {?} r
	     * @return {?}
	     */
	    function toObservable(r) {
	        return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;
	    }
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function coerceToValidator(validator) {
	        return Array.isArray(validator) ? composeValidators(validator) : validator;
	    }
	    /**
	     * @param {?} asyncValidator
	     * @return {?}
	     */
	    function coerceToAsyncValidator(asyncValidator) {
	        return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;
	    }
	    /**
	     * \@whatItDoes This is the base class for {\@link FormControl}, {\@link FormGroup}, and
	     * {\@link FormArray}.
	     *
	     * It provides some of the shared behavior that all controls and groups of controls have, like
	     * running validators, calculating status, and resetting state. It also defines the properties
	     * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
	     * instantiated directly.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AbstractControl = (function () {
	        /**
	         * @param {?} validator
	         * @param {?} asyncValidator
	         */
	        function AbstractControl(validator, asyncValidator) {
	            this.validator = validator;
	            this.asyncValidator = asyncValidator;
	            /** @internal */
	            this._onCollectionChange = function () { };
	            this._pristine = true;
	            this._touched = false;
	            /** @internal */
	            this._onDisabledChange = [];
	        }
	        Object.defineProperty(AbstractControl.prototype, "value", {
	            /**
	             * The value of the control.
	             * @return {?}
	             */
	            get: function () { return this._value; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "parent", {
	            /**
	             * The parent control.
	             * @return {?}
	             */
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "status", {
	            /**
	             * The validation status of the control. There are four possible
	             * validation statuses:
	             *
	             * * **VALID**:  control has passed all validation checks
	             * * **INVALID**: control has failed at least one validation check
	             * * **PENDING**: control is in the midst of conducting a validation check
	             * * **DISABLED**: control is exempt from validation checks
	             *
	             * These statuses are mutually exclusive, so a control cannot be
	             * both valid AND invalid or invalid AND disabled.
	             * @return {?}
	             */
	            get: function () { return this._status; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valid", {
	            /**
	             * A control is `valid` when its `status === VALID`.
	             *
	             * In order to have this status, the control must have passed all its
	             * validation checks.
	             * @return {?}
	             */
	            get: function () { return this._status === VALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "invalid", {
	            /**
	             * A control is `invalid` when its `status === INVALID`.
	             *
	             * In order to have this status, the control must have failed
	             * at least one of its validation checks.
	             * @return {?}
	             */
	            get: function () { return this._status === INVALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pending", {
	            /**
	             * A control is `pending` when its `status === PENDING`.
	             *
	             * In order to have this status, the control must be in the
	             * middle of conducting a validation check.
	             * @return {?}
	             */
	            get: function () { return this._status == PENDING; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "disabled", {
	            /**
	             * A control is `disabled` when its `status === DISABLED`.
	             *
	             * Disabled controls are exempt from validation checks and
	             * are not included in the aggregate value of their ancestor
	             * controls.
	             * @return {?}
	             */
	            get: function () { return this._status === DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "enabled", {
	            /**
	             * A control is `enabled` as long as its `status !== DISABLED`.
	             *
	             * In other words, it has a status of `VALID`, `INVALID`, or
	             * `PENDING`.
	             * @return {?}
	             */
	            get: function () { return this._status !== DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "errors", {
	            /**
	             * Returns any errors generated by failing validation. If there
	             * are no errors, it will return null.
	             * @return {?}
	             */
	            get: function () { return this._errors; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pristine", {
	            /**
	             * A control is `pristine` if the user has not yet changed
	             * the value in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             * @return {?}
	             */
	            get: function () { return this._pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "dirty", {
	            /**
	             * A control is `dirty` if the user has changed the value
	             * in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             * @return {?}
	             */
	            get: function () { return !this.pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "touched", {
	            /**
	             * A control is marked `touched` once the user has triggered
	             * a `blur` event on it.
	             * @return {?}
	             */
	            get: function () { return this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "untouched", {
	            /**
	             * A control is `untouched` if the user has not yet triggered
	             * a `blur` event on it.
	             * @return {?}
	             */
	            get: function () { return !this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valueChanges", {
	            /**
	             * Emits an event every time the value of the control changes, in
	             * the UI or programmatically.
	             * @return {?}
	             */
	            get: function () { return this._valueChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "statusChanges", {
	            /**
	             * Emits an event every time the validation status of the control
	             * is re-calculated.
	             * @return {?}
	             */
	            get: function () { return this._statusChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Sets the synchronous validators that are active on this control.  Calling
	         * this will overwrite any existing sync validators.
	         * @param {?} newValidator
	         * @return {?}
	         */
	        AbstractControl.prototype.setValidators = function (newValidator) {
	            this.validator = coerceToValidator(newValidator);
	        };
	        /**
	         * Sets the async validators that are active on this control. Calling this
	         * will overwrite any existing async validators.
	         * @param {?} newValidator
	         * @return {?}
	         */
	        AbstractControl.prototype.setAsyncValidators = function (newValidator) {
	            this.asyncValidator = coerceToAsyncValidator(newValidator);
	        };
	        /**
	         * Empties out the sync validator list.
	         * @return {?}
	         */
	        AbstractControl.prototype.clearValidators = function () { this.validator = null; };
	        /**
	         * Empties out the async validator list.
	         * @return {?}
	         */
	        AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };
	        /**
	         * Marks the control as `touched`.
	         *
	         * This will also mark all direct ancestors as `touched` to maintain
	         * the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = true;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `untouched`.
	         *
	         * If the control has any children, it will also mark all children as `untouched`
	         * to maintain the model, and re-calculate the `touched` status of all parent
	         * controls.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsUntouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = false;
	            this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `dirty`.
	         *
	         * This will also mark all direct ancestors as `dirty` to maintain
	         * the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsDirty = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = false;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsDirty({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pristine`.
	         *
	         * If the control has any children, it will also mark all children as `pristine`
	         * to maintain the model, and re-calculate the `pristine` status of all parent
	         * controls.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsPristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = true;
	            this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pending`.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsPending = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._status = PENDING;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsPending({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Disables the control. This means the control will be exempt from validation checks and
	         * excluded from the aggregate value of any parent. Its status is `DISABLED`.
	         *
	         * If the control has children, all children will be disabled to maintain the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.disable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = DISABLED;
	            this._errors = null;
	            this._forEachChild(function (control) { control.disable({ onlySelf: true }); });
	            this._updateValue();
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });
	        };
	        /**
	         * Enables the control. This means the control will be included in validation checks and
	         * the aggregate value of its parent. Its status is re-calculated based on its value and
	         * its validators.
	         *
	         * If the control has children, all children will be enabled.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.enable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = VALID;
	            this._forEachChild(function (control) { control.enable({ onlySelf: true }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });
	        };
	        /**
	         * @param {?} onlySelf
	         * @return {?}
	         */
	        AbstractControl.prototype._updateAncestors = function (onlySelf) {
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity();
	                this._parent._updatePristine();
	                this._parent._updateTouched();
	            }
	        };
	        /**
	         * @param {?} parent
	         * @return {?}
	         */
	        AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
	        /**
	         * Sets the value of the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.setValue = function (value, options) { };
	        /**
	         * Patches the value of the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.patchValue = function (value, options) { };
	        /**
	         * Resets the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?=} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.reset = function (value, options) { };
	        /**
	         * Re-calculates the value and validation status of the control.
	         *
	         * By default, it will also update the value and validity of its ancestors.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.updateValueAndValidity = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._setInitialStatus();
	            this._updateValue();
	            if (this.enabled) {
	                this._errors = this._runValidator();
	                this._status = this._calculateStatus();
	                if (this._status === VALID || this._status === PENDING) {
	                    this._runAsyncValidator(emitEvent);
	                }
	            }
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updateTreeValidity = function (_a) {
	            var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;
	            this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity({ emitEvent: emitEvent }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._runValidator = function () {
	            return this.validator ? this.validator(this) : null;
	        };
	        /**
	         * @param {?} emitEvent
	         * @return {?}
	         */
	        AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
	            var _this = this;
	            if (this.asyncValidator) {
	                this._status = PENDING;
	                this._cancelExistingSubscription();
	                var /** @type {?} */ obs = toObservable(this.asyncValidator(this));
	                if (!(isObservable(obs))) {
	                    throw new Error("expected the following validator to return Promise or Observable: " + this.asyncValidator + ". If you are using FormBuilder; did you forget to brace your validators in an array?");
	                }
	                this._asyncValidationSubscription =
	                    obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._cancelExistingSubscription = function () {
	            if (this._asyncValidationSubscription) {
	                this._asyncValidationSubscription.unsubscribe();
	            }
	        };
	        /**
	         * Sets errors on a form control.
	         *
	         * This is used when validations are run manually by the user, rather than automatically.
	         *
	         * Calling `setErrors` will also update the validity of the parent control.
	         *
	         * ### Example
	         *
	         * ```
	         * const login = new FormControl("someLogin");
	         * login.setErrors({
	         *   "notUnique": true
	         * });
	         *
	         * expect(login.valid).toEqual(false);
	         * expect(login.errors).toEqual({"notUnique": true});
	         *
	         * login.setValue("someOtherLogin");
	         *
	         * expect(login.valid).toEqual(true);
	         * ```
	         * @param {?} errors
	         * @param {?=} __1
	         * @return {?}
	         */
	        AbstractControl.prototype.setErrors = function (errors, _a) {
	            var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
	            this._errors = errors;
	            this._updateControlsErrors(emitEvent !== false);
	        };
	        /**
	         * Retrieves a child control given the control's name or path.
	         *
	         * Paths can be passed in as an array or a string delimited by a dot.
	         *
	         * To get a control nested within a `person` sub-group:
	         *
	         * * `this.form.get('person.name');`
	         *
	         * -OR-
	         *
	         * * `this.form.get(['person', 'name']);`
	         * @param {?} path
	         * @return {?}
	         */
	        AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns null or undefined.
	         *
	         * If no path is given, it checks for the error on the present control.
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControl.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            var /** @type {?} */ control = path ? this.get(path) : this;
	            return control && control._errors ? control._errors[errorCode] : null;
	        };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns false.
	         *
	         * If no path is given, it checks for the error on the present control.
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControl.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return !!this.getError(errorCode, path);
	        };
	        Object.defineProperty(AbstractControl.prototype, "root", {
	            /**
	             * Retrieves the top-level ancestor of this control.
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ x = this;
	                while (x._parent) {
	                    x = x._parent;
	                }
	                return x;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} emitEvent
	         * @return {?}
	         */
	        AbstractControl.prototype._updateControlsErrors = function (emitEvent) {
	            this._status = this._calculateStatus();
	            if (emitEvent) {
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent) {
	                this._parent._updateControlsErrors(emitEvent);
	            }
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._initObservables = function () {
	            this._valueChanges = new EventEmitter();
	            this._statusChanges = new EventEmitter();
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._calculateStatus = function () {
	            if (this._allControlsDisabled())
	                return DISABLED;
	            if (this._errors)
	                return INVALID;
	            if (this._anyControlsHaveStatus(PENDING))
	                return PENDING;
	            if (this._anyControlsHaveStatus(INVALID))
	                return INVALID;
	            return VALID;
	        };
	        /**
	         * \@internal
	         * @abstract
	         * @return {?}
	         */
	        AbstractControl.prototype._updateValue = function () { };
	        /**
	         * \@internal
	         * @abstract
	         * @param {?} cb
	         * @return {?}
	         */
	        AbstractControl.prototype._forEachChild = function (cb) { };
	        /**
	         * \@internal
	         * @abstract
	         * @param {?} condition
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControls = function (condition) { };
	        /**
	         * \@internal
	         * @abstract
	         * @return {?}
	         */
	        AbstractControl.prototype._allControlsDisabled = function () { };
	        /**
	         * \@internal
	         * @param {?} status
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsHaveStatus = function (status) {
	            return this._anyControls(function (control) { return control.status === status; });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsDirty = function () {
	            return this._anyControls(function (control) { return control.dirty; });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsTouched = function () {
	            return this._anyControls(function (control) { return control.touched; });
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updatePristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = !this._anyControlsDirty();
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updateTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = this._anyControlsTouched();
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} formState
	         * @return {?}
	         */
	        AbstractControl.prototype._isBoxedValue = function (formState) {
	            return typeof formState === 'object' && formState !== null &&
	                Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
	        };
	        /**
	         * \@internal
	         * @param {?} fn
	         * @return {?}
	         */
	        AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };
	        return AbstractControl;
	    }());
	    /**
	     * \@whatItDoes Tracks the value and validation status of an individual form control.
	     *
	     * It is one of the three fundamental building blocks of Angular forms, along with
	     * {\@link FormGroup} and {\@link FormArray}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormControl}, you can pass in an initial value as the
	     * first argument. Example:
	     *
	     * ```ts
	     * const ctrl = new FormControl('some value');
	     * console.log(ctrl.value);     // 'some value'
	     * ```
	     *
	     * You can also initialize the control with a form state object on instantiation,
	     * which includes both the value and whether or not the control is disabled.
	     * You can't use the value key without the disabled key; both are required
	     * to use this way of initialization.
	     *
	     * ```ts
	     * const ctrl = new FormControl({value: 'n/a', disabled: true});
	     * console.log(ctrl.value);     // 'n/a'
	     * console.log(ctrl.status);   // 'DISABLED'
	     * ```
	     *
	     * To include a sync validator (or an array of sync validators) with the control,
	     * pass it in as the second argument. Async validators are also supported, but
	     * have to be passed in separately as the third arg.
	     *
	     * ```ts
	     * const ctrl = new FormControl('', Validators.required);
	     * console.log(ctrl.value);     // ''
	     * console.log(ctrl.status);   // 'INVALID'
	     * ```
	     *
	     * See its superclass, {\@link AbstractControl}, for more properties and methods.
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormControl = (function (_super) {
	        __extends$6(FormControl, _super);
	        /**
	         * @param {?=} formState
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormControl(formState, validator, asyncValidator) {
	            if (formState === void 0) { formState = null; }
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));
	            /** @internal */
	            this._onChange = [];
	            this._applyFormState(formState);
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	            this._initObservables();
	        }
	        /**
	         * Set the value of the form control to `value`.
	         *
	         * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
	         * and not its parent component. This defaults to false.
	         *
	         * If `emitEvent` is `true`, this
	         * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults
	         * to true (as it falls through to `updateValueAndValidity`).
	         *
	         * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	         * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	         * specified.
	         *
	         * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the
	         * model.  This is the default behavior if `emitViewToModelChange` is not specified.
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormControl.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange, emitViewToModelChange = _b.emitViewToModelChange;
	            this._value = value;
	            if (this._onChange.length && emitModelToViewChange !== false) {
	                this._onChange.forEach(function (changeFn) { return changeFn(_this._value, emitViewToModelChange !== false); });
	            }
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Patches the value of a control.
	         *
	         * This function is functionally the same as {\@link FormControl.setValue} at this level.
	         * It exists for symmetry with {\@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,
	         * where it does behave differently.
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        FormControl.prototype.patchValue = function (value, options) {
	            if (options === void 0) { options = {}; }
	            this.setValue(value, options);
	        };
	        /**
	         * Resets the form control. This means by default:
	         *
	         * * it is marked as `pristine`
	         * * it is marked as `untouched`
	         * * value is set to null
	         *
	         * You can also reset to a specific form state by passing through a standalone
	         * value or a form state object that contains both a value and a disabled state
	         * (these are the only two properties that cannot be calculated).
	         *
	         * Ex:
	         *
	         * ```ts
	         * this.control.reset('Nancy');
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * ```
	         *
	         * OR
	         *
	         * ```
	         * this.control.reset({value: 'Nancy', disabled: true});
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * console.log(this.control.status);  // 'DISABLED'
	         * ```
	         * @param {?=} formState
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormControl.prototype.reset = function (formState, _a) {
	            if (formState === void 0) { formState = null; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._applyFormState(formState);
	            this.markAsPristine({ onlySelf: onlySelf });
	            this.markAsUntouched({ onlySelf: onlySelf });
	            this.setValue(this._value, { onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._updateValue = function () { };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormControl.prototype._anyControls = function (condition) { return false; };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._allControlsDisabled = function () { return this.disabled; };
	        /**
	         * Register a listener for change events.
	         * @param {?} fn
	         * @return {?}
	         */
	        FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._clearChangeFns = function () {
	            this._onChange = [];
	            this._onDisabledChange = [];
	            this._onCollectionChange = function () { };
	        };
	        /**
	         * Register a listener for disabled events.
	         * @param {?} fn
	         * @return {?}
	         */
	        FormControl.prototype.registerOnDisabledChange = function (fn) {
	            this._onDisabledChange.push(fn);
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormControl.prototype._forEachChild = function (cb) { };
	        /**
	         * @param {?} formState
	         * @return {?}
	         */
	        FormControl.prototype._applyFormState = function (formState) {
	            if (this._isBoxedValue(formState)) {
	                this._value = formState.value;
	                formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
	                    this.enable({ onlySelf: true, emitEvent: false });
	            }
	            else {
	                this._value = formState;
	            }
	        };
	        return FormControl;
	    }(AbstractControl));
	    /**
	     * \@whatItDoes Tracks the value and validity state of a group of {\@link FormControl}
	     * instances.
	     *
	     * A `FormGroup` aggregates the values of each child {\@link FormControl} into one object,
	     * with each control name as the key.  It calculates its status by reducing the statuses
	     * of its children. For example, if one of the controls in a group is invalid, the entire
	     * group becomes invalid.
	     *
	     * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {\@link FormControl} and {\@link FormArray}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormGroup}, pass in a collection of child controls as the first
	     * argument. The key for each child will be the name under which it is registered.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   first: new FormControl('Nancy', Validators.minLength(2)),
	     *   last: new FormControl('Drew'),
	     * });
	     *
	     * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
	     * console.log(form.status);  // 'VALID'
	     * ```
	     *
	     * You can also include group-level validators as the second arg, or group-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   password: new FormControl('', Validators.minLength(2)),
	     *   passwordConfirm: new FormControl('', Validators.minLength(2)),
	     * }, passwordMatchValidator);
	     *
	     *
	     * function passwordMatchValidator(g: FormGroup) {
	     *    return g.get('password').value === g.get('passwordConfirm').value
	     *       ? null : {'mismatch': true};
	     * }
	     * ```
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormGroup = (function (_super) {
	        __extends$6(FormGroup, _super);
	        /**
	         * @param {?} controls
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormGroup(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Registers a control with the group's list of controls.
	         *
	         * This method does not update value or validity of the control, so for
	         * most cases you'll want to use {\@link FormGroup.addControl} instead.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.registerControl = function (name, control) {
	            if (this.controls[name])
	                return this.controls[name];
	            this.controls[name] = control;
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	            return control;
	        };
	        /**
	         * Add a control to this group.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.addControl = function (name, control) {
	            this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove a control from this group.
	         * @param {?} name
	         * @return {?}
	         */
	        FormGroup.prototype.removeControl = function (name) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.setControl = function (name, control) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            if (control)
	                this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Check whether there is an enabled control with the given name in the group.
	         *
	         * It will return false for disabled controls. If you'd like to check for
	         * existence in the group only, use {\@link AbstractControl.get} instead.
	         * @param {?} controlName
	         * @return {?}
	         */
	        FormGroup.prototype.contains = function (controlName) {
	            return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
	        };
	        /**
	         *  Sets the value of the {\@link FormGroup}. It accepts an object that matches
	         *  the structure of the group, with control names as keys.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.setValue({first: 'Nancy', last: 'Drew'});
	         *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
	         *
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            Object.keys(value).forEach(function (name) {
	                _this._throwIfControlMissing(name);
	                _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {\@link FormGroup}. It accepts an object with control
	         *  names as keys, and will do its best to match the values to the correct controls
	         *  in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the group without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.patchValue({first: 'Nancy'});
	         *  console.log(form.value);   // {first: 'Nancy', last: null}
	         *
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            Object.keys(value).forEach(function (name) {
	                if (_this.controls[name]) {
	                    _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {\@link FormGroup}. This means by default:
	         *
	         * * The group and all descendants are marked `pristine`
	         * * The group and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in a map of states
	         * that matches the structure of your form, with control names as keys. The state
	         * can be a standalone value or a form state object with both a value and a disabled
	         * status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.form.reset({first: 'name', last: 'last name'});
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.form.reset({
	         *   first: {value: 'name', disabled: true},
	         *   last: 'last'
	         * });
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * console.log(this.form.get('first').status);  // 'DISABLED'
	         * ```
	         * @param {?=} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = {}; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, name) {
	                control.reset(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the {\@link FormGroup}, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the group.
	         * @return {?}
	         */
	        FormGroup.prototype.getRawValue = function () {
	            return this._reduceChildren({}, function (acc, control, name) {
	                acc[name] = control instanceof FormControl ? control.value : ((control)).getRawValue();
	                return acc;
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} name
	         * @return {?}
	         */
	        FormGroup.prototype._throwIfControlMissing = function (name) {
	            if (!Object.keys(this.controls).length) {
	                throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.controls[name]) {
	                throw new Error("Cannot find form control with name: " + name + ".");
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormGroup.prototype._forEachChild = function (cb) {
	            var _this = this;
	            Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) {
	                control.setParent(_this);
	                control._registerOnCollectionChange(_this._onCollectionChange);
	            });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormGroup.prototype._anyControls = function (condition) {
	            var _this = this;
	            var /** @type {?} */ res = false;
	            this._forEachChild(function (control, name) {
	                res = res || (_this.contains(name) && condition(control));
	            });
	            return res;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._reduceValue = function () {
	            var _this = this;
	            return this._reduceChildren({}, function (acc, control, name) {
	                if (control.enabled || _this.disabled) {
	                    acc[name] = control.value;
	                }
	                return acc;
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} initValue
	         * @param {?} fn
	         * @return {?}
	         */
	        FormGroup.prototype._reduceChildren = function (initValue, fn) {
	            var /** @type {?} */ res = initValue;
	            this._forEachChild(function (control, name) { res = fn(res, control, name); });
	            return res;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {
	                var controlName = _a[_i];
	                if (this.controls[controlName].enabled) {
	                    return false;
	                }
	            }
	            return Object.keys(this.controls).length > 0 || this.disabled;
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        FormGroup.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, name) {
	                if (value[name] === undefined) {
	                    throw new Error("Must supply a value for form control with name: '" + name + "'.");
	                }
	            });
	        };
	        return FormGroup;
	    }(AbstractControl));
	    /**
	     * \@whatItDoes Tracks the value and validity state of an array of {\@link FormControl},
	     * {\@link FormGroup} or {\@link FormArray} instances.
	     *
	     * A `FormArray` aggregates the values of each child {\@link FormControl} into an array.
	     * It calculates its status by reducing the statuses of its children. For example, if one of
	     * the controls in a `FormArray` is invalid, the entire array becomes invalid.
	     *
	     * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {\@link FormControl} and {\@link FormGroup}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormArray}, pass in an array of child controls as the first
	     * argument.
	     *
	     * ### Example
	     *
	     * ```
	     * const arr = new FormArray([
	     *   new FormControl('Nancy', Validators.minLength(2)),
	     *   new FormControl('Drew'),
	     * ]);
	     *
	     * console.log(arr.value);   // ['Nancy', 'Drew']
	     * console.log(arr.status);  // 'VALID'
	     * ```
	     *
	     * You can also include array-level validators as the second arg, or array-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Adding or removing controls
	     *
	     * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	     * in `FormArray` itself. These methods ensure the controls are properly tracked in the
	     * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	     * the `FormArray` directly, as that will result in strange and unexpected behavior such
	     * as broken change detection.
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormArray = (function (_super) {
	        __extends$6(FormArray, _super);
	        /**
	         * @param {?} controls
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormArray(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Get the {\@link AbstractControl} at the given `index` in the array.
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype.at = function (index) { return this.controls[index]; };
	        /**
	         * Insert a new {\@link AbstractControl} at the end of the array.
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.push = function (control) {
	            this.controls.push(control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Insert a new {\@link AbstractControl} at the given `index` in the array.
	         * @param {?} index
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.insert = function (index, control) {
	            this.controls.splice(index, 0, control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove the control at the given `index` in the array.
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype.removeAt = function (index) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         * @param {?} index
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.setControl = function (index, control) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            if (control) {
	                this.controls.splice(index, 0, control);
	                this._registerControl(control);
	            }
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        Object.defineProperty(FormArray.prototype, "length", {
	            /**
	             * Length of the control array.
	             * @return {?}
	             */
	            get: function () { return this.controls.length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         *  Sets the value of the {\@link FormArray}. It accepts an array that matches
	         *  the structure of the control.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.setValue(['Nancy', 'Drew']);
	         *  console.log(arr.value);   // ['Nancy', 'Drew']
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            value.forEach(function (newValue, index) {
	                _this._throwIfControlMissing(index);
	                _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {\@link FormArray}. It accepts an array that matches the
	         *  structure of the control, and will do its best to match the values to the correct
	         *  controls in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the array without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.patchValue(['Nancy']);
	         *  console.log(arr.value);   // ['Nancy', null]
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            value.forEach(function (newValue, index) {
	                if (_this.at(index)) {
	                    _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {\@link FormArray}. This means by default:
	         *
	         * * The array and all descendants are marked `pristine`
	         * * The array and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in an array of states
	         * that matches the structure of the control. The state can be a standalone value
	         * or a form state object with both a value and a disabled status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.arr.reset(['name', 'last name']);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.arr.reset([
	         *   {value: 'name', disabled: true},
	         *   'last'
	         * ]);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * console.log(this.arr.get(0).status);  // 'DISABLED'
	         * ```
	         * @param {?=} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = []; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, index) {
	                control.reset(value[index], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the array, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the array.
	         * @return {?}
	         */
	        FormArray.prototype.getRawValue = function () {
	            return this.controls.map(function (control) {
	                return control instanceof FormControl ? control.value : ((control)).getRawValue();
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype._throwIfControlMissing = function (index) {
	            if (!this.controls.length) {
	                throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.at(index)) {
	                throw new Error("Cannot find form control at index " + index);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormArray.prototype._forEachChild = function (cb) {
	            this.controls.forEach(function (control, index) { cb(control, index); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._updateValue = function () {
	            var _this = this;
	            this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })
	                .map(function (control) { return control.value; });
	        };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormArray.prototype._anyControls = function (condition) {
	            return this.controls.some(function (control) { return control.enabled && condition(control); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) { return _this._registerControl(control); });
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        FormArray.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, i) {
	                if (value[i] === undefined) {
	                    throw new Error("Must supply a value for form control at index: " + i + ".");
	                }
	            });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
	                var control = _a[_i];
	                if (control.enabled)
	                    return false;
	            }
	            return this.controls.length > 0 || this.disabled;
	        };
	        /**
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype._registerControl = function (control) {
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	        };
	        return FormArray;
	    }(AbstractControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formDirectiveProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgForm; })
	    };
	    var /** @type {?} */ resolvedPromise = Promise.resolve(null);
	    /**
	     * \@whatItDoes Creates a top-level {\@link FormGroup} instance and binds it to a form
	     * to track aggregate form value and validation status.
	     *
	     * \@howToUse
	     *
	     * As soon as you import the `FormsModule`, this directive becomes active by default on
	     * all `<form>` tags.  You don't need to add a special selector.
	     *
	     * You can export the directive into a local template variable using `ngForm` as the key
	     * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
	     * {\@link FormGroup} instance are duplicated on the directive itself, so a reference to it
	     * will give you access to the aggregate value and validity status of the form, as well as
	     * user interaction properties like `dirty` and `touched`.
	     *
	     * To register child controls with the form, you'll want to use {\@link NgModel} with a
	     * `name` attribute.  You can also use {\@link NgModelGroup} if you'd like to create
	     * sub-groups within the form.
	     *
	     * You can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     *  \@stable
	     */
	    var NgForm = (function (_super) {
	        __extends$4(NgForm, _super);
	        /**
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function NgForm(validators, asyncValidators) {
	            _super.call(this);
	            this._submitted = false;
	            this.ngSubmit = new EventEmitter();
	            this.form =
	                new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
	        }
	        Object.defineProperty(NgForm.prototype, "submitted", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "controls", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form.controls; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.addControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                dir._control = (container.registerControl(dir.name, dir.control));
	                setUpControl(dir.control, dir);
	                dir.control.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.removeControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.addFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                var /** @type {?} */ group = new FormGroup({});
	                setUpFormContainer(group, dir);
	                container.registerControl(dir.name, group);
	                group.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.removeFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @param {?} value
	         * @return {?}
	         */
	        NgForm.prototype.updateModel = function (dir, value) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ ctrl = (_this.form.get(dir.path));
	                ctrl.setValue(value);
	            });
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgForm.prototype.setValue = function (value) { this.control.setValue(value); };
	        /**
	         * @param {?} $event
	         * @return {?}
	         */
	        NgForm.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        NgForm.prototype.onReset = function () { this.resetForm(); };
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        NgForm.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /**
	         * \@internal
	         * @param {?} path
	         * @return {?}
	         */
	        NgForm.prototype._findContainer = function (path) {
	            path.pop();
	            return path.length ? (this.form.get(path)) : this.form;
	        };
	        NgForm.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
	                        providers: [formDirectiveProvider],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        outputs: ['ngSubmit'],
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgForm.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        return NgForm;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ Examples = {
	        formControlName: "\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });",
	        formGroupName: "\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });",
	        formArrayName: "\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; let i=index\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });",
	        ngModelGroup: "\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>",
	        ngModelWithFormGroup: "\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  "
	    };
	
	    var TemplateDrivenErrors = (function () {
	        function TemplateDrivenErrors() {
	        }
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.modelParentException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive \"formControlName\" instead.  Example:\n\n      " + Examples.formControlName + "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " + Examples.ngModelWithFormGroup);
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.formGroupNameException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.missingNameException = function () {
	            throw new Error("If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as 'standalone' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n      Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">");
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.modelGroupParentException = function () {
	            throw new Error("\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        return TemplateDrivenErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ modelGroupProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgModelGroup; })
	    };
	    /**
	     * \@whatItDoes Creates and binds a {\@link FormGroup} instance to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive can only be used as a child of {\@link NgForm} (or in other words,
	     * within `<form>` tags).
	     *
	     * Use this directive if you'd like to create a sub-group within a form. This can
	     * come in handy if you want to validate a sub-group of your form separately from
	     * the rest of your form, or if some values in your domain model make more sense to
	     * consume together in a nested object.
	     *
	     * Pass in the name you'd like this sub-group to have and it will become the key
	     * for the sub-group in the form's full value. You can also export the directive into
	     * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
	     *
	     * {\@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     * \@stable
	     */
	    var NgModelGroup = (function (_super) {
	        __extends$8(NgModelGroup, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function NgModelGroup(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        NgModelGroup.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelGroupParentException();
	            }
	        };
	        NgModelGroup.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },
	        ];
	        /** @nocollapse */
	        NgModelGroup.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        NgModelGroup.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['ngModelGroup',] },],
	        };
	        return NgModelGroup;
	    }(AbstractFormGroupDirective));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formControlBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return NgModel; })
	    };
	    /**
	     * `ngModel` forces an additional change detection run when its inputs change:
	     * E.g.:
	     * ```
	     * <div>{{myModel.valid}}</div>
	     * <input [(ngModel)]="myValue" #myModel="ngModel">
	     * ```
	     * I.e. `ngModel` can export itself on the element and then be used in the template.
	     * Normally, this would result in expressions before the `input` that use the exported directive
	     * to have and old value as they have been
	     * dirty checked before. As this is a very common case for `ngModel`, we added this second change
	     * detection run.
	     *
	     * Notes:
	     * - this is just one extra run no matter how many `ngModel` have been changed.
	     * - this is a general problem when using `exportAs` for directives!
	     */
	    var /** @type {?} */ resolvedPromise$1 = Promise.resolve(null);
	    /**
	     * \@whatItDoes Creates a {\@link FormControl} instance from a domain model and binds it
	     * to a form control element.
	     *
	     * The {\@link FormControl} instance will track the value, user interaction, and
	     * validation status of the control and keep the view synced with the model. If used
	     * within a parent form, the directive will also register itself with the form as a child
	     * control.
	     *
	     * \@howToUse
	     *
	     * This directive can be used by itself or as part of a larger form. All you need is the
	     * `ngModel` selector to activate it.
	     *
	     * It accepts a domain model as an optional {\@link \@Input}. If you have a one-way binding
	     * to `ngModel` with `[]` syntax, changing the value of the domain model in the component
	     * class will set the value in the view. If you have a two-way binding with `[()]` syntax
	     * (also known as 'banana-box syntax'), the value in the UI will always be synced back to
	     * the domain model in your class as well.
	     *
	     * If you wish to inspect the properties of the associated {\@link FormControl} (like
	     * validity state), you can also export the directive into a local template variable using
	     * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the
	     * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)
	     * will fall through to the control anyway, so you can access them directly. You can see a
	     * full list of properties directly available in {\@link AbstractControlDirective}.
	     *
	     * The following is an example of a simple standalone control using `ngModel`:
	     *
	     * {\@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
	     *
	     * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
	     * so that the control can be registered with the parent form under that name.
	     *
	     * It's worth noting that in the context of a parent form, you often can skip one-way or
	     * two-way binding because the parent form will sync the value for you. You can access
	     * its properties by exporting it into a local template variable using `ngForm` (ex:
	     * `#f="ngForm"`). Then you can pass it where it needs to go on submit.
	     *
	     * If you do need to populate initial values into your form, using a one-way binding for
	     * `ngModel` tends to be sufficient as long as you use the exported form's value rather
	     * than the domain model's value on submit.
	     *
	     * Take a look at an example of using `ngModel` within a form:
	     *
	     * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * To see `ngModel` examples with different form control types, see:
	     *
	     * * Radio buttons: {\@link RadioControlValueAccessor}
	     * * Selects: {\@link SelectControlValueAccessor}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: `FormsModule`
	     *
	     *  \@stable
	     */
	    var NgModel = (function (_super) {
	        __extends$7(NgModel, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function NgModel(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            /** @internal */
	            this._control = new FormControl();
	            /** @internal */
	            this._registered = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgModel.prototype.ngOnChanges = function (changes) {
	            this._checkForErrors();
	            if (!this._registered)
	                this._setUpControl();
	            if ('isDisabled' in changes) {
	                this._updateDisabled(changes);
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this._updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };
	        Object.defineProperty(NgModel.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._parent ? controlPath(this.name, this._parent) : [this.name];
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        NgModel.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._setUpControl = function () {
	            this._isStandalone() ? this._setUpStandalone() :
	                this.formDirective.addControl(this);
	            this._registered = true;
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._isStandalone = function () {
	            return !this._parent || (this.options && this.options.standalone);
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._setUpStandalone = function () {
	            setUpControl(this._control, this);
	            this._control.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkForErrors = function () {
	            if (!this._isStandalone()) {
	                this._checkParentType();
	            }
	            this._checkName();
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                TemplateDrivenErrors.formGroupNameException();
	            }
	            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelParentException();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkName = function () {
	            if (this.options && this.options.name)
	                this.name = this.options.name;
	            if (!this._isStandalone() && !this.name) {
	                TemplateDrivenErrors.missingNameException();
	            }
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgModel.prototype._updateValue = function (value) {
	            var _this = this;
	            resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgModel.prototype._updateDisabled = function (changes) {
	            var _this = this;
	            var /** @type {?} */ disabledValue = changes['isDisabled'].currentValue;
	            var /** @type {?} */ isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');
	            resolvedPromise$1.then(function () {
	                if (isDisabled && !_this.control.disabled) {
	                    _this.control.disable();
	                }
	                else if (!isDisabled && _this.control.disabled) {
	                    _this.control.enable();
	                }
	            });
	        };
	        NgModel.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[ngModel]:not([formControlName]):not([formControl])',
	                        providers: [formControlBinding],
	                        exportAs: 'ngModel'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgModel.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        NgModel.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'options': [{ type: _angular_core.Input, args: ['ngModelOptions',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	        };
	        return NgModel;
	    }(NgControl));
	
	    var ReactiveErrors = (function () {
	        function ReactiveErrors() {
	        }
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.controlParentException = function () {
	            throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formControlName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.ngModelGroupException = function () {
	            throw new Error("formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        " + Examples.formGroupName + "\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        " + Examples.ngModelGroup);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.missingFormException = function () {
	            throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + Examples.formControlName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.groupParentException = function () {
	            throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formGroupName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.arrayParentException = function () {
	            throw new Error("formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " + Examples.formArrayName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.disabledAttrWarning = function () {
	            console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ");
	        };
	        return ReactiveErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formControlBinding$1 = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlDirective; })
	    };
	    /**
	     * \@whatItDoes Syncs a standalone {\@link FormControl} instance to a form control element.
	     *
	     * In other words, this directive ensures that any values written to the {\@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {\@link FormControl} instance (view -> model).
	     *
	     * \@howToUse
	     *
	     * Use this directive if you'd like to create and manage a {\@link FormControl} instance directly.
	     * Simply create a {\@link FormControl}, save it to your component class, and pass it into the
	     * {\@link FormControlDirective}.
	     *
	     * This directive is designed to be used as a standalone control.  Unlike {\@link FormControlName},
	     * it does not require that your {\@link FormControl} instance be part of any parent
	     * {\@link FormGroup}, and it won't be registered to any {\@link FormGroupDirective} that
	     * exists above it.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormControl} instance. See a full list of available properties in
	     * {\@link AbstractControl}.
	     *
	     * **Set the value**: You can pass in an initial value when instantiating the {\@link FormControl},
	     * or you can set it programmatically later using {\@link AbstractControl.setValue} or
	     * {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     *  \@stable
	     */
	    var FormControlDirective = (function (_super) {
	        __extends$9(FormControlDirective, _super);
	        /**
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function FormControlDirective(validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this.update = new EventEmitter();
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlDirective.prototype, "isDisabled", {
	            /**
	             * @param {?} isDisabled
	             * @return {?}
	             */
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlDirective.prototype.ngOnChanges = function (changes) {
	            if (this._isControlChanged(changes)) {
	                setUpControl(this.form, this);
	                if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                    this.valueAccessor.setDisabledState(true);
	                }
	                this.form.updateValueAndValidity({ emitEvent: false });
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.form.setValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        Object.defineProperty(FormControlDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        FormControlDirective.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlDirective.prototype._isControlChanged = function (changes) {
	            return changes.hasOwnProperty('form');
	        };
	        FormControlDirective.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },
	        ];
	        /** @nocollapse */
	        FormControlDirective.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        FormControlDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formControl',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlDirective;
	    }(NgControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formDirectiveProvider$1 = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupDirective; })
	    };
	    /**
	     * \@whatItDoes Binds an existing {\@link FormGroup} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive accepts an existing {\@link FormGroup} instance. It will then use this
	     * {\@link FormGroup} instance to match any child {\@link FormControl}, {\@link FormGroup},
	     * and {\@link FormArray} instances to child {\@link FormControlName}, {\@link FormGroupName},
	     * and {\@link FormArrayName} directives.
	     *
	     * **Set value**: You can set the form's initial value when instantiating the
	     * {\@link FormGroup}, or you can set it programmatically later using the {\@link FormGroup}'s
	     * {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue} methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe
	     * to the {\@link FormGroup}'s {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * its {\@link AbstractControl.statusChanges} event to be notified when the validation status is
	     * re-calculated.
	     *
	     * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     *  \@stable
	     */
	    var FormGroupDirective = (function (_super) {
	        __extends$11(FormGroupDirective, _super);
	        /**
	         * @param {?} _validators
	         * @param {?} _asyncValidators
	         */
	        function FormGroupDirective(_validators, _asyncValidators) {
	            _super.call(this);
	            this._validators = _validators;
	            this._asyncValidators = _asyncValidators;
	            this._submitted = false;
	            this.directives = [];
	            this.form = null;
	            this.ngSubmit = new EventEmitter();
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormGroupDirective.prototype.ngOnChanges = function (changes) {
	            this._checkFormPresent();
	            if (changes.hasOwnProperty('form')) {
	                this._updateValidators();
	                this._updateDomValue();
	                this._updateRegistrations();
	            }
	        };
	        Object.defineProperty(FormGroupDirective.prototype, "submitted", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addControl = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpControl(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	            this.directives.push(dir);
	            return ctrl;
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeControl = function (dir) { ListWrapper.remove(this.directives, dir); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addFormGroup = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeFormGroup = function (dir) { };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addFormArray = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeFormArray = function (dir) { };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getFormArray = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @param {?} value
	         * @return {?}
	         */
	        FormGroupDirective.prototype.updateModel = function (dir, value) {
	            var /** @type {?} */ ctrl = (this.form.get(dir.path));
	            ctrl.setValue(value);
	        };
	        /**
	         * @param {?} $event
	         * @return {?}
	         */
	        FormGroupDirective.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype.onReset = function () { this.resetForm(); };
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        FormGroupDirective.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateDomValue = function () {
	            var _this = this;
	            this.directives.forEach(function (dir) {
	                var /** @type {?} */ newCtrl = _this.form.get(dir.path);
	                if (dir._control !== newCtrl) {
	                    cleanUpControl(dir._control, dir);
	                    if (newCtrl)
	                        setUpControl(newCtrl, dir);
	                    dir._control = newCtrl;
	                }
	            });
	            this.form._updateTreeValidity({ emitEvent: false });
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateRegistrations = function () {
	            var _this = this;
	            this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });
	            if (this._oldForm)
	                this._oldForm._registerOnCollectionChange(function () { });
	            this._oldForm = this.form;
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateValidators = function () {
	            var /** @type {?} */ sync = composeValidators(this._validators);
	            this.form.validator = Validators.compose([this.form.validator, sync]);
	            var /** @type {?} */ async = composeAsyncValidators(this._asyncValidators);
	            this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._checkFormPresent = function () {
	            if (!this.form) {
	                ReactiveErrors.missingFormException();
	            }
	        };
	        FormGroupDirective.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroup]',
	                        providers: [formDirectiveProvider$1],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        FormGroupDirective.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormGroupDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formGroup',] },],
	            'ngSubmit': [{ type: _angular_core.Output },],
	        };
	        return FormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formGroupNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupName; })
	    };
	    /**
	     * \@whatItDoes Syncs a nested {\@link FormGroup} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive can only be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {\@link FormGroup} you want to link, and
	     * will look for a {\@link FormGroup} registered with that name in the parent
	     * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
	     *
	     * Nested form groups can come in handy when you want to validate a sub-group of a
	     * form separately from the rest or when you'd like to group the values of certain
	     * controls into their own nested object.
	     *
	     * **Access the group**: You can access the associated {\@link FormGroup} using the
	     * {\@link AbstractControl.get} method. Ex: `this.form.get('name')`.
	     *
	     * You can also access individual controls within the group using dot syntax.
	     * Ex: `this.form.get('name.first')`
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormGroup}. See a full list of available properties in {\@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {\@link FormGroup}, or you can set it programmatically later using
	     * {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the group, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * \@stable
	     */
	    var FormGroupName = (function (_super) {
	        __extends$12(FormGroupName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function FormGroupName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroupName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.groupParentException();
	            }
	        };
	        FormGroupName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormGroupName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormGroupName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formGroupName',] },],
	        };
	        return FormGroupName;
	    }(AbstractFormGroupDirective));
	    var /** @type {?} */ formArrayNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormArrayName; })
	    };
	    /**
	     * \@whatItDoes Syncs a nested {\@link FormArray} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {\@link FormArray} you want to link, and
	     * will look for a {\@link FormArray} registered with that name in the parent
	     * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
	     *
	     * Nested form arrays can come in handy when you have a group of form controls but
	     * you're not sure how many there will be. Form arrays allow you to create new
	     * form controls dynamically.
	     *
	     * **Access the array**: You can access the associated {\@link FormArray} using the
	     * {\@link AbstractControl.get} method on the parent {\@link FormGroup}.
	     * Ex: `this.form.get('cities')`.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormArray}. See a full list of available properties in {\@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {\@link FormArray}, or you can set the value programmatically later using the
	     * {\@link FormArray}'s {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}
	     * methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the array, you can
	     * subscribe to the {\@link FormArray}'s {\@link AbstractControl.valueChanges} event.  You can also
	     * listen to its {\@link AbstractControl.statusChanges} event to be notified when the validation
	     * status is re-calculated.
	     *
	     * **Add new controls**: You can add new controls to the {\@link FormArray} dynamically by
	     * calling its {\@link FormArray.push} method.
	     *  Ex: `this.form.get('cities').push(new FormControl());`
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * \@stable
	     */
	    var FormArrayName = (function (_super) {
	        __extends$12(FormArrayName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function FormArrayName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormArray(this);
	        };
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormArray(this);
	            }
	        };
	        Object.defineProperty(FormArrayName.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.formDirective.getFormArray(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._parent ? (this._parent.formDirective) : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.arrayParentException();
	            }
	        };
	        FormArrayName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormArrayName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormArrayName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formArrayName',] },],
	        };
	        return FormArrayName;
	    }(ControlContainer));
	    /**
	     * @param {?} parent
	     * @return {?}
	     */
	    function _hasInvalidParent(parent) {
	        return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
	            !(parent instanceof FormArrayName);
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ controlNameBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlName; })
	    };
	    /**
	     * \@whatItDoes Syncs a {\@link FormControl} in an existing {\@link FormGroup} to a form control
	     * element by name.
	     *
	     * In other words, this directive ensures that any values written to the {\@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {\@link FormControl} instance (view -> model).
	     *
	     * \@howToUse
	     *
	     * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the {\@link FormControl} instance you want to
	     * link, and will look for a {\@link FormControl} registered with that name in the
	     * closest {\@link FormGroup} or {\@link FormArray} above it.
	     *
	     * **Access the control**: You can access the {\@link FormControl} associated with
	     * this directive by using the {\@link AbstractControl.get} method.
	     * Ex: `this.form.get('first');`
	     *
	     * **Get value**: the `value` property is always synced and available on the {\@link FormControl}.
	     * See a full list of available properties in {\@link AbstractControl}.
	     *
	     *  **Set value**: You can set an initial value for the control when instantiating the
	     *  {\@link FormControl}, or you can set it programmatically later using
	     *  {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * To see `formControlName` examples with different form control types, see:
	     *
	     * * Radio buttons: {\@link RadioControlValueAccessor}
	     * * Selects: {\@link SelectControlValueAccessor}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     *  \@stable
	     */
	    var FormControlName = (function (_super) {
	        __extends$10(FormControlName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function FormControlName(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this._added = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlName.prototype, "isDisabled", {
	            /**
	             * @param {?} isDisabled
	             * @return {?}
	             */
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlName.prototype.ngOnChanges = function (changes) {
	            if (!this._added)
	                this._setUpControl();
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.viewModel = this.model;
	                this.formDirective.updateModel(this, this.model);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeControl(this);
	            }
	        };
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        FormControlName.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        Object.defineProperty(FormControlName.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype._checkParentType = function () {
	            if (!(this._parent instanceof FormGroupName) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                ReactiveErrors.ngModelGroupException();
	            }
	            else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&
	                !(this._parent instanceof FormArrayName)) {
	                ReactiveErrors.controlParentException();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype._setUpControl = function () {
	            this._checkParentType();
	            this._control = this.formDirective.addControl(this);
	            if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                this.valueAccessor.setDisabledState(true);
	            }
	            this._added = true;
	        };
	        FormControlName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },
	        ];
	        /** @nocollapse */
	        FormControlName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        FormControlName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formControlName',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlName;
	    }(NgControl));
	
	    var __extends$13 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return RequiredValidator; }),
	        multi: true
	    };
	    var /** @type {?} */ CHECKBOX_REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxRequiredValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `required` validator to any controls marked with the
	     * `required` attribute, via the {\@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input name="fullName" ngModel required>
	     * ```
	     *
	     * \@stable
	     */
	    var RequiredValidator = (function () {
	        function RequiredValidator() {
	        }
	        Object.defineProperty(RequiredValidator.prototype, "required", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._required; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._required = value != null && value !== false && "" + value !== 'false';
	                if (this._onChange)
	                    this._onChange();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        RequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.required(c) : null;
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        RequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',
	                        providers: [REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        RequiredValidator.ctorParameters = function () { return []; };
	        RequiredValidator.propDecorators = {
	            'required': [{ type: _angular_core.Input },],
	        };
	        return RequiredValidator;
	    }());
	    /**
	     * A Directive that adds the `required` validator to checkbox controls marked with the
	     * `required` attribute, via the {\@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input type="checkbox" name="active" ngModel required>
	     * ```
	     *
	     * \@experimental
	     */
	    var CheckboxRequiredValidator = (function (_super) {
	        __extends$13(CheckboxRequiredValidator, _super);
	        function CheckboxRequiredValidator() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        CheckboxRequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.requiredTrue(c) : null;
	        };
	        CheckboxRequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',
	                        providers: [CHECKBOX_REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxRequiredValidator.ctorParameters = function () { return []; };
	        return CheckboxRequiredValidator;
	    }(RequiredValidator));
	    /**
	     * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='min'}
	     */
	    var /** @type {?} */ MIN_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MinLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {\@link MinLengthValidator} for any `formControlName`,
	     * `formControl`, or control with `ngModel` that also has a `minlength` attribute.
	     *
	     * \@stable
	     */
	    var MinLengthValidator = (function () {
	        function MinLengthValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        MinLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('minlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        MinLengthValidator.prototype.validate = function (c) {
	            return this.minlength == null ? null : this._validator(c);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        MinLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.minLength(parseInt(this.minlength, 10));
	        };
	        MinLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
	                        providers: [MIN_LENGTH_VALIDATOR],
	                        host: { '[attr.minlength]': 'minlength ? minlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MinLengthValidator.ctorParameters = function () { return []; };
	        MinLengthValidator.propDecorators = {
	            'minlength': [{ type: _angular_core.Input },],
	        };
	        return MinLengthValidator;
	    }());
	    /**
	     * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='max'}
	     */
	    var /** @type {?} */ MAX_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MaxLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {\@link MaxLengthValidator} for any `formControlName,
	     * `formControl`,
	     * or control with `ngModel` that also has a `maxlength` attribute.
	     *
	     * \@stable
	     */
	    var MaxLengthValidator = (function () {
	        function MaxLengthValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('maxlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.validate = function (c) {
	            return this.maxlength != null ? this._validator(c) : null;
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        MaxLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.maxLength(parseInt(this.maxlength, 10));
	        };
	        MaxLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
	                        providers: [MAX_LENGTH_VALIDATOR],
	                        host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MaxLengthValidator.ctorParameters = function () { return []; };
	        MaxLengthValidator.propDecorators = {
	            'maxlength': [{ type: _angular_core.Input },],
	        };
	        return MaxLengthValidator;
	    }());
	    var /** @type {?} */ PATTERN_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return PatternValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `pattern` validator to any controls marked with the
	     * `pattern` attribute, via the {\@link NG_VALIDATORS} binding. Uses attribute value
	     * as the regex to validate Control value against.  Follows pattern attribute
	     * semantics; i.e. regex must match entire Control value.
	     *
	     * ### Example
	     *
	     * ```
	     * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel>
	     * ```
	     * \@stable
	     */
	    var PatternValidator = (function () {
	        function PatternValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        PatternValidator.prototype.ngOnChanges = function (changes) {
	            if ('pattern' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        PatternValidator.prototype.validate = function (c) { return this._validator(c); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };
	        PatternValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
	                        providers: [PATTERN_VALIDATOR],
	                        host: { '[attr.pattern]': 'pattern ? pattern : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        PatternValidator.ctorParameters = function () { return []; };
	        PatternValidator.propDecorators = {
	            'pattern': [{ type: _angular_core.Input },],
	        };
	        return PatternValidator;
	    }());
	
	    /**
	     * \@whatItDoes Creates an {\@link AbstractControl} from a user-specified configuration.
	     *
	     * It is essentially syntactic sugar that shortens the `new FormGroup()`,
	     * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger
	     * forms.
	     *
	     * \@howToUse
	     *
	     * To use, inject `FormBuilder` into your component class. You can then call its methods
	     * directly.
	     *
	     * {\@example forms/ts/formBuilder/form_builder_example.ts region='Component'}
	     *
	     *  * **npm package**: `\@angular/forms`
	     *
	     *  * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     * \@stable
	     */
	    var FormBuilder = (function () {
	        function FormBuilder() {
	        }
	        /**
	         * Construct a new {\@link FormGroup} with the given map of configuration.
	         * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.
	         *
	         * See the {\@link FormGroup} constructor for more details.
	         * @param {?} controlsConfig
	         * @param {?=} extra
	         * @return {?}
	         */
	        FormBuilder.prototype.group = function (controlsConfig, extra) {
	            if (extra === void 0) { extra = null; }
	            var /** @type {?} */ controls = this._reduceControls(controlsConfig);
	            var /** @type {?} */ validator = isPresent(extra) ? extra['validator'] : null;
	            var /** @type {?} */ asyncValidator = isPresent(extra) ? extra['asyncValidator'] : null;
	            return new FormGroup(controls, validator, asyncValidator);
	        };
	        /**
	         * Construct a new {\@link FormControl} with the given `formState`,`validator`, and
	         * `asyncValidator`.
	         *
	         * `formState` can either be a standalone value for the form control or an object
	         * that contains both a value and a disabled status.
	         *
	         * @param {?} formState
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         * @return {?}
	         */
	        FormBuilder.prototype.control = function (formState, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            return new FormControl(formState, validator, asyncValidator);
	        };
	        /**
	         * Construct a {\@link FormArray} from the given `controlsConfig` array of
	         * configuration, with the given optional `validator` and `asyncValidator`.
	         * @param {?} controlsConfig
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         * @return {?}
	         */
	        FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
	            var _this = this;
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            var /** @type {?} */ controls = controlsConfig.map(function (c) { return _this._createControl(c); });
	            return new FormArray(controls, validator, asyncValidator);
	        };
	        /**
	         * \@internal
	         * @param {?} controlsConfig
	         * @return {?}
	         */
	        FormBuilder.prototype._reduceControls = function (controlsConfig) {
	            var _this = this;
	            var /** @type {?} */ controls = {};
	            Object.keys(controlsConfig).forEach(function (controlName) {
	                controls[controlName] = _this._createControl(controlsConfig[controlName]);
	            });
	            return controls;
	        };
	        /**
	         * \@internal
	         * @param {?} controlConfig
	         * @return {?}
	         */
	        FormBuilder.prototype._createControl = function (controlConfig) {
	            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||
	                controlConfig instanceof FormArray) {
	                return controlConfig;
	            }
	            else if (Array.isArray(controlConfig)) {
	                var /** @type {?} */ value = controlConfig[0];
	                var /** @type {?} */ validator = controlConfig.length > 1 ? controlConfig[1] : null;
	                var /** @type {?} */ asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	                return this.control(value, validator, asyncValidator);
	            }
	            else {
	                return this.control(controlConfig);
	            }
	        };
	        FormBuilder.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        FormBuilder.ctorParameters = function () { return []; };
	        return FormBuilder;
	    }());
	
	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.8');
	
	    var /** @type {?} */ SHARED_FORM_DIRECTIVES = [
	        NgSelectOption,
	        NgSelectMultipleOption,
	        DefaultValueAccessor,
	        NumberValueAccessor,
	        RangeValueAccessor,
	        CheckboxControlValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	        NgControlStatus,
	        NgControlStatusGroup,
	        RequiredValidator,
	        MinLengthValidator,
	        MaxLengthValidator,
	        PatternValidator,
	        CheckboxRequiredValidator,
	    ];
	    var /** @type {?} */ TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
	    var /** @type {?} */ REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
	    /**
	     * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
	     */
	    var InternalFormsSharedModule = (function () {
	        function InternalFormsSharedModule() {
	        }
	        InternalFormsSharedModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: SHARED_FORM_DIRECTIVES,
	                        exports: SHARED_FORM_DIRECTIVES,
	                    },] },
	        ];
	        /** @nocollapse */
	        InternalFormsSharedModule.ctorParameters = function () { return []; };
	        return InternalFormsSharedModule;
	    }());
	
	    /**
	     * The ng module for forms.
	     * \@stable
	     */
	    var FormsModule = (function () {
	        function FormsModule() {
	        }
	        FormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: TEMPLATE_DRIVEN_DIRECTIVES,
	                        providers: [RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        FormsModule.ctorParameters = function () { return []; };
	        return FormsModule;
	    }());
	    /**
	     * The ng module for reactive forms.
	     * \@stable
	     */
	    var ReactiveFormsModule = (function () {
	        function ReactiveFormsModule() {
	        }
	        ReactiveFormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [REACTIVE_DRIVEN_DIRECTIVES],
	                        providers: [FormBuilder, RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        ReactiveFormsModule.ctorParameters = function () { return []; };
	        return ReactiveFormsModule;
	    }());
	
	    exports.AbstractControlDirective = AbstractControlDirective;
	    exports.AbstractFormGroupDirective = AbstractFormGroupDirective;
	    exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
	    exports.ControlContainer = ControlContainer;
	    exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;
	    exports.DefaultValueAccessor = DefaultValueAccessor;
	    exports.NgControl = NgControl;
	    exports.NgControlStatus = NgControlStatus;
	    exports.NgControlStatusGroup = NgControlStatusGroup;
	    exports.NgForm = NgForm;
	    exports.NgModel = NgModel;
	    exports.NgModelGroup = NgModelGroup;
	    exports.RadioControlValueAccessor = RadioControlValueAccessor;
	    exports.FormControlDirective = FormControlDirective;
	    exports.FormControlName = FormControlName;
	    exports.FormGroupDirective = FormGroupDirective;
	    exports.FormArrayName = FormArrayName;
	    exports.FormGroupName = FormGroupName;
	    exports.NgSelectOption = NgSelectOption;
	    exports.SelectControlValueAccessor = SelectControlValueAccessor;
	    exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
	    exports.CheckboxRequiredValidator = CheckboxRequiredValidator;
	    exports.MaxLengthValidator = MaxLengthValidator;
	    exports.MinLengthValidator = MinLengthValidator;
	    exports.PatternValidator = PatternValidator;
	    exports.RequiredValidator = RequiredValidator;
	    exports.FormBuilder = FormBuilder;
	    exports.AbstractControl = AbstractControl;
	    exports.FormArray = FormArray;
	    exports.FormControl = FormControl;
	    exports.FormGroup = FormGroup;
	    exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
	    exports.NG_VALIDATORS = NG_VALIDATORS;
	    exports.Validators = Validators;
	    exports.VERSION = VERSION;
	    exports.FormsModule = FormsModule;
	    exports.ReactiveFormsModule = ReactiveFormsModule;
	
	}));

/***/ },

/***/ 29:
/***/ function(module, exports, __webpack_require__) {

	/**
	  * @license Angular Material v2.0.0-beta.2
	  * Copyright (c) 2017 Google, Inc. https://material.angular.io/
	  * License: MIT
	  */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(3), __webpack_require__(22), __webpack_require__(6), __webpack_require__(7), __webpack_require__(30), __webpack_require__(33), __webpack_require__(21), __webpack_require__(24), __webpack_require__(40), __webpack_require__(54), __webpack_require__(28), __webpack_require__(57), __webpack_require__(60), __webpack_require__(62), __webpack_require__(64), __webpack_require__(66), __webpack_require__(68), __webpack_require__(72), __webpack_require__(74), __webpack_require__(76), __webpack_require__(79)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/add/observable/fromEvent', 'rxjs/add/operator/auditTime', '@angular/platform-browser', '@angular/forms', 'rxjs/add/operator/startWith', 'rxjs/add/operator/first', '@angular/http', 'rxjs/add/observable/forkJoin', 'rxjs/add/observable/of', 'rxjs/add/operator/map', 'rxjs/add/operator/filter', 'rxjs/add/operator/do', 'rxjs/add/operator/share', 'rxjs/add/operator/finally', 'rxjs/add/operator/catch', 'rxjs/add/observable/merge', 'rxjs/add/operator/switchMap'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}),global.ng.core,global.ng.common,global.Rx,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.ng.platformBrowser,global.ng.forms,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.http,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable,global.Rx.Observable.prototype));
	}(this, (function (exports,_angular_core,_angular_common,rxjs_Subject,rxjs_Observable,rxjs_add_observable_fromEvent,rxjs_add_operator_auditTime,_angular_platformBrowser,_angular_forms,rxjs_add_operator_startWith,rxjs_add_operator_first,_angular_http,rxjs_add_observable_forkJoin,rxjs_add_observable_of,rxjs_add_operator_map,rxjs_add_operator_filter,rxjs_add_operator_do,rxjs_add_operator_share,rxjs_add_operator_finally,rxjs_add_operator_catch,rxjs_add_observable_merge,rxjs_add_operator_switchMap) { 'use strict';
	
	var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$2 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var MATERIAL_COMPATIBILITY_MODE = new _angular_core.OpaqueToken('md-compatibility-mode');
	/** Selector that matches all elements that may have style collisions with AngularJS Material. */
	var MAT_ELEMENTS_SELECTOR = "\n  [mat-button],\n  [mat-dialog-actions],\n  [mat-dialog-close],\n  [mat-dialog-content],\n  [mat-dialog-title],\n  [mat-fab],\n  [mat-icon-button],\n  [mat-menu-trigger-for],\n  [mat-mini-fab],\n  [mat-raised-button],\n  [mat-tab-label],\n  [mat-tab-link],\n  [mat-tab-nav-bar],\n  [matTooltip],\n  mat-autocomplete,\n  mat-button-toggle,\n  mat-button-toggle-group,\n  mat-button-toggle,\n  mat-card,\n  mat-card-actions,\n  mat-card-content,\n  mat-card-footer,\n  mat-card-header,\n  mat-card-subtitle,\n  mat-card-title,\n  mat-card-title-group,\n  mat-checkbox,\n  mat-chip,\n  mat-dialog-actions,\n  mat-dialog-container,\n  mat-dialog-content,\n  mat-divider,\n  mat-grid-list,\n  mat-grid-tile,\n  mat-grid-tile-footer,\n  mat-grid-tile-header,\n  mat-hint,\n  mat-icon,\n  mat-ink-bar,\n  mat-list,\n  mat-list-item,\n  mat-menu,\n  mat-nav-list,\n  mat-option,\n  mat-placeholder,\n  mat-progress-bar,\n  mat-progress-circle,\n  mat-pseudo-checkbox,\n  mat-radio-button,\n  mat-radio-group,\n  mat-select,\n  mat-sidenav,\n  mat-sidenav-container,\n  mat-slider,\n  mat-spinner,\n  mat-tab,\n  mat-tab-body,\n  mat-tab-header,\n  mat-tab-group,\n  mat-toolbar";
	/** Selector that matches all elements that may have style collisions with AngularJS Material. */
	var MD_ELEMENTS_SELECTOR = "  \n  [md-button],\n  [md-dialog-actions],\n  [md-dialog-close],\n  [md-dialog-content],\n  [md-dialog-title],\n  [md-fab],\n  [md-icon-button],\n  [md-menu-trigger-for],\n  [md-mini-fab],\n  [md-raised-button],\n  [md-tab-label],\n  [md-tab-link],\n  [md-tab-nav-bar],\n  [mdTooltip],\n  md-autocomplete,\n  md-button-toggle,\n  md-button-toggle-group,\n  md-button-toggle,\n  md-card,\n  md-card-actions,\n  md-card-content,\n  md-card-footer,\n  md-card-header,\n  md-card-subtitle,\n  md-card-title,\n  md-card-title-group,\n  md-checkbox,\n  md-chip,\n  md-dialog-actions,\n  md-dialog-container,\n  md-dialog-content,\n  md-divider,\n  md-grid-list,\n  md-grid-tile,\n  md-grid-tile-footer,\n  md-grid-tile-header,\n  md-hint,\n  md-icon,\n  md-ink-bar,\n  md-list,\n  md-list-item,\n  md-menu,\n  md-nav-list,\n  md-option,\n  md-placeholder,\n  md-progress-bar,\n  md-progress-circle,\n  md-pseudo-checkbox,\n  md-radio-button,\n  md-radio-group,\n  md-select,\n  md-sidenav,\n  md-sidenav-container,\n  md-slider,\n  md-spinner,\n  md-tab,\n  md-tab-body,\n  md-tab-header,\n  md-tab-group,\n  md-toolbar";
	/** Directive that enforces that the `mat-` prefix cannot be used. */
	var MatPrefixRejector = (function () {
	    function MatPrefixRejector(isCompatibilityMode) {
	        if (!isCompatibilityMode) {
	            throw Error('The "mat-" prefix cannot be used out of ng-material v1 compatibility mode.');
	        }
	    }
	    MatPrefixRejector = __decorate$2([
	        _angular_core.Directive({ selector: MAT_ELEMENTS_SELECTOR }),
	        __param(0, _angular_core.Optional()),
	        __param(0, _angular_core.Inject(MATERIAL_COMPATIBILITY_MODE)), 
	        __metadata$2('design:paramtypes', [Boolean])
	    ], MatPrefixRejector);
	    return MatPrefixRejector;
	}());
	/** Directive that enforces that the `md-` prefix cannot be used. */
	var MdPrefixRejector = (function () {
	    function MdPrefixRejector(isCompatibilityMode) {
	        if (isCompatibilityMode) {
	            throw Error('The "md-" prefix cannot be used in ng-material v1 compatibility mode.');
	        }
	    }
	    MdPrefixRejector = __decorate$2([
	        _angular_core.Directive({ selector: MD_ELEMENTS_SELECTOR }),
	        __param(0, _angular_core.Optional()),
	        __param(0, _angular_core.Inject(MATERIAL_COMPATIBILITY_MODE)), 
	        __metadata$2('design:paramtypes', [Boolean])
	    ], MdPrefixRejector);
	    return MdPrefixRejector;
	}());
	/**
	 * Module that enforces the default compatibility mode settings. When this module is loaded
	 * without NoConflictStyleCompatibilityMode also being imported, it will throw an error if
	 * there are any uses of the `mat-` prefix.
	 */
	var CompatibilityModule = (function () {
	    function CompatibilityModule() {
	    }
	    CompatibilityModule.forRoot = function () {
	        return {
	            ngModule: CompatibilityModule,
	            providers: [],
	        };
	    };
	    CompatibilityModule = __decorate$2([
	        _angular_core.NgModule({
	            declarations: [MatPrefixRejector, MdPrefixRejector],
	            exports: [MatPrefixRejector, MdPrefixRejector],
	        }), 
	        __metadata$2('design:paramtypes', [])
	    ], CompatibilityModule);
	    return CompatibilityModule;
	}());
	/**
	 * Module that enforces "no-conflict" compatibility mode settings. When this module is loaded,
	 * it will throw an error if there are any uses of the `md-` prefix.
	 */
	var NoConflictStyleCompatibilityMode = (function () {
	    function NoConflictStyleCompatibilityMode() {
	    }
	    NoConflictStyleCompatibilityMode = __decorate$2([
	        _angular_core.NgModule({
	            providers: [{
	                    provide: MATERIAL_COMPATIBILITY_MODE, useValue: true,
	                }],
	        }), 
	        __metadata$2('design:paramtypes', [])
	    ], NoConflictStyleCompatibilityMode);
	    return NoConflictStyleCompatibilityMode;
	}());
	
	var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$1 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Shared directive to count lines inside a text area, such as a list item.
	 * Line elements can be extracted with a @ContentChildren(MdLine) query, then
	 * counted by checking the query list's length.
	 */
	var MdLine = (function () {
	    function MdLine() {
	    }
	    MdLine = __decorate$1([
	        _angular_core.Directive({
	            selector: '[md-line], [mat-line]',
	            host: {
	                '[class.mat-line]': 'true'
	            }
	        }), 
	        __metadata$1('design:paramtypes', [])
	    ], MdLine);
	    return MdLine;
	}());
	/**
	 * Helper that takes a query list of lines and sets the correct class on the host.
	 * @docs-private
	 */
	var MdLineSetter = (function () {
	    function MdLineSetter(_lines, _renderer, _element) {
	        var _this = this;
	        this._lines = _lines;
	        this._renderer = _renderer;
	        this._element = _element;
	        this._setLineClass(this._lines.length);
	        this._lines.changes.subscribe(function () {
	            _this._setLineClass(_this._lines.length);
	        });
	    }
	    MdLineSetter.prototype._setLineClass = function (count) {
	        this._resetClasses();
	        if (count === 2 || count === 3) {
	            this._setClass("mat-" + count + "-line", true);
	        }
	        else if (count > 3) {
	            this._setClass("mat-multi-line", true);
	        }
	    };
	    MdLineSetter.prototype._resetClasses = function () {
	        this._setClass('mat-2-line', false);
	        this._setClass('mat-3-line', false);
	        this._setClass('mat-multi-line', false);
	    };
	    MdLineSetter.prototype._setClass = function (className, bool) {
	        this._renderer.setElementClass(this._element.nativeElement, className, bool);
	    };
	    return MdLineSetter;
	}());
	var MdLineModule = (function () {
	    function MdLineModule() {
	    }
	    MdLineModule = __decorate$1([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [MdLine, CompatibilityModule],
	            declarations: [MdLine],
	        }), 
	        __metadata$1('design:paramtypes', [])
	    ], MdLineModule);
	    return MdLineModule;
	}());
	
	var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$3 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive to listen for changes of direction of part of the DOM.
	 *
	 * Applications should use this directive instead of the native attribute so that Material
	 * components can listen on changes of direction.
	 */
	var Dir = (function () {
	    function Dir() {
	        /** Layout direction of the element. */
	        this._dir = 'ltr';
	        /** Event emitted when the direction changes. */
	        this.dirChange = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(Dir.prototype, "dir", {
	        /** @docs-private */
	        get: function () {
	            return this._dir;
	        },
	        set: function (v) {
	            var old = this._dir;
	            this._dir = v;
	            if (old != this._dir) {
	                this.dirChange.emit();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Dir.prototype, "value", {
	        /** Current layout direction of the element. */
	        get: function () { return this.dir; },
	        set: function (v) { this.dir = v; },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$3([
	        _angular_core.Input('dir'), 
	        __metadata$3('design:type', String)
	    ], Dir.prototype, "_dir", void 0);
	    __decorate$3([
	        _angular_core.Output(), 
	        __metadata$3('design:type', Object)
	    ], Dir.prototype, "dirChange", void 0);
	    __decorate$3([
	        _angular_core.HostBinding('attr.dir'), 
	        __metadata$3('design:type', String)
	    ], Dir.prototype, "dir", null);
	    Dir = __decorate$3([
	        _angular_core.Directive({
	            selector: '[dir]',
	            // TODO(hansl): maybe `$implicit` isn't the best option here, but for now that's the best we got.
	            exportAs: '$implicit'
	        }), 
	        __metadata$3('design:paramtypes', [])
	    ], Dir);
	    return Dir;
	}());
	var RtlModule = (function () {
	    function RtlModule() {
	    }
	    /** @deprecated */
	    RtlModule.forRoot = function () {
	        return {
	            ngModule: RtlModule,
	            providers: []
	        };
	    };
	    RtlModule = __decorate$3([
	        _angular_core.NgModule({
	            exports: [Dir],
	            declarations: [Dir]
	        }), 
	        __metadata$3('design:paramtypes', [])
	    ], RtlModule);
	    return RtlModule;
	}());
	
	var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$4 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive that triggers a callback whenever the content of
	 * its associated element has changed.
	 */
	var ObserveContent = (function () {
	    function ObserveContent(_elementRef) {
	        this._elementRef = _elementRef;
	        /** Event emitted for each change in the element's content. */
	        this.event = new _angular_core.EventEmitter();
	    }
	    ObserveContent.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._observer = new MutationObserver(function (mutations) { return mutations.forEach(function () { return _this.event.emit(); }); });
	        this._observer.observe(this._elementRef.nativeElement, {
	            characterData: true,
	            childList: true,
	            subtree: true
	        });
	    };
	    ObserveContent.prototype.ngOnDestroy = function () {
	        if (this._observer) {
	            this._observer.disconnect();
	        }
	    };
	    __decorate$4([
	        _angular_core.Output('cdkObserveContent'), 
	        __metadata$4('design:type', Object)
	    ], ObserveContent.prototype, "event", void 0);
	    ObserveContent = __decorate$4([
	        _angular_core.Directive({
	            selector: '[cdkObserveContent]'
	        }), 
	        __metadata$4('design:paramtypes', [_angular_core.ElementRef])
	    ], ObserveContent);
	    return ObserveContent;
	}());
	var ObserveContentModule = (function () {
	    function ObserveContentModule() {
	    }
	    /** @deprecated */
	    ObserveContentModule.forRoot = function () {
	        return {
	            ngModule: ObserveContentModule,
	            providers: []
	        };
	    };
	    ObserveContentModule = __decorate$4([
	        _angular_core.NgModule({
	            exports: [ObserveContent],
	            declarations: [ObserveContent]
	        }), 
	        __metadata$4('design:paramtypes', [])
	    ], ObserveContentModule);
	    return ObserveContentModule;
	}());
	
	// Due to a bug in the ChromeDriver, Angular keyboard events are not triggered by `sendKeys`
	// during E2E tests when using dot notation such as `(keydown.rightArrow)`. To get around this,
	// we are temporarily using a single (keydown) handler.
	// See: https://github.com/angular/angular/issues/9419
	var UP_ARROW = 38;
	var DOWN_ARROW = 40;
	var RIGHT_ARROW = 39;
	var LEFT_ARROW = 37;
	var PAGE_UP = 33;
	var PAGE_DOWN = 34;
	var HOME = 36;
	var END = 35;
	var ENTER = 13;
	var SPACE = 32;
	var TAB = 9;
	var ESCAPE = 27;
	var BACKSPACE = 8;
	var DELETE = 46;
	
	/** Coerces a data-bound value (typically a string) to a boolean. */
	function coerceBooleanProperty(value) {
	    return value != null && "" + value !== 'false';
	}
	
	/** Fade-in speed in pixels per second. Can be modified with the speedFactor option. */
	var RIPPLE_SPEED_PX_PER_SECOND = 170;
	/** Fade-out speed for the ripples in milliseconds. This can't be modified by the speedFactor. */
	var RIPPLE_FADE_OUT_DURATION = 600;
	/**
	 * Returns the distance from the point (x, y) to the furthest corner of a rectangle.
	 */
	var distanceToFurthestCorner = function (x, y, rect) {
	    var distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));
	    var distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
	    return Math.sqrt(distX * distX + distY * distY);
	};
	/**
	 * Helper service that performs DOM manipulations. Not intended to be used outside this module.
	 * The constructor takes a reference to the ripple directive's host element and a map of DOM
	 * event handlers to be installed on the element that triggers ripple animations.
	 * This will eventually become a custom renderer once Angular support exists.
	 * @docs-private
	 */
	var RippleRenderer = (function () {
	    function RippleRenderer(_elementRef, _ngZone, _ruler) {
	        this._ngZone = _ngZone;
	        this._ruler = _ruler;
	        /** Whether the mouse is currently down or not. */
	        this._isMousedown = false;
	        /** Currently active ripples that will be closed on mouseup. */
	        this._activeRipples = [];
	        /** Events to be registered on the trigger element. */
	        this._triggerEvents = new Map();
	        /** Ripple config for all ripples created by events. */
	        this.rippleConfig = {};
	        /** Whether mouse ripples should be created or not. */
	        this.rippleDisabled = false;
	        this._containerElement = _elementRef.nativeElement;
	        // Specify events which need to be registered on the trigger.
	        this._triggerEvents.set('mousedown', this.onMousedown.bind(this));
	        this._triggerEvents.set('mouseup', this.onMouseup.bind(this));
	        this._triggerEvents.set('mouseleave', this.onMouseLeave.bind(this));
	        // By default use the host element as trigger element.
	        this.setTriggerElement(this._containerElement);
	    }
	    /** Fades in a ripple at the given coordinates. */
	    RippleRenderer.prototype.fadeInRipple = function (pageX, pageY, config) {
	        var _this = this;
	        if (config === void 0) { config = {}; }
	        var containerRect = this._containerElement.getBoundingClientRect();
	        if (config.centered) {
	            pageX = containerRect.left + containerRect.width / 2;
	            pageY = containerRect.top + containerRect.height / 2;
	        }
	        else {
	            // Subtract scroll values from the coordinates because calculations below
	            // are always relative to the viewport rectangle.
	            var scrollPosition = this._ruler.getViewportScrollPosition();
	            pageX -= scrollPosition.left;
	            pageY -= scrollPosition.top;
	        }
	        var radius = config.radius || distanceToFurthestCorner(pageX, pageY, containerRect);
	        var duration = 1 / (config.speedFactor || 1) * (radius / RIPPLE_SPEED_PX_PER_SECOND);
	        var offsetX = pageX - containerRect.left;
	        var offsetY = pageY - containerRect.top;
	        var ripple = document.createElement('div');
	        ripple.classList.add('mat-ripple-element');
	        ripple.style.left = (offsetX - radius) + "px";
	        ripple.style.top = (offsetY - radius) + "px";
	        ripple.style.height = radius * 2 + "px";
	        ripple.style.width = radius * 2 + "px";
	        // If the color is not set, the default CSS color will be used.
	        ripple.style.backgroundColor = config.color;
	        ripple.style.transitionDuration = duration + "s";
	        this._containerElement.appendChild(ripple);
	        // By default the browser does not recalculate the styles of dynamically created
	        // ripple elements. This is critical because then the `scale` would not animate properly.
	        this._enforceStyleRecalculation(ripple);
	        ripple.style.transform = 'scale(1)';
	        // Wait for the ripple to be faded in. Once it's faded in, the ripple can be hidden immediately
	        // if the mouse is released.
	        this.runTimeoutOutsideZone(function () {
	            _this._isMousedown ? _this._activeRipples.push(ripple) : _this.fadeOutRipple(ripple);
	        }, duration * 1000);
	    };
	    /** Fades out a ripple element. */
	    RippleRenderer.prototype.fadeOutRipple = function (ripple) {
	        ripple.style.transitionDuration = RIPPLE_FADE_OUT_DURATION + "ms";
	        ripple.style.opacity = '0';
	        // Once the ripple faded out, the ripple can be safely removed from the DOM.
	        this.runTimeoutOutsideZone(function () {
	            ripple.parentNode.removeChild(ripple);
	        }, RIPPLE_FADE_OUT_DURATION);
	    };
	    /** Sets the trigger element and registers the mouse events. */
	    RippleRenderer.prototype.setTriggerElement = function (element) {
	        var _this = this;
	        // Remove all previously register event listeners from the trigger element.
	        if (this._triggerElement) {
	            this._triggerEvents.forEach(function (fn, type) { return _this._triggerElement.removeEventListener(type, fn); });
	        }
	        if (element) {
	            // If the element is not null, register all event listeners on the trigger element.
	            this._triggerEvents.forEach(function (fn, type) { return element.addEventListener(type, fn); });
	        }
	        this._triggerElement = element;
	    };
	    /** Listener being called on mousedown event. */
	    RippleRenderer.prototype.onMousedown = function (event) {
	        if (this.rippleDisabled) {
	            return;
	        }
	        this._isMousedown = true;
	        this.fadeInRipple(event.pageX, event.pageY, this.rippleConfig);
	    };
	    /** Listener being called on mouseup event. */
	    RippleRenderer.prototype.onMouseup = function () {
	        var _this = this;
	        this._isMousedown = false;
	        this._activeRipples.forEach(function (ripple) { return _this.fadeOutRipple(ripple); });
	        this._activeRipples = [];
	    };
	    /** Listener being called on mouseleave event. */
	    RippleRenderer.prototype.onMouseLeave = function () {
	        if (this._isMousedown) {
	            this.onMouseup();
	        }
	    };
	    /** Runs a timeout outside of the Angular zone to avoid triggering the change detection. */
	    RippleRenderer.prototype.runTimeoutOutsideZone = function (fn, delay) {
	        if (delay === void 0) { delay = 0; }
	        this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });
	    };
	    /** Enforces a style recalculation of a DOM element by computing its styles. */
	    // TODO(devversion): Move into global utility function.
	    RippleRenderer.prototype._enforceStyleRecalculation = function (element) {
	        // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.
	        // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.
	        // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
	        window.getComputedStyle(element).getPropertyValue('opacity');
	    };
	    return RippleRenderer;
	}());
	
	var __decorate$8 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$8 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Time in ms to throttle the scrolling events by default. */
	var DEFAULT_SCROLL_TIME = 20;
	/**
	 * Service contained all registered Scrollable references and emits an event when any one of the
	 * Scrollable references emit a scrolled event.
	 */
	var ScrollDispatcher = (function () {
	    function ScrollDispatcher() {
	        var _this = this;
	        /** Subject for notifying that a registered scrollable reference element has been scrolled. */
	        this._scrolled = new rxjs_Subject.Subject();
	        /**
	         * Map of all the scrollable references that are registered with the service and their
	         * scroll event subscriptions.
	         */
	        this.scrollableReferences = new Map();
	        // By default, notify a scroll event when the document is scrolled or the window is resized.
	        rxjs_Observable.Observable.fromEvent(window.document, 'scroll').subscribe(function () { return _this._notify(); });
	        rxjs_Observable.Observable.fromEvent(window, 'resize').subscribe(function () { return _this._notify(); });
	    }
	    /**
	     * Registers a Scrollable with the service and listens for its scrolled events. When the
	     * scrollable is scrolled, the service emits the event in its scrolled observable.
	     *
	     * @param scrollable Scrollable instance to be registered.
	     */
	    ScrollDispatcher.prototype.register = function (scrollable) {
	        var _this = this;
	        var scrollSubscription = scrollable.elementScrolled().subscribe(function () { return _this._notify(); });
	        this.scrollableReferences.set(scrollable, scrollSubscription);
	    };
	    /**
	     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
	     *
	     * @param scrollable Scrollable instance to be deregistered.
	     */
	    ScrollDispatcher.prototype.deregister = function (scrollable) {
	        this.scrollableReferences.get(scrollable).unsubscribe();
	        this.scrollableReferences.delete(scrollable);
	    };
	    /**
	     * Returns an observable that emits an event whenever any of the registered Scrollable
	     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
	     * to override the default "throttle" time.
	     */
	    ScrollDispatcher.prototype.scrolled = function (auditTimeInMs) {
	        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }
	        // In the case of a 0ms delay, return the observable without auditTime since it does add
	        // a perceptible delay in processing overhead.
	        if (auditTimeInMs == 0) {
	            return this._scrolled.asObservable();
	        }
	        return this._scrolled.asObservable().auditTime(auditTimeInMs);
	    };
	    /** Returns all registered Scrollables that contain the provided element. */
	    ScrollDispatcher.prototype.getScrollContainers = function (elementRef) {
	        var _this = this;
	        var scrollingContainers = [];
	        this.scrollableReferences.forEach(function (subscription, scrollable) {
	            if (_this.scrollableContainsElement(scrollable, elementRef)) {
	                scrollingContainers.push(scrollable);
	            }
	        });
	        return scrollingContainers;
	    };
	    /** Returns true if the element is contained within the provided Scrollable. */
	    ScrollDispatcher.prototype.scrollableContainsElement = function (scrollable, elementRef) {
	        var element = elementRef.nativeElement;
	        var scrollableElement = scrollable.getElementRef().nativeElement;
	        // Traverse through the element parents until we reach null, checking if any of the elements
	        // are the scrollable's element.
	        do {
	            if (element == scrollableElement) {
	                return true;
	            }
	        } while (element = element.parentElement);
	    };
	    /** Sends a notification that a scroll event has been fired. */
	    ScrollDispatcher.prototype._notify = function () {
	        this._scrolled.next();
	    };
	    ScrollDispatcher = __decorate$8([
	        _angular_core.Injectable(), 
	        __metadata$8('design:paramtypes', [])
	    ], ScrollDispatcher);
	    return ScrollDispatcher;
	}());
	function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {
	    return parentDispatcher || new ScrollDispatcher();
	}
	var SCROLL_DISPATCHER_PROVIDER = {
	    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.
	    provide: ScrollDispatcher,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), ScrollDispatcher]],
	    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY
	};
	
	var __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$7 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Simple utility for getting the bounds of the browser viewport.
	 * @docs-private
	 */
	var ViewportRuler = (function () {
	    function ViewportRuler(scrollDispatcher) {
	        var _this = this;
	        // Initially cache the document rectangle.
	        this._cacheViewportGeometry();
	        // Subscribe to scroll and resize events and update the document rectangle on changes.
	        scrollDispatcher.scrolled().subscribe(function () { return _this._cacheViewportGeometry(); });
	    }
	    /** Gets a ClientRect for the viewport's bounds. */
	    ViewportRuler.prototype.getViewportRect = function (documentRect) {
	        if (documentRect === void 0) { documentRect = this._documentRect; }
	        // Use the document element's bounding rect rather than the window scroll properties
	        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
	        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
	        // conceptual viewports. Under most circumstances these viewports are equivalent, but they
	        // can disagree when the page is pinch-zoomed (on devices that support touch).
	        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
	        // We use the documentElement instead of the body because, by default (without a css reset)
	        // browsers typically give the document body an 8px margin, which is not included in
	        // getBoundingClientRect().
	        var scrollPosition = this.getViewportScrollPosition(documentRect);
	        var height = window.innerHeight;
	        var width = window.innerWidth;
	        return {
	            top: scrollPosition.top,
	            left: scrollPosition.left,
	            bottom: scrollPosition.top + height,
	            right: scrollPosition.left + width,
	            height: height,
	            width: width,
	        };
	    };
	    /**
	     * Gets the (top, left) scroll position of the viewport.
	     * @param documentRect
	     */
	    ViewportRuler.prototype.getViewportScrollPosition = function (documentRect) {
	        if (documentRect === void 0) { documentRect = this._documentRect; }
	        // The top-left-corner of the viewport is determined by the scroll position of the document
	        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
	        // whether `document.body` or `document.documentElement` is the scrolled element, so reading
	        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
	        // `document.documentElement` works consistently, where the `top` and `left` values will
	        // equal negative the scroll position.
	        var top = -documentRect.top || document.body.scrollTop || window.scrollY || 0;
	        var left = -documentRect.left || document.body.scrollLeft || window.scrollX || 0;
	        return { top: top, left: left };
	    };
	    /** Caches the latest client rectangle of the document element. */
	    ViewportRuler.prototype._cacheViewportGeometry = function () {
	        this._documentRect = document.documentElement.getBoundingClientRect();
	    };
	    ViewportRuler = __decorate$7([
	        _angular_core.Injectable(), 
	        __metadata$7('design:paramtypes', [ScrollDispatcher])
	    ], ViewportRuler);
	    return ViewportRuler;
	}());
	function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, scrollDispatcher) {
	    return parentRuler || new ViewportRuler(scrollDispatcher);
	}
	var VIEWPORT_RULER_PROVIDER = {
	    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.
	    provide: ViewportRuler,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), ViewportRuler], ScrollDispatcher],
	    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY
	};
	
	var __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$6 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdRipple = (function () {
	    function MdRipple(elementRef, ngZone, ruler) {
	        /**
	         * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius
	         * will be the distance from the center of the ripple to the furthest corner of the host element's
	         * bounding rectangle.
	         */
	        this.radius = 0;
	        /**
	         * If set, the normal duration of ripple animations is divided by this value. For example,
	         * setting it to 0.5 will cause the animations to take twice as long.
	         * A changed speedFactor will not modify the fade-out duration of the ripples.
	         */
	        this.speedFactor = 1;
	        this._rippleRenderer = new RippleRenderer(elementRef, ngZone, ruler);
	    }
	    MdRipple.prototype.ngOnChanges = function (changes) {
	        if (changes['trigger'] && this.trigger) {
	            this._rippleRenderer.setTriggerElement(this.trigger);
	        }
	        this._rippleRenderer.rippleDisabled = this.disabled;
	        this._updateRippleConfig();
	    };
	    MdRipple.prototype.ngOnDestroy = function () {
	        // Set the trigger element to null to cleanup all listeners.
	        this._rippleRenderer.setTriggerElement(null);
	    };
	    /** Launches a manual ripple at the specified position. */
	    MdRipple.prototype.launch = function (pageX, pageY, config) {
	        this._rippleRenderer.fadeInRipple(pageX, pageY, config);
	    };
	    /** Updates the ripple configuration with the input values. */
	    MdRipple.prototype._updateRippleConfig = function () {
	        this._rippleRenderer.rippleConfig = {
	            centered: this.centered,
	            speedFactor: this.speedFactor,
	            radius: this.radius,
	            color: this.color
	        };
	    };
	    __decorate$6([
	        _angular_core.Input('mdRippleTrigger'), 
	        __metadata$6('design:type', Object)
	    ], MdRipple.prototype, "trigger", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleCentered'), 
	        __metadata$6('design:type', Boolean)
	    ], MdRipple.prototype, "centered", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleDisabled'), 
	        __metadata$6('design:type', Boolean)
	    ], MdRipple.prototype, "disabled", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleRadius'), 
	        __metadata$6('design:type', Number)
	    ], MdRipple.prototype, "radius", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleSpeedFactor'), 
	        __metadata$6('design:type', Number)
	    ], MdRipple.prototype, "speedFactor", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleColor'), 
	        __metadata$6('design:type', String)
	    ], MdRipple.prototype, "color", void 0);
	    __decorate$6([
	        _angular_core.Input('mdRippleUnbounded'), 
	        __metadata$6('design:type', Boolean)
	    ], MdRipple.prototype, "unbounded", void 0);
	    MdRipple = __decorate$6([
	        _angular_core.Directive({
	            selector: '[md-ripple], [mat-ripple]',
	            host: {
	                '[class.mat-ripple]': 'true',
	                '[class.mat-ripple-unbounded]': 'unbounded'
	            }
	        }), 
	        __metadata$6('design:paramtypes', [_angular_core.ElementRef, _angular_core.NgZone, ViewportRuler])
	    ], MdRipple);
	    return MdRipple;
	}());
	var MdRippleModule = (function () {
	    function MdRippleModule() {
	    }
	    /** @deprecated */
	    MdRippleModule.forRoot = function () {
	        return {
	            ngModule: MdRippleModule,
	            providers: []
	        };
	    };
	    MdRippleModule = __decorate$6([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [MdRipple, CompatibilityModule],
	            declarations: [MdRipple],
	            providers: [VIEWPORT_RULER_PROVIDER, SCROLL_DISPATCHER_PROVIDER],
	        }), 
	        __metadata$6('design:paramtypes', [])
	    ], MdRippleModule);
	    return MdRippleModule;
	}());
	
	var __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$5 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Option IDs need to be unique across components, so this counter exists outside of
	 * the component definition.
	 */
	var _uniqueIdCounter = 0;
	/** Event object emitted by MdOption when selected. */
	var MdOptionSelectEvent = (function () {
	    function MdOptionSelectEvent(source, isUserInput) {
	        if (isUserInput === void 0) { isUserInput = false; }
	        this.source = source;
	        this.isUserInput = isUserInput;
	    }
	    return MdOptionSelectEvent;
	}());
	/**
	 * Single option inside of a `<md-select>` element.
	 */
	var MdOption = (function () {
	    function MdOption(_element, _renderer) {
	        this._element = _element;
	        this._renderer = _renderer;
	        this._selected = false;
	        this._active = false;
	        /** Whether the option is disabled.  */
	        this._disabled = false;
	        this._id = "md-option-" + _uniqueIdCounter++;
	        /** Event emitted when the option is selected. */
	        this.onSelect = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(MdOption.prototype, "id", {
	        /** The unique ID of the option. */
	        get: function () { return this._id; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "disabled", {
	        /** Whether the option is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "selected", {
	        /** Whether or not the option is currently selected. */
	        get: function () {
	            return this._selected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "active", {
	        /**
	         * Whether or not the option is currently active and ready to be selected.
	         * An active option displays styles as if it is focused, but the
	         * focus is actually retained somewhere else. This comes in handy
	         * for components like autocomplete where focus must remain on the input.
	         */
	        get: function () {
	            return this._active;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdOption.prototype, "viewValue", {
	        /**
	         * The displayed value of the option. It is necessary to show the selected option in the
	         * select's trigger.
	         */
	        get: function () {
	            // TODO(kara): Add input property alternative for node envs.
	            return this._getHostElement().textContent.trim();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Selects the option. */
	    MdOption.prototype.select = function () {
	        this._selected = true;
	        this.onSelect.emit(new MdOptionSelectEvent(this, false));
	    };
	    /** Deselects the option. */
	    MdOption.prototype.deselect = function () {
	        this._selected = false;
	    };
	    /** Sets focus onto this option. */
	    MdOption.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._getHostElement(), 'focus');
	    };
	    /**
	     * This method sets display styles on the option to make it appear
	     * active. This is used by the ActiveDescendantKeyManager so key
	     * events will display the proper options as active on arrow key events.
	     */
	    MdOption.prototype.setActiveStyles = function () {
	        var _this = this;
	        Promise.resolve(null).then(function () { return _this._active = true; });
	    };
	    /**
	     * This method removes display styles on the option that made it appear
	     * active. This is used by the ActiveDescendantKeyManager so key
	     * events will display the proper options as active on arrow key events.
	     */
	    MdOption.prototype.setInactiveStyles = function () {
	        var _this = this;
	        Promise.resolve(null).then(function () { return _this._active = false; });
	    };
	    /** Ensures the option is selected when activated from the keyboard. */
	    MdOption.prototype._handleKeydown = function (event) {
	        if (event.keyCode === ENTER || event.keyCode === SPACE) {
	            this._selectViaInteraction();
	        }
	    };
	    /**
	     * Selects the option while indicating the selection came from the user. Used to
	     * determine if the select's view -> model callback should be invoked.
	     */
	    MdOption.prototype._selectViaInteraction = function () {
	        if (!this.disabled) {
	            this._selected = true;
	            this.onSelect.emit(new MdOptionSelectEvent(this, true));
	        }
	    };
	    /** Returns the correct tabindex for the option depending on disabled state. */
	    MdOption.prototype._getTabIndex = function () {
	        return this.disabled ? '-1' : '0';
	    };
	    MdOption.prototype._getHostElement = function () {
	        return this._element.nativeElement;
	    };
	    __decorate$5([
	        _angular_core.Input(), 
	        __metadata$5('design:type', Object)
	    ], MdOption.prototype, "value", void 0);
	    __decorate$5([
	        _angular_core.Input(), 
	        __metadata$5('design:type', Object)
	    ], MdOption.prototype, "disabled", null);
	    __decorate$5([
	        _angular_core.Output(), 
	        __metadata$5('design:type', Object)
	    ], MdOption.prototype, "onSelect", void 0);
	    MdOption = __decorate$5([
	        _angular_core.Component({selector: 'md-option, mat-option',
	            host: {
	                'role': 'option',
	                '[attr.tabindex]': '_getTabIndex()',
	                '[class.mat-selected]': 'selected',
	                '[class.mat-active]': 'active',
	                '[id]': 'id',
	                '[attr.aria-selected]': 'selected.toString()',
	                '[attr.aria-disabled]': 'disabled.toString()',
	                '[class.mat-option-disabled]': 'disabled',
	                '(click)': '_selectViaInteraction()',
	                '(keydown)': '_handleKeydown($event)',
	                '[class.mat-option]': 'true',
	            },
	            template: "<ng-content></ng-content><div class=\"mat-option-ripple\" *ngIf=\"!disabled\" md-ripple [mdRippleTrigger]=\"_getHostElement()\"></div>",
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$5('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdOption);
	    return MdOption;
	}());
	var MdOptionModule = (function () {
	    function MdOptionModule() {
	    }
	    MdOptionModule.forRoot = function () {
	        return {
	            ngModule: MdOptionModule,
	            providers: []
	        };
	    };
	    MdOptionModule = __decorate$5([
	        _angular_core.NgModule({
	            imports: [MdRippleModule, _angular_common.CommonModule],
	            exports: [MdOption],
	            declarations: [MdOption]
	        }), 
	        __metadata$5('design:paramtypes', [])
	    ], MdOptionModule);
	    return MdOptionModule;
	}());
	
	// TODO(kara): Revisit why error messages are not being properly set.
	var __extends$3 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Wrapper around Error that sets the error message.
	 * @docs-private
	 */
	var MdError = (function (_super) {
	    __extends$3(MdError, _super);
	    function MdError(value) {
	        _super.call(this);
	        this.message = value;
	    }
	    return MdError;
	}(Error));
	
	var __extends$2 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when attempting to attach a null portal to a host.
	 * @docs-private
	 */
	var NullPortalError = (function (_super) {
	    __extends$2(NullPortalError, _super);
	    function NullPortalError() {
	        _super.call(this, 'Must provide a portal to attach');
	    }
	    return NullPortalError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach a portal to a host that is already attached.
	 * @docs-private
	 */
	var PortalAlreadyAttachedError = (function (_super) {
	    __extends$2(PortalAlreadyAttachedError, _super);
	    function PortalAlreadyAttachedError() {
	        _super.call(this, 'Host already has a portal attached');
	    }
	    return PortalAlreadyAttachedError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach a portal to an already-disposed host.
	 * @docs-private
	 */
	var PortalHostAlreadyDisposedError = (function (_super) {
	    __extends$2(PortalHostAlreadyDisposedError, _super);
	    function PortalHostAlreadyDisposedError() {
	        _super.call(this, 'This PortalHost has already been disposed');
	    }
	    return PortalHostAlreadyDisposedError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach an unknown portal type.
	 * @docs-private
	 */
	var UnknownPortalTypeError = (function (_super) {
	    __extends$2(UnknownPortalTypeError, _super);
	    function UnknownPortalTypeError() {
	        _super.call(this, 'Attempting to attach an unknown Portal type. ' +
	            'BasePortalHost accepts either a ComponentPortal or a TemplatePortal.');
	    }
	    return UnknownPortalTypeError;
	}(MdError));
	/**
	 * Exception thrown when attempting to attach a portal to a null host.
	 * @docs-private
	 */
	var NullPortalHostError = (function (_super) {
	    __extends$2(NullPortalHostError, _super);
	    function NullPortalHostError() {
	        _super.call(this, 'Attempting to attach a portal to a null PortalHost');
	    }
	    return NullPortalHostError;
	}(MdError));
	/**
	 * Exception thrown when attempting to detach a portal that is not attached.
	 * @docs-private
	 */
	var NoPortalAttachedError = (function (_super) {
	    __extends$2(NoPortalAttachedError, _super);
	    function NoPortalAttachedError() {
	        _super.call(this, 'Attempting to detach a portal that is not attached to a host');
	    }
	    return NoPortalAttachedError;
	}(MdError));
	
	var __extends$1 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * A `Portal` is something that you want to render somewhere else.
	 * It can be attach to / detached from a `PortalHost`.
	 */
	var Portal = (function () {
	    function Portal() {
	    }
	    /** Attach this portal to a host. */
	    Portal.prototype.attach = function (host) {
	        if (host == null) {
	            throw new NullPortalHostError();
	        }
	        if (host.hasAttached()) {
	            throw new PortalAlreadyAttachedError();
	        }
	        this._attachedHost = host;
	        return host.attach(this);
	    };
	    /** Detach this portal from its host */
	    Portal.prototype.detach = function () {
	        var host = this._attachedHost;
	        if (host == null) {
	            throw new NoPortalAttachedError();
	        }
	        this._attachedHost = null;
	        return host.detach();
	    };
	    Object.defineProperty(Portal.prototype, "isAttached", {
	        /** Whether this portal is attached to a host. */
	        get: function () {
	            return this._attachedHost != null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the PortalHost reference without performing `attach()`. This is used directly by
	     * the PortalHost when it is performing an `attach()` or `detach()`.
	     */
	    Portal.prototype.setAttachedHost = function (host) {
	        this._attachedHost = host;
	    };
	    return Portal;
	}());
	/**
	 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
	 */
	var ComponentPortal = (function (_super) {
	    __extends$1(ComponentPortal, _super);
	    function ComponentPortal(component, viewContainerRef, injector) {
	        if (viewContainerRef === void 0) { viewContainerRef = null; }
	        if (injector === void 0) { injector = null; }
	        _super.call(this);
	        this.component = component;
	        this.viewContainerRef = viewContainerRef;
	        this.injector = injector;
	    }
	    return ComponentPortal;
	}(Portal));
	/**
	 * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
	 */
	var TemplatePortal = (function (_super) {
	    __extends$1(TemplatePortal, _super);
	    function TemplatePortal(template, viewContainerRef) {
	        _super.call(this);
	        /**
	         * Additional locals for the instantiated embedded view.
	         * These locals can be seen as "exports" for the template, such as how ngFor has
	         * index / event / odd.
	         * See https://angular.io/docs/ts/latest/api/core/EmbeddedViewRef-class.html
	         */
	        this.locals = new Map();
	        this.templateRef = template;
	        this.viewContainerRef = viewContainerRef;
	    }
	    Object.defineProperty(TemplatePortal.prototype, "origin", {
	        get: function () {
	            return this.templateRef.elementRef;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TemplatePortal.prototype.attach = function (host, locals) {
	        this.locals = locals == null ? new Map() : locals;
	        return _super.prototype.attach.call(this, host);
	    };
	    TemplatePortal.prototype.detach = function () {
	        this.locals = new Map();
	        return _super.prototype.detach.call(this);
	    };
	    return TemplatePortal;
	}(Portal));
	/**
	 * Partial implementation of PortalHost that only deals with attaching either a
	 * ComponentPortal or a TemplatePortal.
	 */
	var BasePortalHost = (function () {
	    function BasePortalHost() {
	        /** Whether this host has already been permanently disposed. */
	        this._isDisposed = false;
	    }
	    /** Whether this host has an attached portal. */
	    BasePortalHost.prototype.hasAttached = function () {
	        return this._attachedPortal != null;
	    };
	    BasePortalHost.prototype.attach = function (portal) {
	        if (portal == null) {
	            throw new NullPortalError();
	        }
	        if (this.hasAttached()) {
	            throw new PortalAlreadyAttachedError();
	        }
	        if (this._isDisposed) {
	            throw new PortalHostAlreadyDisposedError();
	        }
	        if (portal instanceof ComponentPortal) {
	            this._attachedPortal = portal;
	            return this.attachComponentPortal(portal);
	        }
	        else if (portal instanceof TemplatePortal) {
	            this._attachedPortal = portal;
	            return this.attachTemplatePortal(portal);
	        }
	        throw new UnknownPortalTypeError();
	    };
	    BasePortalHost.prototype.detach = function () {
	        if (this._attachedPortal) {
	            this._attachedPortal.setAttachedHost(null);
	        }
	        this._attachedPortal = null;
	        if (this._disposeFn != null) {
	            this._disposeFn();
	            this._disposeFn = null;
	        }
	    };
	    BasePortalHost.prototype.dispose = function () {
	        if (this.hasAttached()) {
	            this.detach();
	        }
	        this._isDisposed = true;
	    };
	    BasePortalHost.prototype.setDisposeFn = function (fn) {
	        this._disposeFn = fn;
	    };
	    return BasePortalHost;
	}());
	
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$9 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$9 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
	 * the directive instance itself can be attached to a host, enabling declarative use of portals.
	 *
	 * Usage:
	 * <template portal #greeting>
	 *   <p> Hello {{name}} </p>
	 * </template>
	 */
	var TemplatePortalDirective = (function (_super) {
	    __extends(TemplatePortalDirective, _super);
	    function TemplatePortalDirective(templateRef, viewContainerRef) {
	        _super.call(this, templateRef, viewContainerRef);
	    }
	    TemplatePortalDirective = __decorate$9([
	        _angular_core.Directive({
	            selector: '[cdk-portal], [portal]',
	            exportAs: 'cdkPortal',
	        }), 
	        __metadata$9('design:paramtypes', [_angular_core.TemplateRef, _angular_core.ViewContainerRef])
	    ], TemplatePortalDirective);
	    return TemplatePortalDirective;
	}(TemplatePortal));
	/**
	 * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be
	 * directly attached to it, enabling declarative use.
	 *
	 * Usage:
	 * <template [cdkPortalHost]="greeting"></template>
	 */
	var PortalHostDirective = (function (_super) {
	    __extends(PortalHostDirective, _super);
	    function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {
	        _super.call(this);
	        this._componentFactoryResolver = _componentFactoryResolver;
	        this._viewContainerRef = _viewContainerRef;
	    }
	    Object.defineProperty(PortalHostDirective.prototype, "_deprecatedPortal", {
	        /** @deprecated */
	        get: function () { return this.portal; },
	        set: function (v) { this.portal = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PortalHostDirective.prototype, "portal", {
	        /** Portal associated with the Portal host. */
	        get: function () {
	            return this._portal;
	        },
	        set: function (p) {
	            if (p) {
	                this._replaceAttachedPortal(p);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PortalHostDirective.prototype.ngOnDestroy = function () {
	        this.dispose();
	    };
	    /**
	     * Attach the given ComponentPortal to this PortalHost using the ComponentFactoryResolver.
	     *
	     * @param portal Portal to be attached to the portal host.
	     */
	    PortalHostDirective.prototype.attachComponentPortal = function (portal) {
	        portal.setAttachedHost(this);
	        // If the portal specifies an origin, use that as the logical location of the component
	        // in the application tree. Otherwise use the location of this PortalHost.
	        var viewContainerRef = portal.viewContainerRef != null ?
	            portal.viewContainerRef :
	            this._viewContainerRef;
	        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
	        var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);
	        this.setDisposeFn(function () { return ref.destroy(); });
	        return ref;
	    };
	    /**
	     * Attach the given TemplatePortal to this PortlHost as an embedded View.
	     * @param portal Portal to be attached.
	     */
	    PortalHostDirective.prototype.attachTemplatePortal = function (portal) {
	        var _this = this;
	        portal.setAttachedHost(this);
	        this._viewContainerRef.createEmbeddedView(portal.templateRef);
	        this.setDisposeFn(function () { return _this._viewContainerRef.clear(); });
	        // TODO(jelbourn): return locals from view
	        return new Map();
	    };
	    /** Detaches the currently attached Portal (if there is one) and attaches the given Portal. */
	    PortalHostDirective.prototype._replaceAttachedPortal = function (p) {
	        if (this.hasAttached()) {
	            this.detach();
	        }
	        if (p) {
	            this.attach(p);
	            this._portal = p;
	        }
	    };
	    __decorate$9([
	        _angular_core.Input('portalHost'), 
	        __metadata$9('design:type', Object)
	    ], PortalHostDirective.prototype, "_deprecatedPortal", null);
	    PortalHostDirective = __decorate$9([
	        _angular_core.Directive({
	            selector: '[cdkPortalHost], [portalHost]',
	            inputs: ['portal: cdkPortalHost']
	        }), 
	        __metadata$9('design:paramtypes', [_angular_core.ComponentFactoryResolver, _angular_core.ViewContainerRef])
	    ], PortalHostDirective);
	    return PortalHostDirective;
	}(BasePortalHost));
	var PortalModule = (function () {
	    function PortalModule() {
	    }
	    /** @deprecated */
	    PortalModule.forRoot = function () {
	        return {
	            ngModule: PortalModule,
	            providers: []
	        };
	    };
	    PortalModule = __decorate$9([
	        _angular_core.NgModule({
	            exports: [TemplatePortalDirective, PortalHostDirective],
	            declarations: [TemplatePortalDirective, PortalHostDirective],
	        }), 
	        __metadata$9('design:paramtypes', [])
	    ], PortalModule);
	    return PortalModule;
	}());
	
	/**
	 * OverlayState is a bag of values for either the initial configuration or current state of an
	 * overlay.
	 */
	var OverlayState = (function () {
	    function OverlayState() {
	        /** Whether the overlay has a backdrop. */
	        this.hasBackdrop = false;
	        /** Custom class to add to the backdrop **/
	        this.backdropClass = 'cdk-overlay-dark-backdrop';
	        /** The direction of the text in the overlay panel. */
	        this.direction = 'ltr';
	    }
	    return OverlayState;
	}());
	
	var __extends$4 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular
	 * application context.
	 *
	 * This is the only part of the portal core that directly touches the DOM.
	 */
	var DomPortalHost = (function (_super) {
	    __extends$4(DomPortalHost, _super);
	    function DomPortalHost(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {
	        _super.call(this);
	        this._hostDomElement = _hostDomElement;
	        this._componentFactoryResolver = _componentFactoryResolver;
	        this._appRef = _appRef;
	        this._defaultInjector = _defaultInjector;
	    }
	    /**
	     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
	     * @param portal Portal to be attached
	     */
	    DomPortalHost.prototype.attachComponentPortal = function (portal) {
	        var _this = this;
	        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
	        var componentRef;
	        // If the portal specifies a ViewContainerRef, we will use that as the attachment point
	        // for the component (in terms of Angular's component tree, not rendering).
	        // When the ViewContainerRef is missing, we use the factory to create the component directly
	        // and then manually attach the view to the application.
	        if (portal.viewContainerRef) {
	            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);
	            this.setDisposeFn(function () { return componentRef.destroy(); });
	        }
	        else {
	            componentRef = componentFactory.create(portal.injector || this._defaultInjector);
	            this._appRef.attachView(componentRef.hostView);
	            this.setDisposeFn(function () {
	                _this._appRef.detachView(componentRef.hostView);
	                componentRef.destroy();
	            });
	        }
	        // At this point the component has been instantiated, so we move it to the location in the DOM
	        // where we want it to be rendered.
	        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));
	        return componentRef;
	    };
	    /**
	     * Attaches a template portal to the DOM as an embedded view.
	     * @param portal Portal to be attached.
	     */
	    DomPortalHost.prototype.attachTemplatePortal = function (portal) {
	        var _this = this;
	        var viewContainer = portal.viewContainerRef;
	        var viewRef = viewContainer.createEmbeddedView(portal.templateRef);
	        // The method `createEmbeddedView` will add the view as a child of the viewContainer.
	        // But for the DomPortalHost the view can be added everywhere in the DOM (e.g Overlay Container)
	        // To move the view to the specified host element. We just re-append the existing root nodes.
	        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });
	        this.setDisposeFn((function () {
	            var index = viewContainer.indexOf(viewRef);
	            if (index !== -1) {
	                viewContainer.remove(index);
	            }
	        }));
	        // TODO(jelbourn): Return locals from view.
	        return new Map();
	    };
	    /**
	     * Clears out a portal from the DOM.
	     */
	    DomPortalHost.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        if (this._hostDomElement.parentNode != null) {
	            this._hostDomElement.parentNode.removeChild(this._hostDomElement);
	        }
	    };
	    /** Gets the root HTMLElement for an instantiated component. */
	    DomPortalHost.prototype._getComponentRootNode = function (componentRef) {
	        return componentRef.hostView.rootNodes[0];
	    };
	    return DomPortalHost;
	}(BasePortalHost));
	
	/**
	 * Reference to an overlay that has been created with the Overlay service.
	 * Used to manipulate or dispose of said overlay.
	 */
	var OverlayRef = (function () {
	    function OverlayRef(_portalHost, _pane, _state, _ngZone) {
	        this._portalHost = _portalHost;
	        this._pane = _pane;
	        this._state = _state;
	        this._ngZone = _ngZone;
	        this._backdropElement = null;
	        this._backdropClick = new rxjs_Subject.Subject();
	    }
	    Object.defineProperty(OverlayRef.prototype, "overlayElement", {
	        /** The overlay's HTML element */
	        get: function () {
	            return this._pane;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Attaches the overlay to a portal instance and adds the backdrop.
	     * @param portal Portal instance to which to attach the overlay.
	     * @returns The portal attachment result.
	     */
	    OverlayRef.prototype.attach = function (portal) {
	        if (this._state.hasBackdrop) {
	            this._attachBackdrop();
	        }
	        var attachResult = this._portalHost.attach(portal);
	        // Update the pane element with the given state configuration.
	        this.updateSize();
	        this.updateDirection();
	        this.updatePosition();
	        // Enable pointer events for the overlay pane element.
	        this._togglePointerEvents(true);
	        return attachResult;
	    };
	    /**
	     * Detaches an overlay from a portal.
	     * @returns Resolves when the overlay has been detached.
	     */
	    OverlayRef.prototype.detach = function () {
	        this._detachBackdrop();
	        // When the overlay is detached, the pane element should disable pointer events.
	        // This is necessary because otherwise the pane element will cover the page and disable
	        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
	        this._togglePointerEvents(false);
	        return this._portalHost.detach();
	    };
	    /**
	     * Cleans up the overlay from the DOM.
	     */
	    OverlayRef.prototype.dispose = function () {
	        if (this._state.positionStrategy) {
	            this._state.positionStrategy.dispose();
	        }
	        this._detachBackdrop();
	        this._portalHost.dispose();
	    };
	    /**
	     * Checks whether the overlay has been attached.
	     */
	    OverlayRef.prototype.hasAttached = function () {
	        return this._portalHost.hasAttached();
	    };
	    /**
	     * Returns an observable that emits when the backdrop has been clicked.
	     */
	    OverlayRef.prototype.backdropClick = function () {
	        return this._backdropClick.asObservable();
	    };
	    /**
	     * Gets the current state config of the overlay.
	     */
	    OverlayRef.prototype.getState = function () {
	        return this._state;
	    };
	    /** Updates the position of the overlay based on the position strategy. */
	    OverlayRef.prototype.updatePosition = function () {
	        if (this._state.positionStrategy) {
	            this._state.positionStrategy.apply(this._pane);
	        }
	    };
	    /** Updates the text direction of the overlay panel. **/
	    OverlayRef.prototype.updateDirection = function () {
	        this._pane.setAttribute('dir', this._state.direction);
	    };
	    /** Updates the size of the overlay based on the overlay config. */
	    OverlayRef.prototype.updateSize = function () {
	        if (this._state.width || this._state.width === 0) {
	            this._pane.style.width = formatCssUnit(this._state.width);
	        }
	        if (this._state.height || this._state.height === 0) {
	            this._pane.style.height = formatCssUnit(this._state.height);
	        }
	        if (this._state.minWidth || this._state.minWidth === 0) {
	            this._pane.style.minWidth = formatCssUnit(this._state.minWidth);
	        }
	        if (this._state.minHeight || this._state.minHeight === 0) {
	            this._pane.style.minHeight = formatCssUnit(this._state.minHeight);
	        }
	    };
	    /** Toggles the pointer events for the overlay pane element. */
	    OverlayRef.prototype._togglePointerEvents = function (enablePointer) {
	        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
	    };
	    /** Attaches a backdrop for this overlay. */
	    OverlayRef.prototype._attachBackdrop = function () {
	        var _this = this;
	        this._backdropElement = document.createElement('div');
	        this._backdropElement.classList.add('cdk-overlay-backdrop');
	        this._backdropElement.classList.add(this._state.backdropClass);
	        // Insert the backdrop before the pane in the DOM order,
	        // in order to handle stacked overlays properly.
	        this._pane.parentElement.insertBefore(this._backdropElement, this._pane);
	        // Forward backdrop clicks such that the consumer of the overlay can perform whatever
	        // action desired when such a click occurs (usually closing the overlay).
	        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });
	        // Add class to fade-in the backdrop after one frame.
	        requestAnimationFrame(function () {
	            if (_this._backdropElement) {
	                _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');
	            }
	        });
	    };
	    /** Detaches the backdrop (if any) associated with the overlay. */
	    OverlayRef.prototype._detachBackdrop = function () {
	        var _this = this;
	        var backdropToDetach = this._backdropElement;
	        if (backdropToDetach) {
	            var finishDetach_1 = function () {
	                // It may not be attached to anything in certain cases (e.g. unit tests).
	                if (backdropToDetach && backdropToDetach.parentNode) {
	                    backdropToDetach.parentNode.removeChild(backdropToDetach);
	                }
	                // It is possible that a new portal has been attached to this overlay since we started
	                // removing the backdrop. If that is the case, only clear the backdrop reference if it
	                // is still the same instance that we started to remove.
	                if (_this._backdropElement == backdropToDetach) {
	                    _this._backdropElement = null;
	                }
	            };
	            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');
	            backdropToDetach.classList.remove(this._state.backdropClass);
	            backdropToDetach.addEventListener('transitionend', finishDetach_1);
	            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
	            // In this case we make it unclickable and we try to remove it after a delay.
	            backdropToDetach.style.pointerEvents = 'none';
	            // Run this outside the Angular zone because there's nothing that Angular cares about.
	            // If it were to run inside the Angular zone, every test that used Overlay would have to be
	            // either async or fakeAsync.
	            this._ngZone.runOutsideAngular(function () {
	                setTimeout(finishDetach_1, 500);
	            });
	        }
	    };
	    return OverlayRef;
	}());
	function formatCssUnit(value) {
	    return typeof value === 'string' ? value : value + "px";
	}
	
	var __decorate$13 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$13 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$2 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** The points of the origin element and the overlay element to connect. */
	var ConnectionPositionPair = (function () {
	    function ConnectionPositionPair(origin, overlay) {
	        this.originX = origin.originX;
	        this.originY = origin.originY;
	        this.overlayX = overlay.overlayX;
	        this.overlayY = overlay.overlayY;
	    }
	    return ConnectionPositionPair;
	}());
	/**
	 * Set of properties regarding the position of the origin and overlay relative to the viewport
	 * with respect to the containing Scrollable elements.
	 *
	 * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
	 * bounds of any one of the strategy's Scrollable's bounding client rectangle.
	 *
	 * The overlay and origin are outside view if there is no overlap between their bounding client
	 * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
	 *
	 *       -----------                    -----------
	 *       | outside |                    | clipped |
	 *       |  view   |              --------------------------
	 *       |         |              |     |         |        |
	 *       ----------               |     -----------        |
	 *  --------------------------    |                        |
	 *  |                        |    |      Scrollable        |
	 *  |                        |    |                        |
	 *  |                        |     --------------------------
	 *  |      Scrollable        |
	 *  |                        |
	 *  --------------------------
	 */
	var ScrollableViewProperties = (function () {
	    function ScrollableViewProperties() {
	    }
	    return ScrollableViewProperties;
	}());
	/** The change event emitted by the strategy when a fallback position is used. */
	var ConnectedOverlayPositionChange = (function () {
	    function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {
	        this.connectionPair = connectionPair;
	        this.scrollableViewProperties = scrollableViewProperties;
	    }
	    ConnectedOverlayPositionChange = __decorate$13([
	        __param$2(1, _angular_core.Optional()), 
	        __metadata$13('design:paramtypes', [ConnectionPositionPair, ScrollableViewProperties])
	    ], ConnectedOverlayPositionChange);
	    return ConnectedOverlayPositionChange;
	}());
	
	/**
	 * A strategy for positioning overlays. Using this strategy, an overlay is given an
	 * implicit position relative some origin element. The relative position is defined in terms of
	 * a point on the origin element that is connected to a point on the overlay element. For example,
	 * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
	 * of the overlay.
	 */
	var ConnectedPositionStrategy = (function () {
	    function ConnectedPositionStrategy(_connectedTo, _originPos, _overlayPos, _viewportRuler) {
	        this._connectedTo = _connectedTo;
	        this._originPos = _originPos;
	        this._overlayPos = _overlayPos;
	        this._viewportRuler = _viewportRuler;
	        this._dir = 'ltr';
	        /** The offset in pixels for the overlay connection point on the x-axis */
	        this._offsetX = 0;
	        /** The offset in pixels for the overlay connection point on the y-axis */
	        this._offsetY = 0;
	        /** The Scrollable containers used to check scrollable view properties on position change. */
	        this.scrollables = [];
	        /** Ordered list of preferred positions, from most to least desirable. */
	        this._preferredPositions = [];
	        this._onPositionChange = new rxjs_Subject.Subject();
	        this._origin = this._connectedTo.nativeElement;
	        this.withFallbackPosition(_originPos, _overlayPos);
	    }
	    Object.defineProperty(ConnectedPositionStrategy.prototype, "_isRtl", {
	        /** Whether the we're dealing with an RTL context */
	        get: function () {
	            return this._dir === 'rtl';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedPositionStrategy.prototype, "onPositionChange", {
	        /** Emits an event when the connection point changes. */
	        get: function () {
	            return this._onPositionChange.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedPositionStrategy.prototype, "positions", {
	        /** Ordered list of preferred positions, from most to least desirable. */
	        get: function () {
	            return this._preferredPositions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * To be used to for any cleanup after the element gets destroyed.
	     */
	    ConnectedPositionStrategy.prototype.dispose = function () { };
	    /**
	     * Updates the position of the overlay element, using whichever preferred position relative
	     * to the origin fits on-screen.
	     * @docs-private
	     *
	     * @param element Element to which to apply the CSS styles.
	     * @returns Resolves when the styles have been applied.
	     */
	    ConnectedPositionStrategy.prototype.apply = function (element) {
	        // Cache the overlay pane element in case re-calculating position is necessary
	        this._pane = element;
	        // We need the bounding rects for the origin and the overlay to determine how to position
	        // the overlay relative to the origin.
	        var originRect = this._origin.getBoundingClientRect();
	        var overlayRect = element.getBoundingClientRect();
	        // We use the viewport rect to determine whether a position would go off-screen.
	        var viewportRect = this._viewportRuler.getViewportRect();
	        // Fallback point if none of the fallbacks fit into the viewport.
	        var fallbackPoint = null;
	        // We want to place the overlay in the first of the preferred positions such that the
	        // overlay fits on-screen.
	        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {
	            var pos = _a[_i];
	            // Get the (x, y) point of connection on the origin, and then use that to get the
	            // (top, left) coordinate for the overlay at `pos`.
	            var originPoint = this._getOriginConnectionPoint(originRect, pos);
	            var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);
	            // If the overlay in the calculated position fits on-screen, put it there and we're done.
	            if (overlayPoint.fitsInViewport) {
	                this._setElementPosition(element, overlayPoint);
	                // Save the last connected position in case the position needs to be re-calculated.
	                this._lastConnectedPosition = pos;
	                // Notify that the position has been changed along with its change properties.
	                var scrollableViewProperties = this.getScrollableViewProperties(element);
	                var positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);
	                this._onPositionChange.next(positionChange);
	                return Promise.resolve(null);
	            }
	            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {
	                fallbackPoint = overlayPoint;
	            }
	        }
	        // If none of the preferred positions were in the viewport, take the one
	        // with the largest visible area.
	        this._setElementPosition(element, fallbackPoint);
	        return Promise.resolve(null);
	    };
	    /**
	     * This re-aligns the overlay element with the trigger in its last calculated position,
	     * even if a position higher in the "preferred positions" list would now fit. This
	     * allows one to re-align the panel without changing the orientation of the panel.
	     */
	    ConnectedPositionStrategy.prototype.recalculateLastPosition = function () {
	        var originRect = this._origin.getBoundingClientRect();
	        var overlayRect = this._pane.getBoundingClientRect();
	        var viewportRect = this._viewportRuler.getViewportRect();
	        var originPoint = this._getOriginConnectionPoint(originRect, this._lastConnectedPosition);
	        var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, this._lastConnectedPosition);
	        this._setElementPosition(this._pane, overlayPoint);
	    };
	    /**
	     * Sets the list of Scrollable containers that host the origin element so that
	     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
	     * Scrollable must be an ancestor element of the strategy's origin element.
	     */
	    ConnectedPositionStrategy.prototype.withScrollableContainers = function (scrollables) {
	        this.scrollables = scrollables;
	    };
	    /**
	     * Adds a new preferred fallback position.
	     * @param originPos
	     * @param overlayPos
	     */
	    ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos) {
	        this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));
	        return this;
	    };
	    /**
	     * Sets the layout direction so the overlay's position can be adjusted to match.
	     * @param dir New layout direction.
	     */
	    ConnectedPositionStrategy.prototype.withDirection = function (dir) {
	        this._dir = dir;
	        return this;
	    };
	    /**
	     * Sets an offset for the overlay's connection point on the x-axis
	     * @param offset New offset in the X axis.
	     */
	    ConnectedPositionStrategy.prototype.withOffsetX = function (offset) {
	        this._offsetX = offset;
	        return this;
	    };
	    /**
	     * Sets an offset for the overlay's connection point on the y-axis
	     * @param  offset New offset in the Y axis.
	     */
	    ConnectedPositionStrategy.prototype.withOffsetY = function (offset) {
	        this._offsetY = offset;
	        return this;
	    };
	    /**
	     * Gets the horizontal (x) "start" dimension based on whether the overlay is in an RTL context.
	     * @param rect
	     */
	    ConnectedPositionStrategy.prototype._getStartX = function (rect) {
	        return this._isRtl ? rect.right : rect.left;
	    };
	    /**
	     * Gets the horizontal (x) "end" dimension based on whether the overlay is in an RTL context.
	     * @param rect
	     */
	    ConnectedPositionStrategy.prototype._getEndX = function (rect) {
	        return this._isRtl ? rect.left : rect.right;
	    };
	    /**
	     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
	     * @param originRect
	     * @param pos
	     */
	    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = function (originRect, pos) {
	        var originStartX = this._getStartX(originRect);
	        var originEndX = this._getEndX(originRect);
	        var x;
	        if (pos.originX == 'center') {
	            x = originStartX + (originRect.width / 2);
	        }
	        else {
	            x = pos.originX == 'start' ? originStartX : originEndX;
	        }
	        var y;
	        if (pos.originY == 'center') {
	            y = originRect.top + (originRect.height / 2);
	        }
	        else {
	            y = pos.originY == 'top' ? originRect.top : originRect.bottom;
	        }
	        return { x: x, y: y };
	    };
	    /**
	     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
	     * origin point to which the overlay should be connected, as well as how much of the element
	     * would be inside the viewport at that position.
	     */
	    ConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, viewportRect, pos) {
	        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position
	        // relative to the origin point.
	        var overlayStartX;
	        if (pos.overlayX == 'center') {
	            overlayStartX = -overlayRect.width / 2;
	        }
	        else if (pos.overlayX === 'start') {
	            overlayStartX = this._isRtl ? -overlayRect.width : 0;
	        }
	        else {
	            overlayStartX = this._isRtl ? 0 : -overlayRect.width;
	        }
	        var overlayStartY;
	        if (pos.overlayY == 'center') {
	            overlayStartY = -overlayRect.height / 2;
	        }
	        else {
	            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
	        }
	        // The (x, y) coordinates of the overlay.
	        var x = originPoint.x + overlayStartX + this._offsetX;
	        var y = originPoint.y + overlayStartY + this._offsetY;
	        // How much the overlay would overflow at this position, on each side.
	        var leftOverflow = 0 - x;
	        var rightOverflow = (x + overlayRect.width) - viewportRect.width;
	        var topOverflow = 0 - y;
	        var bottomOverflow = (y + overlayRect.height) - viewportRect.height;
	        // Visible parts of the element on each axis.
	        var visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);
	        var visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);
	        // The area of the element that's within the viewport.
	        var visibleArea = visibleWidth * visibleHeight;
	        var fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;
	        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };
	    };
	    /**
	     * Gets the view properties of the trigger and overlay, including whether they are clipped
	     * or completely outside the view of any of the strategy's scrollables.
	     */
	    ConnectedPositionStrategy.prototype.getScrollableViewProperties = function (overlay) {
	        var _this = this;
	        var originBounds = this._getElementBounds(this._origin);
	        var overlayBounds = this._getElementBounds(overlay);
	        var scrollContainerBounds = this.scrollables.map(function (scrollable) {
	            return _this._getElementBounds(scrollable.getElementRef().nativeElement);
	        });
	        return {
	            isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),
	            isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),
	            isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),
	            isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),
	        };
	    };
	    /** Whether the element is completely out of the view of any of the containers. */
	    ConnectedPositionStrategy.prototype.isElementOutsideView = function (elementBounds, containersBounds) {
	        return containersBounds.some(function (containerBounds) {
	            var outsideAbove = elementBounds.bottom < containerBounds.top;
	            var outsideBelow = elementBounds.top > containerBounds.bottom;
	            var outsideLeft = elementBounds.right < containerBounds.left;
	            var outsideRight = elementBounds.left > containerBounds.right;
	            return outsideAbove || outsideBelow || outsideLeft || outsideRight;
	        });
	    };
	    /** Whether the element is clipped by any of the containers. */
	    ConnectedPositionStrategy.prototype.isElementClipped = function (elementBounds, containersBounds) {
	        return containersBounds.some(function (containerBounds) {
	            var clippedAbove = elementBounds.top < containerBounds.top;
	            var clippedBelow = elementBounds.bottom > containerBounds.bottom;
	            var clippedLeft = elementBounds.left < containerBounds.left;
	            var clippedRight = elementBounds.right > containerBounds.right;
	            return clippedAbove || clippedBelow || clippedLeft || clippedRight;
	        });
	    };
	    /**
	     * Physically positions the overlay element to the given coordinate.
	     * @param element
	     * @param overlayPoint
	     */
	    ConnectedPositionStrategy.prototype._setElementPosition = function (element, overlayPoint) {
	        element.style.left = overlayPoint.x + 'px';
	        element.style.top = overlayPoint.y + 'px';
	    };
	    /** Returns the bounding positions of the provided element with respect to the viewport. */
	    ConnectedPositionStrategy.prototype._getElementBounds = function (element) {
	        var boundingClientRect = element.getBoundingClientRect();
	        return {
	            top: boundingClientRect.top,
	            right: boundingClientRect.left + boundingClientRect.width,
	            bottom: boundingClientRect.top + boundingClientRect.height,
	            left: boundingClientRect.left
	        };
	    };
	    /**
	     * Subtracts the amount that an element is overflowing on an axis from it's length.
	     */
	    ConnectedPositionStrategy.prototype._subtractOverflows = function (length) {
	        var overflows = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            overflows[_i - 1] = arguments[_i];
	        }
	        return overflows.reduce(function (currentValue, currentOverflow) {
	            return currentValue - Math.max(currentOverflow, 0);
	        }, length);
	    };
	    return ConnectedPositionStrategy;
	}());
	
	/**
	 * A strategy for positioning overlays. Using this strategy, an overlay is given an
	 * explicit position relative to the browser's viewport. We use flexbox, instead of
	 * transforms, in order to avoid issues with subpixel rendering which can cause the
	 * element to become blurry.
	 */
	var GlobalPositionStrategy = (function () {
	    function GlobalPositionStrategy() {
	        this._cssPosition = 'static';
	        this._topOffset = '';
	        this._bottomOffset = '';
	        this._leftOffset = '';
	        this._rightOffset = '';
	        this._alignItems = '';
	        this._justifyContent = '';
	        this._width = '';
	        this._height = '';
	    }
	    /**
	     * Sets the top position of the overlay. Clears any previously set vertical position.
	     * @param value New top offset.
	     */
	    GlobalPositionStrategy.prototype.top = function (value) {
	        this._bottomOffset = '';
	        this._topOffset = value;
	        this._alignItems = 'flex-start';
	        return this;
	    };
	    /**
	     * Sets the left position of the overlay. Clears any previously set horizontal position.
	     * @param value New left offset.
	     */
	    GlobalPositionStrategy.prototype.left = function (value) {
	        this._rightOffset = '';
	        this._leftOffset = value;
	        this._justifyContent = 'flex-start';
	        return this;
	    };
	    /**
	     * Sets the bottom position of the overlay. Clears any previously set vertical position.
	     * @param value New bottom offset.
	     */
	    GlobalPositionStrategy.prototype.bottom = function (value) {
	        this._topOffset = '';
	        this._bottomOffset = value;
	        this._alignItems = 'flex-end';
	        return this;
	    };
	    /**
	     * Sets the right position of the overlay. Clears any previously set horizontal position.
	     * @param value New right offset.
	     */
	    GlobalPositionStrategy.prototype.right = function (value) {
	        this._leftOffset = '';
	        this._rightOffset = value;
	        this._justifyContent = 'flex-end';
	        return this;
	    };
	    /**
	     * Sets the overlay width and clears any previously set width.
	     * @param value New width for the overlay
	     */
	    GlobalPositionStrategy.prototype.width = function (value) {
	        this._width = value;
	        // When the width is 100%, we should reset the `left` and the offset,
	        // in order to ensure that the element is flush against the viewport edge.
	        if (value === '100%') {
	            this.left('0px');
	        }
	        return this;
	    };
	    /**
	     * Sets the overlay height and clears any previously set height.
	     * @param value New height for the overlay
	     */
	    GlobalPositionStrategy.prototype.height = function (value) {
	        this._height = value;
	        // When the height is 100%, we should reset the `top` and the offset,
	        // in order to ensure that the element is flush against the viewport edge.
	        if (value === '100%') {
	            this.top('0px');
	        }
	        return this;
	    };
	    /**
	     * Centers the overlay horizontally with an optional offset.
	     * Clears any previously set horizontal position.
	     *
	     * @param offset Overlay offset from the horizontal center.
	     */
	    GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {
	        if (offset === void 0) { offset = ''; }
	        this.left(offset);
	        this._justifyContent = 'center';
	        return this;
	    };
	    /**
	     * Centers the overlay vertically with an optional offset.
	     * Clears any previously set vertical position.
	     *
	     * @param offset Overlay offset from the vertical center.
	     */
	    GlobalPositionStrategy.prototype.centerVertically = function (offset) {
	        if (offset === void 0) { offset = ''; }
	        this.top(offset);
	        this._alignItems = 'center';
	        return this;
	    };
	    /**
	     * Apply the position to the element.
	     * @docs-private
	     *
	     * @param element Element to which to apply the CSS.
	     * @returns Resolved when the styles have been applied.
	     */
	    GlobalPositionStrategy.prototype.apply = function (element) {
	        if (!this._wrapper) {
	            this._wrapper = document.createElement('div');
	            this._wrapper.classList.add('cdk-global-overlay-wrapper');
	            element.parentNode.insertBefore(this._wrapper, element);
	            this._wrapper.appendChild(element);
	        }
	        var styles = element.style;
	        var parentStyles = element.parentNode.style;
	        styles.position = this._cssPosition;
	        styles.marginTop = this._topOffset;
	        styles.marginLeft = this._leftOffset;
	        styles.marginBottom = this._bottomOffset;
	        styles.marginRight = this._rightOffset;
	        styles.width = this._width;
	        styles.height = this._height;
	        parentStyles.justifyContent = this._justifyContent;
	        parentStyles.alignItems = this._alignItems;
	        return Promise.resolve(null);
	    };
	    /**
	     * Removes the wrapper element from the DOM.
	     */
	    GlobalPositionStrategy.prototype.dispose = function () {
	        if (this._wrapper && this._wrapper.parentNode) {
	            this._wrapper.parentNode.removeChild(this._wrapper);
	            this._wrapper = null;
	        }
	    };
	    return GlobalPositionStrategy;
	}());
	
	var __decorate$12 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$12 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Builder for overlay position strategy. */
	var OverlayPositionBuilder = (function () {
	    function OverlayPositionBuilder(_viewportRuler) {
	        this._viewportRuler = _viewportRuler;
	    }
	    /**
	     * Creates a global position strategy.
	     */
	    OverlayPositionBuilder.prototype.global = function () {
	        return new GlobalPositionStrategy();
	    };
	    /**
	     * Creates a relative position strategy.
	     * @param elementRef
	     * @param originPos
	     * @param overlayPos
	     */
	    OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {
	        return new ConnectedPositionStrategy(elementRef, originPos, overlayPos, this._viewportRuler);
	    };
	    OverlayPositionBuilder = __decorate$12([
	        _angular_core.Injectable(), 
	        __metadata$12('design:paramtypes', [ViewportRuler])
	    ], OverlayPositionBuilder);
	    return OverlayPositionBuilder;
	}());
	
	var __decorate$14 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$14 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * The OverlayContainer is the container in which all overlays will load.
	 * It should be provided in the root component to ensure it is properly shared.
	 */
	var OverlayContainer = (function () {
	    function OverlayContainer() {
	    }
	    /**
	     * This method returns the overlay container element.  It will lazily
	     * create the element the first time  it is called to facilitate using
	     * the container in non-browser environments.
	     * @returns the container element
	     */
	    OverlayContainer.prototype.getContainerElement = function () {
	        if (!this._containerElement) {
	            this._createContainer();
	        }
	        return this._containerElement;
	    };
	    /**
	     * Create the overlay container element, which is simply a div
	     * with the 'cdk-overlay-container' class on the document body.
	     */
	    OverlayContainer.prototype._createContainer = function () {
	        var container = document.createElement('div');
	        container.classList.add('cdk-overlay-container');
	        document.body.appendChild(container);
	        this._containerElement = container;
	    };
	    OverlayContainer = __decorate$14([
	        _angular_core.Injectable(), 
	        __metadata$14('design:paramtypes', [])
	    ], OverlayContainer);
	    return OverlayContainer;
	}());
	function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer) {
	    return parentContainer || new OverlayContainer();
	}
	
	var OVERLAY_CONTAINER_PROVIDER = {
	    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
	    provide: OverlayContainer,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), OverlayContainer]],
	    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY
	};
	
	var __decorate$11 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$11 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Next overlay unique ID. */
	var nextUniqueId = 0;
	/** The default state for newly created overlays. */
	var defaultState = new OverlayState();
	/**
	 * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
	 * used as a low-level building building block for other components. Dialogs, tooltips, menus,
	 * selects, etc. can all be built using overlays. The service should primarily be used by authors
	 * of re-usable components rather than developers building end-user applications.
	 *
	 * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.
	 */
	var Overlay = (function () {
	    function Overlay(_overlayContainer, _componentFactoryResolver, _positionBuilder, _appRef, _injector, _ngZone) {
	        this._overlayContainer = _overlayContainer;
	        this._componentFactoryResolver = _componentFactoryResolver;
	        this._positionBuilder = _positionBuilder;
	        this._appRef = _appRef;
	        this._injector = _injector;
	        this._ngZone = _ngZone;
	    }
	    /**
	     * Creates an overlay.
	     * @param state State to apply to the overlay.
	     * @returns Reference to the created overlay.
	     */
	    Overlay.prototype.create = function (state$$1) {
	        if (state$$1 === void 0) { state$$1 = defaultState; }
	        return this._createOverlayRef(this._createPaneElement(), state$$1);
	    };
	    /**
	     * Returns a position builder that can be used, via fluent API,
	     * to construct and configure a position strategy.
	     */
	    Overlay.prototype.position = function () {
	        return this._positionBuilder;
	    };
	    /**
	     * Creates the DOM element for an overlay and appends it to the overlay container.
	     * @returns Newly-created pane element
	     */
	    Overlay.prototype._createPaneElement = function () {
	        var pane = document.createElement('div');
	        pane.id = "cdk-overlay-" + nextUniqueId++;
	        pane.classList.add('cdk-overlay-pane');
	        this._overlayContainer.getContainerElement().appendChild(pane);
	        return pane;
	    };
	    /**
	     * Create a DomPortalHost into which the overlay content can be loaded.
	     * @param pane The DOM element to turn into a portal host.
	     * @returns A portal host for the given DOM element.
	     */
	    Overlay.prototype._createPortalHost = function (pane) {
	        return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef, this._injector);
	    };
	    /**
	     * Creates an OverlayRef for an overlay in the given DOM element.
	     * @param pane DOM element for the overlay
	     * @param state
	     */
	    Overlay.prototype._createOverlayRef = function (pane, state$$1) {
	        return new OverlayRef(this._createPortalHost(pane), pane, state$$1, this._ngZone);
	    };
	    Overlay = __decorate$11([
	        _angular_core.Injectable(), 
	        __metadata$11('design:paramtypes', [OverlayContainer, _angular_core.ComponentFactoryResolver, OverlayPositionBuilder, _angular_core.ApplicationRef, _angular_core.Injector, _angular_core.NgZone])
	    ], Overlay);
	    return Overlay;
	}());
	/** Providers for Overlay and its related injectables. */
	var OVERLAY_PROVIDERS = [
	    Overlay,
	    OverlayPositionBuilder,
	    VIEWPORT_RULER_PROVIDER,
	    SCROLL_DISPATCHER_PROVIDER,
	    OVERLAY_CONTAINER_PROVIDER,
	];
	
	var __decorate$15 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$15 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Sends an event when the directive's element is scrolled. Registers itself with the
	 * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
	 * can be listened to through the service.
	 */
	var Scrollable = (function () {
	    function Scrollable(_elementRef, _scroll) {
	        this._elementRef = _elementRef;
	        this._scroll = _scroll;
	    }
	    Scrollable.prototype.ngOnInit = function () {
	        this._scroll.register(this);
	    };
	    Scrollable.prototype.ngOnDestroy = function () {
	        this._scroll.deregister(this);
	    };
	    /**
	     * Returns observable that emits when a scroll event is fired on the host element.
	     */
	    Scrollable.prototype.elementScrolled = function () {
	        return rxjs_Observable.Observable.fromEvent(this._elementRef.nativeElement, 'scroll');
	    };
	    Scrollable.prototype.getElementRef = function () {
	        return this._elementRef;
	    };
	    Scrollable = __decorate$15([
	        _angular_core.Directive({
	            selector: '[cdk-scrollable]'
	        }), 
	        __metadata$15('design:paramtypes', [_angular_core.ElementRef, ScrollDispatcher])
	    ], Scrollable);
	    return Scrollable;
	}());
	
	var __decorate$10 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$10 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** Default set of positions for the overlay. Follows the behavior of a dropdown. */
	var defaultPositionList = [
	    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
	    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
	];
	/**
	 * Directive applied to an element to make it usable as an origin for an Overlay using a
	 * ConnectedPositionStrategy.
	 */
	var OverlayOrigin = (function () {
	    function OverlayOrigin(elementRef) {
	        this.elementRef = elementRef;
	    }
	    OverlayOrigin = __decorate$10([
	        _angular_core.Directive({
	            selector: '[cdk-overlay-origin], [overlay-origin]',
	            exportAs: 'cdkOverlayOrigin',
	        }), 
	        __metadata$10('design:paramtypes', [_angular_core.ElementRef])
	    ], OverlayOrigin);
	    return OverlayOrigin;
	}());
	/**
	 * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.
	 */
	var ConnectedOverlayDirective = (function () {
	    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
	    function ConnectedOverlayDirective(_overlay, templateRef, viewContainerRef, _dir) {
	        this._overlay = _overlay;
	        this._dir = _dir;
	        this._open = false;
	        this._hasBackdrop = false;
	        this._offsetX = 0;
	        this._offsetY = 0;
	        /** Event emitted when the backdrop is clicked. */
	        this.backdropClick = new _angular_core.EventEmitter();
	        /** Event emitted when the position has changed. */
	        this.positionChange = new _angular_core.EventEmitter();
	        /** Event emitted when the overlay has been attached. */
	        this.attach = new _angular_core.EventEmitter();
	        /** Event emitted when the overlay has been detached. */
	        this.detach = new _angular_core.EventEmitter();
	        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
	    }
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetX", {
	        /** The offset in pixels for the overlay connection point on the x-axis */
	        get: function () {
	            return this._offsetX;
	        },
	        set: function (offsetX) {
	            this._offsetX = offsetX;
	            if (this._position) {
	                this._position.withOffsetX(offsetX);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "offsetY", {
	        /** The offset in pixels for the overlay connection point on the y-axis */
	        get: function () {
	            return this._offsetY;
	        },
	        set: function (offsetY) {
	            this._offsetY = offsetY;
	            if (this._position) {
	                this._position.withOffsetY(offsetY);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "hasBackdrop", {
	        /** Whether or not the overlay should attach a backdrop. */
	        get: function () {
	            return this._hasBackdrop;
	        },
	        set: function (value) {
	            this._hasBackdrop = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "open", {
	        get: function () {
	            return this._open;
	        },
	        set: function (value) {
	            value ? this._attachOverlay() : this._detachOverlay();
	            this._open = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "overlayRef", {
	        /** The associated overlay reference. */
	        get: function () {
	            return this._overlayRef;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ConnectedOverlayDirective.prototype, "dir", {
	        /** The element's layout direction. */
	        get: function () {
	            return this._dir ? this._dir.value : 'ltr';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {
	        this._destroyOverlay();
	    };
	    /** Creates an overlay */
	    ConnectedOverlayDirective.prototype._createOverlay = function () {
	        if (!this.positions || !this.positions.length) {
	            this.positions = defaultPositionList;
	        }
	        this._overlayRef = this._overlay.create(this._buildConfig());
	    };
	    /** Builds the overlay config based on the directive's inputs */
	    ConnectedOverlayDirective.prototype._buildConfig = function () {
	        var overlayConfig = new OverlayState();
	        if (this.width || this.width === 0) {
	            overlayConfig.width = this.width;
	        }
	        if (this.height || this.height === 0) {
	            overlayConfig.height = this.height;
	        }
	        if (this.minWidth || this.minWidth === 0) {
	            overlayConfig.minWidth = this.minWidth;
	        }
	        if (this.minHeight || this.minHeight === 0) {
	            overlayConfig.minHeight = this.minHeight;
	        }
	        overlayConfig.hasBackdrop = this.hasBackdrop;
	        if (this.backdropClass) {
	            overlayConfig.backdropClass = this.backdropClass;
	        }
	        this._position = this._createPositionStrategy();
	        overlayConfig.positionStrategy = this._position;
	        overlayConfig.direction = this.dir;
	        return overlayConfig;
	    };
	    /** Returns the position strategy of the overlay to be set on the overlay config */
	    ConnectedOverlayDirective.prototype._createPositionStrategy = function () {
	        var pos = this.positions[0];
	        var originPoint = { originX: pos.originX, originY: pos.originY };
	        var overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };
	        var strategy = this._overlay.position()
	            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)
	            .withDirection(this.dir)
	            .withOffsetX(this.offsetX)
	            .withOffsetY(this.offsetY);
	        this._handlePositionChanges(strategy);
	        return strategy;
	    };
	    ConnectedOverlayDirective.prototype._handlePositionChanges = function (strategy) {
	        var _this = this;
	        for (var i = 1; i < this.positions.length; i++) {
	            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });
	        }
	        this._positionSubscription =
	            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });
	    };
	    /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
	    ConnectedOverlayDirective.prototype._attachOverlay = function () {
	        var _this = this;
	        if (!this._overlayRef) {
	            this._createOverlay();
	        }
	        if (!this._overlayRef.hasAttached()) {
	            this._overlayRef.attach(this._templatePortal);
	            this.attach.emit();
	        }
	        if (this.hasBackdrop) {
	            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
	                _this.backdropClick.emit();
	            });
	        }
	    };
	    /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
	    ConnectedOverlayDirective.prototype._detachOverlay = function () {
	        if (this._overlayRef) {
	            this._overlayRef.detach();
	            this.detach.emit();
	        }
	        if (this._backdropSubscription) {
	            this._backdropSubscription.unsubscribe();
	            this._backdropSubscription = null;
	        }
	    };
	    /** Destroys the overlay created by this directive. */
	    ConnectedOverlayDirective.prototype._destroyOverlay = function () {
	        if (this._overlayRef) {
	            this._overlayRef.dispose();
	        }
	        if (this._backdropSubscription) {
	            this._backdropSubscription.unsubscribe();
	        }
	        if (this._positionSubscription) {
	            this._positionSubscription.unsubscribe();
	        }
	    };
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', OverlayOrigin)
	    ], ConnectedOverlayDirective.prototype, "origin", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Array)
	    ], ConnectedOverlayDirective.prototype, "positions", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Number)
	    ], ConnectedOverlayDirective.prototype, "offsetX", null);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "offsetY", null);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "width", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "height", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "minWidth", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "minHeight", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', String)
	    ], ConnectedOverlayDirective.prototype, "backdropClass", void 0);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "hasBackdrop", null);
	    __decorate$10([
	        _angular_core.Input(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "open", null);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "backdropClick", void 0);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "positionChange", void 0);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "attach", void 0);
	    __decorate$10([
	        _angular_core.Output(), 
	        __metadata$10('design:type', Object)
	    ], ConnectedOverlayDirective.prototype, "detach", void 0);
	    ConnectedOverlayDirective = __decorate$10([
	        _angular_core.Directive({
	            selector: '[cdk-connected-overlay], [connected-overlay]',
	            exportAs: 'cdkConnectedOverlay'
	        }),
	        __param$1(3, _angular_core.Optional()), 
	        __metadata$10('design:paramtypes', [Overlay, _angular_core.TemplateRef, _angular_core.ViewContainerRef, Dir])
	    ], ConnectedOverlayDirective);
	    return ConnectedOverlayDirective;
	}());
	var OverlayModule = (function () {
	    function OverlayModule() {
	    }
	    /** @deprecated */
	    OverlayModule.forRoot = function () {
	        return {
	            ngModule: OverlayModule,
	            providers: [],
	        };
	    };
	    OverlayModule = __decorate$10([
	        _angular_core.NgModule({
	            imports: [PortalModule],
	            exports: [ConnectedOverlayDirective, OverlayOrigin, Scrollable],
	            declarations: [ConnectedOverlayDirective, OverlayOrigin, Scrollable],
	            providers: [OVERLAY_PROVIDERS],
	        }), 
	        __metadata$10('design:paramtypes', [])
	    ], OverlayModule);
	    return OverlayModule;
	}());
	
	var __decorate$19 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$19 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Whether the current platform supports the V8 Break Iterator. The V8 check
	// is necessary to detect all Blink based browsers.
	var hasV8BreakIterator = typeof (window) !== 'undefined' ?
	    (window.Intl && window.Intl.v8BreakIterator) :
	    (typeof (Intl) !== 'undefined' && Intl.v8BreakIterator);
	/**
	 * Service to detect the current platform by comparing the userAgent strings and
	 * checking browser-specific global properties.
	 * @docs-private
	 */
	var Platform = (function () {
	    function Platform() {
	        /** Layout Engines */
	        this.EDGE = /(edge)/i.test(navigator.userAgent);
	        this.TRIDENT = /(msie|trident)/i.test(navigator.userAgent);
	        // EdgeHTML and Trident mock Blink specific things and need to excluded from this check.
	        this.BLINK = !!(window.chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT;
	        // Webkit is part of the userAgent in EdgeHTML Blink and Trident, so we need to
	        // ensure that Webkit runs standalone and is not use as another engines base.
	        this.WEBKIT = /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
	        /** Browsers and Platform Types */
	        this.IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
	        // It's difficult to detect the plain Gecko engine, because most of the browsers identify
	        // them self as Gecko-like browsers and modify the userAgent's according to that.
	        // Since we only cover one explicit Firefox case, we can simply check for Firefox
	        // instead of having an unstable check for Gecko.
	        this.FIREFOX = /(firefox|minefield)/i.test(navigator.userAgent);
	        // Trident on mobile adds the android platform to the userAgent to trick detections.
	        this.ANDROID = /android/i.test(navigator.userAgent) && !this.TRIDENT;
	    }
	    Platform = __decorate$19([
	        _angular_core.Injectable(), 
	        __metadata$19('design:paramtypes', [])
	    ], Platform);
	    return Platform;
	}());
	
	var __decorate$18 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$18 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * The InteractivityChecker leans heavily on the ally.js accessibility utilities.
	 * Methods like `isTabbable` are only covering specific edge-cases for the browsers which are
	 * supported.
	 */
	/**
	 * Utility for checking the interactivity of an element, such as whether is is focusable or
	 * tabbable.
	 */
	var InteractivityChecker = (function () {
	    function InteractivityChecker(_platform) {
	        this._platform = _platform;
	    }
	    /**
	     * Gets whether an element is disabled.
	     *
	     * @param element Element to be checked.
	     * @returns Whether the element is disabled.
	     */
	    InteractivityChecker.prototype.isDisabled = function (element) {
	        // This does not capture some cases, such as a non-form control with a disabled attribute or
	        // a form control inside of a disabled form, but should capture the most common cases.
	        return element.hasAttribute('disabled');
	    };
	    /**
	     * Gets whether an element is visible for the purposes of interactivity.
	     *
	     * This will capture states like `display: none` and `visibility: hidden`, but not things like
	     * being clipped by an `overflow: hidden` parent or being outside the viewport.
	     *
	     * @returns Whether the element is visible.
	     */
	    InteractivityChecker.prototype.isVisible = function (element) {
	        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';
	    };
	    /**
	     * Gets whether an element can be reached via Tab key.
	     * Assumes that the element has already been checked with isFocusable.
	     *
	     * @param element Element to be checked.
	     * @returns Whether the element is tabbable.
	     */
	    InteractivityChecker.prototype.isTabbable = function (element) {
	        var frameElement = getWindow(element).frameElement;
	        if (frameElement) {
	            var frameType = frameElement && frameElement.nodeName.toLowerCase();
	            // Frame elements inherit their tabindex onto all child elements.
	            if (getTabIndexValue(frameElement) === -1) {
	                return false;
	            }
	            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.
	            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {
	                return false;
	            }
	            // Webkit and Blink disable tabbing to an element inside of an invisible frame.
	            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {
	                return false;
	            }
	        }
	        var nodeName = element.nodeName.toLowerCase();
	        var tabIndexValue = getTabIndexValue(element);
	        if (element.hasAttribute('contenteditable')) {
	            return tabIndexValue !== -1;
	        }
	        if (nodeName === 'iframe') {
	            // The frames may be tabbable depending on content, but it's not possibly to reliably
	            // investigate the content of the frames.
	            return false;
	        }
	        if (nodeName === 'audio') {
	            if (!element.hasAttribute('controls')) {
	                // By default an <audio> element without the controls enabled is not tabbable.
	                return false;
	            }
	            else if (this._platform.BLINK) {
	                // In Blink <audio controls> elements are always tabbable.
	                return true;
	            }
	        }
	        if (nodeName === 'video') {
	            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {
	                // In Trident a <video> element without the controls enabled is not tabbable.
	                return false;
	            }
	            else if (this._platform.BLINK || this._platform.FIREFOX) {
	                // In Chrome and Firefox <video controls> elements are always tabbable.
	                return true;
	            }
	        }
	        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {
	            // In all Blink and WebKit based browsers <object> elements are never tabbable.
	            return false;
	        }
	        // In iOS the browser only considers some specific elements as tabbable.
	        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
	            return false;
	        }
	        return element.tabIndex >= 0;
	    };
	    /**
	     * Gets whether an element can be focused by the user.
	     *
	     * @param element Element to be checked.
	     * @returns Whether the element is focusable.
	     */
	    InteractivityChecker.prototype.isFocusable = function (element) {
	        // Perform checks in order of left to most expensive.
	        // Again, naive approach that does not capture many edge cases and browser quirks.
	        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);
	    };
	    InteractivityChecker = __decorate$18([
	        _angular_core.Injectable(), 
	        __metadata$18('design:paramtypes', [Platform])
	    ], InteractivityChecker);
	    return InteractivityChecker;
	}());
	/** Checks whether the specified element has any geometry / rectangles. */
	function hasGeometry(element) {
	    // Use logic from jQuery to check for an invisible element.
	    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12
	    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
	}
	/** Gets whether an element's  */
	function isNativeFormElement(element) {
	    var nodeName = element.nodeName.toLowerCase();
	    return nodeName === 'input' ||
	        nodeName === 'select' ||
	        nodeName === 'button' ||
	        nodeName === 'textarea';
	}
	/** Gets whether an element is an <input type="hidden">. */
	function isHiddenInput(element) {
	    return isInputElement(element) && element.type == 'hidden';
	}
	/** Gets whether an element is an anchor that has an href attribute. */
	function isAnchorWithHref(element) {
	    return isAnchorElement(element) && element.hasAttribute('href');
	}
	/** Gets whether an element is an input element. */
	function isInputElement(element) {
	    return element.nodeName == 'input';
	}
	/** Gets whether an element is an anchor element. */
	function isAnchorElement(element) {
	    return element.nodeName.toLowerCase() == 'a';
	}
	/** Gets whether an element has a valid tabindex. */
	function hasValidTabIndex(element) {
	    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {
	        return false;
	    }
	    var tabIndex = element.getAttribute('tabindex');
	    // IE11 parses tabindex="" as the value "-32768"
	    if (tabIndex == '-32768') {
	        return false;
	    }
	    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
	}
	/**
	 * Returns the parsed tabindex from the element attributes instead of returning the
	 * evaluated tabindex from the browsers defaults.
	 */
	function getTabIndexValue(element) {
	    if (!hasValidTabIndex(element)) {
	        return null;
	    }
	    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
	    var tabIndex = parseInt(element.getAttribute('tabindex'), 10);
	    return isNaN(tabIndex) ? -1 : tabIndex;
	}
	/** Checks whether the specified element is potentially tabbable on iOS */
	function isPotentiallyTabbableIOS(element) {
	    var nodeName = element.nodeName.toLowerCase();
	    var inputType = nodeName === 'input' && element.type;
	    return inputType === 'text'
	        || inputType === 'password'
	        || nodeName === 'select'
	        || nodeName === 'textarea';
	}
	/**
	 * Gets whether an element is potentially focusable without taking current visible/disabled state
	 * into account.
	 */
	function isPotentiallyFocusable(element) {
	    // Inputs are potentially focusable *unless* they're type="hidden".
	    if (isHiddenInput(element)) {
	        return false;
	    }
	    return isNativeFormElement(element) ||
	        isAnchorWithHref(element) ||
	        element.hasAttribute('contenteditable') ||
	        hasValidTabIndex(element);
	}
	/** Gets the parent window of a DOM node with regards of being inside of an iframe. */
	function getWindow(node) {
	    return node.ownerDocument.defaultView || window;
	}
	
	var __decorate$17 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$17 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive for trapping focus within a region.
	 *
	 * NOTE: This directive currently uses a very simple (naive) approach to focus trapping.
	 * It assumes that the tab order is the same as DOM order, which is not necessarily true.
	 * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.
	 * This will be replaced with a more intelligent solution before the library is considered stable.
	 */
	var FocusTrap = (function () {
	    function FocusTrap(_checker, _ngZone) {
	        this._checker = _checker;
	        this._ngZone = _ngZone;
	        this._disabled = false;
	    }
	    Object.defineProperty(FocusTrap.prototype, "disabled", {
	        /** Whether the focus trap is active. */
	        get: function () { return this._disabled; },
	        set: function (val) { this._disabled = coerceBooleanProperty(val); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Waits for microtask queue to empty, then focuses the first tabbable element within the focus
	     * trap region.
	     */
	    FocusTrap.prototype.focusFirstTabbableElementWhenReady = function () {
	        var _this = this;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this.focusFirstTabbableElement();
	        });
	    };
	    /**
	     * Waits for microtask queue to empty, then focuses the last tabbable element within the focus
	     * trap region.
	     */
	    FocusTrap.prototype.focusLastTabbableElementWhenReady = function () {
	        var _this = this;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this.focusLastTabbableElement();
	        });
	    };
	    /**
	     * Focuses the first tabbable element within the focus trap region.
	     */
	    FocusTrap.prototype.focusFirstTabbableElement = function () {
	        var rootElement = this.trappedContent.nativeElement;
	        var redirectToElement = rootElement.querySelector('[cdk-focus-start]') ||
	            this._getFirstTabbableElement(rootElement);
	        if (redirectToElement) {
	            redirectToElement.focus();
	        }
	    };
	    /**
	     * Focuses the last tabbable element within the focus trap region.
	     */
	    FocusTrap.prototype.focusLastTabbableElement = function () {
	        var rootElement = this.trappedContent.nativeElement;
	        var focusTargets = rootElement.querySelectorAll('[cdk-focus-end]');
	        var redirectToElement = null;
	        if (focusTargets.length) {
	            redirectToElement = focusTargets[focusTargets.length - 1];
	        }
	        else {
	            redirectToElement = this._getLastTabbableElement(rootElement);
	        }
	        if (redirectToElement) {
	            redirectToElement.focus();
	        }
	    };
	    /** Get the first tabbable element from a DOM subtree (inclusive). */
	    FocusTrap.prototype._getFirstTabbableElement = function (root) {
	        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
	            return root;
	        }
	        // Iterate in DOM order.
	        var childCount = root.children.length;
	        for (var i = 0; i < childCount; i++) {
	            var tabbableChild = this._getFirstTabbableElement(root.children[i]);
	            if (tabbableChild) {
	                return tabbableChild;
	            }
	        }
	        return null;
	    };
	    /** Get the last tabbable element from a DOM subtree (inclusive). */
	    FocusTrap.prototype._getLastTabbableElement = function (root) {
	        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
	            return root;
	        }
	        // Iterate in reverse DOM order.
	        for (var i = root.children.length - 1; i >= 0; i--) {
	            var tabbableChild = this._getLastTabbableElement(root.children[i]);
	            if (tabbableChild) {
	                return tabbableChild;
	            }
	        }
	        return null;
	    };
	    __decorate$17([
	        _angular_core.ViewChild('trappedContent'), 
	        __metadata$17('design:type', _angular_core.ElementRef)
	    ], FocusTrap.prototype, "trappedContent", void 0);
	    __decorate$17([
	        _angular_core.Input(), 
	        __metadata$17('design:type', Boolean)
	    ], FocusTrap.prototype, "disabled", null);
	    FocusTrap = __decorate$17([
	        _angular_core.Component({selector: 'cdk-focus-trap, focus-trap',
	            template: "<div *ngIf=\"!disabled\" tabindex=\"0\" (focus)=\"focusLastTabbableElement()\"></div><div #trappedContent class=\"cdk-focus-trap-content\"><ng-content></ng-content></div><div *ngIf=\"!disabled\" tabindex=\"0\" (focus)=\"focusFirstTabbableElement()\"></div>",
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$17('design:paramtypes', [InteractivityChecker, _angular_core.NgZone])
	    ], FocusTrap);
	    return FocusTrap;
	}());
	
	var __decorate$20 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$20 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$3 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var LIVE_ANNOUNCER_ELEMENT_TOKEN = new _angular_core.OpaqueToken('liveAnnouncerElement');
	var LiveAnnouncer = (function () {
	    function LiveAnnouncer(elementToken) {
	        // We inject the live element as `any` because the constructor signature cannot reference
	        // browser globals (HTMLElement) on non-browser environments, since having a class decorator
	        // causes TypeScript to preserve the constructor signature types.
	        this._liveElement = elementToken || this._createLiveElement();
	    }
	    /**
	     * Announces a message to screenreaders.
	     * @param message Message to be announced to the screenreader
	     * @param politeness The politeness of the announcer element
	     */
	    LiveAnnouncer.prototype.announce = function (message, politeness) {
	        var _this = this;
	        if (politeness === void 0) { politeness = 'polite'; }
	        this._liveElement.textContent = '';
	        // TODO: ensure changing the politeness works on all environments we support.
	        this._liveElement.setAttribute('aria-live', politeness);
	        // This 100ms timeout is necessary for some browser + screen-reader combinations:
	        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
	        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
	        //   second time without clearing and then using a non-zero delay.
	        // (using JAWS 17 at time of this writing).
	        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);
	    };
	    /** Removes the aria-live element from the DOM. */
	    LiveAnnouncer.prototype._removeLiveElement = function () {
	        if (this._liveElement && this._liveElement.parentNode) {
	            this._liveElement.parentNode.removeChild(this._liveElement);
	        }
	    };
	    LiveAnnouncer.prototype._createLiveElement = function () {
	        var liveEl = document.createElement('div');
	        liveEl.classList.add('cdk-visually-hidden');
	        liveEl.setAttribute('aria-atomic', 'true');
	        liveEl.setAttribute('aria-live', 'polite');
	        document.body.appendChild(liveEl);
	        return liveEl;
	    };
	    LiveAnnouncer = __decorate$20([
	        _angular_core.Injectable(),
	        __param$3(0, _angular_core.Optional()),
	        __param$3(0, _angular_core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)), 
	        __metadata$20('design:paramtypes', [Object])
	    ], LiveAnnouncer);
	    return LiveAnnouncer;
	}());
	function LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement) {
	    return parentDispatcher || new LiveAnnouncer(liveElement);
	}
	
	var LIVE_ANNOUNCER_PROVIDER = {
	    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.
	    provide: LiveAnnouncer,
	    deps: [
	        [new _angular_core.Optional(), new _angular_core.SkipSelf(), LiveAnnouncer],
	        [new _angular_core.Optional(), new _angular_core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)]
	    ],
	    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY
	};
	
	var supportedInputTypes;
	/** @returns The input types supported by this browser. */
	function getSupportedInputTypes() {
	    if (!supportedInputTypes) {
	        var featureTestInput_1 = document.createElement('input');
	        supportedInputTypes = new Set([
	            // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after
	            // first changing it to something else:
	            // The specified value "" does not conform to the required format.
	            // The format is "#rrggbb" where rr, gg, bb are two-digit hexadecimal numbers.
	            'color',
	            'button',
	            'checkbox',
	            'date',
	            'datetime-local',
	            'email',
	            'file',
	            'hidden',
	            'image',
	            'month',
	            'number',
	            'password',
	            'radio',
	            'range',
	            'reset',
	            'search',
	            'submit',
	            'tel',
	            'text',
	            'time',
	            'url',
	            'week',
	        ].filter(function (value) {
	            featureTestInput_1.setAttribute('type', value);
	            return featureTestInput_1.type === value;
	        }));
	    }
	    return supportedInputTypes;
	}
	
	var __decorate$21 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$21 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var PlatformModule = (function () {
	    function PlatformModule() {
	    }
	    /** @deprecated */
	    PlatformModule.forRoot = function () {
	        return {
	            ngModule: PlatformModule,
	            providers: [],
	        };
	    };
	    PlatformModule = __decorate$21([
	        _angular_core.NgModule({
	            providers: [Platform]
	        }), 
	        __metadata$21('design:paramtypes', [])
	    ], PlatformModule);
	    return PlatformModule;
	}());
	
	var __decorate$16 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$16 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var A11yModule = (function () {
	    function A11yModule() {
	    }
	    /** @deprecated */
	    A11yModule.forRoot = function () {
	        return {
	            ngModule: A11yModule,
	            providers: [],
	        };
	    };
	    A11yModule = __decorate$16([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, PlatformModule],
	            declarations: [FocusTrap],
	            exports: [FocusTrap],
	            providers: [InteractivityChecker, LIVE_ANNOUNCER_PROVIDER]
	        }), 
	        __metadata$16('design:paramtypes', [])
	    ], A11yModule);
	    return A11yModule;
	}());
	
	var __decorate$23 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$23 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Component that shows a simplified checkbox without including any kind of "real" checkbox.
	 * Meant to be used when the checkbox is purely decorative and a large number of them will be
	 * included, such as for the options in a multi-select. Uses no SVGs or complex animations.
	 *
	 * Note that this component will be completely invisible to screen-reader users. This is *not*
	 * interchangeable with <md-checkbox> and should *not* be used if the user would directly interact
	 * with the checkbox. The pseudo-checkbox should only be used as an implementation detail of
	 * more complex components that appropriately handle selected / checked state.
	 * @docs-private
	 */
	var MdPseudoCheckbox = (function () {
	    function MdPseudoCheckbox(_elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** Display state of the checkbox. */
	        this.state = 'unchecked';
	        /** Whether the checkbox is disabled. */
	        this.disabled = false;
	        this.color = 'accent';
	    }
	    Object.defineProperty(MdPseudoCheckbox.prototype, "color", {
	        /** Color of the checkbox. */
	        get: function () { return this._color; },
	        set: function (value) {
	            if (value) {
	                var nativeElement = this._elementRef.nativeElement;
	                this._renderer.setElementClass(nativeElement, "mat-" + this.color, false);
	                this._renderer.setElementClass(nativeElement, "mat-" + value, true);
	                this._color = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    
	    __decorate$23([
	        _angular_core.Input(), 
	        __metadata$23('design:type', String)
	    ], MdPseudoCheckbox.prototype, "state", void 0);
	    __decorate$23([
	        _angular_core.Input(), 
	        __metadata$23('design:type', Boolean)
	    ], MdPseudoCheckbox.prototype, "disabled", void 0);
	    __decorate$23([
	        _angular_core.Input(), 
	        __metadata$23('design:type', String)
	    ], MdPseudoCheckbox.prototype, "color", null);
	    MdPseudoCheckbox = __decorate$23([
	        _angular_core.Component({encapsulation: _angular_core.ViewEncapsulation.None,
	            selector: 'md-pseudo-checkbox, mat-pseudo-checkbox',
	            styles: [".mat-pseudo-checkbox{width:20px;height:20px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;transition:border-color 90ms cubic-bezier(0,0,.2,.1),background-color 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:'';border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:9px;left:2px;width:16px;opacity:1}.mat-pseudo-checkbox-checked::after{top:5px;left:3px;width:12px;height:5px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1}"],
	            template: '',
	            host: {
	                '[class.mat-pseudo-checkbox]': 'true',
	                '[class.mat-pseudo-checkbox-indeterminate]': 'state === "indeterminate"',
	                '[class.mat-pseudo-checkbox-checked]': 'state === "checked"',
	                '[class.mat-pseudo-checkbox-disabled]': 'disabled',
	            },
	        }), 
	        __metadata$23('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdPseudoCheckbox);
	    return MdPseudoCheckbox;
	}());
	
	var __decorate$22 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$22 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdSelectionModule = (function () {
	    function MdSelectionModule() {
	    }
	    MdSelectionModule = __decorate$22([
	        _angular_core.NgModule({
	            exports: [MdPseudoCheckbox],
	            declarations: [MdPseudoCheckbox]
	        }), 
	        __metadata$22('design:paramtypes', [])
	    ], MdSelectionModule);
	    return MdSelectionModule;
	}());
	
	var __decorate$24 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$24 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// "Polyfill" for `Node.replaceWith()`.
	// cf. https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/replaceWith
	function _replaceWith(toReplaceEl, otherEl) {
	    toReplaceEl.parentElement.replaceChild(otherEl, toReplaceEl);
	}
	/** @docs-private */
	var DomProjectionHost = (function () {
	    function DomProjectionHost(ref) {
	        this.ref = ref;
	    }
	    DomProjectionHost = __decorate$24([
	        _angular_core.Directive({
	            selector: 'cdk-dom-projection-host'
	        }), 
	        __metadata$24('design:paramtypes', [_angular_core.ElementRef])
	    ], DomProjectionHost);
	    return DomProjectionHost;
	}());
	/** @docs-private */
	var DomProjection = (function () {
	    function DomProjection() {
	    }
	    /**
	     * Project an element into a host element.
	     * Replace a host element by another element. This also replaces the children of the element
	     * by the children of the host.
	     *
	     * It should be used like this:
	     *
	     * ```
	     *   @Component({
	     *     template: `<div>
	     *       <cdk-dom-projection-host>
	     *         <div>other</div>
	     *         <ng-content></ng-content>
	     *       </cdk-dom-projection-host>
	     *     </div>`
	     *   })
	     *   class Cmpt {
	     *     constructor(private _projector: DomProjection, private _el: ElementRef) {}
	     *     ngOnInit() { this._projector.project(this._el, this._projector); }
	     *   }
	     * ```
	     *
	     * This component will move the content of the element it's applied to in the outer div. Because
	     * `project()` also move the children of the host inside the projected element, the element will
	     * contain the `<div>other</div>` HTML as well as its own children.
	     *
	     * Note: without `<ng-content></ng-content>` the projection will project an empty element.
	     *
	     * @param ref ElementRef to be projected.
	     * @param host Projection host into which to project the `ElementRef`.
	     */
	    DomProjection.prototype.project = function (ref, host) {
	        var projectedEl = ref.nativeElement;
	        var hostEl = host.ref.nativeElement;
	        var childNodes = projectedEl.childNodes;
	        var child = childNodes[0];
	        // We hoist all of the projected element's children out into the projected elements position
	        // because we *only* want to move the projected element and not its children.
	        _replaceWith(projectedEl, child);
	        var l = childNodes.length;
	        while (l--) {
	            child.parentNode.insertBefore(childNodes[0], child.nextSibling);
	            child = child.nextSibling; // nextSibling is now the childNodes[0].
	        }
	        // Insert all host children under the projectedEl, then replace host by component.
	        l = hostEl.childNodes.length;
	        while (l--) {
	            projectedEl.appendChild(hostEl.childNodes[0]);
	        }
	        _replaceWith(hostEl, projectedEl);
	        // At this point the host is replaced by the component. Nothing else to be done.
	    };
	    DomProjection = __decorate$24([
	        _angular_core.Injectable(), 
	        __metadata$24('design:paramtypes', [])
	    ], DomProjection);
	    return DomProjection;
	}());
	/** @docs-private */
	var ProjectionModule = (function () {
	    function ProjectionModule() {
	    }
	    /** @deprecated */
	    ProjectionModule.forRoot = function () {
	        return {
	            ngModule: ProjectionModule,
	        };
	    };
	    ProjectionModule = __decorate$24([
	        _angular_core.NgModule({
	            exports: [DomProjectionHost],
	            declarations: [DomProjectionHost],
	            providers: [DomProjection],
	        }), 
	        __metadata$24('design:paramtypes', [])
	    ], ProjectionModule);
	    return ProjectionModule;
	}());
	
	var __extends$5 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$25 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$25 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * The FullscreenOverlayContainer is the alternative to OverlayContainer
	 * that supports correct displaying of overlay elements in Fullscreen mode
	 * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
	 * It should be provided in the root component that way:
	 * providers: [
	 *   {provide: OverlayContainer, useClass: FullscreenOverlayContainer}
	 * ],
	 */
	var FullscreenOverlayContainer = (function (_super) {
	    __extends$5(FullscreenOverlayContainer, _super);
	    function FullscreenOverlayContainer() {
	        _super.apply(this, arguments);
	    }
	    FullscreenOverlayContainer.prototype._createContainer = function () {
	        var _this = this;
	        _super.prototype._createContainer.call(this);
	        this._adjustParentForFullscreenChange();
	        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });
	    };
	    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = function () {
	        if (!this._containerElement) {
	            return;
	        }
	        var fullscreenElement = this.getFullscreenElement();
	        var parent = fullscreenElement || document.body;
	        parent.appendChild(this._containerElement);
	    };
	    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = function (fn) {
	        if (document.fullscreenEnabled) {
	            document.addEventListener('fullscreenchange', fn);
	        }
	        else if (document.webkitFullscreenEnabled) {
	            document.addEventListener('webkitfullscreenchange', fn);
	        }
	        else if (document.mozFullScreenEnabled) {
	            document.addEventListener('mozfullscreenchange', fn);
	        }
	        else if (document.msFullscreenEnabled) {
	            document.addEventListener('MSFullscreenChange', fn);
	        }
	    };
	    /**
	     * When the page is put into fullscreen mode, a specific element is specified.
	     * Only that element and its children are visible when in fullscreen mode.
	    */
	    FullscreenOverlayContainer.prototype.getFullscreenElement = function () {
	        return document.fullscreenElement ||
	            document.webkitFullscreenElement ||
	            document.mozFullScreenElement ||
	            document.msFullscreenElement ||
	            null;
	    };
	    FullscreenOverlayContainer = __decorate$25([
	        _angular_core.Injectable(), 
	        __metadata$25('design:paramtypes', [])
	    ], FullscreenOverlayContainer);
	    return FullscreenOverlayContainer;
	}(OverlayContainer));
	
	var __extends$6 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$26 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$26 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/* Adjusts configuration of our gesture library, Hammer. */
	var GestureConfig = (function (_super) {
	    __extends$6(GestureConfig, _super);
	    function GestureConfig() {
	        _super.call(this);
	        this._hammer = typeof window !== 'undefined' ? window.Hammer : null;
	        /* List of new event names to add to the gesture support list */
	        this.events = this._hammer ? [
	            'longpress',
	            'slide',
	            'slidestart',
	            'slideend',
	            'slideright',
	            'slideleft'
	        ] : [];
	        if (!this._hammer && _angular_core.isDevMode()) {
	            console.warn('Could not find HammerJS. Certain Angular Material ' +
	                'components may not work correctly.');
	        }
	    }
	    /**
	     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
	     *
	     * Our gesture names come from the Material Design gestures spec:
	     * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics
	     *
	     * More information on default recognizers can be found in Hammer docs:
	     * http://hammerjs.github.io/recognizer-pan/
	     * http://hammerjs.github.io/recognizer-press/
	     *
	     * @param element Element to which to assign the new HammerJS gestures.
	     * @returns Newly-created HammerJS instance.
	     */
	    GestureConfig.prototype.buildHammer = function (element) {
	        var mc = new this._hammer(element);
	        // Default Hammer Recognizers.
	        var pan = new this._hammer.Pan();
	        var swipe = new this._hammer.Swipe();
	        var press = new this._hammer.Press();
	        // Notice that a HammerJS recognizer can only depend on one other recognizer once.
	        // Otherwise the previous `recognizeWith` will be dropped.
	        // TODO: Confirm threshold numbers with Material Design UX Team
	        var slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
	        var longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
	        // Overwrite the default `pan` event to use the swipe event.
	        pan.recognizeWith(swipe);
	        // Add customized gestures to Hammer manager
	        mc.add([swipe, press, pan, slide, longpress]);
	        return mc;
	    };
	    /** Creates a new recognizer, without affecting the default recognizers of HammerJS */
	    GestureConfig.prototype._createRecognizer = function (base, options) {
	        var inheritances = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            inheritances[_i - 2] = arguments[_i];
	        }
	        var recognizer = new base.constructor(options);
	        inheritances.push(base);
	        inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });
	        return recognizer;
	    };
	    GestureConfig = __decorate$26([
	        _angular_core.Injectable(), 
	        __metadata$26('design:paramtypes', [])
	    ], GestureConfig);
	    return GestureConfig;
	}(_angular_platformBrowser.HammerGestureConfig));
	
	/**
	 * Class to be used to power selecting one or more options from a list.
	 * @docs-private
	 */
	var SelectionModel = (function () {
	    function SelectionModel(_isMulti, initiallySelectedValues) {
	        var _this = this;
	        if (_isMulti === void 0) { _isMulti = false; }
	        this._isMulti = _isMulti;
	        /** Currently-selected values. */
	        this._selection = new Set();
	        /** Keeps track of the deselected options that haven't been emitted by the change event. */
	        this._deselectedToEmit = [];
	        /** Keeps track of the selected option that haven't been emitted by the change event. */
	        this._selectedToEmit = [];
	        /** Event emitted when the value has changed. */
	        this.onChange = new rxjs_Subject.Subject();
	        if (initiallySelectedValues) {
	            if (_isMulti) {
	                initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });
	            }
	            else {
	                this._markSelected(initiallySelectedValues[0]);
	            }
	            // Clear the array in order to avoid firing the change event for preselected values.
	            this._selectedToEmit.length = 0;
	        }
	    }
	    Object.defineProperty(SelectionModel.prototype, "selected", {
	        /** Selected value(s). */
	        get: function () {
	            if (!this._selected) {
	                this._selected = Array.from(this._selection.values());
	            }
	            return this._selected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Selects a value or an array of values.
	     */
	    SelectionModel.prototype.select = function (value) {
	        this._markSelected(value);
	        this._emitChangeEvent();
	    };
	    /**
	     * Deselects a value or an array of values.
	     */
	    SelectionModel.prototype.deselect = function (value) {
	        this._unmarkSelected(value);
	        this._emitChangeEvent();
	    };
	    /**
	     * Clears all of the selected values.
	     */
	    SelectionModel.prototype.clear = function () {
	        this._unmarkAll();
	        this._emitChangeEvent();
	    };
	    /**
	     * Determines whether a value is selected.
	     */
	    SelectionModel.prototype.isSelected = function (value) {
	        return this._selection.has(value);
	    };
	    /**
	     * Determines whether the model has a value.
	     */
	    SelectionModel.prototype.isEmpty = function () {
	        return this._selection.size === 0;
	    };
	    /** Emits a change event and clears the records of selected and deselected values. */
	    SelectionModel.prototype._emitChangeEvent = function () {
	        if (this._selectedToEmit.length || this._deselectedToEmit.length) {
	            var eventData = new SelectionChange(this._selectedToEmit, this._deselectedToEmit);
	            this.onChange.next(eventData);
	            this._deselectedToEmit = [];
	            this._selectedToEmit = [];
	            this._selected = null;
	        }
	    };
	    /** Selects a value. */
	    SelectionModel.prototype._markSelected = function (value) {
	        if (!this.isSelected(value)) {
	            if (!this._isMulti) {
	                this._unmarkAll();
	            }
	            this._selection.add(value);
	            this._selectedToEmit.push(value);
	        }
	    };
	    /** Deselects a value. */
	    SelectionModel.prototype._unmarkSelected = function (value) {
	        if (this.isSelected(value)) {
	            this._selection.delete(value);
	            this._deselectedToEmit.push(value);
	        }
	    };
	    /** Clears out the selected values. */
	    SelectionModel.prototype._unmarkAll = function () {
	        var _this = this;
	        if (!this.isEmpty()) {
	            this._selection.forEach(function (value) { return _this._unmarkSelected(value); });
	        }
	    };
	    return SelectionModel;
	}());
	/**
	 * Describes an event emitted when the value of a MdSelectionModel has changed.
	 * @docs-private
	 */
	var SelectionChange = (function () {
	    function SelectionChange(added, removed) {
	        this.added = added;
	        this.removed = removed;
	    }
	    return SelectionChange;
	}());
	
	/**
	 * Screenreaders will often fire fake mousedown events when a focusable element
	 * is activated using the keyboard. We can typically distinguish between these faked
	 * mousedown events and real mousedown events using the "buttons" property. While
	 * real mousedowns will indicate the mouse button that was pressed (e.g. "1" for
	 * the left mouse button), faked mousedowns will usually set the property value to 0.
	 */
	function isFakeMousedownFromScreenReader(event) {
	    return event.buttons === 0;
	}
	
	var __decorate$27 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$27 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Class to coordinate unique selection based on name.
	 * Intended to be consumed as an Angular service.
	 * This service is needed because native radio change events are only fired on the item currently
	 * being selected, and we still need to uncheck the previous selection.
	 *
	 * This service does not *store* any IDs and names because they may change at any time, so it is
	 * less error-prone if they are simply passed through when the events occur.
	 */
	var UniqueSelectionDispatcher = (function () {
	    function UniqueSelectionDispatcher() {
	        this._listeners = [];
	    }
	    /**
	     * Notify other items that selection for the given name has been set.
	     * @param id ID of the item.
	     * @param name Name of the item.
	     */
	    UniqueSelectionDispatcher.prototype.notify = function (id, name) {
	        for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {
	            var listener = _a[_i];
	            listener(id, name);
	        }
	    };
	    /** Listen for future changes to item selection. */
	    UniqueSelectionDispatcher.prototype.listen = function (listener) {
	        this._listeners.push(listener);
	    };
	    UniqueSelectionDispatcher = __decorate$27([
	        _angular_core.Injectable(), 
	        __metadata$27('design:paramtypes', [])
	    ], UniqueSelectionDispatcher);
	    return UniqueSelectionDispatcher;
	}());
	function UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY(parentDispatcher) {
	    return parentDispatcher || new UniqueSelectionDispatcher();
	}
	var UNIQUE_SELECTION_DISPATCHER_PROVIDER = {
	    // If there is already a dispatcher available, use that. Otherwise, provide a new one.
	    provide: UniqueSelectionDispatcher,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), UniqueSelectionDispatcher]],
	    useFactory: UNIQUE_SELECTION_DISPATCHER_PROVIDER_FACTORY
	};
	
	var __decorate$29 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$29 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found
	// that a value of around 650ms seems appropriate.
	var TOUCH_BUFFER_MS = 650;
	/** Monitors mouse and keyboard events to determine the cause of focus events. */
	var FocusOriginMonitor = (function () {
	    function FocusOriginMonitor() {
	        // Note: we listen to events in the capture phase so we can detect them even if the user stops
	        // propagation.
	        var _this = this;
	        /** The focus origin that the next focus event is a result of. */
	        this._origin = null;
	        /** Whether the window has just been focused. */
	        this._windowFocused = false;
	        // On keydown record the origin and clear any touch event that may be in progress.
	        document.addEventListener('keydown', function () {
	            _this._lastTouchTarget = null;
	            _this._setOriginForCurrentEventQueue('keyboard');
	        }, true);
	        // On mousedown record the origin only if there is not touch target, since a mousedown can
	        // happen as a result of a touch event.
	        document.addEventListener('mousedown', function () {
	            if (!_this._lastTouchTarget) {
	                _this._setOriginForCurrentEventQueue('mouse');
	            }
	        }, true);
	        // When the touchstart event fires the focus event is not yet in the event queue. This means we
	        // can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to see if
	        // a focus happens.
	        document.addEventListener('touchstart', function (event) {
	            if (_this._touchTimeout != null) {
	                clearTimeout(_this._touchTimeout);
	            }
	            _this._lastTouchTarget = event.target;
	            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);
	        }, true);
	        // Make a note of when the window regains focus, so we can restore the origin info for the
	        // focused element.
	        window.addEventListener('focus', function () {
	            _this._windowFocused = true;
	            setTimeout(function () { return _this._windowFocused = false; }, 0);
	        });
	    }
	    /** Register an element to receive focus classes. */
	    FocusOriginMonitor.prototype.registerElementForFocusClasses = function (element, renderer) {
	        var _this = this;
	        var subject = new rxjs_Subject.Subject();
	        renderer.listen(element, 'focus', function (event) { return _this._onFocus(event, element, renderer, subject); });
	        renderer.listen(element, 'blur', function () { return _this._onBlur(element, renderer, subject); });
	        return subject.asObservable();
	    };
	    /** Focuses the element via the specified focus origin. */
	    FocusOriginMonitor.prototype.focusVia = function (element, renderer, origin) {
	        this._setOriginForCurrentEventQueue(origin);
	        renderer.invokeElementMethod(element, 'focus');
	    };
	    /** Sets the origin and schedules an async function to clear it at the end of the event queue. */
	    FocusOriginMonitor.prototype._setOriginForCurrentEventQueue = function (origin) {
	        var _this = this;
	        this._origin = origin;
	        setTimeout(function () { return _this._origin = null; }, 0);
	    };
	    /** Checks whether the given focus event was caused by a touchstart event. */
	    FocusOriginMonitor.prototype._wasCausedByTouch = function (event) {
	        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.
	        // Consider the following dom structure:
	        //
	        // <div #parent tabindex="0" cdkFocusClasses>
	        //   <div #child (click)="#parent.focus()"></div>
	        // </div>
	        //
	        // If the user touches the #child element and the #parent is programmatically focused as a
	        // result, this code will still consider it to have been caused by the touch event and will
	        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a
	        // relatively small edge-case that can be worked around by using
	        // focusVia(parentEl, renderer,  'program') to focus the parent element.
	        //
	        // If we decide that we absolutely must handle this case correctly, we can do so by listening
	        // for the first focus event after the touchstart, and then the first blur event after that
	        // focus event. When that blur event fires we know that whatever follows is not a result of the
	        // touchstart.
	        var focusTarget = event.target;
	        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&
	            (focusTarget == this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));
	    };
	    /** Handles focus events on a registered element. */
	    FocusOriginMonitor.prototype._onFocus = function (event, element, renderer, subject) {
	        // If we couldn't detect a cause for the focus event, it's due to one of two reasons:
	        // 1) The window has just regained focus, in which case we want to restore the focused state of
	        //    the element from before the window blurred.
	        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.
	        // 3) The element was programmatically focused, in which case we should mark the origin as
	        //    'program'.
	        if (!this._origin) {
	            if (this._windowFocused && this._lastFocusOrigin) {
	                this._origin = this._lastFocusOrigin;
	            }
	            else if (this._wasCausedByTouch(event)) {
	                this._origin = 'touch';
	            }
	            else {
	                this._origin = 'program';
	            }
	        }
	        renderer.setElementClass(element, 'cdk-focused', true);
	        renderer.setElementClass(element, 'cdk-touch-focused', this._origin == 'touch');
	        renderer.setElementClass(element, 'cdk-keyboard-focused', this._origin == 'keyboard');
	        renderer.setElementClass(element, 'cdk-mouse-focused', this._origin == 'mouse');
	        renderer.setElementClass(element, 'cdk-program-focused', this._origin == 'program');
	        subject.next(this._origin);
	        this._lastFocusOrigin = this._origin;
	        this._origin = null;
	    };
	    /** Handles blur events on a registered element. */
	    FocusOriginMonitor.prototype._onBlur = function (element, renderer, subject) {
	        renderer.setElementClass(element, 'cdk-focused', false);
	        renderer.setElementClass(element, 'cdk-touch-focused', false);
	        renderer.setElementClass(element, 'cdk-keyboard-focused', false);
	        renderer.setElementClass(element, 'cdk-mouse-focused', false);
	        renderer.setElementClass(element, 'cdk-program-focused', false);
	        subject.next(null);
	    };
	    FocusOriginMonitor = __decorate$29([
	        _angular_core.Injectable(), 
	        __metadata$29('design:paramtypes', [])
	    ], FocusOriginMonitor);
	    return FocusOriginMonitor;
	}());
	/**
	 * Directive that determines how a particular element was focused (via keyboard, mouse, or
	 * programmatically) and adds corresponding classes to the element.
	 */
	var CdkFocusClasses = (function () {
	    function CdkFocusClasses(elementRef, focusOriginMonitor, renderer) {
	        this.changes =
	            focusOriginMonitor.registerElementForFocusClasses(elementRef.nativeElement, renderer);
	    }
	    CdkFocusClasses = __decorate$29([
	        _angular_core.Directive({
	            selector: '[cdkFocusClasses]',
	        }), 
	        __metadata$29('design:paramtypes', [_angular_core.ElementRef, FocusOriginMonitor, _angular_core.Renderer])
	    ], CdkFocusClasses);
	    return CdkFocusClasses;
	}());
	function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher) {
	    return parentDispatcher || new FocusOriginMonitor();
	}
	var FOCUS_ORIGIN_MONITOR_PROVIDER = {
	    // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.
	    provide: FocusOriginMonitor,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), FocusOriginMonitor]],
	    useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY
	};
	
	/**
	 * Applies a CSS transform to an element, including browser-prefixed properties.
	 * @param element
	 * @param transformValue
	 */
	function applyCssTransform(element, transformValue) {
	    // It's important to trim the result, because the browser will ignore the set operation
	    // if the string contains only whitespace.
	    var value = transformValue.trim();
	    element.style.transform = value;
	    element.style.webkitTransform = value;
	}
	
	var __decorate$28 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$28 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var StyleModule = (function () {
	    function StyleModule() {
	    }
	    StyleModule = __decorate$28([
	        _angular_core.NgModule({
	            declarations: [CdkFocusClasses],
	            exports: [CdkFocusClasses],
	            providers: [FOCUS_ORIGIN_MONITOR_PROVIDER],
	        }), 
	        __metadata$28('design:paramtypes', [])
	    ], StyleModule);
	    return StyleModule;
	}());
	
	/** @docs-private */
	var AnimationCurves = (function () {
	    function AnimationCurves() {
	    }
	    AnimationCurves.STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';
	    AnimationCurves.DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';
	    AnimationCurves.ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';
	    AnimationCurves.SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';
	    return AnimationCurves;
	}());
	/** @docs-private */
	var AnimationDurations = (function () {
	    function AnimationDurations() {
	    }
	    AnimationDurations.COMPLEX = '375ms';
	    AnimationDurations.ENTERING = '225ms';
	    AnimationDurations.EXITING = '195ms';
	    return AnimationDurations;
	}());
	
	/** Coerces a data-bound value (typically a string) to a number. */
	function coerceNumberProperty(value, fallbackValue) {
	    if (fallbackValue === void 0) { fallbackValue = 0; }
	    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
	    // and other non-number values as NaN, where Number just uses 0) but it considers the string
	    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
	    return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);
	}
	
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdCoreModule = (function () {
	    function MdCoreModule() {
	    }
	    /** @deprecated */
	    MdCoreModule.forRoot = function () {
	        return {
	            ngModule: MdCoreModule,
	            providers: [],
	        };
	    };
	    MdCoreModule = __decorate([
	        _angular_core.NgModule({
	            imports: [
	                MdLineModule,
	                RtlModule,
	                MdRippleModule,
	                ObserveContentModule,
	                PortalModule,
	                OverlayModule,
	                A11yModule,
	                MdOptionModule,
	                MdSelectionModule,
	            ],
	            exports: [
	                MdLineModule,
	                RtlModule,
	                MdRippleModule,
	                ObserveContentModule,
	                PortalModule,
	                OverlayModule,
	                A11yModule,
	                MdOptionModule,
	                MdSelectionModule,
	            ],
	        }), 
	        __metadata('design:paramtypes', [])
	    ], MdCoreModule);
	    return MdCoreModule;
	}());
	
	var __decorate$31 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$31 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$4 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Provider Expression that allows md-button-toggle-group to register as a ControlValueAccessor.
	 * This allows it to support [(ngModel)].
	 * @docs-private
	 */
	var MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdButtonToggleGroup; }),
	    multi: true
	};
	var _uniqueIdCounter$1 = 0;
	/** Change event object emitted by MdButtonToggle. */
	var MdButtonToggleChange = (function () {
	    function MdButtonToggleChange() {
	    }
	    return MdButtonToggleChange;
	}());
	/** Exclusive selection button toggle group that behaves like a radio-button group. */
	var MdButtonToggleGroup = (function () {
	    function MdButtonToggleGroup() {
	        /** The value for the button toggle group. Should match currently selected button toggle. */
	        this._value = null;
	        /** The HTML name attribute applied to toggles in this group. */
	        this._name = "md-button-toggle-group-" + _uniqueIdCounter$1++;
	        /** Disables all toggles in the group. */
	        this._disabled = null;
	        /** Whether the button toggle group should be vertical. */
	        this._vertical = false;
	        /** The currently selected button toggle, should match the value. */
	        this._selected = null;
	        /** Whether the button toggle group is initialized or not. */
	        this._isInitialized = false;
	        /**
	         * The method to be called in order to update ngModel.
	         * Now `ngModel` binding is not supported in multiple selection mode.
	         */
	        this._controlValueAccessorChangeFn = function (value) { };
	        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
	        this.onTouched = function () { };
	        /** Event emitted when the group's value changes. */
	        this._change = new _angular_core.EventEmitter();
	        /** Child button toggle buttons. */
	        this._buttonToggles = null;
	    }
	    Object.defineProperty(MdButtonToggleGroup.prototype, "change", {
	        get: function () {
	            return this._change.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdButtonToggleGroup.prototype.ngAfterViewInit = function () {
	        this._isInitialized = true;
	    };
	    Object.defineProperty(MdButtonToggleGroup.prototype, "name", {
	        /** `name` attribute for the underlying `input` element. */
	        get: function () {
	            return this._name;
	        },
	        set: function (value) {
	            this._name = value;
	            this._updateButtonToggleNames();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "disabled", {
	        /** Whether the toggle group is disabled. */
	        get: function () {
	            return this._disabled;
	        },
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "vertical", {
	        /** Whether the toggle group is vertical. */
	        get: function () {
	            return this._vertical;
	        },
	        set: function (value) {
	            this._vertical = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "value", {
	        /** Value of the toggle group. */
	        get: function () {
	            return this._value;
	        },
	        set: function (newValue) {
	            if (this._value != newValue) {
	                this._value = newValue;
	                this._updateSelectedButtonToggleFromValue();
	                // Only emit a change event if the view is completely initialized.
	                // We don't want to emit a change event for the initial values.
	                if (this._isInitialized) {
	                    this._emitChangeEvent();
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroup.prototype, "selected", {
	        /** Whether the toggle group is selected. */
	        get: function () {
	            return this._selected;
	        },
	        set: function (selected) {
	            this._selected = selected;
	            this.value = selected ? selected.value : null;
	            if (selected && !selected.checked) {
	                selected.checked = true;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdButtonToggleGroup.prototype._updateButtonToggleNames = function () {
	        var _this = this;
	        if (this._buttonToggles) {
	            this._buttonToggles.forEach(function (toggle) {
	                toggle.name = _this._name;
	            });
	        }
	    };
	    // TODO: Refactor into shared code with radio.
	    MdButtonToggleGroup.prototype._updateSelectedButtonToggleFromValue = function () {
	        var _this = this;
	        var isAlreadySelected = this._selected != null && this._selected.value == this._value;
	        if (this._buttonToggles != null && !isAlreadySelected) {
	            var matchingButtonToggle = this._buttonToggles.filter(function (buttonToggle) { return buttonToggle.value == _this._value; })[0];
	            if (matchingButtonToggle) {
	                this.selected = matchingButtonToggle;
	            }
	            else if (this.value == null) {
	                this.selected = null;
	                this._buttonToggles.forEach(function (buttonToggle) {
	                    buttonToggle.checked = false;
	                });
	            }
	        }
	    };
	    /** Dispatch change event with current selection and group value. */
	    MdButtonToggleGroup.prototype._emitChangeEvent = function () {
	        var event = new MdButtonToggleChange();
	        event.source = this._selected;
	        event.value = this._value;
	        this._controlValueAccessorChangeFn(event.value);
	        this._change.emit(event);
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value Value to be set to the model.
	     */
	    MdButtonToggleGroup.prototype.writeValue = function (value) {
	        this.value = value;
	    };
	    /**
	     * Registers a callback that will be triggered when the value has changed.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn On change callback function.
	     */
	    MdButtonToggleGroup.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback that will be triggered when the control has been touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn On touch callback function.
	     */
	    MdButtonToggleGroup.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Toggles the disabled state of the component. Implemented as part of ControlValueAccessor.
	     * @param isDisabled Whether the component should be disabled.
	     */
	    MdButtonToggleGroup.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    __decorate$31([
	        _angular_core.Output(), 
	        __metadata$31('design:type', rxjs_Observable.Observable)
	    ], MdButtonToggleGroup.prototype, "change", null);
	    __decorate$31([
	        _angular_core.ContentChildren(_angular_core.forwardRef(function () { return MdButtonToggle; })), 
	        __metadata$31('design:type', _angular_core.QueryList)
	    ], MdButtonToggleGroup.prototype, "_buttonToggles", void 0);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', String)
	    ], MdButtonToggleGroup.prototype, "name", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroup.prototype, "disabled", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroup.prototype, "vertical", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Object)
	    ], MdButtonToggleGroup.prototype, "value", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Object)
	    ], MdButtonToggleGroup.prototype, "selected", null);
	    MdButtonToggleGroup = __decorate$31([
	        _angular_core.Directive({
	            selector: 'md-button-toggle-group:not([multiple]), mat-button-toggle-group:not([multiple])',
	            providers: [MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],
	            host: {
	                '[class.mat-button-toggle-group]': 'true',
	                'role': 'radiogroup',
	                '[class.mat-button-toggle-vertical]': 'vertical'
	            },
	            exportAs: 'mdButtonToggleGroup',
	        }), 
	        __metadata$31('design:paramtypes', [])
	    ], MdButtonToggleGroup);
	    return MdButtonToggleGroup;
	}());
	/** Multiple selection button-toggle group. `ngModel` is not supported in this mode. */
	var MdButtonToggleGroupMultiple = (function () {
	    function MdButtonToggleGroupMultiple() {
	        /** Disables all toggles in the group. */
	        this._disabled = null;
	        /** Whether the button toggle group should be vertical. */
	        this._vertical = false;
	    }
	    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, "disabled", {
	        /** Whether the toggle group is disabled. */
	        get: function () {
	            return this._disabled;
	        },
	        set: function (value) {
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, "vertical", {
	        /** Whether the toggle group is vertical. */
	        get: function () {
	            return this._vertical;
	        },
	        set: function (value) {
	            this._vertical = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroupMultiple.prototype, "disabled", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggleGroupMultiple.prototype, "vertical", null);
	    MdButtonToggleGroupMultiple = __decorate$31([
	        _angular_core.Directive({
	            selector: 'md-button-toggle-group[multiple], mat-button-toggle-group[multiple]',
	            exportAs: 'mdButtonToggleGroup',
	            host: {
	                '[class.mat-button-toggle-group]': 'true',
	                '[class.mat-button-toggle-vertical]': 'vertical'
	            }
	        }), 
	        __metadata$31('design:paramtypes', [])
	    ], MdButtonToggleGroupMultiple);
	    return MdButtonToggleGroupMultiple;
	}());
	/** Single button inside of a toggle group. */
	var MdButtonToggle = (function () {
	    function MdButtonToggle(toggleGroup, toggleGroupMultiple, buttonToggleDispatcher, _renderer) {
	        var _this = this;
	        this.buttonToggleDispatcher = buttonToggleDispatcher;
	        this._renderer = _renderer;
	        /** Whether or not this button toggle is checked. */
	        this._checked = false;
	        /** Whether or not this button toggle is disabled. */
	        this._disabled = null;
	        /** Value assigned to this button toggle. */
	        this._value = null;
	        /** Whether or not the button toggle is a single selection. */
	        this._isSingleSelector = null;
	        /** Event emitted when the group value changes. */
	        this._change = new _angular_core.EventEmitter();
	        this.buttonToggleGroup = toggleGroup;
	        this.buttonToggleGroupMultiple = toggleGroupMultiple;
	        if (this.buttonToggleGroup) {
	            buttonToggleDispatcher.listen(function (id, name) {
	                if (id != _this.id && name == _this.name) {
	                    _this.checked = false;
	                }
	            });
	            this._type = 'radio';
	            this.name = this.buttonToggleGroup.name;
	            this._isSingleSelector = true;
	        }
	        else {
	            // Even if there is no group at all, treat the button toggle as a checkbox so it can be
	            // toggled on or off.
	            this._type = 'checkbox';
	            this._isSingleSelector = false;
	        }
	    }
	    Object.defineProperty(MdButtonToggle.prototype, "change", {
	        get: function () {
	            return this._change.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdButtonToggle.prototype.ngOnInit = function () {
	        if (this.id == null) {
	            this.id = "md-button-toggle-" + _uniqueIdCounter$1++;
	        }
	        if (this.buttonToggleGroup && this._value == this.buttonToggleGroup.value) {
	            this._checked = true;
	        }
	    };
	    Object.defineProperty(MdButtonToggle.prototype, "inputId", {
	        /** Unique ID for the underlying `input` element. */
	        get: function () {
	            return this.id + "-input";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggle.prototype, "checked", {
	        /** Whether the button is checked. */
	        get: function () {
	            return this._checked;
	        },
	        set: function (newCheckedState) {
	            if (this._isSingleSelector) {
	                if (newCheckedState) {
	                    // Notify all button toggles with the same name (in the same group) to un-check.
	                    this.buttonToggleDispatcher.notify(this.id, this.name);
	                }
	            }
	            this._checked = newCheckedState;
	            if (newCheckedState && this._isSingleSelector && this.buttonToggleGroup.value != this.value) {
	                this.buttonToggleGroup.selected = this;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButtonToggle.prototype, "value", {
	        /** MdButtonToggleGroup reads this to assign its own value. */
	        get: function () {
	            return this._value;
	        },
	        set: function (value) {
	            if (this._value != value) {
	                if (this.buttonToggleGroup != null && this.checked) {
	                    this.buttonToggleGroup.value = value;
	                }
	                this._value = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Dispatch change event with current value. */
	    MdButtonToggle.prototype._emitChangeEvent = function () {
	        var event = new MdButtonToggleChange();
	        event.source = this;
	        event.value = this._value;
	        this._change.emit(event);
	    };
	    Object.defineProperty(MdButtonToggle.prototype, "disabled", {
	        /** Whether the button is disabled. */
	        get: function () {
	            return this._disabled || (this.buttonToggleGroup != null && this.buttonToggleGroup.disabled) ||
	                (this.buttonToggleGroupMultiple != null && this.buttonToggleGroupMultiple.disabled);
	        },
	        set: function (value) {
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Toggle the state of the current button toggle. */
	    MdButtonToggle.prototype._toggle = function () {
	        this.checked = !this.checked;
	    };
	    /** Checks the button toggle due to an interaction with the underlying native input. */
	    MdButtonToggle.prototype._onInputChange = function (event) {
	        event.stopPropagation();
	        if (this._isSingleSelector) {
	            // Propagate the change one-way via the group, which will in turn mark this
	            // button toggle as checked.
	            this.checked = true;
	            this.buttonToggleGroup.selected = this;
	            this.buttonToggleGroup.onTouched();
	        }
	        else {
	            this._toggle();
	        }
	        // Emit a change event when the native input does.
	        this._emitChangeEvent();
	    };
	    MdButtonToggle.prototype._onInputClick = function (event) {
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `slide-toggle` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    /** Focuses the button. */
	    MdButtonToggle.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	    };
	    __decorate$31([
	        _angular_core.HostBinding(),
	        _angular_core.Input(), 
	        __metadata$31('design:type', String)
	    ], MdButtonToggle.prototype, "id", void 0);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', String)
	    ], MdButtonToggle.prototype, "name", void 0);
	    __decorate$31([
	        _angular_core.Output(), 
	        __metadata$31('design:type', rxjs_Observable.Observable)
	    ], MdButtonToggle.prototype, "change", null);
	    __decorate$31([
	        _angular_core.ViewChild('input'), 
	        __metadata$31('design:type', _angular_core.ElementRef)
	    ], MdButtonToggle.prototype, "_inputElement", void 0);
	    __decorate$31([
	        _angular_core.HostBinding('class.mat-button-toggle-checked'),
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggle.prototype, "checked", null);
	    __decorate$31([
	        _angular_core.Input(), 
	        __metadata$31('design:type', Object)
	    ], MdButtonToggle.prototype, "value", null);
	    __decorate$31([
	        _angular_core.HostBinding('class.mat-button-toggle-disabled'),
	        _angular_core.Input(), 
	        __metadata$31('design:type', Boolean)
	    ], MdButtonToggle.prototype, "disabled", null);
	    MdButtonToggle = __decorate$31([
	        _angular_core.Component({selector: 'md-button-toggle, mat-button-toggle',
	            template: "<label [attr.for]=\"inputId\" class=\"mat-button-toggle-label\"><input #input class=\"mat-button-toggle-input cdk-visually-hidden\" [type]=\"_type\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [name]=\"name\" (change)=\"_onInputChange($event)\" (click)=\"_onInputClick($event)\"><div class=\"mat-button-toggle-label-content\"><ng-content></ng-content></div></label>",
	            styles: [".mat-button-toggle-group{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);position:relative;display:inline-flex;flex-direction:row;border-radius:2px;cursor:pointer;white-space:nowrap}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle-disabled .mat-button-toggle-label-content{cursor:default}.mat-button-toggle{white-space:nowrap;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-button-toggle-label-content{display:inline-block;line-height:36px;padding:0 16px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mat-button-toggle-label-content>*{vertical-align:middle}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                '[class.mat-button-toggle]': 'true'
	            }
	        }),
	        __param$4(0, _angular_core.Optional()),
	        __param$4(1, _angular_core.Optional()), 
	        __metadata$31('design:paramtypes', [MdButtonToggleGroup, MdButtonToggleGroupMultiple, UniqueSelectionDispatcher, _angular_core.Renderer])
	    ], MdButtonToggle);
	    return MdButtonToggle;
	}());
	var MdButtonToggleModule = (function () {
	    function MdButtonToggleModule() {
	    }
	    /** @deprecated */
	    MdButtonToggleModule.forRoot = function () {
	        return {
	            ngModule: MdButtonToggleModule,
	            providers: []
	        };
	    };
	    MdButtonToggleModule = __decorate$31([
	        _angular_core.NgModule({
	            imports: [_angular_forms.FormsModule, CompatibilityModule],
	            exports: [
	                MdButtonToggleGroup,
	                MdButtonToggleGroupMultiple,
	                MdButtonToggle,
	                CompatibilityModule,
	            ],
	            declarations: [MdButtonToggleGroup, MdButtonToggleGroupMultiple, MdButtonToggle],
	            providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER]
	        }), 
	        __metadata$31('design:paramtypes', [])
	    ], MdButtonToggleModule);
	    return MdButtonToggleModule;
	}());
	
	var __extends$7 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$32 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$32 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(jelbourn): Make the `isMouseDown` stuff done with one global listener.
	// TODO(kara): Convert attribute selectors to classes when attr maps become available
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdButtonCssMatStyler = (function () {
	    function MdButtonCssMatStyler() {
	    }
	    MdButtonCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-button], button[mat-button], a[md-button], a[mat-button]',
	            host: {
	                '[class.mat-button]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdButtonCssMatStyler);
	    return MdButtonCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdRaisedButtonCssMatStyler = (function () {
	    function MdRaisedButtonCssMatStyler() {
	    }
	    MdRaisedButtonCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-raised-button], button[mat-raised-button], ' +
	                'a[md-raised-button], a[mat-raised-button]',
	            host: {
	                '[class.mat-raised-button]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdRaisedButtonCssMatStyler);
	    return MdRaisedButtonCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdIconButtonCssMatStyler = (function () {
	    function MdIconButtonCssMatStyler() {
	    }
	    MdIconButtonCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-icon-button], button[mat-icon-button], a[md-icon-button], a[mat-icon-button]',
	            host: {
	                '[class.mat-icon-button]': 'true',
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdIconButtonCssMatStyler);
	    return MdIconButtonCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdFabCssMatStyler = (function () {
	    function MdFabCssMatStyler() {
	    }
	    MdFabCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-fab], button[mat-fab], a[md-fab], a[mat-fab]',
	            host: {
	                '[class.mat-fab]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdFabCssMatStyler);
	    return MdFabCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdMiniFabCssMatStyler = (function () {
	    function MdMiniFabCssMatStyler() {
	    }
	    MdMiniFabCssMatStyler = __decorate$32([
	        _angular_core.Directive({
	            selector: 'button[md-mini-fab], button[mat-mini-fab], a[md-mini-fab], a[mat-mini-fab]',
	            host: {
	                '[class.mat-mini-fab]': 'true'
	            }
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdMiniFabCssMatStyler);
	    return MdMiniFabCssMatStyler;
	}());
	/**
	 * Material design button.
	 */
	var MdButton = (function () {
	    function MdButton(_elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** Whether the button has focus from the keyboard (not the mouse). Used for class binding. */
	        this._isKeyboardFocused = false;
	        /** Whether a mousedown has occurred on this element in the last 100ms. */
	        this._isMouseDown = false;
	        /** Whether the ripple effect on click should be disabled. */
	        this._disableRipple = false;
	        this._disabled = null;
	    }
	    Object.defineProperty(MdButton.prototype, "disableRipple", {
	        /** Whether the ripple effect for this button is disabled. */
	        get: function () { return this._disableRipple; },
	        set: function (v) { this._disableRipple = coerceBooleanProperty(v); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButton.prototype, "disabled", {
	        /** Whether the button is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value) ? true : null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdButton.prototype, "color", {
	        /** The color of the button. Can be `primary`, `accent`, or `warn`. */
	        get: function () { return this._color; },
	        set: function (value) { this._updateColor(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdButton.prototype._setMousedown = function () {
	        var _this = this;
	        // We only *show* the focus style when focus has come to the button via the keyboard.
	        // The Material Design spec is silent on this topic, and without doing this, the
	        // button continues to look :active after clicking.
	        // @see http://marcysutton.com/button-focus-hell/
	        this._isMouseDown = true;
	        setTimeout(function () { _this._isMouseDown = false; }, 100);
	    };
	    MdButton.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdButton.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._getHostElement(), "mat-" + color, isAdd);
	        }
	    };
	    MdButton.prototype._setKeyboardFocus = function () {
	        this._isKeyboardFocused = !this._isMouseDown;
	    };
	    MdButton.prototype._removeKeyboardFocus = function () {
	        this._isKeyboardFocused = false;
	    };
	    /** Focuses the button. */
	    MdButton.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._getHostElement(), 'focus');
	    };
	    MdButton.prototype._getHostElement = function () {
	        return this._elementRef.nativeElement;
	    };
	    MdButton.prototype._isRoundButton = function () {
	        var el = this._getHostElement();
	        return el.hasAttribute('md-icon-button') ||
	            el.hasAttribute('md-fab') ||
	            el.hasAttribute('md-mini-fab');
	    };
	    MdButton.prototype._isRippleDisabled = function () {
	        return this.disableRipple || this.disabled;
	    };
	    __decorate$32([
	        _angular_core.Input(), 
	        __metadata$32('design:type', Object)
	    ], MdButton.prototype, "disableRipple", null);
	    __decorate$32([
	        _angular_core.Input(), 
	        __metadata$32('design:type', Object)
	    ], MdButton.prototype, "disabled", null);
	    __decorate$32([
	        _angular_core.Input(), 
	        __metadata$32('design:type', String)
	    ], MdButton.prototype, "color", null);
	    MdButton = __decorate$32([
	        _angular_core.Component({selector: 'button[md-button], button[md-raised-button], button[md-icon-button],' +
	                'button[md-fab], button[md-mini-fab],' +
	                'button[mat-button], button[mat-raised-button], button[mat-icon-button],' +
	                'button[mat-fab], button[mat-mini-fab]',
	            host: {
	                '[disabled]': 'disabled',
	                '[class.mat-button-focus]': '_isKeyboardFocused',
	                '(mousedown)': '_setMousedown()',
	                '(focus)': '_setKeyboardFocus()',
	                '(blur)': '_removeKeyboardFocus()',
	            },
	            template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"_isRoundButton()\" [mdRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\" (touchstart)=\"$event.preventDefault()\"></div>",
	            styles: [".mat-button-focus.mat-button .mat-button-focus-overlay,.mat-button-focus.mat-fab .mat-button-focus-overlay,.mat-button-focus.mat-icon-button .mat-button-focus-overlay,.mat-button-focus.mat-mini-fab .mat-button-focus-overlay,.mat-button-focus.mat-raised-button .mat-button-focus-overlay,.mat-button:hover .mat-button-focus-overlay,.mat-icon-button:hover .mat-button-focus-overlay{opacity:1}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button[disabled]:hover .mat-button-focus-overlay,.mat-button[disabled]:hover.mat-accent,.mat-button[disabled]:hover.mat-primary,.mat-button[disabled]:hover.mat-warn,.mat-icon-button[disabled]:hover .mat-button-focus-overlay,.mat-icon-button[disabled]:hover.mat-accent,.mat-icon-button[disabled]:hover.mat-primary,.mat-icon-button[disabled]:hover.mat-warn{background-color:transparent}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-icon-button,.mat-mini-fab{min-width:0;width:40px;height:40px;border-radius:50%}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;flex-shrink:0;line-height:40px}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;pointer-events:none;opacity:0}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$32('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdButton);
	    return MdButton;
	}());
	/**
	 * Raised Material design button.
	 */
	var MdAnchor = (function (_super) {
	    __extends$7(MdAnchor, _super);
	    function MdAnchor(elementRef, renderer) {
	        _super.call(this, elementRef, renderer);
	    }
	    Object.defineProperty(MdAnchor.prototype, "tabIndex", {
	        /** @docs-private */
	        get: function () {
	            return this.disabled ? -1 : 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdAnchor.prototype, "_isAriaDisabled", {
	        get: function () {
	            return this.disabled ? 'true' : 'false';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdAnchor.prototype._haltDisabledEvents = function (event) {
	        // A disabled button shouldn't apply any actions
	        if (this.disabled) {
	            event.preventDefault();
	            event.stopImmediatePropagation();
	        }
	    };
	    __decorate$32([
	        _angular_core.HostBinding('tabIndex'), 
	        __metadata$32('design:type', Number)
	    ], MdAnchor.prototype, "tabIndex", null);
	    MdAnchor = __decorate$32([
	        _angular_core.Component({selector: "a[md-button], a[md-raised-button], a[md-icon-button], a[md-fab], a[md-mini-fab],\n             a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab], a[mat-mini-fab]",
	            host: {
	                '[attr.disabled]': 'disabled',
	                '[attr.aria-disabled]': '_isAriaDisabled',
	                '[class.mat-button-focus]': '_isKeyboardFocused',
	                '(mousedown)': '_setMousedown()',
	                '(focus)': '_setKeyboardFocus()',
	                '(blur)': '_removeKeyboardFocus()',
	                '(click)': '_haltDisabledEvents($event)',
	            },
	            template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"_isRoundButton()\" [mdRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\" (touchstart)=\"$event.preventDefault()\"></div>",
	            styles: [".mat-button-focus.mat-button .mat-button-focus-overlay,.mat-button-focus.mat-fab .mat-button-focus-overlay,.mat-button-focus.mat-icon-button .mat-button-focus-overlay,.mat-button-focus.mat-mini-fab .mat-button-focus-overlay,.mat-button-focus.mat-raised-button .mat-button-focus-overlay,.mat-button:hover .mat-button-focus-overlay,.mat-icon-button:hover .mat-button-focus-overlay{opacity:1}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{box-sizing:border-box;position:relative;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;text-align:center;margin:0;min-width:88px;line-height:36px;padding:0 16px;border-radius:2px}[disabled].mat-button,[disabled].mat-fab,[disabled].mat-icon-button,[disabled].mat-mini-fab,[disabled].mat-raised-button{cursor:default}.mat-fab,.mat-mini-fab,.mat-raised-button{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-fab:not([disabled]):active,.mat-mini-fab:not([disabled]):active,.mat-raised-button:not([disabled]):active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}[disabled].mat-fab,[disabled].mat-mini-fab,[disabled].mat-raised-button{box-shadow:none}.mat-button[disabled]:hover .mat-button-focus-overlay,.mat-button[disabled]:hover.mat-accent,.mat-button[disabled]:hover.mat-primary,.mat-button[disabled]:hover.mat-warn,.mat-icon-button[disabled]:hover .mat-button-focus-overlay,.mat-icon-button[disabled]:hover.mat-accent,.mat-icon-button[disabled]:hover.mat-primary,.mat-icon-button[disabled]:hover.mat-warn{background-color:transparent}.mat-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-icon-button,.mat-mini-fab{min-width:0;width:40px;height:40px;border-radius:50%}.mat-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab .mat-icon,.mat-fab i{padding:16px 0;line-height:24px}.mat-mini-fab{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);padding:0;flex-shrink:0}.mat-mini-fab:not([disabled]):active{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-mini-fab .mat-icon,.mat-mini-fab i{padding:8px 0;line-height:24px}.mat-icon-button{padding:0;flex-shrink:0;line-height:40px}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button,.mat-icon-button,.mat-raised-button{color:currentColor}.mat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*{vertical-align:middle}.mat-button-focus-overlay,.mat-button-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mat-button-focus-overlay{background-color:rgba(0,0,0,.12);border-radius:inherit;pointer-events:none;opacity:0}.mat-button-ripple-round{border-radius:50%;z-index:1}@media screen and (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:rgba(255,255,255,.5)}.mat-button,.mat-fab,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$32('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdAnchor);
	    return MdAnchor;
	}(MdButton));
	var MdButtonModule = (function () {
	    function MdButtonModule() {
	    }
	    /** @deprecated */
	    MdButtonModule.forRoot = function () {
	        return {
	            ngModule: MdButtonModule,
	            providers: []
	        };
	    };
	    MdButtonModule = __decorate$32([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [
	                MdButton, MdAnchor,
	                CompatibilityModule,
	                MdButtonCssMatStyler,
	                MdRaisedButtonCssMatStyler,
	                MdIconButtonCssMatStyler,
	                MdFabCssMatStyler,
	                MdMiniFabCssMatStyler
	            ],
	            declarations: [
	                MdButton,
	                MdAnchor,
	                MdButtonCssMatStyler,
	                MdRaisedButtonCssMatStyler,
	                MdIconButtonCssMatStyler,
	                MdFabCssMatStyler,
	                MdMiniFabCssMatStyler
	            ],
	        }), 
	        __metadata$32('design:paramtypes', [])
	    ], MdButtonModule);
	    return MdButtonModule;
	}());
	
	var __decorate$33 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$33 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Monotonically increasing integer used to auto-generate unique ids for checkbox components. */
	var nextId = 0;
	/**
	 * Provider Expression that allows md-checkbox to register as a ControlValueAccessor.
	 * This allows it to support [(ngModel)].
	 * @docs-private
	 */
	var MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdCheckbox; }),
	    multi: true
	};
	/**
	 * Represents the different states that require custom transitions between them.
	 * @docs-private
	 */
	
	(function (TransitionCheckState) {
	    /** The initial state of the component before any user interaction. */
	    TransitionCheckState[TransitionCheckState["Init"] = 0] = "Init";
	    /** The state representing the component when it's becoming checked. */
	    TransitionCheckState[TransitionCheckState["Checked"] = 1] = "Checked";
	    /** The state representing the component when it's becoming unchecked. */
	    TransitionCheckState[TransitionCheckState["Unchecked"] = 2] = "Unchecked";
	    /** The state representing the component when it's becoming indeterminate. */
	    TransitionCheckState[TransitionCheckState["Indeterminate"] = 3] = "Indeterminate";
	})(exports.TransitionCheckState || (exports.TransitionCheckState = {}));
	/** Change event object emitted by MdCheckbox. */
	var MdCheckboxChange = (function () {
	    function MdCheckboxChange() {
	    }
	    return MdCheckboxChange;
	}());
	/**
	 * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,
	 * and exposes a similar API. A MdCheckbox can be either checked, unchecked, indeterminate, or
	 * disabled. Note that all additional accessibility attributes are taken care of by the component,
	 * so there is no need to provide them yourself. However, if you want to omit a label and still
	 * have the checkbox be accessible, you may supply an [aria-label] input.
	 * See: https://www.google.com/design/spec/components/selection-controls.html
	 */
	var MdCheckbox = (function () {
	    function MdCheckbox(_renderer, _elementRef, _changeDetectorRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._changeDetectorRef = _changeDetectorRef;
	        /**
	         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
	         * take precedence so this may be omitted.
	         */
	        this.ariaLabel = '';
	        /**
	         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
	         */
	        this.ariaLabelledby = null;
	        /** A unique id for the checkbox. If one is not supplied, it is auto-generated. */
	        this.id = "md-checkbox-" + ++nextId;
	        /** Whether the label should appear after or before the checkbox. Defaults to 'after' */
	        this.labelPosition = 'after';
	        this._disabled = false;
	        /** Tabindex value that is passed to the underlying input element. */
	        this.tabIndex = 0;
	        /** Name value will be applied to the input element if present */
	        this.name = null;
	        /** Event emitted when the checkbox's `checked` value changes. */
	        this.change = new _angular_core.EventEmitter();
	        /** Event emitted when the checkbox's `indeterminate` value changes. */
	        this.indeterminateChange = new _angular_core.EventEmitter();
	        /**
	         * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
	         * @docs-private
	         */
	        this.onTouched = function () { };
	        this._currentAnimationClass = '';
	        this._currentCheckState = exports.TransitionCheckState.Init;
	        this._checked = false;
	        this._indeterminate = false;
	        this._controlValueAccessorChangeFn = function (value) { };
	        this._hasFocus = false;
	        this.color = 'accent';
	    }
	    Object.defineProperty(MdCheckbox.prototype, "disableRipple", {
	        /** Whether the ripple effect for this checkbox is disabled. */
	        get: function () { return this._disableRipple; },
	        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "inputId", {
	        /** ID of the native input element inside `<md-checkbox>` */
	        get: function () {
	            return "input-" + this.id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "required", {
	        /** Whether the checkbox is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "align", {
	        /**
	         * Whether or not the checkbox should appear before or after the label.
	         * @deprecated
	         */
	        get: function () {
	            // align refers to the checkbox relative to the label, while labelPosition refers to the
	            // label relative to the checkbox. As such, they are inverted.
	            return this.labelPosition == 'after' ? 'start' : 'end';
	        },
	        set: function (v) {
	            this.labelPosition = (v == 'start') ? 'after' : 'before';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "disabled", {
	        /** Whether the checkbox is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "checked", {
	        /**
	         * Whether the checkbox is checked. Note that setting `checked` will immediately set
	         * `indeterminate` to false.
	         */
	        get: function () {
	            return this._checked;
	        },
	        set: function (checked) {
	            if (checked != this.checked) {
	                if (this._indeterminate) {
	                    this._indeterminate = false;
	                    this.indeterminateChange.emit(this._indeterminate);
	                }
	                this._checked = checked;
	                this._transitionCheckState(this._checked ? exports.TransitionCheckState.Checked : exports.TransitionCheckState.Unchecked);
	                this._changeDetectorRef.markForCheck();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "indeterminate", {
	        /**
	         * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
	         * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
	         * checkable items. Note that whenever `checked` is set, indeterminate is immediately set to
	         * false. This differs from the web platform in that indeterminate state on native
	         * checkboxes is only remove when the user manually checks the checkbox (rather than setting the
	         * `checked` property programmatically). However, we feel that this behavior is more accommodating
	         * to the way consumers would envision using this component.
	         */
	        get: function () {
	            return this._indeterminate;
	        },
	        set: function (indeterminate) {
	            var changed = indeterminate != this._indeterminate;
	            this._indeterminate = indeterminate;
	            if (this._indeterminate) {
	                this._transitionCheckState(exports.TransitionCheckState.Indeterminate);
	            }
	            else {
	                this._transitionCheckState(this.checked ? exports.TransitionCheckState.Checked : exports.TransitionCheckState.Unchecked);
	            }
	            if (changed) {
	                this.indeterminateChange.emit(this._indeterminate);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdCheckbox.prototype, "color", {
	        /** The color of the button. Can be `primary`, `accent`, or `warn`. */
	        get: function () { return this._color; },
	        set: function (value) { this._updateColor(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdCheckbox.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdCheckbox.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    MdCheckbox.prototype._isRippleDisabled = function () {
	        return this.disableRipple || this.disabled;
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value Value to be set to the model.
	     */
	    MdCheckbox.prototype.writeValue = function (value) {
	        this.checked = !!value;
	    };
	    /**
	     * Registers a callback to be triggered when the value has changed.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Function to be called on change.
	     */
	    MdCheckbox.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback to be triggered when the control has been touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be triggered when the checkbox is touched.
	     */
	    MdCheckbox.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Sets the checkbox's disabled state. Implemented as a part of ControlValueAccessor.
	     * @param isDisabled Whether the checkbox should be disabled.
	     */
	    MdCheckbox.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    MdCheckbox.prototype._transitionCheckState = function (newState) {
	        var oldState = this._currentCheckState;
	        var renderer = this._renderer;
	        var elementRef = this._elementRef;
	        if (oldState === newState) {
	            return;
	        }
	        if (this._currentAnimationClass.length > 0) {
	            renderer.setElementClass(elementRef.nativeElement, this._currentAnimationClass, false);
	        }
	        this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
	        this._currentCheckState = newState;
	        if (this._currentAnimationClass.length > 0) {
	            renderer.setElementClass(elementRef.nativeElement, this._currentAnimationClass, true);
	        }
	    };
	    MdCheckbox.prototype._emitChangeEvent = function () {
	        var event = new MdCheckboxChange();
	        event.source = this;
	        event.checked = this.checked;
	        this._controlValueAccessorChangeFn(this.checked);
	        this.change.emit(event);
	    };
	    /** Informs the component when the input has focus so that we can style accordingly */
	    MdCheckbox.prototype._onInputFocus = function () {
	        this._hasFocus = true;
	    };
	    /** Informs the component when we lose focus in order to style accordingly */
	    MdCheckbox.prototype._onInputBlur = function () {
	        this._hasFocus = false;
	        this.onTouched();
	    };
	    /** Toggles the `checked` state of the checkbox. */
	    MdCheckbox.prototype.toggle = function () {
	        this.checked = !this.checked;
	    };
	    /**
	     * Event handler for checkbox input element.
	     * Toggles checked state if element is not disabled.
	     * @param event
	     */
	    MdCheckbox.prototype._onInteractionEvent = function (event) {
	        // We always have to stop propagation on the change event.
	        // Otherwise the change event, from the input element, will bubble up and
	        // emit its event object to the `change` output.
	        event.stopPropagation();
	        if (!this.disabled) {
	            this.toggle();
	            // Emit our custom change event if the native input emitted one.
	            // It is important to only emit it, if the native input triggered one, because
	            // we don't want to trigger a change event, when the `checked` variable changes for example.
	            this._emitChangeEvent();
	        }
	    };
	    /** Focuses the checkbox. */
	    MdCheckbox.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	        this._onInputFocus();
	    };
	    MdCheckbox.prototype._onInputClick = function (event) {
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `checkbox` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    MdCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {
	        var animSuffix;
	        switch (oldState) {
	            case exports.TransitionCheckState.Init:
	                // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or
	                // [checked] bound to it.
	                if (newState === exports.TransitionCheckState.Checked) {
	                    animSuffix = 'unchecked-checked';
	                }
	                else {
	                    return '';
	                }
	                break;
	            case exports.TransitionCheckState.Unchecked:
	                animSuffix = newState === exports.TransitionCheckState.Checked ?
	                    'unchecked-checked' : 'unchecked-indeterminate';
	                break;
	            case exports.TransitionCheckState.Checked:
	                animSuffix = newState === exports.TransitionCheckState.Unchecked ?
	                    'checked-unchecked' : 'checked-indeterminate';
	                break;
	            case exports.TransitionCheckState.Indeterminate:
	                animSuffix = newState === exports.TransitionCheckState.Checked ?
	                    'indeterminate-checked' : 'indeterminate-unchecked';
	        }
	        return "mat-checkbox-anim-" + animSuffix;
	    };
	    MdCheckbox.prototype._getHostElement = function () {
	        return this._elementRef.nativeElement;
	    };
	    __decorate$33([
	        _angular_core.Input('aria-label'), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "ariaLabel", void 0);
	    __decorate$33([
	        _angular_core.Input('aria-labelledby'), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "ariaLabelledby", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "id", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Boolean)
	    ], MdCheckbox.prototype, "disableRipple", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Boolean)
	    ], MdCheckbox.prototype, "required", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "align", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "labelPosition", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Boolean)
	    ], MdCheckbox.prototype, "disabled", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Number)
	    ], MdCheckbox.prototype, "tabIndex", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "name", void 0);
	    __decorate$33([
	        _angular_core.Output(), 
	        __metadata$33('design:type', _angular_core.EventEmitter)
	    ], MdCheckbox.prototype, "change", void 0);
	    __decorate$33([
	        _angular_core.Output(), 
	        __metadata$33('design:type', _angular_core.EventEmitter)
	    ], MdCheckbox.prototype, "indeterminateChange", void 0);
	    __decorate$33([
	        _angular_core.ViewChild('input'), 
	        __metadata$33('design:type', _angular_core.ElementRef)
	    ], MdCheckbox.prototype, "_inputElement", void 0);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "checked", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', Object)
	    ], MdCheckbox.prototype, "indeterminate", null);
	    __decorate$33([
	        _angular_core.Input(), 
	        __metadata$33('design:type', String)
	    ], MdCheckbox.prototype, "color", null);
	    MdCheckbox = __decorate$33([
	        _angular_core.Component({selector: 'md-checkbox, mat-checkbox',
	            template: "<label class=\"mat-checkbox-layout\"><div class=\"mat-checkbox-inner-container\"><input #input class=\"mat-checkbox-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [checked]=\"checked\" [disabled]=\"disabled\" [name]=\"name\" [tabIndex]=\"tabIndex\" [indeterminate]=\"indeterminate\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (focus)=\"_onInputFocus()\" (blur)=\"_onInputBlur()\" (change)=\"_onInteractionEvent($event)\" (click)=\"_onInputClick($event)\"><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-checkbox-ripple\" [mdRippleTrigger]=\"_getHostElement()\" [mdRippleCentered]=\"true\" [mdRippleSpeedFactor]=\"0.3\"></div><div class=\"mat-checkbox-frame\"></div><div class=\"mat-checkbox-background\"><svg version=\"1.1\" class=\"mat-checkbox-checkmark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" xml:space=\"preserve\"><path class=\"mat-checkbox-checkmark-path\" fill=\"none\" stroke=\"white\" d=\"M4.1,12.7 9,17.6 20.3,6.3\"/></svg><div class=\"mat-checkbox-mixedmark\"></div></div></div><span class=\"mat-checkbox-label\"><ng-content></ng-content></span></label>",
	            styles: [".mat-checkbox-frame,.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-checkmark,.mat-checkbox-frame{bottom:0;left:0;position:absolute;right:0;top:0}.mat-checkbox-checkmark,.mat-checkbox-mixedmark{width:calc(100% - 4px)}.mat-checkbox-background,.mat-checkbox-frame{border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{cursor:pointer;font-family:Roboto,\"Helvetica Neue\",sans-serif;transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-checkbox-layout{cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex}.mat-checkbox-inner-container{display:inline-block;height:20px;line-height:0;margin:auto 8px auto auto;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:20px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-checkbox-frame{transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-checkbox-checkmark{width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.67px}.mat-checkbox-checked .mat-checkbox-checkmark-path,.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-mixedmark{height:2px;opacity:0;transform:scaleX(0) rotate(0)}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none}"],
	            host: {
	                '[class.mat-checkbox]': 'true',
	                '[class.mat-checkbox-indeterminate]': 'indeterminate',
	                '[class.mat-checkbox-checked]': 'checked',
	                '[class.mat-checkbox-disabled]': 'disabled',
	                '[class.mat-checkbox-label-before]': 'labelPosition == "before"',
	                '[class.mat-checkbox-focused]': '_hasFocus',
	            },
	            providers: [MD_CHECKBOX_CONTROL_VALUE_ACCESSOR],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush
	        }), 
	        __metadata$33('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef, _angular_core.ChangeDetectorRef])
	    ], MdCheckbox);
	    return MdCheckbox;
	}());
	var MdCheckboxModule = (function () {
	    function MdCheckboxModule() {
	    }
	    /** @deprecated */
	    MdCheckboxModule.forRoot = function () {
	        return {
	            ngModule: MdCheckboxModule,
	            providers: []
	        };
	    };
	    MdCheckboxModule = __decorate$33([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [MdCheckbox, CompatibilityModule],
	            declarations: [MdCheckbox],
	        }), 
	        __metadata$33('design:paramtypes', [])
	    ], MdCheckboxModule);
	    return MdCheckboxModule;
	}());
	
	var __decorate$34 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$34 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$5 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Provider Expression that allows md-radio-group to register as a ControlValueAccessor. This
	 * allows it to support [(ngModel)] and ngControl.
	 * @docs-private
	 */
	var MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdRadioGroup; }),
	    multi: true
	};
	var _uniqueIdCounter$2 = 0;
	/** Change event object emitted by MdRadio and MdRadioGroup. */
	var MdRadioChange = (function () {
	    function MdRadioChange() {
	    }
	    return MdRadioChange;
	}());
	/**
	 * A group of radio buttons. May contain one or more `<md-radio-button>` elements.
	 */
	var MdRadioGroup = (function () {
	    function MdRadioGroup() {
	        /**
	         * Selected value for group. Should equal the value of the selected radio button if there *is*
	         * a corresponding radio button with a matching value. If there is *not* such a corresponding
	         * radio button, this value persists to be applied in case a new radio button is added with a
	         * matching value.
	         */
	        this._value = null;
	        /** The HTML name attribute applied to radio buttons in this group. */
	        this._name = "md-radio-group-" + _uniqueIdCounter$2++;
	        /** Disables all individual radio buttons assigned to this group. */
	        this._disabled = false;
	        /** The currently selected radio button. Should match value. */
	        this._selected = null;
	        /** Whether the `value` has been set to its initial value. */
	        this._isInitialized = false;
	        /** The method to be called in order to update ngModel */
	        this._controlValueAccessorChangeFn = function (value) { };
	        /**
	         * onTouch function registered via registerOnTouch (ControlValueAccessor).
	         * @docs-private
	         */
	        this.onTouched = function () { };
	        /**
	         * Event emitted when the group value changes.
	         * Change events are only emitted when the value changes due to user interaction with
	         * a radio button (the same behavior as `<input type-"radio">`).
	         */
	        this.change = new _angular_core.EventEmitter();
	        /** Child radio buttons. */
	        this._radios = null;
	        /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */
	        this.labelPosition = 'after';
	    }
	    Object.defineProperty(MdRadioGroup.prototype, "name", {
	        /** Name of the radio button group. All radio buttons inside this group will use this name. */
	        get: function () { return this._name; },
	        set: function (value) {
	            this._name = value;
	            this._updateRadioButtonNames();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioGroup.prototype, "align", {
	        /**
	         * Alignment of the radio-buttons relative to their labels. Can be 'before' or 'after'.
	         * @deprecated
	         */
	        get: function () {
	            // align refers to the checkbox relative to the label, while labelPosition refers to the
	            // label relative to the checkbox. As such, they are inverted.
	            return this.labelPosition == 'after' ? 'start' : 'end';
	        },
	        set: function (v) {
	            this.labelPosition = (v == 'start') ? 'after' : 'before';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioGroup.prototype, "disabled", {
	        /** Whether the radio button is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) {
	            // The presence of *any* disabled value makes the component disabled, *except* for false.
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioGroup.prototype, "value", {
	        /** Value of the radio button. */
	        get: function () { return this._value; },
	        set: function (newValue) {
	            if (this._value != newValue) {
	                // Set this before proceeding to ensure no circular loop occurs with selection.
	                this._value = newValue;
	                this._updateSelectedRadioFromValue();
	                this._checkSelectedRadioButton();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdRadioGroup.prototype._checkSelectedRadioButton = function () {
	        if (this.selected && !this._selected.checked) {
	            this._selected.checked = true;
	        }
	    };
	    Object.defineProperty(MdRadioGroup.prototype, "selected", {
	        /** Whether the radio button is selected. */
	        get: function () { return this._selected; },
	        set: function (selected) {
	            this._selected = selected;
	            this.value = selected ? selected.value : null;
	            this._checkSelectedRadioButton();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Initialize properties once content children are available.
	     * This allows us to propagate relevant attributes to associated buttons.
	     */
	    MdRadioGroup.prototype.ngAfterContentInit = function () {
	        // Mark this component as initialized in AfterContentInit because the initial value can
	        // possibly be set by NgModel on MdRadioGroup, and it is possible that the OnInit of the
	        // NgModel occurs *after* the OnInit of the MdRadioGroup.
	        this._isInitialized = true;
	    };
	    /**
	     * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
	     * radio buttons upon their blur.
	     */
	    MdRadioGroup.prototype._touch = function () {
	        if (this.onTouched) {
	            this.onTouched();
	        }
	    };
	    MdRadioGroup.prototype._updateRadioButtonNames = function () {
	        var _this = this;
	        if (this._radios) {
	            this._radios.forEach(function (radio) {
	                radio.name = _this.name;
	            });
	        }
	    };
	    /** Updates the `selected` radio button from the internal _value state. */
	    MdRadioGroup.prototype._updateSelectedRadioFromValue = function () {
	        var _this = this;
	        // If the value already matches the selected radio, do nothing.
	        var isAlreadySelected = this._selected != null && this._selected.value == this._value;
	        if (this._radios != null && !isAlreadySelected) {
	            this._selected = null;
	            this._radios.forEach(function (radio) {
	                radio.checked = _this.value == radio.value;
	                if (radio.checked) {
	                    _this._selected = radio;
	                }
	            });
	        }
	    };
	    /** Dispatch change event with current selection and group value. */
	    MdRadioGroup.prototype._emitChangeEvent = function () {
	        if (this._isInitialized) {
	            var event_1 = new MdRadioChange();
	            event_1.source = this._selected;
	            event_1.value = this._value;
	            this.change.emit(event_1);
	        }
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value
	     */
	    MdRadioGroup.prototype.writeValue = function (value) {
	        this.value = value;
	    };
	    /**
	     * Registers a callback to be triggered when the model value changes.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdRadioGroup.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback to be triggered when the control is touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdRadioGroup.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
	     * @param isDisabled Whether the control should be disabled.
	     */
	    MdRadioGroup.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    __decorate$34([
	        _angular_core.Output(), 
	        __metadata$34('design:type', _angular_core.EventEmitter)
	    ], MdRadioGroup.prototype, "change", void 0);
	    __decorate$34([
	        _angular_core.ContentChildren(_angular_core.forwardRef(function () { return MdRadioButton; })), 
	        __metadata$34('design:type', _angular_core.QueryList)
	    ], MdRadioGroup.prototype, "_radios", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', String)
	    ], MdRadioGroup.prototype, "name", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "align", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "labelPosition", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioGroup.prototype, "disabled", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "value", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioGroup.prototype, "selected", null);
	    MdRadioGroup = __decorate$34([
	        _angular_core.Directive({
	            selector: 'md-radio-group, mat-radio-group',
	            providers: [MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],
	            host: {
	                'role': 'radiogroup',
	                '[class.mat-radio-group]': 'true',
	            },
	        }), 
	        __metadata$34('design:paramtypes', [])
	    ], MdRadioGroup);
	    return MdRadioGroup;
	}());
	/**
	 * A radio-button. May be inside of
	 */
	var MdRadioButton = (function () {
	    function MdRadioButton(radioGroup, _elementRef, _renderer, radioDispatcher) {
	        // Assertions. Ideally these should be stripped out by the compiler.
	        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.
	        var _this = this;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this.radioDispatcher = radioDispatcher;
	        /** Whether this radio is checked. */
	        this._checked = false;
	        /** The unique ID for the radio button. */
	        this.id = "md-radio-" + _uniqueIdCounter$2++;
	        /** Value assigned to this radio.*/
	        this._value = null;
	        /**
	         * Event emitted when the checked state of this radio button changes.
	         * Change events are only emitted when the value changes due to user interaction with
	         * the radio button (the same behavior as `<input type-"radio">`).
	         */
	        this.change = new _angular_core.EventEmitter();
	        this.radioGroup = radioGroup;
	        radioDispatcher.listen(function (id, name) {
	            if (id != _this.id && name == _this.name) {
	                _this.checked = false;
	            }
	        });
	    }
	    Object.defineProperty(MdRadioButton.prototype, "disableRipple", {
	        /** Whether the ripple effect for this radio button is disabled. */
	        get: function () { return this._disableRipple; },
	        set: function (value) { this._disableRipple = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "inputId", {
	        /** ID of the native input element inside `<md-radio-button>` */
	        get: function () {
	            return this.id + "-input";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "checked", {
	        /** Whether this radio button is checked. */
	        get: function () {
	            return this._checked;
	        },
	        set: function (newCheckedState) {
	            if (this._checked != newCheckedState) {
	                this._checked = newCheckedState;
	                if (newCheckedState && this.radioGroup && this.radioGroup.value != this.value) {
	                    this.radioGroup.selected = this;
	                }
	                else if (!newCheckedState && this.radioGroup && this.radioGroup.value == this.value) {
	                    // When unchecking the selected radio button, update the selected radio
	                    // property on the group.
	                    this.radioGroup.selected = null;
	                }
	                if (newCheckedState) {
	                    // Notify all radio buttons with the same name to un-check.
	                    this.radioDispatcher.notify(this.id, this.name);
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "value", {
	        /** The value of this radio button. */
	        get: function () {
	            return this._value;
	        },
	        set: function (value) {
	            if (this._value != value) {
	                this._value = value;
	                if (this.radioGroup != null) {
	                    if (!this.checked) {
	                        // Update checked when the value changed to match the radio group's value
	                        this.checked = this.radioGroup.value == value;
	                    }
	                    if (this.checked) {
	                        this.radioGroup.selected = this;
	                    }
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "align", {
	        /**
	         * Whether or not the radio-button should appear before or after the label.
	         * @deprecated
	         */
	        get: function () {
	            // align refers to the checkbox relative to the label, while labelPosition refers to the
	            // label relative to the checkbox. As such, they are inverted.
	            return this.labelPosition == 'after' ? 'start' : 'end';
	        },
	        set: function (v) {
	            this.labelPosition = (v == 'start') ? 'after' : 'before';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "labelPosition", {
	        /** Whether the label should appear after or before the radio button. Defaults to 'after' */
	        get: function () {
	            return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';
	        },
	        set: function (value) {
	            this._labelPosition = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdRadioButton.prototype, "disabled", {
	        /** Whether the radio button is disabled. */
	        get: function () {
	            return this._disabled || (this.radioGroup != null && this.radioGroup.disabled);
	        },
	        set: function (value) {
	            // The presence of *any* disabled value makes the component disabled, *except* for false.
	            this._disabled = (value != null && value !== false) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdRadioButton.prototype.ngOnInit = function () {
	        if (this.radioGroup) {
	            // If the radio is inside a radio group, determine if it should be checked
	            this.checked = this.radioGroup.value === this._value;
	            // Copy name from parent radio group
	            this.name = this.radioGroup.name;
	        }
	    };
	    /** Dispatch change event with current value. */
	    MdRadioButton.prototype._emitChangeEvent = function () {
	        var event = new MdRadioChange();
	        event.source = this;
	        event.value = this._value;
	        this.change.emit(event);
	    };
	    MdRadioButton.prototype._isRippleDisabled = function () {
	        return this.disableRipple || this.disabled;
	    };
	    /**
	     * We use a hidden native input field to handle changes to focus state via keyboard navigation,
	     * with visual rendering done separately. The native element is kept in sync with the overall
	     * state of the component.
	     */
	    MdRadioButton.prototype._onInputFocus = function () {
	        this._isFocused = true;
	    };
	    /** Focuses the radio button. */
	    MdRadioButton.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	        this._onInputFocus();
	    };
	    MdRadioButton.prototype._onInputBlur = function () {
	        this._isFocused = false;
	        if (this.radioGroup) {
	            this.radioGroup._touch();
	        }
	    };
	    MdRadioButton.prototype._onInputClick = function (event) {
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `radio-button` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    /**
	     * Triggered when the radio button received a click or the input recognized any change.
	     * Clicking on a label element, will trigger a change event on the associated input.
	     */
	    MdRadioButton.prototype._onInputChange = function (event) {
	        // We always have to stop propagation on the change event.
	        // Otherwise the change event, from the input element, will bubble up and
	        // emit its event object to the `change` output.
	        event.stopPropagation();
	        var groupValueChanged = this.radioGroup && this.value != this.radioGroup.value;
	        this.checked = true;
	        this._emitChangeEvent();
	        if (this.radioGroup) {
	            this.radioGroup._controlValueAccessorChangeFn(this.value);
	            this.radioGroup._touch();
	            if (groupValueChanged) {
	                this.radioGroup._emitChangeEvent();
	            }
	        }
	    };
	    __decorate$34([
	        _angular_core.HostBinding('class.mat-radio-focused'), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "_isFocused", void 0);
	    __decorate$34([
	        _angular_core.HostBinding('id'),
	        _angular_core.Input(), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "id", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "name", void 0);
	    __decorate$34([
	        _angular_core.Input('aria-label'), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "ariaLabel", void 0);
	    __decorate$34([
	        _angular_core.Input('aria-labelledby'), 
	        __metadata$34('design:type', String)
	    ], MdRadioButton.prototype, "ariaLabelledby", void 0);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "disableRipple", null);
	    __decorate$34([
	        _angular_core.Output(), 
	        __metadata$34('design:type', _angular_core.EventEmitter)
	    ], MdRadioButton.prototype, "change", void 0);
	    __decorate$34([
	        _angular_core.ViewChild('input'), 
	        __metadata$34('design:type', _angular_core.ElementRef)
	    ], MdRadioButton.prototype, "_inputElement", void 0);
	    __decorate$34([
	        _angular_core.HostBinding('class.mat-radio-checked'),
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "checked", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioButton.prototype, "value", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioButton.prototype, "align", null);
	    __decorate$34([
	        _angular_core.Input(), 
	        __metadata$34('design:type', Object)
	    ], MdRadioButton.prototype, "labelPosition", null);
	    __decorate$34([
	        _angular_core.HostBinding('class.mat-radio-disabled'),
	        _angular_core.Input(), 
	        __metadata$34('design:type', Boolean)
	    ], MdRadioButton.prototype, "disabled", null);
	    MdRadioButton = __decorate$34([
	        _angular_core.Component({selector: 'md-radio-button, mat-radio-button',
	            template: "<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label><div class=\"mat-radio-container\"><div class=\"mat-radio-outer-circle\"></div><div class=\"mat-radio-inner-circle\"></div><div md-ripple *ngIf=\"!_isRippleDisabled()\" class=\"mat-radio-ripple\" [mdRippleTrigger]=\"label\" [mdRippleCentered]=\"true\" [mdRippleSpeedFactor]=\"0.3\"></div></div><input #input class=\"mat-radio-input cdk-visually-hidden\" type=\"radio\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [name]=\"name\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (change)=\"_onInputChange($event)\" (focus)=\"_onInputFocus()\" (blur)=\"_onInputBlur()\" (click)=\"_onInputClick($event)\"><div class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\"><ng-content></ng-content></div></label>",
	            styles: [".mat-radio-button{display:inline-block;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-radio-label{cursor:pointer;display:inline-flex;align-items:baseline;white-space:nowrap}.mat-radio-container{box-sizing:border-box;display:inline-block;height:20px;position:relative;width:20px;top:2px}.mat-radio-inner-circle,.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;top:0;width:20px;position:absolute;border-radius:50%}.mat-radio-outer-circle{transition:border-color ease 280ms;border-width:2px;border-style:solid}.mat-radio-inner-circle{transition:transform ease 280ms,background-color ease 280ms;transform:scale(0)}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}.mat-radio-label-content{display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-ripple{position:absolute;left:-15px;top:-15px;right:-15px;bottom:-15px;border-radius:50%;z-index:1;pointer-events:none}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                '[class.mat-radio-button]': 'true',
	            }
	        }),
	        __param$5(0, _angular_core.Optional()), 
	        __metadata$34('design:paramtypes', [MdRadioGroup, _angular_core.ElementRef, _angular_core.Renderer, UniqueSelectionDispatcher])
	    ], MdRadioButton);
	    return MdRadioButton;
	}());
	var MdRadioModule = (function () {
	    function MdRadioModule() {
	    }
	    /** @deprecated */
	    MdRadioModule.forRoot = function () {
	        return {
	            ngModule: MdRadioModule,
	            providers: [],
	        };
	    };
	    MdRadioModule = __decorate$34([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [MdRadioGroup, MdRadioButton, CompatibilityModule],
	            providers: [UNIQUE_SELECTION_DISPATCHER_PROVIDER, VIEWPORT_RULER_PROVIDER],
	            declarations: [MdRadioGroup, MdRadioButton],
	        }), 
	        __metadata$34('design:paramtypes', [])
	    ], MdRadioModule);
	    return MdRadioModule;
	}());
	
	/**
	 * This class manages keyboard events for selectable lists. If you pass it a query list
	 * of items, it will set the active item correctly when arrow events occur.
	 */
	var ListKeyManager = (function () {
	    function ListKeyManager(_items) {
	        this._items = _items;
	        this._tabOut = new rxjs_Subject.Subject();
	        this._wrap = false;
	    }
	    /**
	     * Turns on wrapping mode, which ensures that the active item will wrap to
	     * the other end of list when there are no more items in the given direction.
	     *
	     * @returns The ListKeyManager that the method was called on.
	     */
	    ListKeyManager.prototype.withWrap = function () {
	        this._wrap = true;
	        return this;
	    };
	    /**
	     * Sets the active item to the item at the index specified.
	     *
	     * @param index The index of the item to be set as active.
	     */
	    ListKeyManager.prototype.setActiveItem = function (index) {
	        this._activeItemIndex = index;
	        this._activeItem = this._items.toArray()[index];
	    };
	    /**
	     * Sets the active item depending on the key event passed in.
	     * @param event Keyboard event to be used for determining which element should be active.
	     */
	    ListKeyManager.prototype.onKeydown = function (event) {
	        switch (event.keyCode) {
	            case DOWN_ARROW:
	                this.setNextItemActive();
	                break;
	            case UP_ARROW:
	                this.setPreviousItemActive();
	                break;
	            case HOME:
	                this.setFirstItemActive();
	                break;
	            case END:
	                this.setLastItemActive();
	                break;
	            case TAB:
	                // Note that we shouldn't prevent the default action on tab.
	                this._tabOut.next(null);
	                return;
	            default:
	                return;
	        }
	        event.preventDefault();
	    };
	    Object.defineProperty(ListKeyManager.prototype, "activeItemIndex", {
	        /** Returns the index of the currently active item. */
	        get: function () {
	            return this._activeItemIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ListKeyManager.prototype, "activeItem", {
	        /** Returns the currently active item. */
	        get: function () {
	            return this._activeItem;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Sets the active item to the first enabled item in the list. */
	    ListKeyManager.prototype.setFirstItemActive = function () {
	        this._setActiveItemByIndex(0, 1);
	    };
	    /** Sets the active item to the last enabled item in the list. */
	    ListKeyManager.prototype.setLastItemActive = function () {
	        this._setActiveItemByIndex(this._items.length - 1, -1);
	    };
	    /** Sets the active item to the next enabled item in the list. */
	    ListKeyManager.prototype.setNextItemActive = function () {
	        this._activeItemIndex === null ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
	    };
	    /** Sets the active item to a previous enabled item in the list. */
	    ListKeyManager.prototype.setPreviousItemActive = function () {
	        this._activeItemIndex === null && this._wrap ? this.setLastItemActive()
	            : this._setActiveItemByDelta(-1);
	    };
	    /**
	     * Allows setting of the activeItemIndex without any other effects.
	     * @param index The new activeItemIndex.
	     */
	    ListKeyManager.prototype.updateActiveItemIndex = function (index) {
	        this._activeItemIndex = index;
	    };
	    Object.defineProperty(ListKeyManager.prototype, "tabOut", {
	        /**
	         * Observable that emits any time the TAB key is pressed, so components can react
	         * when focus is shifted off of the list.
	         */
	        get: function () {
	            return this._tabOut.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * This method sets the active item, given a list of items and the delta between the
	     * currently active item and the new active item. It will calculate differently
	     * depending on whether wrap mode is turned on.
	     */
	    ListKeyManager.prototype._setActiveItemByDelta = function (delta, items) {
	        if (items === void 0) { items = this._items.toArray(); }
	        this._wrap ? this._setActiveInWrapMode(delta, items)
	            : this._setActiveInDefaultMode(delta, items);
	    };
	    /**
	     * Sets the active item properly given "wrap" mode. In other words, it will continue to move
	     * down the list until it finds an item that is not disabled, and it will wrap if it
	     * encounters either end of the list.
	     */
	    ListKeyManager.prototype._setActiveInWrapMode = function (delta, items) {
	        // when active item would leave menu, wrap to beginning or end
	        this._activeItemIndex =
	            (this._activeItemIndex + delta + items.length) % items.length;
	        // skip all disabled menu items recursively until an enabled one is reached
	        if (items[this._activeItemIndex].disabled) {
	            this._setActiveInWrapMode(delta, items);
	        }
	        else {
	            this.setActiveItem(this._activeItemIndex);
	        }
	    };
	    /**
	     * Sets the active item properly given the default mode. In other words, it will
	     * continue to move down the list until it finds an item that is not disabled. If
	     * it encounters either end of the list, it will stop and not wrap.
	     */
	    ListKeyManager.prototype._setActiveInDefaultMode = function (delta, items) {
	        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);
	    };
	    /**
	     * Sets the active item to the first enabled item starting at the index specified. If the
	     * item is disabled, it will move in the fallbackDelta direction until it either
	     * finds an enabled item or encounters the end of the list.
	     */
	    ListKeyManager.prototype._setActiveItemByIndex = function (index, fallbackDelta, items) {
	        if (items === void 0) { items = this._items.toArray(); }
	        if (!items[index]) {
	            return;
	        }
	        while (items[index].disabled) {
	            index += fallbackDelta;
	            if (!items[index]) {
	                return;
	            }
	        }
	        this.setActiveItem(index);
	    };
	    return ListKeyManager;
	}());
	
	var __extends$8 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var FocusKeyManager = (function (_super) {
	    __extends$8(FocusKeyManager, _super);
	    function FocusKeyManager(items) {
	        _super.call(this, items);
	    }
	    /**
	     * This method sets the active item to the item at the specified index.
	     * It also adds focuses the newly active item.
	     */
	    FocusKeyManager.prototype.setActiveItem = function (index) {
	        _super.prototype.setActiveItem.call(this, index);
	        this.activeItem.focus();
	    };
	    return FocusKeyManager;
	}(ListKeyManager));
	
	/**
	 * The following are all the animations for the md-select component, with each
	 * const containing the metadata for one animation.
	 *
	 * The values below match the implementation of the AngularJS Material md-select animation.
	 */
	/**
	 * This animation shrinks the placeholder text to 75% of its normal size and translates
	 * it to either the top left corner (ltr) or top right corner (rtl) of the trigger,
	 * depending on the text direction of the application.
	 */
	var transformPlaceholder = _angular_core.trigger('transformPlaceholder', [
	    _angular_core.state('floating-ltr', _angular_core.style({
	        top: '-22px',
	        left: '-2px',
	        transform: "scale(0.75)"
	    })),
	    _angular_core.state('floating-rtl', _angular_core.style({
	        top: '-22px',
	        left: '2px',
	        transform: "scale(0.75)"
	    })),
	    _angular_core.transition('* => *', _angular_core.animate("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))
	]);
	/**
	 * This animation transforms the select's overlay panel on and off the page.
	 *
	 * When the panel is attached to the DOM, it expands its width 32px, scales it up to
	 * 100% on the Y axis, fades in its border, and translates slightly up and to the
	 * side to ensure the option text correctly overlaps the trigger text.
	 *
	 * When the panel is removed from the DOM, it simply fades out linearly.
	 */
	var transformPanel = _angular_core.trigger('transformPanel', [
	    _angular_core.state('showing', _angular_core.style({
	        opacity: 1,
	        minWidth: 'calc(100% + 32px)',
	        transform: "translate3d(0,0,0) scaleY(1)"
	    })),
	    _angular_core.transition('void => *', [
	        _angular_core.style({
	            opacity: 0,
	            minWidth: '100%',
	            transform: "translate3d(0, 0, 0) scaleY(0)"
	        }),
	        _angular_core.animate("150ms cubic-bezier(0.25, 0.8, 0.25, 1)")
	    ]),
	    _angular_core.transition('* => void', [
	        _angular_core.animate('250ms 100ms linear', _angular_core.style({ opacity: 0 }))
	    ])
	]);
	/**
	 * This animation fades in the background color and text content of the
	 * select's options. It is time delayed to occur 100ms after the overlay
	 * panel has transformed in.
	 */
	var fadeInContent = _angular_core.trigger('fadeInContent', [
	    _angular_core.state('showing', _angular_core.style({ opacity: 1 })),
	    _angular_core.transition('void => showing', [
	        _angular_core.style({ opacity: 0 }),
	        _angular_core.animate("150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
	    ])
	]);
	
	var __decorate$36 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$36 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$6 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * The following style constants are necessary to save here in order
	 * to properly calculate the alignment of the selected option over
	 * the trigger element.
	 */
	/** The fixed height of every option element. */
	var SELECT_OPTION_HEIGHT = 48;
	/** The max height of the select's overlay panel */
	var SELECT_PANEL_MAX_HEIGHT = 256;
	/** The max number of options visible at once in the select panel. */
	var SELECT_MAX_OPTIONS_DISPLAYED = 5;
	/** The fixed height of the select's trigger element. */
	var SELECT_TRIGGER_HEIGHT = 30;
	/**
	 * Must adjust for the difference in height between the option and the trigger,
	 * so the text will align on the y axis.
	 * (SELECT_OPTION_HEIGHT (48) - SELECT_TRIGGER_HEIGHT (30)) / 2 = 9
	 */
	var SELECT_OPTION_HEIGHT_ADJUSTMENT = 9;
	/** The panel's padding on the x-axis */
	var SELECT_PANEL_PADDING_X = 16;
	/**
	 * The panel's padding on the y-axis. This padding indicates there are more
	 * options available if you scroll.
	 */
	var SELECT_PANEL_PADDING_Y = 16;
	/**
	 * The select panel will only "fit" inside the viewport if it is positioned at
	 * this value or more away from the viewport boundary.
	 */
	var SELECT_PANEL_VIEWPORT_PADDING = 8;
	/** Change event object that is emitted when the select value has changed. */
	var MdSelectChange = (function () {
	    function MdSelectChange(source, value) {
	        this.source = source;
	        this.value = value;
	    }
	    return MdSelectChange;
	}());
	var MdSelect = (function () {
	    function MdSelect(_element, _renderer, _viewportRuler, _changeDetectorRef, _dir, _control) {
	        this._element = _element;
	        this._renderer = _renderer;
	        this._viewportRuler = _viewportRuler;
	        this._changeDetectorRef = _changeDetectorRef;
	        this._dir = _dir;
	        this._control = _control;
	        /** Whether or not the overlay panel is open. */
	        this._panelOpen = false;
	        /** Subscriptions to option events. */
	        this._subscriptions = [];
	        /** Whether filling out the select is required in the form.  */
	        this._required = false;
	        /** Whether the select is disabled.  */
	        this._disabled = false;
	        /** The scroll position of the overlay panel, calculated to center the selected option. */
	        this._scrollTop = 0;
	        /** The animation state of the placeholder. */
	        this._placeholderState = '';
	        /** View -> model callback called when value changes */
	        this._onChange = function (value) { };
	        /** View -> model callback called when select has been touched */
	        this._onTouched = function () { };
	        /** The IDs of child options to be passed to the aria-owns attribute. */
	        this._optionIds = '';
	        /** The value of the select panel's transform-origin property. */
	        this._transformOrigin = 'top';
	        /** Whether the panel's animation is done. */
	        this._panelDoneAnimating = false;
	        /**
	         * The x-offset of the overlay panel in relation to the trigger's top start corner.
	         * This must be adjusted to align the selected option text over the trigger text when
	         * the panel opens. Will change based on LTR or RTL text direction.
	         */
	        this._offsetX = 0;
	        /**
	         * The y-offset of the overlay panel in relation to the trigger's top start corner.
	         * This must be adjusted to align the selected option text over the trigger text.
	         * when the panel opens. Will change based on the y-position of the selected option.
	         */
	        this._offsetY = 0;
	        /**
	         * This position config ensures that the top "start" corner of the overlay
	         * is aligned with with the top "start" of the origin by default (overlapping
	         * the trigger completely). If the panel cannot fit below the trigger, it
	         * will fall back to a position above the trigger.
	         */
	        this._positions = [
	            {
	                originX: 'start',
	                originY: 'top',
	                overlayX: 'start',
	                overlayY: 'top',
	            },
	            {
	                originX: 'start',
	                originY: 'bottom',
	                overlayX: 'start',
	                overlayY: 'bottom',
	            },
	        ];
	        /** Event emitted when the select has been opened. */
	        this.onOpen = new _angular_core.EventEmitter();
	        /** Event emitted when the select has been closed. */
	        this.onClose = new _angular_core.EventEmitter();
	        /** Event emitted when the selected value has been changed by the user. */
	        this.change = new _angular_core.EventEmitter();
	        if (this._control) {
	            this._control.valueAccessor = this;
	        }
	    }
	    Object.defineProperty(MdSelect.prototype, "placeholder", {
	        /** Placeholder to be shown if no value has been selected. */
	        get: function () { return this._placeholder; },
	        set: function (value) {
	            var _this = this;
	            this._placeholder = value;
	            // Must wait to record the trigger width to ensure placeholder width is included.
	            Promise.resolve(null).then(function () { return _this._triggerWidth = _this._getWidth(); });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSelect.prototype, "disabled", {
	        /** Whether the component is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSelect.prototype, "required", {
	        /** Whether the component is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdSelect.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._initKeyManager();
	        this._changeSubscription = this.options.changes.startWith(null).subscribe(function () {
	            _this._resetOptions();
	            if (_this._control) {
	                // Defer setting the value in order to avoid the "Expression
	                // has changed after it was checked" errors from Angular.
	                Promise.resolve(null).then(function () { return _this._setSelectionByValue(_this._control.value); });
	            }
	        });
	    };
	    MdSelect.prototype.ngOnDestroy = function () {
	        this._dropSubscriptions();
	        if (this._changeSubscription) {
	            this._changeSubscription.unsubscribe();
	        }
	        if (this._tabSubscription) {
	            this._tabSubscription.unsubscribe();
	        }
	    };
	    /** Toggles the overlay panel open or closed. */
	    MdSelect.prototype.toggle = function () {
	        this.panelOpen ? this.close() : this.open();
	    };
	    /** Opens the overlay panel. */
	    MdSelect.prototype.open = function () {
	        if (this.disabled || !this.options.length) {
	            return;
	        }
	        this._calculateOverlayPosition();
	        this._placeholderState = this._isRtl() ? 'floating-rtl' : 'floating-ltr';
	        this._panelOpen = true;
	    };
	    /** Closes the overlay panel and focuses the host element. */
	    MdSelect.prototype.close = function () {
	        this._panelOpen = false;
	        if (!this._selected) {
	            this._placeholderState = '';
	        }
	        this._focusHost();
	    };
	    /**
	     * Sets the select's value. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param value New value to be written to the model.
	     */
	    MdSelect.prototype.writeValue = function (value) {
	        if (this.options) {
	            this._setSelectionByValue(value);
	            this._changeDetectorRef.markForCheck();
	        }
	    };
	    /**
	     * Saves a callback function to be invoked when the select's value
	     * changes from user input. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the value changes.
	     */
	    MdSelect.prototype.registerOnChange = function (fn) {
	        this._onChange = fn;
	    };
	    /**
	     * Saves a callback function to be invoked when the select is blurred
	     * by the user. Part of the ControlValueAccessor interface required
	     * to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the component has been touched.
	     */
	    MdSelect.prototype.registerOnTouched = function (fn) {
	        this._onTouched = fn;
	    };
	    /**
	     * Disables the select. Part of the ControlValueAccessor interface required
	     * to integrate with Angular's core forms API.
	     *
	     * @param isDisabled Sets whether the component is disabled.
	     */
	    MdSelect.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    Object.defineProperty(MdSelect.prototype, "panelOpen", {
	        /** Whether or not the overlay panel is open. */
	        get: function () {
	            return this._panelOpen;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSelect.prototype, "selected", {
	        /** The currently selected option. */
	        get: function () {
	            return this._selected;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdSelect.prototype._isRtl = function () {
	        return this._dir ? this._dir.value === 'rtl' : false;
	    };
	    /** The width of the trigger element. This is necessary to match
	     * the overlay width to the trigger width.
	     */
	    MdSelect.prototype._getWidth = function () {
	        return this._getTriggerRect().width;
	    };
	    /** Ensures the panel opens if activated by the keyboard. */
	    MdSelect.prototype._handleKeydown = function (event) {
	        if (event.keyCode === ENTER || event.keyCode === SPACE) {
	            this.open();
	        }
	    };
	    /**
	     * When the panel element is finished transforming in (though not fading in), it
	     * emits an event and focuses an option if the panel is open.
	     */
	    MdSelect.prototype._onPanelDone = function () {
	        if (this.panelOpen) {
	            this._focusCorrectOption();
	            this.onOpen.emit();
	        }
	        else {
	            this.onClose.emit();
	        }
	    };
	    /**
	     * When the panel content is done fading in, the _panelDoneAnimating property is
	     * set so the proper class can be added to the panel.
	     */
	    MdSelect.prototype._onFadeInDone = function () {
	        this._panelDoneAnimating = this.panelOpen;
	    };
	    /**
	     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
	     * "blur" to the panel when it opens, causing a false positive.
	     */
	    MdSelect.prototype._onBlur = function () {
	        if (!this.panelOpen) {
	            this._onTouched();
	        }
	    };
	    /** Returns the correct tabindex for the select depending on disabled state. */
	    MdSelect.prototype._getTabIndex = function () {
	        return this.disabled ? '-1' : '0';
	    };
	    /**
	     * Sets the scroll position of the scroll container. This must be called after
	     * the overlay pane is attached or the scroll container element will not yet be
	     * present in the DOM.
	     */
	    MdSelect.prototype._setScrollTop = function () {
	        var scrollContainer = this.overlayDir.overlayRef.overlayElement.querySelector('.mat-select-panel');
	        scrollContainer.scrollTop = this._scrollTop;
	    };
	    /**
	     * Sets the selected option based on a value. If no option can be
	     * found with the designated value, the select trigger is cleared.
	     */
	    MdSelect.prototype._setSelectionByValue = function (value) {
	        var options = this.options.toArray();
	        for (var i = 0; i < this.options.length; i++) {
	            if (options[i].value === value) {
	                options[i].select();
	                return;
	            }
	        }
	        // Clear selection if no item was selected.
	        this._clearSelection();
	    };
	    /** Clears the select trigger and deselects every option in the list. */
	    MdSelect.prototype._clearSelection = function () {
	        this._selected = null;
	        this._updateOptions();
	    };
	    MdSelect.prototype._getTriggerRect = function () {
	        return this.trigger.nativeElement.getBoundingClientRect();
	    };
	    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
	    MdSelect.prototype._initKeyManager = function () {
	        var _this = this;
	        this._keyManager = new FocusKeyManager(this.options);
	        this._tabSubscription = this._keyManager.tabOut.subscribe(function () {
	            _this.close();
	        });
	    };
	    /** Drops current option subscriptions and IDs and resets from scratch. */
	    MdSelect.prototype._resetOptions = function () {
	        this._dropSubscriptions();
	        this._listenToOptions();
	        this._setOptionIds();
	    };
	    /** Listens to selection events on each option. */
	    MdSelect.prototype._listenToOptions = function () {
	        var _this = this;
	        this.options.forEach(function (option) {
	            var sub = option.onSelect.subscribe(function (event) {
	                if (event.isUserInput && _this._selected !== option) {
	                    _this._emitChangeEvent(option);
	                }
	                _this._onSelect(option);
	            });
	            _this._subscriptions.push(sub);
	        });
	    };
	    /** Unsubscribes from all option subscriptions. */
	    MdSelect.prototype._dropSubscriptions = function () {
	        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
	        this._subscriptions = [];
	    };
	    /** Emits an event when the user selects an option. */
	    MdSelect.prototype._emitChangeEvent = function (option) {
	        this._onChange(option.value);
	        this.change.emit(new MdSelectChange(this, option.value));
	    };
	    /** Records option IDs to pass to the aria-owns property. */
	    MdSelect.prototype._setOptionIds = function () {
	        this._optionIds = this.options.map(function (option) { return option.id; }).join(' ');
	    };
	    /** When a new option is selected, deselects the others and closes the panel. */
	    MdSelect.prototype._onSelect = function (option) {
	        this._selected = option;
	        this._updateOptions();
	        this._setValueWidth();
	        this._placeholderState = '';
	        if (this.panelOpen) {
	            this.close();
	        }
	    };
	    /** Deselect each option that doesn't match the current selection. */
	    MdSelect.prototype._updateOptions = function () {
	        var _this = this;
	        this.options.forEach(function (option) {
	            if (option !== _this.selected) {
	                option.deselect();
	            }
	        });
	    };
	    /**
	     * Must set the width of the selected option's value programmatically
	     * because it is absolutely positioned and otherwise will not clip
	     * overflow. The selection arrow is 9px wide, add 4px of padding = 13
	     */
	    MdSelect.prototype._setValueWidth = function () {
	        this._selectedValueWidth = this._triggerWidth - 13;
	    };
	    /** Focuses the selected item. If no option is selected, it will focus
	     * the first item instead.
	     */
	    MdSelect.prototype._focusCorrectOption = function () {
	        if (this.selected) {
	            this._keyManager.setActiveItem(this._getOptionIndex(this.selected));
	        }
	        else {
	            this._keyManager.setFirstItemActive();
	        }
	    };
	    /** Focuses the host element when the panel closes. */
	    MdSelect.prototype._focusHost = function () {
	        this._renderer.invokeElementMethod(this._element.nativeElement, 'focus');
	    };
	    /** Gets the index of the provided option in the option list. */
	    MdSelect.prototype._getOptionIndex = function (option) {
	        return this.options.reduce(function (result, current, index) {
	            return result === undefined ? (option === current ? index : undefined) : result;
	        }, undefined);
	    };
	    /** Calculates the scroll position and x- and y-offsets of the overlay panel. */
	    MdSelect.prototype._calculateOverlayPosition = function () {
	        this._offsetX = this._isRtl() ? SELECT_PANEL_PADDING_X : -SELECT_PANEL_PADDING_X;
	        var panelHeight = Math.min(this.options.length * SELECT_OPTION_HEIGHT, SELECT_PANEL_MAX_HEIGHT);
	        var scrollContainerHeight = this.options.length * SELECT_OPTION_HEIGHT;
	        // The farthest the panel can be scrolled before it hits the bottom
	        var maxScroll = scrollContainerHeight - panelHeight;
	        if (this.selected) {
	            var selectedIndex = this._getOptionIndex(this.selected);
	            // We must maintain a scroll buffer so the selected option will be scrolled to the
	            // center of the overlay panel rather than the top.
	            var scrollBuffer = panelHeight / 2;
	            this._scrollTop = this._calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll);
	            this._offsetY = this._calculateOverlayOffset(selectedIndex, scrollBuffer, maxScroll);
	        }
	        else {
	            // If no option is selected, the panel centers on the first option. In this case,
	            // we must only adjust for the height difference between the option element
	            // and the trigger element, then multiply it by -1 to ensure the panel moves
	            // in the correct direction up the page.
	            this._offsetY = (SELECT_OPTION_HEIGHT - SELECT_TRIGGER_HEIGHT) / 2 * -1;
	        }
	        this._checkOverlayWithinViewport(maxScroll);
	    };
	    /**
	     * Calculates the scroll position of the select's overlay panel.
	     *
	     * Attempts to center the selected option in the panel. If the option is
	     * too high or too low in the panel to be scrolled to the center, it clamps the
	     * scroll position to the min or max scroll positions respectively.
	     */
	    MdSelect.prototype._calculateOverlayScroll = function (selectedIndex, scrollBuffer, maxScroll) {
	        var optionOffsetFromScrollTop = SELECT_OPTION_HEIGHT * selectedIndex;
	        var halfOptionHeight = SELECT_OPTION_HEIGHT / 2;
	        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the
	        // scroll container, then subtracts the scroll buffer to scroll the option down to
	        // the center of the overlay panel. Half the option height must be re-added to the
	        // scrollTop so the option is centered based on its middle, not its top edge.
	        var optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;
	        return clampValue(0, optimalScrollPosition, maxScroll);
	    };
	    /**
	     * Calculates the y-offset of the select's overlay panel in relation to the
	     * top start corner of the trigger. It has to be adjusted in order for the
	     * selected option to be aligned over the trigger when the panel opens.
	     */
	    MdSelect.prototype._calculateOverlayOffset = function (selectedIndex, scrollBuffer, maxScroll) {
	        var optionOffsetFromPanelTop;
	        if (this._scrollTop === 0) {
	            optionOffsetFromPanelTop = selectedIndex * SELECT_OPTION_HEIGHT;
	        }
	        else if (this._scrollTop === maxScroll) {
	            var firstDisplayedIndex = this.options.length - SELECT_MAX_OPTIONS_DISPLAYED;
	            var selectedDisplayIndex = selectedIndex - firstDisplayedIndex;
	            // Because the panel height is longer than the height of the options alone,
	            // there is always extra padding at the top or bottom of the panel. When
	            // scrolled to the very bottom, this padding is at the top of the panel and
	            // must be added to the offset.
	            optionOffsetFromPanelTop =
	                selectedDisplayIndex * SELECT_OPTION_HEIGHT + SELECT_PANEL_PADDING_Y;
	        }
	        else {
	            // If the option was scrolled to the middle of the panel using a scroll buffer,
	            // its offset will be the scroll buffer minus the half height that was added to
	            // center it.
	            optionOffsetFromPanelTop = scrollBuffer - SELECT_OPTION_HEIGHT / 2;
	        }
	        // The final offset is the option's offset from the top, adjusted for the height
	        // difference, multiplied by -1 to ensure that the overlay moves in the correct
	        // direction up the page.
	        return optionOffsetFromPanelTop * -1 - SELECT_OPTION_HEIGHT_ADJUSTMENT;
	    };
	    /**
	     * Checks that the attempted overlay position will fit within the viewport.
	     * If it will not fit, tries to adjust the scroll position and the associated
	     * y-offset so the panel can open fully on-screen. If it still won't fit,
	     * sets the offset back to 0 to allow the fallback position to take over.
	     */
	    MdSelect.prototype._checkOverlayWithinViewport = function (maxScroll) {
	        var viewportRect = this._viewportRuler.getViewportRect();
	        var triggerRect = this._getTriggerRect();
	        var topSpaceAvailable = triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;
	        var bottomSpaceAvailable = viewportRect.height - triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;
	        var panelHeightTop = Math.abs(this._offsetY);
	        var totalPanelHeight = Math.min(this.options.length * SELECT_OPTION_HEIGHT, SELECT_PANEL_MAX_HEIGHT);
	        var panelHeightBottom = totalPanelHeight - panelHeightTop - triggerRect.height;
	        if (panelHeightBottom > bottomSpaceAvailable) {
	            this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);
	        }
	        else if (panelHeightTop > topSpaceAvailable) {
	            this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);
	        }
	        else {
	            this._transformOrigin = this._getOriginBasedOnOption();
	        }
	    };
	    /** Adjusts the overlay panel up to fit in the viewport. */
	    MdSelect.prototype._adjustPanelUp = function (panelHeightBottom, bottomSpaceAvailable) {
	        var distanceBelowViewport = panelHeightBottom - bottomSpaceAvailable;
	        // Scrolls the panel up by the distance it was extending past the boundary, then
	        // adjusts the offset by that amount to move the panel up into the viewport.
	        this._scrollTop -= distanceBelowViewport;
	        this._offsetY -= distanceBelowViewport;
	        this._transformOrigin = this._getOriginBasedOnOption();
	        // If the panel is scrolled to the very top, it won't be able to fit the panel
	        // by scrolling, so set the offset to 0 to allow the fallback position to take
	        // effect.
	        if (this._scrollTop <= 0) {
	            this._scrollTop = 0;
	            this._offsetY = 0;
	            this._transformOrigin = "50% bottom 0px";
	        }
	    };
	    /** Adjusts the overlay panel down to fit in the viewport. */
	    MdSelect.prototype._adjustPanelDown = function (panelHeightTop, topSpaceAvailable, maxScroll) {
	        var distanceAboveViewport = panelHeightTop - topSpaceAvailable;
	        // Scrolls the panel down by the distance it was extending past the boundary, then
	        // adjusts the offset by that amount to move the panel down into the viewport.
	        this._scrollTop += distanceAboveViewport;
	        this._offsetY += distanceAboveViewport;
	        this._transformOrigin = this._getOriginBasedOnOption();
	        // If the panel is scrolled to the very bottom, it won't be able to fit the
	        // panel by scrolling, so set the offset to 0 to allow the fallback position
	        // to take effect.
	        if (this._scrollTop >= maxScroll) {
	            this._scrollTop = maxScroll;
	            this._offsetY = 0;
	            this._transformOrigin = "50% top 0px";
	            return;
	        }
	    };
	    /** Sets the transform origin point based on the selected option. */
	    MdSelect.prototype._getOriginBasedOnOption = function () {
	        var originY = Math.abs(this._offsetY) - SELECT_OPTION_HEIGHT_ADJUSTMENT + SELECT_OPTION_HEIGHT / 2;
	        return "50% " + originY + "px 0px";
	    };
	    __decorate$36([
	        _angular_core.ViewChild('trigger'), 
	        __metadata$36('design:type', _angular_core.ElementRef)
	    ], MdSelect.prototype, "trigger", void 0);
	    __decorate$36([
	        _angular_core.ViewChild(ConnectedOverlayDirective), 
	        __metadata$36('design:type', ConnectedOverlayDirective)
	    ], MdSelect.prototype, "overlayDir", void 0);
	    __decorate$36([
	        _angular_core.ContentChildren(MdOption), 
	        __metadata$36('design:type', _angular_core.QueryList)
	    ], MdSelect.prototype, "options", void 0);
	    __decorate$36([
	        _angular_core.Input(), 
	        __metadata$36('design:type', Object)
	    ], MdSelect.prototype, "placeholder", null);
	    __decorate$36([
	        _angular_core.Input(), 
	        __metadata$36('design:type', Object)
	    ], MdSelect.prototype, "disabled", null);
	    __decorate$36([
	        _angular_core.Input(), 
	        __metadata$36('design:type', Object)
	    ], MdSelect.prototype, "required", null);
	    __decorate$36([
	        _angular_core.Output(), 
	        __metadata$36('design:type', _angular_core.EventEmitter)
	    ], MdSelect.prototype, "onOpen", void 0);
	    __decorate$36([
	        _angular_core.Output(), 
	        __metadata$36('design:type', _angular_core.EventEmitter)
	    ], MdSelect.prototype, "onClose", void 0);
	    __decorate$36([
	        _angular_core.Output(), 
	        __metadata$36('design:type', _angular_core.EventEmitter)
	    ], MdSelect.prototype, "change", void 0);
	    MdSelect = __decorate$36([
	        _angular_core.Component({selector: 'md-select, mat-select',
	            template: "<div class=\"mat-select-trigger\" cdk-overlay-origin (click)=\"toggle()\" #origin=\"cdkOverlayOrigin\" #trigger><span class=\"mat-select-placeholder\" [class.mat-floating-placeholder]=\"this.selected\" [@transformPlaceholder]=\"_placeholderState\" [style.width.px]=\"_selectedValueWidth\">{{ placeholder }} </span><span class=\"mat-select-value\" *ngIf=\"selected\"><span class=\"mat-select-value-text\">{{ selected?.viewValue }}</span> </span><span class=\"mat-select-arrow\"></span> <span class=\"mat-select-underline\"></span></div><template cdk-connected-overlay [origin]=\"origin\" [open]=\"panelOpen\" hasBackdrop (backdropClick)=\"close()\" backdropClass=\"cdk-overlay-transparent-backdrop\" [positions]=\"_positions\" [minWidth]=\"_triggerWidth\" [offsetY]=\"_offsetY\" [offsetX]=\"_offsetX\" (attach)=\"_setScrollTop()\"><div class=\"mat-select-panel\" [@transformPanel]=\"'showing'\" (@transformPanel.done)=\"_onPanelDone()\" (keydown)=\"_keyManager.onKeydown($event)\" [style.transformOrigin]=\"_transformOrigin\" [class.mat-select-panel-done-animating]=\"_panelDoneAnimating\"><div class=\"mat-select-content\" [@fadeInContent]=\"'showing'\" (@fadeInContent.done)=\"_onFadeInDone()\"><ng-content></ng-content></div></div></template>",
	            styles: [".mat-select{display:inline-block;outline:0;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-select-trigger{display:flex;align-items:center;height:30px;min-width:112px;cursor:pointer;position:relative;box-sizing:border-box;font-size:16px}[aria-disabled=true] .mat-select-trigger{cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.mat-select-underline{position:absolute;bottom:0;left:0;right:0;height:1px}[aria-disabled=true] .mat-select-underline{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;background-color:transparent;background-position:0 bottom}.mat-select-placeholder{position:relative;padding:0 2px;transform-origin:left top;flex-grow:1}.mat-select-placeholder.mat-floating-placeholder{top:-22px;left:-2px;text-align:left;transform:scale(.75)}[dir=rtl] .mat-select-placeholder{transform-origin:right top}[dir=rtl] .mat-select-placeholder.mat-floating-placeholder{left:2px;text-align:right}[aria-required=true] .mat-select-placeholder::after{content:'*'}.mat-select-value{position:absolute;max-width:calc(100% - 18px);flex-grow:1;top:0;left:0;bottom:0;display:flex;align-items:center}[dir=rtl] .mat-select-value{left:auto;right:0}.mat-select-value-text{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;line-height:30px}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px}@media screen and (-ms-high-contrast:active){.mat-select-panel{outline:solid 1px}}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                'role': 'listbox',
	                '[attr.tabindex]': '_getTabIndex()',
	                '[attr.aria-label]': 'placeholder',
	                '[attr.aria-required]': 'required.toString()',
	                '[attr.aria-disabled]': 'disabled.toString()',
	                '[attr.aria-invalid]': '_control?.invalid || "false"',
	                '[attr.aria-owns]': '_optionIds',
	                '[class.mat-select-disabled]': 'disabled',
	                '[class.mat-select]': 'true',
	                '(keydown)': '_handleKeydown($event)',
	                '(blur)': '_onBlur()'
	            },
	            animations: [
	                transformPlaceholder,
	                transformPanel,
	                fadeInContent
	            ],
	            exportAs: 'mdSelect',
	        }),
	        __param$6(4, _angular_core.Optional()),
	        __param$6(5, _angular_core.Self()),
	        __param$6(5, _angular_core.Optional()), 
	        __metadata$36('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer, ViewportRuler, _angular_core.ChangeDetectorRef, Dir, _angular_forms.NgControl])
	    ], MdSelect);
	    return MdSelect;
	}());
	/** Clamps a value n between min and max values. */
	function clampValue(min, n, max) {
	    return Math.min(Math.max(min, n), max);
	}
	
	var __decorate$35 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$35 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdSelectModule = (function () {
	    function MdSelectModule() {
	    }
	    /** @deprecated */
	    MdSelectModule.forRoot = function () {
	        return {
	            ngModule: MdSelectModule,
	            providers: []
	        };
	    };
	    MdSelectModule = __decorate$35([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, OverlayModule, MdOptionModule, CompatibilityModule],
	            exports: [MdSelect, MdOptionModule, CompatibilityModule],
	            declarations: [MdSelect],
	        }), 
	        __metadata$35('design:paramtypes', [])
	    ], MdSelectModule);
	    return MdSelectModule;
	}());
	
	var __decorate$37 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$37 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MD_SLIDE_TOGGLE_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdSlideToggle; }),
	    multi: true
	};
	// A simple change event emitted by the MdSlideToggle component.
	var MdSlideToggleChange = (function () {
	    function MdSlideToggleChange() {
	    }
	    return MdSlideToggleChange;
	}());
	// Increasing integer for generating unique ids for slide-toggle components.
	var nextId$1 = 0;
	/**
	 * Two-state control, which can be also called `switch`.
	 */
	var MdSlideToggle = (function () {
	    function MdSlideToggle(_elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	        // A unique id for the slide-toggle. By default the id is auto-generated.
	        this._uniqueId = "md-slide-toggle-" + ++nextId$1;
	        this._checked = false;
	        this._isMousedown = false;
	        this._slideRenderer = null;
	        this._disabled = false;
	        this._required = false;
	        // Needs to be public to support AOT compilation (as host binding).
	        this._hasFocus = false;
	        /** Name value will be applied to the input element if present */
	        this.name = null;
	        /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */
	        this.id = this._uniqueId;
	        /** Used to specify the tabIndex value for the underlying input element. */
	        this.tabIndex = 0;
	        /** Whether the label should appear after or before the slide-toggle. Defaults to 'after' */
	        this.labelPosition = 'after';
	        /** Used to set the aria-label attribute on the underlying input element. */
	        this.ariaLabel = null;
	        /** Used to set the aria-labelledby attribute on the underlying input element. */
	        this.ariaLabelledby = null;
	        this._change = new _angular_core.EventEmitter();
	        /** An event will be dispatched each time the slide-toggle changes its value. */
	        this.change = this._change.asObservable();
	    }
	    Object.defineProperty(MdSlideToggle.prototype, "disabled", {
	        /** Whether the slide-toggle is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlideToggle.prototype, "required", {
	        /** Whether the slide-toggle is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlideToggle.prototype, "inputId", {
	        /** Returns the unique id for the visual hidden input. */
	        get: function () { return (this.id || this._uniqueId) + "-input"; },
	        enumerable: true,
	        configurable: true
	    });
	    MdSlideToggle.prototype.ngAfterContentInit = function () {
	        this._slideRenderer = new SlideToggleRenderer(this._elementRef);
	    };
	    /**
	     * The onChangeEvent method will be also called on click.
	     * This is because everything for the slide-toggle is wrapped inside of a label,
	     * which triggers a onChange event on click.
	     */
	    MdSlideToggle.prototype._onChangeEvent = function (event) {
	        // We always have to stop propagation on the change event.
	        // Otherwise the change event, from the input element, will bubble up and
	        // emit its event object to the component's `change` output.
	        event.stopPropagation();
	        // Once a drag is currently in progress, we do not want to toggle the slide-toggle on a click.
	        if (!this.disabled && !this._slideRenderer.isDragging()) {
	            this.toggle();
	            // Emit our custom change event if the native input emitted one.
	            // It is important to only emit it, if the native input triggered one, because
	            // we don't want to trigger a change event, when the `checked` variable changes for example.
	            this._emitChangeEvent();
	        }
	    };
	    MdSlideToggle.prototype._onInputClick = function (event) {
	        this.onTouched();
	        // We have to stop propagation for click events on the visual hidden input element.
	        // By default, when a user clicks on a label element, a generated click event will be
	        // dispatched on the associated input element. Since we are using a label element as our
	        // root container, the click event on the `slide-toggle` will be executed twice.
	        // The real click event will bubble up, and the generated click event also tries to bubble up.
	        // This will lead to multiple click events.
	        // Preventing bubbling for the second event will solve that issue.
	        event.stopPropagation();
	    };
	    MdSlideToggle.prototype._setMousedown = function () {
	        var _this = this;
	        // We only *show* the focus style when focus has come to the button via the keyboard.
	        // The Material Design spec is silent on this topic, and without doing this, the
	        // button continues to look :active after clicking.
	        // @see http://marcysutton.com/button-focus-hell/
	        this._isMousedown = true;
	        setTimeout(function () { return _this._isMousedown = false; }, 100);
	    };
	    MdSlideToggle.prototype._onInputFocus = function () {
	        // Only show the focus / ripple indicator when the focus was not triggered by a mouse
	        // interaction on the component.
	        if (!this._isMousedown) {
	            this._hasFocus = true;
	        }
	    };
	    MdSlideToggle.prototype._onInputBlur = function () {
	        this._hasFocus = false;
	        this.onTouched();
	    };
	    /** Implemented as part of ControlValueAccessor. */
	    MdSlideToggle.prototype.writeValue = function (value) {
	        this.checked = value;
	    };
	    /** Implemented as part of ControlValueAccessor. */
	    MdSlideToggle.prototype.registerOnChange = function (fn) {
	        this.onChange = fn;
	    };
	    /** Implemented as part of ControlValueAccessor. */
	    MdSlideToggle.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /** Implemented as a part of ControlValueAccessor. */
	    MdSlideToggle.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    /** Focuses the slide-toggle. */
	    MdSlideToggle.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._inputElement.nativeElement, 'focus');
	        this._onInputFocus();
	    };
	    Object.defineProperty(MdSlideToggle.prototype, "checked", {
	        /** Whether the slide-toggle is checked. */
	        get: function () { return !!this._checked; },
	        set: function (value) {
	            if (this.checked !== !!value) {
	                this._checked = value;
	                this.onChange(this._checked);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlideToggle.prototype, "color", {
	        /** The color of the slide-toggle. Can be primary, accent, or warn. */
	        get: function () { return this._color; },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Toggles the checked state of the slide-toggle. */
	    MdSlideToggle.prototype.toggle = function () {
	        this.checked = !this.checked;
	    };
	    MdSlideToggle.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdSlideToggle.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    /** Emits the change event to the `change` output EventEmitter */
	    MdSlideToggle.prototype._emitChangeEvent = function () {
	        var event = new MdSlideToggleChange();
	        event.source = this;
	        event.checked = this.checked;
	        this._change.emit(event);
	    };
	    MdSlideToggle.prototype._onDragStart = function () {
	        if (!this.disabled) {
	            this._slideRenderer.startThumbDrag(this.checked);
	        }
	    };
	    MdSlideToggle.prototype._onDrag = function (event) {
	        if (this._slideRenderer.isDragging()) {
	            this._slideRenderer.updateThumbPosition(event.deltaX);
	        }
	    };
	    MdSlideToggle.prototype._onDragEnd = function () {
	        var _this = this;
	        if (!this._slideRenderer.isDragging()) {
	            return;
	        }
	        // Notice that we have to stop outside of the current event handler,
	        // because otherwise the click event will be fired and will reset the new checked variable.
	        setTimeout(function () {
	            _this.checked = _this._slideRenderer.stopThumbDrag();
	            _this._emitChangeEvent();
	        }, 0);
	    };
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "name", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "id", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Number)
	    ], MdSlideToggle.prototype, "tabIndex", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Object)
	    ], MdSlideToggle.prototype, "labelPosition", void 0);
	    __decorate$37([
	        _angular_core.Input('aria-label'), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "ariaLabel", void 0);
	    __decorate$37([
	        _angular_core.Input('aria-labelledby'), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "ariaLabelledby", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Boolean)
	    ], MdSlideToggle.prototype, "disabled", null);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Boolean)
	    ], MdSlideToggle.prototype, "required", null);
	    __decorate$37([
	        _angular_core.Output(), 
	        __metadata$37('design:type', rxjs_Observable.Observable)
	    ], MdSlideToggle.prototype, "change", void 0);
	    __decorate$37([
	        _angular_core.ViewChild('input'), 
	        __metadata$37('design:type', _angular_core.ElementRef)
	    ], MdSlideToggle.prototype, "_inputElement", void 0);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', Object)
	    ], MdSlideToggle.prototype, "checked", null);
	    __decorate$37([
	        _angular_core.Input(), 
	        __metadata$37('design:type', String)
	    ], MdSlideToggle.prototype, "color", null);
	    MdSlideToggle = __decorate$37([
	        _angular_core.Component({selector: 'md-slide-toggle, mat-slide-toggle',
	            host: {
	                '[class.mat-slide-toggle]': 'true',
	                '[class.mat-checked]': 'checked',
	                '[class.mat-disabled]': 'disabled',
	                // This mat-slide-toggle prefix will change, once the temporary ripple is removed.
	                '[class.mat-slide-toggle-focused]': '_hasFocus',
	                '[class.mat-slide-toggle-label-before]': 'labelPosition == "before"',
	                '(mousedown)': '_setMousedown()'
	            },
	            template: "<label class=\"mat-slide-toggle-label\"><div class=\"mat-slide-toggle-container\"><div class=\"mat-slide-toggle-bar\"></div><div class=\"mat-slide-toggle-thumb-container\" (slidestart)=\"_onDragStart()\" (slide)=\"_onDrag($event)\" (slideend)=\"_onDragEnd()\"><div class=\"mat-slide-toggle-thumb\"><div class=\"mat-ink-ripple\"></div></div></div><input #input class=\"mat-slide-toggle-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [tabIndex]=\"tabIndex\" [checked]=\"checked\" [disabled]=\"disabled\" [attr.name]=\"name\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (blur)=\"_onInputBlur()\" (focus)=\"_onInputFocus()\" (change)=\"_onChangeEvent($event)\" (click)=\"_onInputClick($event)\"></div><span class=\"mat-slide-toggle-content\"><ng-content></ng-content></span></label>",
	            styles: [".mat-slide-toggle{display:flex;height:24px;margin:16px 0;line-height:24px;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(100%,0,0)}.mat-slide-toggle .mat-ink-ripple{border-radius:50%;opacity:0;height:48px;left:50%;overflow:hidden;pointer-events:none;position:absolute;top:50%;transform:translate(-50%,-50%);transition:opacity ease 280ms,background-color ease 280ms;width:48px}.mat-slide-toggle.mat-slide-toggle-focused .mat-ink-ripple{opacity:1}.mat-slide-toggle.mat-slide-toggle-disabled .mat-ink-ripple{background-color:#000}.mat-slide-toggle.mat-disabled .mat-slide-toggle-container,.mat-slide-toggle.mat-disabled .mat-slide-toggle-label{cursor:default}.mat-slide-toggle-content{font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500}.mat-slide-toggle-label{display:flex;flex:1;cursor:pointer}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-container{order:2}.mat-slide-toggle-container{cursor:-webkit-grab;cursor:grab;width:36px;height:24px;position:relative}.mat-slide-toggle-container,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-container{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-container,[dir=rtl] .mat-slide-toggle-container{margin-left:8px;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;top:2px;left:0;z-index:1;width:16px;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform}.mat-slide-toggle-thumb-container.mat-dragging{transition-duration:0s}.mat-slide-toggle-thumb{position:absolute;margin:0;left:0;top:0;height:20px;width:20px;border-radius:50%;box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}@media screen and (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:1px solid #000}.mat-slide-toggle-bar{background:#fff}}.mat-slide-toggle-bar{position:absolute;left:1px;top:5px;width:34px;height:14px;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}"],
	            providers: [MD_SLIDE_TOGGLE_VALUE_ACCESSOR],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush
	        }), 
	        __metadata$37('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdSlideToggle);
	    return MdSlideToggle;
	}());
	/**
	 * Renderer for the Slide Toggle component, which separates DOM modification in its own class
	 */
	var SlideToggleRenderer = (function () {
	    function SlideToggleRenderer(_elementRef) {
	        this._elementRef = _elementRef;
	        this._thumbEl = _elementRef.nativeElement.querySelector('.mat-slide-toggle-thumb-container');
	        this._thumbBarEl = _elementRef.nativeElement.querySelector('.mat-slide-toggle-bar');
	    }
	    /** Whether the slide-toggle is currently dragging. */
	    SlideToggleRenderer.prototype.isDragging = function () {
	        return !!this._thumbBarWidth;
	    };
	    /** Initializes the drag of the slide-toggle. */
	    SlideToggleRenderer.prototype.startThumbDrag = function (checked) {
	        if (!this.isDragging()) {
	            this._thumbBarWidth = this._thumbBarEl.clientWidth - this._thumbEl.clientWidth;
	            this._checked = checked;
	            this._thumbEl.classList.add('mat-dragging');
	        }
	    };
	    /** Stops the current drag and returns the new checked value. */
	    SlideToggleRenderer.prototype.stopThumbDrag = function () {
	        if (this.isDragging()) {
	            this._thumbBarWidth = null;
	            this._thumbEl.classList.remove('mat-dragging');
	            applyCssTransform(this._thumbEl, '');
	            return this._percentage > 50;
	        }
	    };
	    /** Updates the thumb containers position from the specified distance. */
	    SlideToggleRenderer.prototype.updateThumbPosition = function (distance) {
	        this._percentage = this._getThumbPercentage(distance);
	        applyCssTransform(this._thumbEl, "translate3d(" + this._percentage + "%, 0, 0)");
	    };
	    /** Retrieves the percentage of thumb from the moved distance. */
	    SlideToggleRenderer.prototype._getThumbPercentage = function (distance) {
	        var percentage = (distance / this._thumbBarWidth) * 100;
	        // When the toggle was initially checked, then we have to start the drag at the end.
	        if (this._checked) {
	            percentage += 100;
	        }
	        return Math.max(0, Math.min(percentage, 100));
	    };
	    return SlideToggleRenderer;
	}());
	var MdSlideToggleModule = (function () {
	    function MdSlideToggleModule() {
	    }
	    /** @deprecated */
	    MdSlideToggleModule.forRoot = function () {
	        return {
	            ngModule: MdSlideToggleModule,
	            providers: []
	        };
	    };
	    MdSlideToggleModule = __decorate$37([
	        _angular_core.NgModule({
	            imports: [_angular_forms.FormsModule, CompatibilityModule],
	            exports: [MdSlideToggle, CompatibilityModule],
	            declarations: [MdSlideToggle],
	            providers: [{ provide: _angular_platformBrowser.HAMMER_GESTURE_CONFIG, useClass: GestureConfig }],
	        }), 
	        __metadata$37('design:paramtypes', [])
	    ], MdSlideToggleModule);
	    return MdSlideToggleModule;
	}());
	
	var __decorate$38 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$38 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$7 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Visually, a 30px separation between tick marks looks best. This is very subjective but it is
	 * the default separation we chose.
	 */
	var MIN_AUTO_TICK_SEPARATION = 30;
	/** The thumb gap size for a disabled slider. */
	var DISABLED_THUMB_GAP = 7;
	/** The thumb gap size for a non-active slider at its minimum value. */
	var MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
	/** The thumb gap size for an active slider at its minimum value. */
	var MIN_VALUE_ACTIVE_THUMB_GAP = 10;
	/**
	 * Provider Expression that allows md-slider to register as a ControlValueAccessor.
	 * This allows it to support [(ngModel)] and [formControl].
	 */
	var MD_SLIDER_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdSlider; }),
	    multi: true
	};
	/** A simple change event emitted by the MdSlider component. */
	var MdSliderChange = (function () {
	    function MdSliderChange() {
	    }
	    return MdSliderChange;
	}());
	/**
	 * Allows users to select from a range of values by moving the slider thumb. It is similar in
	 * behavior to the native `<input type="range">` element.
	 */
	var MdSlider = (function () {
	    function MdSlider(_dir, elementRef) {
	        this._dir = _dir;
	        /** A renderer to handle updating the slider's thumb and fill track. */
	        this._renderer = null;
	        /** The dimensions of the slider. */
	        this._sliderDimensions = null;
	        this._disabled = false;
	        this._thumbLabel = false;
	        this._controlValueAccessorChangeFn = function () { };
	        /** The last values for which a change or input event was emitted. */
	        this._lastChangeValue = null;
	        this._lastInputValue = null;
	        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
	        this.onTouched = function () { };
	        /**
	         * Whether or not the thumb is sliding.
	         * Used to determine if there should be a transition for the thumb and fill track.
	         */
	        this._isSliding = false;
	        /**
	         * Whether or not the slider is active (clicked or sliding).
	         * Used to shrink and grow the thumb as according to the Material Design spec.
	         */
	        this._isActive = false;
	        this._step = 1;
	        this._tickInterval = 0;
	        this._tickIntervalPercent = 0;
	        this._percent = 0;
	        this._value = null;
	        this._min = 0;
	        this._max = 100;
	        this._invert = false;
	        this._vertical = false;
	        /** Event emitted when the slider value has changed. */
	        this.change = new _angular_core.EventEmitter();
	        /** Event emitted when the slider thumb moves. */
	        this.input = new _angular_core.EventEmitter();
	        this._renderer = new SliderRenderer(elementRef);
	    }
	    Object.defineProperty(MdSlider.prototype, "disabled", {
	        /** Whether or not the slider is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "thumbLabel", {
	        /** Whether or not to show the thumb label. */
	        get: function () { return this._thumbLabel; },
	        set: function (value) { this._thumbLabel = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_thumbLabelDeprecated", {
	        /** @deprecated */
	        get: function () { return this._thumbLabel; },
	        set: function (value) { this._thumbLabel = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "step", {
	        /** The values at which the thumb will snap. */
	        get: function () { return this._step; },
	        set: function (v) {
	            this._step = coerceNumberProperty(v, this._step);
	            if (this._step % 1 !== 0) {
	                this._roundLabelTo = this._step.toString().split('.').pop().length;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "tickInterval", {
	        /**
	         * How often to show ticks. Relative to the step so that a tick always appears on a step.
	         * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
	         */
	        get: function () { return this._tickInterval; },
	        set: function (v) {
	            this._tickInterval = (v == 'auto') ? v : coerceNumberProperty(v, this._tickInterval);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_tickIntervalDeprecated", {
	        /** @deprecated */
	        get: function () { return this.tickInterval; },
	        set: function (v) { this.tickInterval = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "tickIntervalPercent", {
	        /** The size of a tick interval as a percentage of the size of the track. */
	        get: function () { return this._tickIntervalPercent; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "percent", {
	        /** The percentage of the slider that coincides with the value. */
	        get: function () { return this._clamp(this._percent); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "value", {
	        /** Value of the slider. */
	        get: function () {
	            // If the value needs to be read and it is still uninitialized, initialize it to the min.
	            if (this._value === null) {
	                this.value = this._min;
	            }
	            return this._value;
	        },
	        set: function (v) {
	            this._value = coerceNumberProperty(v, this._value);
	            this._percent = this._calculatePercentage(this._value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "min", {
	        /** The minimum value that the slider can have. */
	        get: function () {
	            return this._min;
	        },
	        set: function (v) {
	            this._min = coerceNumberProperty(v, this._min);
	            // If the value wasn't explicitly set by the user, set it to the min.
	            if (this._value === null) {
	                this.value = this._min;
	            }
	            this._percent = this._calculatePercentage(this.value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "max", {
	        /** The maximum value that the slider can have. */
	        get: function () {
	            return this._max;
	        },
	        set: function (v) {
	            this._max = coerceNumberProperty(v, this._max);
	            this._percent = this._calculatePercentage(this.value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "invert", {
	        /** Whether the slider is inverted. */
	        get: function () { return this._invert; },
	        set: function (value) { this._invert = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "vertical", {
	        /** Whether the slider is vertical. */
	        get: function () { return this._vertical; },
	        set: function (value) { this._vertical = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "displayValue", {
	        /** The value to be used for display purposes. */
	        get: function () {
	            // Note that this could be improved further by rounding something like 0.999 to 1 or
	            // 0.899 to 0.9, however it is very performance sensitive, because it gets called on
	            // every change detection cycle.
	            if (this._roundLabelTo && this.value % 1 !== 0) {
	                return this.value.toFixed(this._roundLabelTo);
	            }
	            return this.value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "invertAxis", {
	        /**
	         * Whether the axis of the slider is inverted.
	         * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
	         */
	        get: function () {
	            // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to
	            // top. However from a y-axis standpoint this is inverted.
	            return this.vertical ? !this.invert : this.invert;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "invertMouseCoords", {
	        /**
	         * Whether mouse events should be converted to a slider position by calculating their distance
	         * from the right or bottom edge of the slider as opposed to the top or left.
	         */
	        get: function () {
	            return (this.direction == 'rtl' && !this.vertical) ? !this.invertAxis : this.invertAxis;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_isMinValue", {
	        /** Whether the slider is at its minimum value. */
	        get: function () {
	            return this.percent === 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "_thumbGap", {
	        /**
	         * The amount of space to leave between the slider thumb and the track fill & track background
	         * elements.
	         */
	        get: function () {
	            if (this.disabled) {
	                return DISABLED_THUMB_GAP;
	            }
	            if (this._isMinValue && !this.thumbLabel) {
	                return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
	            }
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "trackBackgroundStyles", {
	        /** CSS styles for the track background element. */
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            var sign = this.invertMouseCoords ? '-' : '';
	            return {
	                'transform': "translate" + axis + "(" + sign + this._thumbGap + "px) scale" + axis + "(" + (1 - this.percent) + ")"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "trackFillStyles", {
	        /** CSS styles for the track fill element. */
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            var sign = this.invertMouseCoords ? '' : '-';
	            return {
	                'transform': "translate" + axis + "(" + sign + this._thumbGap + "px) scale" + axis + "(" + this.percent + ")"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "ticksContainerStyles", {
	        /** CSS styles for the ticks container element. */
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            // For a horizontal slider in RTL languages we push the ticks container off the left edge
	            // instead of the right edge to avoid causing a horizontal scrollbar to appear.
	            var sign = !this.vertical && this.direction == 'rtl' ? '' : '-';
	            var offset = this.tickIntervalPercent / 2 * 100;
	            return {
	                'transform': "translate" + axis + "(" + sign + offset + "%)"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "ticksStyles", {
	        /** CSS styles for the ticks element. */
	        get: function () {
	            var tickSize = this.tickIntervalPercent * 100;
	            var backgroundSize = this.vertical ? "2px " + tickSize + "%" : tickSize + "% 2px";
	            var axis = this.vertical ? 'Y' : 'X';
	            // Depending on the direction we pushed the ticks container, push the ticks the opposite
	            // direction to re-center them but clip off the end edge. In RTL languages we need to flip the
	            // ticks 180 degrees so we're really cutting off the end edge abd not the start.
	            var sign = !this.vertical && this.direction == 'rtl' ? '-' : '';
	            var rotate = !this.vertical && this.direction == 'rtl' ? ' rotate(180deg)' : '';
	            var styles = {
	                'backgroundSize': backgroundSize,
	                // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
	                'transform': "translateZ(0) translate" + axis + "(" + sign + tickSize / 2 + "%)" + rotate
	            };
	            if (this._isMinValue && this._thumbGap) {
	                var side = this.vertical ?
	                    (this.invertAxis ? 'Bottom' : 'Top') :
	                    (this.invertAxis ? 'Right' : 'Left');
	                styles[("padding" + side)] = this._thumbGap + "px";
	            }
	            return styles;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "thumbContainerStyles", {
	        get: function () {
	            var axis = this.vertical ? 'Y' : 'X';
	            // For a horizontal slider in RTL languages we push the thumb container off the left edge
	            // instead of the right edge to avoid causing a horizontal scrollbar to appear.
	            var invertOffset = (this.direction == 'rtl' && !this.vertical) ? !this.invertAxis : this.invertAxis;
	            var offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
	            return {
	                'transform': "translate" + axis + "(-" + offset + "%)"
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSlider.prototype, "direction", {
	        /** The language direction for this slider element. */
	        get: function () {
	            return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdSlider.prototype._onMouseenter = function () {
	        if (this.disabled) {
	            return;
	        }
	        // We save the dimensions of the slider here so we can use them to update the spacing of the
	        // ticks and determine where on the slider click and slide events happen.
	        this._sliderDimensions = this._renderer.getSliderDimensions();
	        this._updateTickIntervalPercent();
	    };
	    MdSlider.prototype._onClick = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        this._isActive = true;
	        this._isSliding = false;
	        this._renderer.addFocus();
	        this._updateValueFromPosition({ x: event.clientX, y: event.clientY });
	        /* Emits a change and input event if the value changed. */
	        this._emitInputEvent();
	        this._emitValueIfChanged();
	    };
	    MdSlider.prototype._onSlide = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        // Prevent the slide from selecting anything else.
	        event.preventDefault();
	        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
	        // Native range elements always emit `input` events when the value changed while sliding.
	        this._emitInputEvent();
	    };
	    MdSlider.prototype._onSlideStart = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        // Simulate mouseenter in case this is a mobile device.
	        this._onMouseenter();
	        event.preventDefault();
	        this._isSliding = true;
	        this._isActive = true;
	        this._renderer.addFocus();
	        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
	    };
	    MdSlider.prototype._onSlideEnd = function () {
	        this._isSliding = false;
	        this._emitValueIfChanged();
	    };
	    MdSlider.prototype._onBlur = function () {
	        this._isActive = false;
	        this.onTouched();
	    };
	    MdSlider.prototype._onKeydown = function (event) {
	        if (this.disabled) {
	            return;
	        }
	        switch (event.keyCode) {
	            case PAGE_UP:
	                this._increment(10);
	                break;
	            case PAGE_DOWN:
	                this._increment(-10);
	                break;
	            case END:
	                this.value = this.max;
	                break;
	            case HOME:
	                this.value = this.min;
	                break;
	            case LEFT_ARROW:
	                // NOTE: For a sighted user it would make more sense that when they press an arrow key on an
	                // inverted slider the thumb moves in that direction. However for a blind user, nothing
	                // about the slider indicates that it is inverted. They will expect left to be decrement,
	                // regardless of how it appears on the screen. For speakers ofRTL languages, they probably
	                // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for
	                // RTL. For inverted sliders we prefer a good a11y experience to having it "look right" for
	                // sighted users, therefore we do not swap the meaning.
	                this._increment(this.direction == 'rtl' ? 1 : -1);
	                break;
	            case UP_ARROW:
	                this._increment(1);
	                break;
	            case RIGHT_ARROW:
	                // See comment on LEFT_ARROW about the conditions under which we flip the meaning.
	                this._increment(this.direction == 'rtl' ? -1 : 1);
	                break;
	            case DOWN_ARROW:
	                this._increment(-1);
	                break;
	            default:
	                // Return if the key is not one that we explicitly handle to avoid calling preventDefault on
	                // it.
	                return;
	        }
	        this._isSliding = true;
	        event.preventDefault();
	    };
	    MdSlider.prototype._onKeyup = function () {
	        this._isSliding = false;
	    };
	    /** Increments the slider by the given number of steps (negative number decrements). */
	    MdSlider.prototype._increment = function (numSteps) {
	        this.value = this._clamp(this.value + this.step * numSteps, this.min, this.max);
	        this._emitInputEvent();
	        this._emitValueIfChanged();
	    };
	    /** Calculate the new value from the new physical location. The value will always be snapped. */
	    MdSlider.prototype._updateValueFromPosition = function (pos) {
	        if (!this._sliderDimensions) {
	            return;
	        }
	        var offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
	        var size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
	        var posComponent = this.vertical ? pos.y : pos.x;
	        // The exact value is calculated from the event and used to find the closest snap value.
	        var percent = this._clamp((posComponent - offset) / size);
	        if (this.invertMouseCoords) {
	            percent = 1 - percent;
	        }
	        var exactValue = this._calculateValue(percent);
	        // This calculation finds the closest step by finding the closest whole number divisible by the
	        // step relative to the min.
	        var closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
	        // The value needs to snap to the min and max.
	        this.value = this._clamp(closestValue, this.min, this.max);
	    };
	    /** Emits a change event if the current value is different from the last emitted value. */
	    MdSlider.prototype._emitValueIfChanged = function () {
	        if (this.value != this._lastChangeValue) {
	            var event_1 = this._createChangeEvent();
	            this._lastChangeValue = this.value;
	            this._controlValueAccessorChangeFn(this.value);
	            this.change.emit(event_1);
	        }
	    };
	    /** Emits an input event when the current value is different from the last emitted value. */
	    MdSlider.prototype._emitInputEvent = function () {
	        if (this.value != this._lastInputValue) {
	            var event_2 = this._createChangeEvent();
	            this._lastInputValue = this.value;
	            this.input.emit(event_2);
	        }
	    };
	    /** Updates the amount of space between ticks as a percentage of the width of the slider. */
	    MdSlider.prototype._updateTickIntervalPercent = function () {
	        if (!this.tickInterval) {
	            return;
	        }
	        if (this.tickInterval == 'auto') {
	            var trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
	            var pixelsPerStep = trackSize * this.step / (this.max - this.min);
	            var stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
	            var pixelsPerTick = stepsPerTick * this.step;
	            this._tickIntervalPercent = pixelsPerTick / trackSize;
	        }
	        else {
	            this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
	        }
	    };
	    /** Creates a slider change object from the specified value. */
	    MdSlider.prototype._createChangeEvent = function (value) {
	        if (value === void 0) { value = this.value; }
	        var event = new MdSliderChange();
	        event.source = this;
	        event.value = value;
	        return event;
	    };
	    /** Calculates the percentage of the slider that a value is. */
	    MdSlider.prototype._calculatePercentage = function (value) {
	        return (value - this.min) / (this.max - this.min);
	    };
	    /** Calculates the value a percentage of the slider corresponds to. */
	    MdSlider.prototype._calculateValue = function (percentage) {
	        return this.min + percentage * (this.max - this.min);
	    };
	    /** Return a number between two numbers. */
	    MdSlider.prototype._clamp = function (value, min, max) {
	        if (min === void 0) { min = 0; }
	        if (max === void 0) { max = 1; }
	        return Math.max(min, Math.min(value, max));
	    };
	    /**
	     * Sets the model value. Implemented as part of ControlValueAccessor.
	     * @param value
	     */
	    MdSlider.prototype.writeValue = function (value) {
	        this.value = value;
	    };
	    /**
	     * Registers a callback to eb triggered when the value has changed.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdSlider.prototype.registerOnChange = function (fn) {
	        this._controlValueAccessorChangeFn = fn;
	    };
	    /**
	     * Registers a callback to be triggered when the component is touched.
	     * Implemented as part of ControlValueAccessor.
	     * @param fn Callback to be registered.
	     */
	    MdSlider.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /**
	     * Sets whether the component should be disabled.
	     * Implemented as part of ControlValueAccessor.
	     * @param isDisabled
	     */
	    MdSlider.prototype.setDisabledState = function (isDisabled) {
	        this.disabled = isDisabled;
	    };
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Boolean)
	    ], MdSlider.prototype, "disabled", null);
	    __decorate$38([
	        _angular_core.Input('thumbLabel'), 
	        __metadata$38('design:type', Boolean)
	    ], MdSlider.prototype, "thumbLabel", null);
	    __decorate$38([
	        _angular_core.Input('thumb-label'), 
	        __metadata$38('design:type', Boolean)
	    ], MdSlider.prototype, "_thumbLabelDeprecated", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "step", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "tickInterval", null);
	    __decorate$38([
	        _angular_core.Input('tick-interval'), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "_tickIntervalDeprecated", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "value", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "min", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "max", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "invert", null);
	    __decorate$38([
	        _angular_core.Input(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "vertical", null);
	    __decorate$38([
	        _angular_core.Output(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "change", void 0);
	    __decorate$38([
	        _angular_core.Output(), 
	        __metadata$38('design:type', Object)
	    ], MdSlider.prototype, "input", void 0);
	    MdSlider = __decorate$38([
	        _angular_core.Component({selector: 'md-slider, mat-slider',
	            providers: [MD_SLIDER_VALUE_ACCESSOR],
	            host: {
	                '[class.mat-slider]': 'true',
	                '(blur)': '_onBlur()',
	                '(click)': '_onClick($event)',
	                '(keydown)': '_onKeydown($event)',
	                '(keyup)': '_onKeyup()',
	                '(mouseenter)': '_onMouseenter()',
	                '(slide)': '_onSlide($event)',
	                '(slideend)': '_onSlideEnd()',
	                '(slidestart)': '_onSlideStart($event)',
	                'role': 'slider',
	                'tabindex': '0',
	                '[attr.aria-disabled]': 'disabled',
	                '[attr.aria-valuemax]': 'max',
	                '[attr.aria-valuemin]': 'min',
	                '[attr.aria-valuenow]': 'value',
	                '[class.mat-slider-active]': '_isActive',
	                '[class.mat-slider-disabled]': 'disabled',
	                '[class.mat-slider-has-ticks]': 'tickInterval',
	                '[class.mat-slider-horizontal]': '!vertical',
	                '[class.mat-slider-axis-inverted]': 'invertAxis',
	                '[class.mat-slider-sliding]': '_isSliding',
	                '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
	                '[class.mat-slider-vertical]': 'vertical',
	                '[class.mat-slider-min-value]': '_isMinValue',
	                '[class.mat-slider-hide-last-tick]': '_isMinValue && _thumbGap && invertAxis',
	            },
	            template: "<div class=\"mat-slider-wrapper\"><div class=\"mat-slider-track-wrapper\"><div class=\"mat-slider-track-background\" [ngStyle]=\"trackBackgroundStyles\"></div><div class=\"mat-slider-track-fill\" [ngStyle]=\"trackFillStyles\"></div></div><div class=\"mat-slider-ticks-container\" [ngStyle]=\"ticksContainerStyles\"><div class=\"mat-slider-ticks\" [ngStyle]=\"ticksStyles\"></div></div><div class=\"mat-slider-thumb-container\" [ngStyle]=\"thumbContainerStyles\"><div class=\"mat-slider-thumb\"></div><div class=\"mat-slider-thumb-label\"><span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span></div></div></div>",
	            styles: [".mat-slider-track-background,.mat-slider-track-fill{transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0}.mat-slider-track-background{position:absolute;transform-origin:100% 100%}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-disabled .mat-slider-ticks{opacity:0}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label-text{z-index:1;font-size:12px;font-weight:700;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:'';position:absolute;border:0 solid rgba(0,0,0,.6);opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-active .mat-slider-thumb-label-text,.mat-slider-has-ticks.mat-slider-active .mat-slider-ticks,.mat-slider-has-ticks.mat-slider-active:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider-active .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-active.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider-active .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.mat-slider-horizontal .mat-slider-ticks{background:repeating-linear-gradient(to right,rgba(0,0,0,.6),rgba(0,0,0,.6) 2px,transparent 0,transparent);background:-moz-repeating-linear-gradient(.0001deg,rgba(0,0,0,.6),rgba(0,0,0,.6) 2px,transparent 0,transparent);background-clip:content-box;height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.mat-slider-active .mat-slider-thumb-label{transform:rotate(45deg)}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.mat-slider-vertical .mat-slider-ticks{background:repeating-linear-gradient(to bottom,rgba(0,0,0,.6),rgba(0,0,0,.6) 2px,transparent 0,transparent);background-clip:content-box;width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.mat-slider-active .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background,[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }),
	        __param$7(0, _angular_core.Optional()), 
	        __metadata$38('design:paramtypes', [Dir, _angular_core.ElementRef])
	    ], MdSlider);
	    return MdSlider;
	}());
	/**
	 * Renderer class in order to keep all dom manipulation in one place and outside of the main class.
	 * @docs-private
	 */
	var SliderRenderer = (function () {
	    function SliderRenderer(elementRef) {
	        this._sliderElement = elementRef.nativeElement;
	    }
	    /**
	     * Get the bounding client rect of the slider track element.
	     * The track is used rather than the native element to ignore the extra space that the thumb can
	     * take up.
	     */
	    SliderRenderer.prototype.getSliderDimensions = function () {
	        var wrapperElement = this._sliderElement.querySelector('.mat-slider-wrapper');
	        return wrapperElement.getBoundingClientRect();
	    };
	    /**
	     * Focuses the native element.
	     * Currently only used to allow a blur event to fire but will be used with keyboard input later.
	     */
	    SliderRenderer.prototype.addFocus = function () {
	        this._sliderElement.focus();
	    };
	    return SliderRenderer;
	}());
	var MdSliderModule = (function () {
	    function MdSliderModule() {
	    }
	    /** @deprecated */
	    MdSliderModule.forRoot = function () {
	        return {
	            ngModule: MdSliderModule,
	            providers: []
	        };
	    };
	    MdSliderModule = __decorate$38([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, _angular_forms.FormsModule, CompatibilityModule],
	            exports: [MdSlider, CompatibilityModule],
	            declarations: [MdSlider],
	            providers: [{ provide: _angular_platformBrowser.HAMMER_GESTURE_CONFIG, useClass: GestureConfig }]
	        }), 
	        __metadata$38('design:paramtypes', [])
	    ], MdSliderModule);
	    return MdSliderModule;
	}());
	
	var __extends$9 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$39 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$39 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$8 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** Exception thrown when two MdSidenav are matching the same side. */
	var MdDuplicatedSidenavError = (function (_super) {
	    __extends$9(MdDuplicatedSidenavError, _super);
	    function MdDuplicatedSidenavError(align) {
	        _super.call(this, "A sidenav was already declared for 'align=\"" + align + "\"'");
	    }
	    return MdDuplicatedSidenavError;
	}(MdError));
	/** Sidenav toggle promise result. */
	var MdSidenavToggleResult = (function () {
	    function MdSidenavToggleResult(type, animationFinished) {
	        this.type = type;
	        this.animationFinished = animationFinished;
	    }
	    return MdSidenavToggleResult;
	}());
	/**
	 * <md-sidenav> component.
	 *
	 * This component corresponds to the drawer of the sidenav.
	 *
	 * Please refer to README.md for examples on how to use it.
	 */
	var MdSidenav = (function () {
	    /**
	     * @param _elementRef The DOM element reference. Used for transition and width calculation.
	     *     If not available we do not hook on transitions.
	     */
	    function MdSidenav(_elementRef, _renderer) {
	        var _this = this;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** Alignment of the sidenav (direction neutral); whether 'start' or 'end'. */
	        this._align = 'start';
	        this._valid = true;
	        /** Mode of the sidenav; whether 'over' or 'side'. */
	        this.mode = 'over';
	        this._disableClose = false;
	        /** Whether the sidenav is opened. */
	        this._opened = false;
	        /** Event emitted when the sidenav is being opened. Use this to synchronize animations. */
	        this.onOpenStart = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav is fully opened. */
	        this.onOpen = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav is being closed. Use this to synchronize animations. */
	        this.onCloseStart = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav is fully closed. */
	        this.onClose = new _angular_core.EventEmitter();
	        /** Event emitted when the sidenav alignment changes. */
	        this.onAlignChanged = new _angular_core.EventEmitter();
	        /** The current toggle animation promise. `null` if no animation is in progress. */
	        this._toggleAnimationPromise = null;
	        /**
	         * The current toggle animation promise resolution function.
	         * `null` if no animation is in progress.
	         */
	        this._resolveToggleAnimationPromise = null;
	        this._elementFocusedBeforeSidenavWasOpened = null;
	        this.onOpen.subscribe(function () {
	            _this._elementFocusedBeforeSidenavWasOpened = document.activeElement;
	            if (!_this.isFocusTrapDisabled) {
	                _this._focusTrap.focusFirstTabbableElementWhenReady();
	            }
	        });
	        this.onClose.subscribe(function () {
	            if (_this._elementFocusedBeforeSidenavWasOpened instanceof HTMLElement) {
	                _this._renderer.invokeElementMethod(_this._elementFocusedBeforeSidenavWasOpened, 'focus');
	            }
	            else {
	                _this._renderer.invokeElementMethod(_this._elementRef.nativeElement, 'blur');
	            }
	            _this._elementFocusedBeforeSidenavWasOpened = null;
	        });
	    }
	    Object.defineProperty(MdSidenav.prototype, "valid", {
	        /** Whether this md-sidenav is part of a valid md-sidenav-container configuration. */
	        get: function () { return this._valid; },
	        set: function (value) {
	            value = coerceBooleanProperty(value);
	            // When the drawers are not in a valid configuration we close them all until they are in a valid
	            // configuration again.
	            if (!value) {
	                this.close();
	            }
	            this._valid = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "align", {
	        /** Direction which the sidenav is aligned in. */
	        get: function () { return this._align; },
	        set: function (value) {
	            // Make sure we have a valid value.
	            value = (value == 'end') ? 'end' : 'start';
	            if (value != this._align) {
	                this._align = value;
	                this.onAlignChanged.emit();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "disableClose", {
	        /** Whether the sidenav can be closed with the escape key or not. */
	        get: function () { return this._disableClose; },
	        set: function (value) { this._disableClose = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "isFocusTrapDisabled", {
	        get: function () {
	            // The focus trap is only enabled when the sidenav is open in any mode other than side.
	            return !this.opened || this.mode == 'side';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdSidenav.prototype.ngAfterContentInit = function () {
	        // This can happen when the sidenav is set to opened in the template and the transition
	        // isn't ended.
	        if (this._toggleAnimationPromise) {
	            this._resolveToggleAnimationPromise(true);
	            this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;
	        }
	    };
	    Object.defineProperty(MdSidenav.prototype, "opened", {
	        /**
	         * Whether the sidenav is opened. We overload this because we trigger an event when it
	         * starts or end.
	         */
	        get: function () { return this._opened; },
	        set: function (v) {
	            this.toggle(coerceBooleanProperty(v));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Open this sidenav, and return a Promise that will resolve when it's fully opened (or get
	     * rejected if it didn't). */
	    MdSidenav.prototype.open = function () {
	        return this.toggle(true);
	    };
	    /**
	     * Close this sidenav, and return a Promise that will resolve when it's fully closed (or get
	     * rejected if it didn't).
	     */
	    MdSidenav.prototype.close = function () {
	        return this.toggle(false);
	    };
	    /**
	     * Toggle this sidenav. This is equivalent to calling open() when it's already opened, or
	     * close() when it's closed.
	     * @param isOpen Whether the sidenav should be open.
	     * @returns Resolves with the result of whether the sidenav was opened or closed.
	     */
	    MdSidenav.prototype.toggle = function (isOpen) {
	        var _this = this;
	        if (isOpen === void 0) { isOpen = !this.opened; }
	        if (!this.valid) {
	            return Promise.resolve(new MdSidenavToggleResult(isOpen ? 'open' : 'close', true));
	        }
	        // Shortcut it if we're already opened.
	        if (isOpen === this.opened) {
	            return this._toggleAnimationPromise ||
	                Promise.resolve(new MdSidenavToggleResult(isOpen ? 'open' : 'close', true));
	        }
	        this._opened = isOpen;
	        if (isOpen) {
	            this.onOpenStart.emit();
	        }
	        else {
	            this.onCloseStart.emit();
	        }
	        if (this._toggleAnimationPromise) {
	            this._resolveToggleAnimationPromise(false);
	        }
	        this._toggleAnimationPromise = new Promise(function (resolve) {
	            _this._resolveToggleAnimationPromise = function (animationFinished) {
	                return resolve(new MdSidenavToggleResult(isOpen ? 'open' : 'close', animationFinished));
	            };
	        });
	        return this._toggleAnimationPromise;
	    };
	    /**
	     * Handles the keyboard events.
	     * @docs-private
	     */
	    MdSidenav.prototype.handleKeydown = function (event) {
	        if (event.keyCode === ESCAPE && !this.disableClose) {
	            this.close();
	            event.stopPropagation();
	        }
	    };
	    /**
	     * When transition has finished, set the internal state for classes and emit the proper event.
	     * The event passed is actually of type TransitionEvent, but that type is not available in
	     * Android so we use any.
	     */
	    MdSidenav.prototype._onTransitionEnd = function (transitionEvent) {
	        if (transitionEvent.target == this._elementRef.nativeElement
	            && transitionEvent.propertyName.endsWith('transform')) {
	            if (this._opened) {
	                this.onOpen.emit();
	            }
	            else {
	                this.onClose.emit();
	            }
	            if (this._toggleAnimationPromise) {
	                this._resolveToggleAnimationPromise(true);
	                this._toggleAnimationPromise = this._resolveToggleAnimationPromise = null;
	            }
	        }
	    };
	    Object.defineProperty(MdSidenav.prototype, "_isClosing", {
	        get: function () {
	            return !this._opened && !!this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isOpening", {
	        get: function () {
	            return this._opened && !!this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isClosed", {
	        get: function () {
	            return !this._opened && !this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isOpened", {
	        get: function () {
	            return this._opened && !this._toggleAnimationPromise;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_isEnd", {
	        get: function () {
	            return this.align == 'end';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_modeSide", {
	        get: function () {
	            return this.mode == 'side';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_modeOver", {
	        get: function () {
	            return this.mode == 'over';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_modePush", {
	        get: function () {
	            return this.mode == 'push';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenav.prototype, "_width", {
	        get: function () {
	            if (this._elementRef.nativeElement) {
	                return this._elementRef.nativeElement.offsetWidth;
	            }
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$39([
	        _angular_core.ViewChild(FocusTrap), 
	        __metadata$39('design:type', FocusTrap)
	    ], MdSidenav.prototype, "_focusTrap", void 0);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "align", null);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "mode", void 0);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Boolean)
	    ], MdSidenav.prototype, "disableClose", null);
	    __decorate$39([
	        _angular_core.Output('open-start'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onOpenStart", void 0);
	    __decorate$39([
	        _angular_core.Output('open'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onOpen", void 0);
	    __decorate$39([
	        _angular_core.Output('close-start'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onCloseStart", void 0);
	    __decorate$39([
	        _angular_core.Output('close'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onClose", void 0);
	    __decorate$39([
	        _angular_core.Output('align-changed'), 
	        __metadata$39('design:type', Object)
	    ], MdSidenav.prototype, "onAlignChanged", void 0);
	    __decorate$39([
	        _angular_core.Input(), 
	        __metadata$39('design:type', Boolean)
	    ], MdSidenav.prototype, "opened", null);
	    MdSidenav = __decorate$39([
	        _angular_core.Component({selector: 'md-sidenav, mat-sidenav',
	            // TODO(mmalerba): move template to separate file.
	            template: "<cdk-focus-trap class=\"mat-sidenav-focus-trap\" [disabled]=\"isFocusTrapDisabled\"><ng-content></ng-content></cdk-focus-trap>",
	            host: {
	                '[class.mat-sidenav]': 'true',
	                '(transitionend)': '_onTransitionEnd($event)',
	                '(keydown)': 'handleKeydown($event)',
	                // must prevent the browser from aligning text based on value
	                '[attr.align]': 'null',
	                '[class.mat-sidenav-closed]': '_isClosed',
	                '[class.mat-sidenav-closing]': '_isClosing',
	                '[class.mat-sidenav-end]': '_isEnd',
	                '[class.mat-sidenav-opened]': '_isOpened',
	                '[class.mat-sidenav-opening]': '_isOpening',
	                '[class.mat-sidenav-over]': '_modeOver',
	                '[class.mat-sidenav-push]': '_modePush',
	                '[class.mat-sidenav-side]': '_modeSide',
	                '[class.mat-sidenav-invalid]': '!valid',
	                'tabIndex': '-1'
	            },
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$39('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdSidenav);
	    return MdSidenav;
	}());
	/**
	 * <md-sidenav-container> component.
	 *
	 * This is the parent component to one or two <md-sidenav>s that validates the state internally
	 * and coordinates the backdrop and content styling.
	 */
	var MdSidenavContainer = (function () {
	    function MdSidenavContainer(_dir, _element, _renderer, _ngZone) {
	        var _this = this;
	        this._dir = _dir;
	        this._element = _element;
	        this._renderer = _renderer;
	        this._ngZone = _ngZone;
	        /** Event emitted when the sidenav backdrop is clicked. */
	        this.backdropClick = new _angular_core.EventEmitter();
	        /** Whether to enable open/close trantions. */
	        this._enableTransitions = false;
	        // If a `Dir` directive exists up the tree, listen direction changes and update the left/right
	        // properties to point to the proper start/end.
	        if (_dir != null) {
	            _dir.dirChange.subscribe(function () { return _this._validateDrawers(); });
	        }
	    }
	    Object.defineProperty(MdSidenavContainer.prototype, "start", {
	        /** The sidenav child with the `start` alignment. */
	        get: function () { return this._start; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdSidenavContainer.prototype, "end", {
	        /** The sidenav child with the `end` alignment. */
	        get: function () { return this._end; },
	        enumerable: true,
	        configurable: true
	    });
	    MdSidenavContainer.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        // On changes, assert on consistency.
	        this._sidenavs.changes.subscribe(function () { return _this._validateDrawers(); });
	        this._sidenavs.forEach(function (sidenav) {
	            _this._watchSidenavToggle(sidenav);
	            _this._watchSidenavAlign(sidenav);
	        });
	        this._validateDrawers();
	        // Give the view a chance to render the initial state, then enable transitions.
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () { return _this._enableTransitions = true; });
	    };
	    /**
	     * Subscribes to sidenav events in order to set a class on the main container element when the
	     * sidenav is open and the backdrop is visible. This ensures any overflow on the container element
	     * is properly hidden.
	     */
	    MdSidenavContainer.prototype._watchSidenavToggle = function (sidenav) {
	        var _this = this;
	        if (!sidenav || sidenav.mode === 'side') {
	            return;
	        }
	        sidenav.onOpen.subscribe(function () { return _this._setContainerClass(sidenav, true); });
	        sidenav.onClose.subscribe(function () { return _this._setContainerClass(sidenav, false); });
	    };
	    /**
	     * Subscribes to sidenav onAlignChanged event in order to re-validate drawers when the align
	     * changes.
	     */
	    MdSidenavContainer.prototype._watchSidenavAlign = function (sidenav) {
	        var _this = this;
	        if (!sidenav) {
	            return;
	        }
	        sidenav.onAlignChanged.subscribe(function () { return _this._validateDrawers(); });
	    };
	    /** Toggles the 'mat-sidenav-opened' class on the main 'md-sidenav-container' element. */
	    MdSidenavContainer.prototype._setContainerClass = function (sidenav, bool) {
	        this._renderer.setElementClass(this._element.nativeElement, 'mat-sidenav-opened', bool);
	    };
	    /** Sets the valid state of the drawers. */
	    MdSidenavContainer.prototype._setDrawersValid = function (valid) {
	        this._sidenavs.forEach(function (sidenav) {
	            sidenav.valid = valid;
	        });
	        if (!valid) {
	            this._start = this._end = this._left = this._right = null;
	        }
	    };
	    /** Validate the state of the sidenav children components. */
	    MdSidenavContainer.prototype._validateDrawers = function () {
	        this._start = this._end = null;
	        // Ensure that we have at most one start and one end sidenav.
	        // NOTE: We must call toArray on _sidenavs even though it's iterable
	        // (see https://github.com/Microsoft/TypeScript/issues/3164).
	        for (var _i = 0, _a = this._sidenavs.toArray(); _i < _a.length; _i++) {
	            var sidenav = _a[_i];
	            if (sidenav.align == 'end') {
	                if (this._end != null) {
	                    this._setDrawersValid(false);
	                    return;
	                }
	                this._end = sidenav;
	            }
	            else {
	                if (this._start != null) {
	                    this._setDrawersValid(false);
	                    return;
	                }
	                this._start = sidenav;
	            }
	        }
	        this._right = this._left = null;
	        // Detect if we're LTR or RTL.
	        if (this._dir == null || this._dir.value == 'ltr') {
	            this._left = this._start;
	            this._right = this._end;
	        }
	        else {
	            this._left = this._end;
	            this._right = this._start;
	        }
	        this._setDrawersValid(true);
	    };
	    MdSidenavContainer.prototype._onBackdropClicked = function () {
	        this.backdropClick.emit();
	        this._closeModalSidenav();
	    };
	    MdSidenavContainer.prototype._closeModalSidenav = function () {
	        // Close all open sidenav's where closing is not disabled and the mode is not `side`.
	        [this._start, this._end]
	            .filter(function (sidenav) { return sidenav && !sidenav.disableClose && sidenav.mode !== 'side'; })
	            .forEach(function (sidenav) { return sidenav.close(); });
	    };
	    MdSidenavContainer.prototype._isShowingBackdrop = function () {
	        return (this._isSidenavOpen(this._start) && this._start.mode != 'side')
	            || (this._isSidenavOpen(this._end) && this._end.mode != 'side');
	    };
	    MdSidenavContainer.prototype._isSidenavOpen = function (side) {
	        return side != null && side.opened;
	    };
	    /**
	     * Return the width of the sidenav, if it's in the proper mode and opened.
	     * This may relayout the view, so do not call this often.
	     * @param sidenav
	     * @param mode
	     */
	    MdSidenavContainer.prototype._getSidenavEffectiveWidth = function (sidenav, mode) {
	        return (this._isSidenavOpen(sidenav) && sidenav.mode == mode) ? sidenav._width : 0;
	    };
	    MdSidenavContainer.prototype._getMarginLeft = function () {
	        return this._getSidenavEffectiveWidth(this._left, 'side');
	    };
	    MdSidenavContainer.prototype._getMarginRight = function () {
	        return this._getSidenavEffectiveWidth(this._right, 'side');
	    };
	    MdSidenavContainer.prototype._getPositionLeft = function () {
	        return this._getSidenavEffectiveWidth(this._left, 'push');
	    };
	    MdSidenavContainer.prototype._getPositionRight = function () {
	        return this._getSidenavEffectiveWidth(this._right, 'push');
	    };
	    /**
	     * Returns the horizontal offset for the content area.  There should never be a value for both
	     * left and right, so by subtracting the right value from the left value, we should always get
	     * the appropriate offset.
	     */
	    MdSidenavContainer.prototype._getPositionOffset = function () {
	        return this._getPositionLeft() - this._getPositionRight();
	    };
	    /**
	     * This is using [ngStyle] rather than separate [style...] properties because [style.transform]
	     * doesn't seem to work right now.
	     */
	    MdSidenavContainer.prototype._getStyles = function () {
	        return {
	            marginLeft: this._getMarginLeft() + "px",
	            marginRight: this._getMarginRight() + "px",
	            transform: "translate3d(" + this._getPositionOffset() + "px, 0, 0)"
	        };
	    };
	    __decorate$39([
	        _angular_core.ContentChildren(MdSidenav), 
	        __metadata$39('design:type', _angular_core.QueryList)
	    ], MdSidenavContainer.prototype, "_sidenavs", void 0);
	    __decorate$39([
	        _angular_core.Output(), 
	        __metadata$39('design:type', Object)
	    ], MdSidenavContainer.prototype, "backdropClick", void 0);
	    MdSidenavContainer = __decorate$39([
	        _angular_core.Component({selector: 'md-sidenav-container, mat-sidenav-container',
	            // Do not use ChangeDetectionStrategy.OnPush. It does not work for this component because
	            // technically it is a sibling of MdSidenav (on the content tree) and isn't updated when MdSidenav
	            // changes its state.
	            template: "<div class=\"mat-sidenav-backdrop\" (click)=\"_onBackdropClicked()\" [class.mat-sidenav-shown]=\"_isShowingBackdrop()\"></div><ng-content select=\"md-sidenav, mat-sidenav\"></ng-content><div class=\"mat-sidenav-content\" [ngStyle]=\"_getStyles()\" cdk-scrollable><ng-content></ng-content></div>",
	            styles: [".mat-sidenav-container{position:relative;transform:translate3d(0,0,0);box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-sidenav-backdrop,.mat-sidenav-container[fullscreen]{position:absolute;top:0;bottom:0;right:0;left:0}.mat-sidenav-container[fullscreen].mat-sidenav-opened{overflow:hidden}.mat-sidenav-backdrop{display:block;z-index:2;visibility:hidden}.mat-sidenav-backdrop.mat-sidenav-shown{visibility:visible}.mat-sidenav.mat-sidenav-closed,.mat-sidenav.mat-sidenav-end.mat-sidenav-closed,[dir=rtl] .mat-sidenav.mat-sidenav-closed,[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-closed{visibility:hidden}@media screen and (-ms-high-contrast:active){.mat-sidenav-backdrop{opacity:.5}}.mat-sidenav-content{position:relative;transform:translate3d(0,0,0);display:block;height:100%;overflow:auto}.mat-sidenav{display:block;position:absolute;top:0;bottom:0;z-index:3;min-width:5%;outline:0;transform:translate3d(-100%,0,0)}.mat-sidenav.mat-sidenav-opened,.mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-side{z-index:1}.mat-sidenav.mat-sidenav-end{right:0;transform:translate3d(100%,0,0)}.mat-sidenav.mat-sidenav-end.mat-sidenav-opened,.mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav{transform:translate3d(100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-opening{transform:translate3d(0,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end{left:0;right:auto;transform:translate3d(-100%,0,0)}[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opened,[dir=rtl] .mat-sidenav.mat-sidenav-end.mat-sidenav-opening{transform:translate3d(0,0,0)}.mat-sidenav.mat-sidenav-opened:not(.mat-sidenav-side),.mat-sidenav.mat-sidenav-opening:not(.mat-sidenav-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.mat-sidenav-focus-trap{height:100%}.mat-sidenav-focus-trap>.cdk-focus-trap-content{box-sizing:border-box;height:100%;overflow-y:auto;transform:translateZ(0)}.mat-sidenav-invalid{display:none}",
	".mat-sidenav-transition .mat-sidenav{transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-sidenav-transition .mat-sidenav-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-sidenav-transition .mat-sidenav-backdrop.mat-sidenav-shown{transition:background-color .4s cubic-bezier(.25,.8,.25,1)}"],
	            host: {
	                '[class.mat-sidenav-container]': 'true',
	                '[class.mat-sidenav-transition]': '_enableTransitions',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }),
	        __param$8(0, _angular_core.Optional()), 
	        __metadata$39('design:paramtypes', [Dir, _angular_core.ElementRef, _angular_core.Renderer, _angular_core.NgZone])
	    ], MdSidenavContainer);
	    return MdSidenavContainer;
	}());
	var MdSidenavModule = (function () {
	    function MdSidenavModule() {
	    }
	    /** @deprecated */
	    MdSidenavModule.forRoot = function () {
	        return {
	            ngModule: MdSidenavModule,
	            providers: []
	        };
	    };
	    MdSidenavModule = __decorate$39([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, CompatibilityModule, A11yModule, OverlayModule],
	            exports: [MdSidenavContainer, MdSidenav, CompatibilityModule],
	            declarations: [MdSidenavContainer, MdSidenav],
	        }), 
	        __metadata$39('design:paramtypes', [])
	    ], MdSidenavModule);
	    return MdSidenavModule;
	}());
	
	var __decorate$40 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$40 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdListDivider = (function () {
	    function MdListDivider() {
	    }
	    MdListDivider = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-divider, mat-divider'
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListDivider);
	    return MdListDivider;
	}());
	var MdList = (function () {
	    function MdList() {
	    }
	    MdList = __decorate$40([
	        _angular_core.Component({selector: 'md-list, mat-list, md-nav-list, mat-nav-list',
	            host: {
	                'role': 'list' },
	            template: '<ng-content></ng-content>',
	            styles: [".mat-list,.mat-nav-list{padding-top:8px;display:block}.mat-list .mat-subheader,.mat-nav-list .mat-subheader{display:block;box-sizing:border-box;height:48px;padding:16px;margin:0;font-size:14px;font-weight:500}.mat-list .mat-subheader:first-child,.mat-nav-list .mat-subheader:first-child{margin-top:-8px}.mat-list .mat-list-item,.mat-nav-list .mat-list-item{display:block}.mat-list .mat-list-item .mat-list-item-content,.mat-nav-list .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;font-family:Roboto,\"Helvetica Neue\",sans-serif;box-sizing:border-box;font-size:16px;height:48px;padding:0 16px}.mat-list .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:56px}.mat-list .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-2-line .mat-list-item-content{height:72px}.mat-list .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-3-line .mat-list-item-content{height:88px}.mat-list .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list .mat-list-item .mat-list-text,.mat-nav-list .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list .mat-list-item .mat-list-text>*,.mat-nav-list .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list .mat-list-item .mat-list-text:empty,.mat-nav-list .mat-list-item .mat-list-text:empty{display:none}.mat-list .mat-list-item .mat-list-text:first-child,.mat-nav-list .mat-list-item .mat-list-text:first-child{padding:0}.mat-list .mat-list-item .mat-list-avatar,.mat-nav-list .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list .mat-list-item .mat-list-icon,.mat-nav-list .mat-list-item .mat-list-icon{width:24px;height:24px;border-radius:50%;padding:4px}.mat-list .mat-list-item .mat-line,.mat-nav-list .mat-list-item .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list .mat-list-item .mat-line:nth-child(n+2),.mat-nav-list .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list[dense],.mat-nav-list[dense]{padding-top:4px;display:block}.mat-list[dense] .mat-subheader,.mat-nav-list[dense] .mat-subheader{display:block;box-sizing:border-box;height:40px;padding:16px;margin:0;font-size:13px;font-weight:500}.mat-list[dense] .mat-subheader:first-child,.mat-nav-list[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list[dense] .mat-list-item,.mat-nav-list[dense] .mat-list-item{display:block}.mat-list[dense] .mat-list-item .mat-list-item-content,.mat-nav-list[dense] .mat-list-item .mat-list-item-content{display:flex;flex-direction:row;align-items:center;font-family:Roboto,\"Helvetica Neue\",sans-serif;box-sizing:border-box;font-size:13px;height:40px;padding:0 16px}.mat-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-list-item-avatar .mat-list-item-content{height:48px}.mat-list[dense] .mat-list-item.mat-2-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-2-line .mat-list-item-content{height:60px}.mat-list[dense] .mat-list-item.mat-3-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-3-line .mat-list-item-content{height:76px}.mat-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-nav-list[dense] .mat-list-item.mat-multi-line .mat-list-item-content{height:100%;padding:8px 16px}.mat-list[dense] .mat-list-item .mat-list-text,.mat-nav-list[dense] .mat-list-item .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0 16px}.mat-list[dense] .mat-list-item .mat-list-text>*,.mat-nav-list[dense] .mat-list-item .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list[dense] .mat-list-item .mat-list-text:empty,.mat-nav-list[dense] .mat-list-item .mat-list-text:empty{display:none}.mat-list[dense] .mat-list-item .mat-list-text:first-child,.mat-nav-list[dense] .mat-list-item .mat-list-text:first-child{padding:0}.mat-list[dense] .mat-list-item .mat-list-avatar,.mat-nav-list[dense] .mat-list-item .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%}.mat-list[dense] .mat-list-item .mat-list-icon,.mat-nav-list[dense] .mat-list-item .mat-list-icon{width:24px;height:24px;border-radius:50%;padding:4px}.mat-list[dense] .mat-list-item .mat-line,.mat-nav-list[dense] .mat-list-item .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-nav-list[dense] .mat-list-item .mat-line:nth-child(n+2){font-size:13px}.mat-divider{display:block;border-top-style:solid;border-top-width:1px;margin:0}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item-content{cursor:pointer}.mat-nav-list .mat-list-item-content.mat-list-item-focus,.mat-nav-list .mat-list-item-content:hover{outline:0}"],
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdList);
	    return MdList;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdListCssMatStyler = (function () {
	    function MdListCssMatStyler() {
	    }
	    MdListCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-list, mat-list',
	            host: {
	                '[class.mat-list]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListCssMatStyler);
	    return MdListCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdNavListCssMatStyler = (function () {
	    function MdNavListCssMatStyler() {
	    }
	    MdNavListCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-nav-list, mat-nav-list',
	            host: {
	                '[class.mat-nav-list]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdNavListCssMatStyler);
	    return MdNavListCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdDividerCssMatStyler = (function () {
	    function MdDividerCssMatStyler() {
	    }
	    MdDividerCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: 'md-divider, mat-divider',
	            host: {
	                '[class.mat-divider]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdDividerCssMatStyler);
	    return MdDividerCssMatStyler;
	}());
	/* Need directive for a ContentChild query in list-item */
	var MdListAvatarCssMatStyler = (function () {
	    function MdListAvatarCssMatStyler() {
	    }
	    MdListAvatarCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: '[md-list-avatar], [mat-list-avatar]',
	            host: {
	                '[class.mat-list-avatar]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListAvatarCssMatStyler);
	    return MdListAvatarCssMatStyler;
	}());
	/* Need directive to add mat- CSS styling */
	var MdListIconCssMatStyler = (function () {
	    function MdListIconCssMatStyler() {
	    }
	    MdListIconCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: '[md-list-icon], [mat-list-icon]',
	            host: {
	                '[class.mat-list-icon]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListIconCssMatStyler);
	    return MdListIconCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdListSubheaderCssMatStyler = (function () {
	    function MdListSubheaderCssMatStyler() {
	    }
	    MdListSubheaderCssMatStyler = __decorate$40([
	        _angular_core.Directive({
	            selector: '[md-subheader], [mat-subheader]',
	            host: {
	                '[class.mat-subheader]': 'true'
	            }
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListSubheaderCssMatStyler);
	    return MdListSubheaderCssMatStyler;
	}());
	var MdListItem = (function () {
	    function MdListItem(_renderer, _element) {
	        this._renderer = _renderer;
	        this._element = _element;
	        this._hasFocus = false;
	    }
	    Object.defineProperty(MdListItem.prototype, "_hasAvatar", {
	        set: function (avatar) {
	            this._renderer.setElementClass(this._element.nativeElement, 'mat-list-item-avatar', avatar != null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdListItem.prototype.ngAfterContentInit = function () {
	        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);
	    };
	    MdListItem.prototype._handleFocus = function () {
	        this._hasFocus = true;
	    };
	    MdListItem.prototype._handleBlur = function () {
	        this._hasFocus = false;
	    };
	    __decorate$40([
	        _angular_core.ContentChildren(MdLine), 
	        __metadata$40('design:type', _angular_core.QueryList)
	    ], MdListItem.prototype, "_lines", void 0);
	    __decorate$40([
	        _angular_core.ContentChild(MdListAvatarCssMatStyler), 
	        __metadata$40('design:type', MdListAvatarCssMatStyler), 
	        __metadata$40('design:paramtypes', [MdListAvatarCssMatStyler])
	    ], MdListItem.prototype, "_hasAvatar", null);
	    MdListItem = __decorate$40([
	        _angular_core.Component({selector: 'md-list-item, mat-list-item, a[md-list-item], a[mat-list-item]',
	            host: {
	                'role': 'listitem',
	                '(focus)': '_handleFocus()',
	                '(blur)': '_handleBlur()',
	                '[class.mat-list-item]': 'true',
	            },
	            template: "<div class=\"mat-list-item-content\" [class.mat-list-item-focus]=\"_hasFocus\"><ng-content select=\"[md-list-avatar],[md-list-icon], [mat-list-avatar], [mat-list-icon]\"></ng-content><div class=\"mat-list-text\"><ng-content select=\"[md-line], [mat-line]\"></ng-content></div><ng-content></ng-content></div>",
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$40('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdListItem);
	    return MdListItem;
	}());
	var MdListModule = (function () {
	    function MdListModule() {
	    }
	    /** @deprecated */
	    MdListModule.forRoot = function () {
	        return {
	            ngModule: MdListModule,
	            providers: []
	        };
	    };
	    MdListModule = __decorate$40([
	        _angular_core.NgModule({
	            imports: [MdLineModule, CompatibilityModule],
	            exports: [
	                MdList,
	                MdListItem,
	                MdListDivider,
	                MdListAvatarCssMatStyler,
	                MdLineModule,
	                CompatibilityModule,
	                MdListIconCssMatStyler,
	                MdListCssMatStyler,
	                MdNavListCssMatStyler,
	                MdDividerCssMatStyler,
	                MdListSubheaderCssMatStyler
	            ],
	            declarations: [
	                MdList,
	                MdListItem,
	                MdListDivider,
	                MdListAvatarCssMatStyler,
	                MdListIconCssMatStyler,
	                MdListCssMatStyler,
	                MdNavListCssMatStyler,
	                MdDividerCssMatStyler,
	                MdListSubheaderCssMatStyler
	            ],
	        }), 
	        __metadata$40('design:paramtypes', [])
	    ], MdListModule);
	    return MdListModule;
	}());
	
	/**
	 * Converts values into strings. Falsy values become empty strings.
	 * @docs-private
	 */
	function coerceToString(value) {
	    return "" + (value || '');
	}
	/**
	 * Converts a value that might be a string into a number.
	 * @docs-private
	 */
	function coerceToNumber(value) {
	    return typeof value === 'string' ? parseInt(value, 10) : value;
	}
	
	var __decorate$42 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$42 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdGridTile = (function () {
	    function MdGridTile(_renderer, _element) {
	        this._renderer = _renderer;
	        this._element = _element;
	        this._rowspan = 1;
	        this._colspan = 1;
	    }
	    Object.defineProperty(MdGridTile.prototype, "rowspan", {
	        /** Amount of rows that the grid tile takes up. */
	        get: function () { return this._rowspan; },
	        set: function (value) { this._rowspan = coerceToNumber(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdGridTile.prototype, "colspan", {
	        /** Amount of columns that the grid tile takes up. */
	        get: function () { return this._colspan; },
	        set: function (value) { this._colspan = coerceToNumber(value); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the style of the grid-tile element.  Needs to be set manually to avoid
	     * "Changed after checked" errors that would occur with HostBinding.
	     */
	    MdGridTile.prototype._setStyle = function (property, value) {
	        this._renderer.setElementStyle(this._element.nativeElement, property, value);
	    };
	    __decorate$42([
	        _angular_core.Input(), 
	        __metadata$42('design:type', Object)
	    ], MdGridTile.prototype, "rowspan", null);
	    __decorate$42([
	        _angular_core.Input(), 
	        __metadata$42('design:type', Object)
	    ], MdGridTile.prototype, "colspan", null);
	    MdGridTile = __decorate$42([
	        _angular_core.Component({selector: 'md-grid-tile, mat-grid-tile',
	            host: {
	                'role': 'listitem',
	                '[class.mat-grid-tile]': 'true',
	            },
	            template: "<figure class=\"mat-figure\"><ng-content></ng-content></figure>",
	            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;font-size:16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer .mat-line,.mat-grid-tile .mat-grid-tile-header .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile .mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile .mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}.mat-grid-tile .mat-grid-list-text>*,.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-avatar:empty,.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$42('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdGridTile);
	    return MdGridTile;
	}());
	var MdGridTileText = (function () {
	    function MdGridTileText(_renderer, _element) {
	        this._renderer = _renderer;
	        this._element = _element;
	    }
	    MdGridTileText.prototype.ngAfterContentInit = function () {
	        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);
	    };
	    __decorate$42([
	        _angular_core.ContentChildren(MdLine), 
	        __metadata$42('design:type', _angular_core.QueryList)
	    ], MdGridTileText.prototype, "_lines", void 0);
	    MdGridTileText = __decorate$42([
	        _angular_core.Component({selector: 'md-grid-tile-header, mat-grid-tile-header, md-grid-tile-footer, mat-grid-tile-footer',
	            template: "<ng-content select=\"[md-grid-avatar], [mat-grid-avatar]\"></ng-content><div class=\"mat-grid-list-text\"><ng-content select=\"[md-line], [mat-line]\"></ng-content></div><ng-content></ng-content>"
	        }), 
	        __metadata$42('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdGridTileText);
	    return MdGridTileText;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdGridAvatarCssMatStyler = (function () {
	    function MdGridAvatarCssMatStyler() {
	    }
	    MdGridAvatarCssMatStyler = __decorate$42([
	        _angular_core.Directive({
	            selector: '[md-grid-avatar], [mat-grid-avatar]',
	            host: {
	                '[class.mat-grid-avatar]': 'true'
	            }
	        }), 
	        __metadata$42('design:paramtypes', [])
	    ], MdGridAvatarCssMatStyler);
	    return MdGridAvatarCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdGridTileHeaderCssMatStyler = (function () {
	    function MdGridTileHeaderCssMatStyler() {
	    }
	    MdGridTileHeaderCssMatStyler = __decorate$42([
	        _angular_core.Directive({
	            selector: 'md-grid-tile-header, mat-grid-tile-header',
	            host: {
	                '[class.mat-grid-tile-header]': 'true'
	            }
	        }), 
	        __metadata$42('design:paramtypes', [])
	    ], MdGridTileHeaderCssMatStyler);
	    return MdGridTileHeaderCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdGridTileFooterCssMatStyler = (function () {
	    function MdGridTileFooterCssMatStyler() {
	    }
	    MdGridTileFooterCssMatStyler = __decorate$42([
	        _angular_core.Directive({
	            selector: 'md-grid-tile-footer, mat-grid-tile-footer',
	            host: {
	                '[class.mat-grid-tile-footer]': 'true'
	            }
	        }), 
	        __metadata$42('design:paramtypes', [])
	    ], MdGridTileFooterCssMatStyler);
	    return MdGridTileFooterCssMatStyler;
	}());
	
	var __extends$10 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when cols property is missing from grid-list
	 * @docs-private
	 */
	var MdGridListColsError = (function (_super) {
	    __extends$10(MdGridListColsError, _super);
	    function MdGridListColsError() {
	        _super.call(this, "md-grid-list: must pass in number of columns. Example: <md-grid-list cols=\"3\">");
	    }
	    return MdGridListColsError;
	}(MdError));
	/**
	 * Exception thrown when a tile's colspan is longer than the number of cols in list
	 * @docs-private
	 */
	var MdGridTileTooWideError = (function (_super) {
	    __extends$10(MdGridTileTooWideError, _super);
	    function MdGridTileTooWideError(cols, listLength) {
	        _super.call(this, "md-grid-list: tile with colspan " + cols + " is wider than grid with cols=\"" + listLength + "\".");
	    }
	    return MdGridTileTooWideError;
	}(MdError));
	/**
	 * Exception thrown when an invalid ratio is passed in as a rowHeight
	 * @docs-private
	 */
	var MdGridListBadRatioError = (function (_super) {
	    __extends$10(MdGridListBadRatioError, _super);
	    function MdGridListBadRatioError(value) {
	        _super.call(this, "md-grid-list: invalid ratio given for row-height: \"" + value + "\"");
	    }
	    return MdGridListBadRatioError;
	}(MdError));
	
	/**
	 * Class for determining, from a list of tiles, the (row, col) position of each of those tiles
	 * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)
	 * because the tiles can have a rowspan.
	 *
	 * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid
	 * large enough to accommodate it so that the tiles still render in the same order in which they
	 * are given.
	 *
	 * The basis of the algorithm is the use of an array to track the already placed tiles. Each
	 * element of the array corresponds to a column, and the value indicates how many cells in that
	 * column are already occupied; zero indicates an empty cell. Moving "down" to the next row
	 * decrements each value in the tracking array (indicating that the column is one cell closer to
	 * being free).
	 *
	 * @docs-private
	 */
	var TileCoordinator = (function () {
	    function TileCoordinator(numColumns, tiles) {
	        var _this = this;
	        /** Index at which the search for the next gap will start. */
	        this.columnIndex = 0;
	        /** The current row index. */
	        this.rowIndex = 0;
	        this.tracker = new Array(numColumns);
	        this.tracker.fill(0, 0, this.tracker.length);
	        this.positions = tiles.map(function (tile) { return _this._trackTile(tile); });
	    }
	    Object.defineProperty(TileCoordinator.prototype, "rowCount", {
	        /** Gets the total number of rows occupied by tiles */
	        get: function () { return this.rowIndex + 1; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TileCoordinator.prototype, "rowspan", {
	        /** Gets the total span of rows occupied by tiles.
	         * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2. */
	        get: function () {
	            var lastRowMax = Math.max.apply(Math, this.tracker);
	            // if any of the tiles has a rowspan that pushes it beyond the total row count,
	            // add the difference to the rowcount
	            return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Calculates the row and col position of a tile. */
	    TileCoordinator.prototype._trackTile = function (tile) {
	        // Find a gap large enough for this tile.
	        var gapStartIndex = this._findMatchingGap(tile.colspan);
	        // Place tile in the resulting gap.
	        this._markTilePosition(gapStartIndex, tile);
	        // The next time we look for a gap, the search will start at columnIndex, which should be
	        // immediately after the tile that has just been placed.
	        this.columnIndex = gapStartIndex + tile.colspan;
	        return new TilePosition(this.rowIndex, gapStartIndex);
	    };
	    /** Finds the next available space large enough to fit the tile. */
	    TileCoordinator.prototype._findMatchingGap = function (tileCols) {
	        if (tileCols > this.tracker.length) {
	            throw new MdGridTileTooWideError(tileCols, this.tracker.length);
	        }
	        // Start index is inclusive, end index is exclusive.
	        var gapStartIndex = -1;
	        var gapEndIndex = -1;
	        // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.
	        do {
	            // If we've reached the end of the row, go to the next row.
	            if (this.columnIndex + tileCols > this.tracker.length) {
	                this._nextRow();
	                continue;
	            }
	            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
	            // If there are no more empty spaces in this row at all, move on to the next row.
	            if (gapStartIndex == -1) {
	                this._nextRow();
	                continue;
	            }
	            gapEndIndex = this._findGapEndIndex(gapStartIndex);
	            // If a gap large enough isn't found, we want to start looking immediately after the current
	            // gap on the next iteration.
	            this.columnIndex = gapStartIndex + 1;
	        } while (gapEndIndex - gapStartIndex < tileCols);
	        return gapStartIndex;
	    };
	    /** Move "down" to the next row. */
	    TileCoordinator.prototype._nextRow = function () {
	        this.columnIndex = 0;
	        this.rowIndex++;
	        // Decrement all spaces by one to reflect moving down one row.
	        for (var i = 0; i < this.tracker.length; i++) {
	            this.tracker[i] = Math.max(0, this.tracker[i] - 1);
	        }
	    };
	    /**
	     * Finds the end index (exclusive) of a gap given the index from which to start looking.
	     * The gap ends when a non-zero value is found.
	     */
	    TileCoordinator.prototype._findGapEndIndex = function (gapStartIndex) {
	        for (var i = gapStartIndex + 1; i < this.tracker.length; i++) {
	            if (this.tracker[i] != 0) {
	                return i;
	            }
	        }
	        // The gap ends with the end of the row.
	        return this.tracker.length;
	    };
	    /** Update the tile tracker to account for the given tile in the given space. */
	    TileCoordinator.prototype._markTilePosition = function (start, tile) {
	        for (var i = 0; i < tile.colspan; i++) {
	            this.tracker[start + i] = tile.rowspan;
	        }
	    };
	    return TileCoordinator;
	}());
	/**
	 * Simple data structure for tile position (row, col).
	 * @docs-private
	 */
	var TilePosition = (function () {
	    function TilePosition(row, col) {
	        this.row = row;
	        this.col = col;
	    }
	    return TilePosition;
	}());
	
	var __extends$11 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Sets the style properties for an individual tile, given the position calculated by the
	 * Tile Coordinator.
	 * @docs-private
	 */
	var TileStyler = (function () {
	    function TileStyler() {
	        this._rows = 0;
	        this._rowspan = 0;
	    }
	    /**
	     * Adds grid-list layout info once it is available. Cannot be processed in the constructor
	     * because these properties haven't been calculated by that point.
	     *
	     * @param gutterSize Size of the grid's gutter.
	     * @param tracker Instance of the TileCoordinator.
	     * @param cols Amount of columns in the grid.
	     * @param direction Layout direction of the grid.
	     */
	    TileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
	        this._gutterSize = normalizeUnits(gutterSize);
	        this._rows = tracker.rowCount;
	        this._rowspan = tracker.rowspan;
	        this._cols = cols;
	        this._direction = direction;
	    };
	    /**
	     * Computes the amount of space a single 1x1 tile would take up (width or height).
	     * Used as a basis for other calculations.
	     * @param sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
	     * @param gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
	     * @return The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
	     */
	    TileStyler.prototype.getBaseTileSize = function (sizePercent, gutterFraction) {
	        // Take the base size percent (as would be if evenly dividing the size between cells),
	        // and then subtracting the size of one gutter. However, since there are no gutters on the
	        // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter
	        // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the
	        // edge evenly among the cells).
	        return "(" + sizePercent + "% - ( " + this._gutterSize + " * " + gutterFraction + " ))";
	    };
	    /**
	     * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
	     * @param offset Number of tiles that have already been rendered in the row/column.
	     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
	     * @return Position of the tile as a CSS calc() expression.
	     */
	    TileStyler.prototype.getTilePosition = function (baseSize, offset) {
	        // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
	        // row/column (offset).
	        return calc("(" + baseSize + " + " + this._gutterSize + ") * " + offset);
	    };
	    /**
	     * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
	     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
	     * @param span The tile's rowspan or colspan.
	     * @return Size of the tile as a CSS calc() expression.
	     */
	    TileStyler.prototype.getTileSize = function (baseSize, span) {
	        return "(" + baseSize + " * " + span + ") + (" + (span - 1) + " * " + this._gutterSize + ")";
	    };
	    /**
	     * Sets the style properties to be applied to a tile for the given row and column index.
	     * @param tile Tile to which to apply the styling.
	     * @param rowIndex Index of the tile's row.
	     * @param colIndex Index of the tile's column.
	     */
	    TileStyler.prototype.setStyle = function (tile, rowIndex, colIndex) {
	        // Percent of the available horizontal space that one column takes up.
	        var percentWidthPerTile = 100 / this._cols;
	        // Fraction of the vertical gutter size that each column takes up.
	        // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.
	        var gutterWidthFractionPerTile = (this._cols - 1) / this._cols;
	        this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);
	        this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);
	    };
	    /** Sets the horizontal placement of the tile in the list. */
	    TileStyler.prototype.setColStyles = function (tile, colIndex, percentWidth, gutterWidth) {
	        // Base horizontal size of a column.
	        var baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);
	        // The width and horizontal position of each tile is always calculated the same way, but the
	        // height and vertical position depends on the rowMode.
	        var side = this._direction === 'ltr' ? 'left' : 'right';
	        tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));
	        tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));
	    };
	    /**
	     * Calculates the total size taken up by gutters across one axis of a list.
	     */
	    TileStyler.prototype.getGutterSpan = function () {
	        return this._gutterSize + " * (" + this._rowspan + " - 1)";
	    };
	    /**
	     * Calculates the total size taken up by tiles across one axis of a list.
	     * @param tileHeight Height of the tile.
	     */
	    TileStyler.prototype.getTileSpan = function (tileHeight) {
	        return this._rowspan + " * " + this.getTileSize(tileHeight, 1);
	    };
	    /**
	     * Sets the vertical placement of the tile in the list.
	     * This method will be implemented by each type of TileStyler.
	     * @docs-private
	     */
	    TileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) { };
	    /**
	     * Calculates the computed height and returns the correct style property to set.
	     * This method will be implemented by each type of TileStyler.
	     * @docs-private
	     */
	    TileStyler.prototype.getComputedHeight = function () { return null; };
	    return TileStyler;
	}());
	/**
	 * This type of styler is instantiated when the user passes in a fixed row height.
	 * Example <md-grid-list cols="3" rowHeight="100px">
	 * @docs-private
	 */
	var FixedTileStyler = (function (_super) {
	    __extends$11(FixedTileStyler, _super);
	    function FixedTileStyler(fixedRowHeight) {
	        _super.call(this);
	        this.fixedRowHeight = fixedRowHeight;
	    }
	    FixedTileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
	        _super.prototype.init.call(this, gutterSize, tracker, cols, direction);
	        this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);
	    };
	    FixedTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
	        tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));
	        tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));
	    };
	    FixedTileStyler.prototype.getComputedHeight = function () {
	        return [
	            'height', calc(this.getTileSpan(this.fixedRowHeight) + " + " + this.getGutterSpan())
	        ];
	    };
	    return FixedTileStyler;
	}(TileStyler));
	/**
	 * This type of styler is instantiated when the user passes in a width:height ratio
	 * for the row height.  Example <md-grid-list cols="3" rowHeight="3:1">
	 * @docs-private
	 */
	var RatioTileStyler = (function (_super) {
	    __extends$11(RatioTileStyler, _super);
	    function RatioTileStyler(value) {
	        _super.call(this);
	        this._parseRatio(value);
	    }
	    RatioTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
	        var percentHeightPerTile = percentWidth / this.rowHeightRatio;
	        this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);
	        // Use paddingTop and marginTop to maintain the given aspect ratio, as
	        // a percentage-based value for these properties is applied versus the *width* of the
	        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
	        tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));
	        tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));
	    };
	    RatioTileStyler.prototype.getComputedHeight = function () {
	        return [
	            'paddingBottom', calc(this.getTileSpan(this.baseTileHeight) + " + " + this.getGutterSpan())
	        ];
	    };
	    RatioTileStyler.prototype._parseRatio = function (value) {
	        var ratioParts = value.split(':');
	        if (ratioParts.length !== 2) {
	            throw new MdGridListBadRatioError(value);
	        }
	        this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);
	    };
	    return RatioTileStyler;
	}(TileStyler));
	/**
	 * This type of styler is instantiated when the user selects a "fit" row height mode.
	 * In other words, the row height will reflect the total height of the container divided
	 * by the number of rows.  Example <md-grid-list cols="3" rowHeight="fit">
	 *
	 * @docs-private
	 */
	var FitTileStyler = (function (_super) {
	    __extends$11(FitTileStyler, _super);
	    function FitTileStyler() {
	        _super.apply(this, arguments);
	    }
	    FitTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
	        // Percent of the available vertical space that one row takes up.
	        var percentHeightPerTile = 100 / this._rowspan;
	        // Fraction of the horizontal gutter size that each column takes up.
	        var gutterHeightPerTile = (this._rows - 1) / this._rows;
	        // Base vertical size of a column.
	        var baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);
	        tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));
	        tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));
	    };
	    return FitTileStyler;
	}(TileStyler));
	/** Wraps a CSS string in a calc function */
	function calc(exp) { return "calc(" + exp + ")"; }
	/** Appends pixels to a CSS string if no units are given. */
	function normalizeUnits(value) {
	    return (value.match(/px|em|rem/)) ? value : value + 'px';
	}
	
	var __decorate$41 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$41 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$9 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	// TODO(kara): Conditional (responsive) column count / row size.
	// TODO(kara): Re-layout on window resize / media change (debounced).
	// TODO(kara): gridTileHeader and gridTileFooter.
	var MD_FIT_MODE = 'fit';
	var MdGridList = (function () {
	    function MdGridList(_renderer, _element, _dir) {
	        this._renderer = _renderer;
	        this._element = _element;
	        this._dir = _dir;
	        /** The amount of space between tiles. This will be something like '5px' or '2em'. */
	        this._gutter = '1px';
	    }
	    Object.defineProperty(MdGridList.prototype, "cols", {
	        /** Amount of columns in the grid list. */
	        get: function () { return this._cols; },
	        set: function (value) { this._cols = coerceToNumber(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdGridList.prototype, "gutterSize", {
	        /** Size of the grid list's gutter in pixels. */
	        get: function () { return this._gutter; },
	        set: function (value) { this._gutter = coerceToString(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdGridList.prototype, "rowHeight", {
	        /** Set internal representation of row height from the user-provided value. */
	        set: function (value) {
	            this._rowHeight = coerceToString(value);
	            this._setTileStyler();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdGridList.prototype.ngOnInit = function () {
	        this._checkCols();
	        this._checkRowHeight();
	    };
	    /**
	     * The layout calculation is fairly cheap if nothing changes, so there's little cost
	     * to run it frequently.
	     */
	    MdGridList.prototype.ngAfterContentChecked = function () {
	        this._layoutTiles();
	    };
	    /** Throw a friendly error if cols property is missing */
	    MdGridList.prototype._checkCols = function () {
	        if (!this.cols) {
	            throw new MdGridListColsError();
	        }
	    };
	    /** Default to equal width:height if rowHeight property is missing */
	    MdGridList.prototype._checkRowHeight = function () {
	        if (!this._rowHeight) {
	            this._tileStyler = new RatioTileStyler('1:1');
	        }
	    };
	    /** Creates correct Tile Styler subtype based on rowHeight passed in by user */
	    MdGridList.prototype._setTileStyler = function () {
	        if (this._rowHeight === MD_FIT_MODE) {
	            this._tileStyler = new FitTileStyler();
	        }
	        else if (this._rowHeight && this._rowHeight.indexOf(':') > -1) {
	            this._tileStyler = new RatioTileStyler(this._rowHeight);
	        }
	        else {
	            this._tileStyler = new FixedTileStyler(this._rowHeight);
	        }
	    };
	    /** Computes and applies the size and position for all children grid tiles. */
	    MdGridList.prototype._layoutTiles = function () {
	        var _this = this;
	        var tracker = new TileCoordinator(this.cols, this._tiles);
	        var direction = this._dir ? this._dir.value : 'ltr';
	        this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);
	        this._tiles.forEach(function (tile, index) {
	            var pos = tracker.positions[index];
	            _this._tileStyler.setStyle(tile, pos.row, pos.col);
	        });
	        this._setListStyle(this._tileStyler.getComputedHeight());
	    };
	    /** Sets style on the main grid-list element, given the style name and value. */
	    MdGridList.prototype._setListStyle = function (style$$1) {
	        if (style$$1) {
	            this._renderer.setElementStyle(this._element.nativeElement, style$$1[0], style$$1[1]);
	        }
	    };
	    __decorate$41([
	        _angular_core.ContentChildren(MdGridTile), 
	        __metadata$41('design:type', _angular_core.QueryList)
	    ], MdGridList.prototype, "_tiles", void 0);
	    __decorate$41([
	        _angular_core.Input(), 
	        __metadata$41('design:type', Object)
	    ], MdGridList.prototype, "cols", null);
	    __decorate$41([
	        _angular_core.Input(), 
	        __metadata$41('design:type', Object)
	    ], MdGridList.prototype, "gutterSize", null);
	    __decorate$41([
	        _angular_core.Input(), 
	        __metadata$41('design:type', Object), 
	        __metadata$41('design:paramtypes', [Object])
	    ], MdGridList.prototype, "rowHeight", null);
	    MdGridList = __decorate$41([
	        _angular_core.Component({selector: 'md-grid-list, mat-grid-list',
	            template: "<div><ng-content></ng-content></div>",
	            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{display:flex;position:absolute;align-items:center;justify-content:center;height:100%;top:0;right:0;bottom:0;left:0;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;font-size:16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer .mat-line,.mat-grid-tile .mat-grid-tile-header .mat-line{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile .mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile .mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}.mat-grid-tile .mat-grid-list-text>*,.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-avatar:empty,.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}"],
	            host: {
	                'role': 'list',
	                '[class.mat-grid-list]': 'true',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }),
	        __param$9(2, _angular_core.Optional()), 
	        __metadata$41('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef, Dir])
	    ], MdGridList);
	    return MdGridList;
	}());
	var MdGridListModule = (function () {
	    function MdGridListModule() {
	    }
	    /** @deprecated */
	    MdGridListModule.forRoot = function () {
	        return {
	            ngModule: MdGridListModule,
	            providers: []
	        };
	    };
	    MdGridListModule = __decorate$41([
	        _angular_core.NgModule({
	            imports: [MdLineModule, CompatibilityModule],
	            exports: [
	                MdGridList,
	                MdGridTile,
	                MdGridTileText,
	                MdLineModule,
	                CompatibilityModule,
	                MdGridTileHeaderCssMatStyler,
	                MdGridTileFooterCssMatStyler,
	                MdGridAvatarCssMatStyler
	            ],
	            declarations: [
	                MdGridList,
	                MdGridTile,
	                MdGridTileText,
	                MdGridTileHeaderCssMatStyler,
	                MdGridTileFooterCssMatStyler,
	                MdGridAvatarCssMatStyler],
	        }), 
	        __metadata$41('design:paramtypes', [])
	    ], MdGridListModule);
	    return MdGridListModule;
	}());
	
	var __decorate$43 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$43 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Content of a card, needed as it's used as a selector in the API.
	 */
	var MdCardContent = (function () {
	    function MdCardContent() {
	    }
	    MdCardContent = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-content, mat-card-content',
	            host: {
	                '[class.mat-card-content]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardContent);
	    return MdCardContent;
	}());
	/**
	 * Title of a card, needed as it's used as a selector in the API.
	 */
	var MdCardTitle = (function () {
	    function MdCardTitle() {
	    }
	    MdCardTitle = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-title, mat-card-title',
	            host: {
	                '[class.mat-card-title]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardTitle);
	    return MdCardTitle;
	}());
	/**
	 * Sub-title of a card, needed as it's used as a selector in the API.
	 */
	var MdCardSubtitle = (function () {
	    function MdCardSubtitle() {
	    }
	    MdCardSubtitle = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-subtitle, mat-card-subtitle',
	            host: {
	                '[class.mat-card-subtitle]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardSubtitle);
	    return MdCardSubtitle;
	}());
	/**
	 * Action section of a card, needed as it's used as a selector in the API.
	 */
	var MdCardActions = (function () {
	    function MdCardActions() {
	    }
	    MdCardActions = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-actions, mat-card-actions',
	            host: {
	                '[class.mat-card-actions]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardActions);
	    return MdCardActions;
	}());
	/**
	 * Footer of a card, needed as it's used as a selector in the API.
	 */
	var MdCardFooter = (function () {
	    function MdCardFooter() {
	    }
	    MdCardFooter = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-footer, mat-card-footer',
	            host: {
	                '[class.mat-card-footer]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardFooter);
	    return MdCardFooter;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardSmImage = (function () {
	    function MdCardSmImage() {
	    }
	    MdCardSmImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-sm-image], [mat-card-sm-image]',
	            host: {
	                '[class.mat-card-sm-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardSmImage);
	    return MdCardSmImage;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardMdImage = (function () {
	    function MdCardMdImage() {
	    }
	    MdCardMdImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-md-image], [mat-card-md-image]',
	            host: {
	                '[class.mat-card-md-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardMdImage);
	    return MdCardMdImage;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardLgImage = (function () {
	    function MdCardLgImage() {
	    }
	    MdCardLgImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-lg-image], [mat-card-lg-image]',
	            host: {
	                'class.mat-card-lg-image': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardLgImage);
	    return MdCardLgImage;
	}());
	/**
	 * Image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardImage = (function () {
	    function MdCardImage() {
	    }
	    MdCardImage = __decorate$43([
	        _angular_core.Directive({
	            selector: '[md-card-image], [mat-card-image]',
	            host: {
	                '[class.mat-card-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardImage);
	    return MdCardImage;
	}());
	/**
	 * Large image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardXlImage = (function () {
	    function MdCardXlImage() {
	    }
	    MdCardXlImage = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-xl-image, mat-card-xl-image',
	            host: {
	                '[class.mat-card-xl-image]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardXlImage);
	    return MdCardXlImage;
	}());
	/**
	 * Avatar image used in a card, needed to add the mat- CSS styling.
	 */
	var MdCardAvatar = (function () {
	    function MdCardAvatar() {
	    }
	    MdCardAvatar = __decorate$43([
	        _angular_core.Directive({
	            selector: 'md-card-avatar, mat-card-avatar',
	            host: {
	                '[class.mat-card-avatar]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardAvatar);
	    return MdCardAvatar;
	}());
	/**
	 * A basic content container component that adds the styles of a Material design card.
	 *
	 * While this component can be used alone, it also provides a number
	 * of preset styles for common card sections, including:
	 * - md-card-title
	 * - md-card-subtitle
	 * - md-card-content
	 * - md-card-actions
	 * - md-card-footer
	 */
	var MdCard = (function () {
	    function MdCard() {
	    }
	    MdCard = __decorate$43([
	        _angular_core.Component({selector: 'md-card, mat-card',
	            template: "<ng-content></ng-content>",
	            styles: [".mat-card{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);will-change:box-shadow;display:block;position:relative;padding:24px;border-radius:2px;font-family:Roboto,\"Helvetica Neue\",sans-serif}@media screen and (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-flat{box-shadow:none}.mat-card-actions,.mat-card-content,.mat-card-subtitle,.mat-card-title{display:block;margin-bottom:16px}.mat-card-title{font-size:24px;font-weight:400}.mat-card-content,.mat-card-header .mat-card-title,.mat-card-subtitle{font-size:14px}.mat-card-actions{margin-left:-16px;margin-right:-16px;padding:8px 0}.mat-card-actions[align=end]{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 48px);margin:0 -24px 16px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-footer{position:absolute;width:100%;min-height:5px;bottom:0;left:0}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 4px}.mat-card-header{display:flex;flex-direction:row;height:40px;margin:-8px 0 16px}.mat-card-header-text{height:40px;margin:0 8px}.mat-card-avatar{height:40px;width:40px;border-radius:50%}.mat-card-lg-image,.mat-card-md-image,.mat-card-sm-image{margin:-8px 0}.mat-card-title-group{display:flex;justify-content:space-between;margin:0 -8px}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}@media (max-width:600px){.mat-card{padding:24px 16px}.mat-card-actions{margin-left:-8px;margin-right:-8px}.mat-card-image{width:calc(100% + 32px);margin:16px -16px}.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}.mat-card-header{margin:-8px 0 0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child,.mat-card>:last-child{margin-bottom:0}.mat-card-image:first-child{margin-top:-24px}.mat-card>.mat-card-actions:last-child{margin-bottom:-16px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child),.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            host: {
	                '[class.mat-card]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCard);
	    return MdCard;
	}());
	/**
	 * Component intended to be used within the `<md-card>` component. It adds styles for a
	 * preset header section (i.e. a title, subtitle, and avatar layout).
	 */
	var MdCardHeader = (function () {
	    function MdCardHeader() {
	    }
	    MdCardHeader = __decorate$43([
	        _angular_core.Component({selector: 'md-card-header, mat-card-header',
	            template: "<ng-content select=\"[md-card-avatar], [mat-card-avatar]\"></ng-content><div class=\"mat-card-header-text\"><ng-content select=\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle\"></ng-content></div><ng-content></ng-content>",
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            host: {
	                '[class.mat-card-header]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardHeader);
	    return MdCardHeader;
	}());
	/**
	 * Component intended to be used within the <md-card> component. It adds styles for a preset
	 * layout that groups an image with a title section.
	 */
	var MdCardTitleGroup = (function () {
	    function MdCardTitleGroup() {
	    }
	    MdCardTitleGroup = __decorate$43([
	        _angular_core.Component({selector: 'md-card-title-group, mat-card-title-group',
	            template: "<div><ng-content select=\"md-card-title, mat-card-title, md-card-subtitle, mat-card-subtitle\"></ng-content></div><ng-content select=\"img\"></ng-content><ng-content></ng-content>",
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            host: {
	                '[class.mat-card-title-group]': 'true'
	            }
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardTitleGroup);
	    return MdCardTitleGroup;
	}());
	var MdCardModule = (function () {
	    function MdCardModule() {
	    }
	    /** @deprecated */
	    MdCardModule.forRoot = function () {
	        return {
	            ngModule: MdCardModule,
	            providers: []
	        };
	    };
	    MdCardModule = __decorate$43([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [
	                MdCard,
	                MdCardHeader,
	                MdCardTitleGroup,
	                MdCardContent,
	                MdCardTitle,
	                MdCardSubtitle,
	                MdCardActions,
	                MdCardFooter,
	                MdCardSmImage,
	                MdCardMdImage,
	                MdCardLgImage,
	                MdCardImage,
	                MdCardXlImage,
	                MdCardAvatar,
	                CompatibilityModule,
	            ],
	            declarations: [
	                MdCard, MdCardHeader, MdCardTitleGroup, MdCardContent, MdCardTitle, MdCardSubtitle,
	                MdCardActions, MdCardFooter, MdCardSmImage, MdCardMdImage, MdCardLgImage, MdCardImage,
	                MdCardXlImage, MdCardAvatar,
	            ],
	        }), 
	        __metadata$43('design:paramtypes', [])
	    ], MdCardModule);
	    return MdCardModule;
	}());
	
	var __decorate$45 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$45 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Material design styled Chip component. Used inside the MdChipList component.
	 */
	var MdChip = (function () {
	    function MdChip(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        /** Whether or not the chip is disabled. Disabled chips cannot be focused. */
	        this._disabled = null;
	        /** Whether or not the chip is selected. */
	        this._selected = false;
	        /** The palette color of selected chips. */
	        this._color = 'primary';
	        /** Emitted when the chip is focused. */
	        this.onFocus = new _angular_core.EventEmitter();
	        /** Emitted when the chip is selected. */
	        this.select = new _angular_core.EventEmitter();
	        /** Emitted when the chip is deselected. */
	        this.deselect = new _angular_core.EventEmitter();
	        /** Emitted when the chip is destroyed. */
	        this.destroy = new _angular_core.EventEmitter();
	    }
	    MdChip.prototype.ngOnInit = function () {
	        this._addDefaultCSSClass();
	        this._updateColor(this._color);
	    };
	    MdChip.prototype.ngOnDestroy = function () {
	        this.destroy.emit({ chip: this });
	    };
	    Object.defineProperty(MdChip.prototype, "disabled", {
	        /** Whether or not the chip is disabled. */
	        get: function () {
	            return this._disabled;
	        },
	        /** Sets the disabled state of the chip. */
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value) ? true : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdChip.prototype, "_isAriaDisabled", {
	        /** A String representation of the current disabled state. */
	        get: function () {
	            return String(coerceBooleanProperty(this.disabled));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdChip.prototype, "selected", {
	        /** Whether or not this chip is selected. */
	        get: function () {
	            return this._selected;
	        },
	        set: function (value) {
	            this._selected = coerceBooleanProperty(value);
	            if (this._selected) {
	                this.select.emit({ chip: this });
	            }
	            else {
	                this.deselect.emit({ chip: this });
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Toggles the current selected state of this chip.
	     * @return Whether the chip is selected.
	     */
	    MdChip.prototype.toggleSelected = function () {
	        this.selected = !this.selected;
	        return this.selected;
	    };
	    Object.defineProperty(MdChip.prototype, "color", {
	        /** The color of the chip. Can be `primary`, `accent`, or `warn`. */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Allows for programmatic focusing of the chip. */
	    MdChip.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._elementRef.nativeElement, 'focus');
	        this.onFocus.emit({ chip: this });
	    };
	    /** Ensures events fire properly upon click. */
	    MdChip.prototype._handleClick = function (event) {
	        // Check disabled
	        if (this.disabled) {
	            event.preventDefault();
	            event.stopPropagation();
	        }
	        else {
	            this.focus();
	        }
	    };
	    /** Initializes the appropriate CSS classes based on the chip type (basic or standard). */
	    MdChip.prototype._addDefaultCSSClass = function () {
	        var el = this._elementRef.nativeElement;
	        // Always add the `mat-chip` class
	        el.classList.add('mat-chip');
	        // If we are a basic chip, also add the `mat-basic-chip` class for :not() targeting
	        if (el.nodeName.toLowerCase() == 'mat-basic-chip' || el.hasAttribute('mat-basic-chip') ||
	            el.nodeName.toLowerCase() == 'md-basic-chip' || el.hasAttribute('md-basic-chip')) {
	            el.classList.add('mat-basic-chip');
	        }
	    };
	    /** Updates the private _color variable and the native element. */
	    MdChip.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    /** Sets the mat-color on the native element. */
	    MdChip.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    __decorate$45([
	        _angular_core.Output(), 
	        __metadata$45('design:type', Object)
	    ], MdChip.prototype, "select", void 0);
	    __decorate$45([
	        _angular_core.Output(), 
	        __metadata$45('design:type', Object)
	    ], MdChip.prototype, "deselect", void 0);
	    __decorate$45([
	        _angular_core.Output(), 
	        __metadata$45('design:type', Object)
	    ], MdChip.prototype, "destroy", void 0);
	    __decorate$45([
	        _angular_core.Input(), 
	        __metadata$45('design:type', Boolean)
	    ], MdChip.prototype, "disabled", null);
	    __decorate$45([
	        _angular_core.Input(), 
	        __metadata$45('design:type', Boolean)
	    ], MdChip.prototype, "selected", null);
	    __decorate$45([
	        _angular_core.Input(), 
	        __metadata$45('design:type', String)
	    ], MdChip.prototype, "color", null);
	    MdChip = __decorate$45([
	        _angular_core.Component({
	            selector: "md-basic-chip, [md-basic-chip], md-chip, [md-chip],\n             mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]",
	            template: "<ng-content></ng-content>",
	            host: {
	                '[class.mat-chip]': 'true',
	                'tabindex': '-1',
	                'role': 'option',
	                '[class.mat-chip-selected]': 'selected',
	                '[attr.disabled]': 'disabled',
	                '[attr.aria-disabled]': '_isAriaDisabled',
	                '(click)': '_handleClick($event)'
	            }
	        }), 
	        __metadata$45('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdChip);
	    return MdChip;
	}());
	
	var __decorate$44 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$44 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * A material design chips component (named ChipList for it's similarity to the List component).
	 *
	 * Example:
	 *
	 *     <md-chip-list>
	 *       <md-chip>Chip 1<md-chip>
	 *       <md-chip>Chip 2<md-chip>
	 *     </md-chip-list>
	 */
	var MdChipList = (function () {
	    function MdChipList(_elementRef) {
	        this._elementRef = _elementRef;
	        /** Track which chips we're listening to for focus/destruction. */
	        this._subscribed = new WeakMap();
	        /** Whether or not the chip is selectable. */
	        this._selectable = true;
	    }
	    MdChipList.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._keyManager = new FocusKeyManager(this.chips).withWrap();
	        // Go ahead and subscribe all of the initial chips
	        this._subscribeChips(this.chips);
	        // When the list changes, re-subscribe
	        this.chips.changes.subscribe(function (chips) {
	            _this._subscribeChips(chips);
	        });
	    };
	    Object.defineProperty(MdChipList.prototype, "selectable", {
	        /**
	         * Whether or not this chip is selectable. When a chip is not selectable,
	         * it's selected state is always ignored.
	         */
	        get: function () {
	            return this._selectable;
	        },
	        set: function (value) {
	            this._selectable = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Programmatically focus the chip list. This in turn focuses the first
	     * non-disabled chip in this chip list.
	     */
	    MdChipList.prototype.focus = function () {
	        // TODO: ARIA says this should focus the first `selected` chip.
	        this._keyManager.setFirstItemActive();
	    };
	    /** Passes relevant key presses to our key manager. */
	    MdChipList.prototype._keydown = function (event) {
	        var target = event.target;
	        // If they are on a chip, check for space/left/right, otherwise pass to our key manager
	        if (target && target.classList.contains('mat-chip')) {
	            switch (event.keyCode) {
	                case SPACE:
	                    // If we are selectable, toggle the focused chip
	                    if (this.selectable) {
	                        this._toggleSelectOnFocusedChip();
	                    }
	                    // Always prevent space from scrolling the page since the list has focus
	                    event.preventDefault();
	                    break;
	                case LEFT_ARROW:
	                    this._keyManager.setPreviousItemActive();
	                    event.preventDefault();
	                    break;
	                case RIGHT_ARROW:
	                    this._keyManager.setNextItemActive();
	                    event.preventDefault();
	                    break;
	                default:
	                    this._keyManager.onKeydown(event);
	            }
	        }
	    };
	    /** Toggles the selected state of the currently focused chip. */
	    MdChipList.prototype._toggleSelectOnFocusedChip = function () {
	        // Allow disabling of chip selection
	        if (!this.selectable) {
	            return;
	        }
	        var focusedIndex = this._keyManager.activeItemIndex;
	        if (this._isValidIndex(focusedIndex)) {
	            var focusedChip = this.chips.toArray()[focusedIndex];
	            if (focusedChip) {
	                focusedChip.toggleSelected();
	            }
	        }
	    };
	    /**
	     * Iterate through the list of chips and add them to our list of
	     * subscribed chips.
	     *
	     * @param chips The list of chips to be subscribed.
	     */
	    MdChipList.prototype._subscribeChips = function (chips) {
	        var _this = this;
	        chips.forEach(function (chip) { return _this._addChip(chip); });
	    };
	    /**
	     * Add a specific chip to our subscribed list. If the chip has
	     * already been subscribed, this ensures it is only subscribed
	     * once.
	     *
	     * @param chip The chip to be subscribed (or checked for existing
	     * subscription).
	     */
	    MdChipList.prototype._addChip = function (chip) {
	        var _this = this;
	        // If we've already been subscribed to a parent, do nothing
	        if (this._subscribed.has(chip)) {
	            return;
	        }
	        // Watch for focus events outside of the keyboard navigation
	        chip.onFocus.subscribe(function () {
	            var chipIndex = _this.chips.toArray().indexOf(chip);
	            if (_this._isValidIndex(chipIndex)) {
	                _this._keyManager.updateActiveItemIndex(chipIndex);
	            }
	        });
	        // On destroy, remove the item from our list, and check focus
	        chip.destroy.subscribe(function () {
	            var chipIndex = _this.chips.toArray().indexOf(chip);
	            if (_this._isValidIndex(chipIndex)) {
	                // Check whether the chip is the last item
	                if (chipIndex < _this.chips.length - 1) {
	                    _this._keyManager.setActiveItem(chipIndex);
	                }
	                else if (chipIndex - 1 >= 0) {
	                    _this._keyManager.setActiveItem(chipIndex - 1);
	                }
	            }
	            _this._subscribed.delete(chip);
	            chip.destroy.unsubscribe();
	        });
	        this._subscribed.set(chip, true);
	    };
	    /**
	     * Utility to ensure all indexes are valid.
	     *
	     * @param index The index to be checked.
	     * @returns True if the index is valid for our list of chips.
	     */
	    MdChipList.prototype._isValidIndex = function (index) {
	        return index >= 0 && index < this.chips.length;
	    };
	    __decorate$44([
	        _angular_core.Input(), 
	        __metadata$44('design:type', Boolean)
	    ], MdChipList.prototype, "selectable", null);
	    MdChipList = __decorate$44([
	        _angular_core.Component({selector: 'md-chip-list, mat-chip-list',
	            template: "<div class=\"md-chip-list-wrapper\"><ng-content></ng-content></div>",
	            host: {
	                // Properties
	                'tabindex': '0',
	                'role': 'listbox',
	                '[class.mat-chip-list]': 'true',
	                // Events
	                '(focus)': 'focus()',
	                '(keydown)': '_keydown($event)'
	            },
	            queries: {
	                chips: new _angular_core.ContentChildren(MdChip)
	            },
	            styles: [".mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:flex-start}.mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){margin:0 3px}.mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):first-child{margin-left:0;margin-right:3px}.mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child,[dir=rtl] .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):first-child{margin-left:3px;margin-right:0}[dir=rtl] .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child{margin-left:0;margin-right:3px}.mat-chip:not(.mat-basic-chip){display:inline-block;padding:8px 12px;border-radius:24px;font-size:13px;line-height:16px}.mat-chip-list-stacked .mat-chip-list-wrapper{display:block}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){display:block;margin:0 0 8px}[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip){margin:0 0 8px}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child,[dir=rtl] .mat-chip-list-stacked .mat-chip-list-wrapper .mat-chip:not(.mat-basic-chip):last-child{margin-bottom:0}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush
	        }), 
	        __metadata$44('design:paramtypes', [_angular_core.ElementRef])
	    ], MdChipList);
	    return MdChipList;
	}());
	var MdChipsModule = (function () {
	    function MdChipsModule() {
	    }
	    /** @deprecated */
	    MdChipsModule.forRoot = function () {
	        return {
	            ngModule: MdChipsModule,
	            providers: []
	        };
	    };
	    MdChipsModule = __decorate$44([
	        _angular_core.NgModule({
	            imports: [],
	            exports: [MdChipList, MdChip],
	            declarations: [MdChipList, MdChip]
	        }), 
	        __metadata$44('design:paramtypes', [])
	    ], MdChipsModule);
	    return MdChipsModule;
	}());
	
	var __extends$13 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$47 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$47 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Exception thrown when attempting to load an icon with a name that cannot be found.
	 * @docs-private
	 */
	var MdIconNameNotFoundError = (function (_super) {
	    __extends$13(MdIconNameNotFoundError, _super);
	    function MdIconNameNotFoundError(iconName) {
	        _super.call(this, "Unable to find icon with the name \"" + iconName + "\"");
	    }
	    return MdIconNameNotFoundError;
	}(MdError));
	/**
	 * Exception thrown when attempting to load SVG content that does not contain the expected
	 * <svg> tag.
	 * @docs-private
	 */
	var MdIconSvgTagNotFoundError = (function (_super) {
	    __extends$13(MdIconSvgTagNotFoundError, _super);
	    function MdIconSvgTagNotFoundError() {
	        _super.call(this, '<svg> tag not found');
	    }
	    return MdIconSvgTagNotFoundError;
	}(MdError));
	/**
	 * Configuration for an icon, including the URL and possibly the cached SVG element.
	 * @docs-private
	 */
	var SvgIconConfig = (function () {
	    function SvgIconConfig(url) {
	        this.url = url;
	        this.svgElement = null;
	    }
	    return SvgIconConfig;
	}());
	/** Returns the cache key to use for an icon namespace and name. */
	var iconKey = function (namespace, name) { return namespace + ':' + name; };
	/**
	 * Service to register and display icons used by the <md-icon> component.
	 * - Registers icon URLs by namespace and name.
	 * - Registers icon set URLs by namespace.
	 * - Registers aliases for CSS classes, for use with icon fonts.
	 * - Loads icons from URLs and extracts individual icons from icon sets.
	 */
	var MdIconRegistry = (function () {
	    function MdIconRegistry(_http, _sanitizer) {
	        this._http = _http;
	        this._sanitizer = _sanitizer;
	        /**
	         * URLs and cached SVG elements for individual icons. Keys are of the format "[namespace]:[icon]".
	         */
	        this._svgIconConfigs = new Map();
	        /**
	         * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.
	         * Multiple icon sets can be registered under the same namespace.
	         */
	        this._iconSetConfigs = new Map();
	        /** Cache for icons loaded by direct URLs. */
	        this._cachedIconsByUrl = new Map();
	        /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */
	        this._inProgressUrlFetches = new Map();
	        /** Map from font identifiers to their CSS class names. Used for icon fonts. */
	        this._fontCssClassesByAlias = new Map();
	        /**
	         * The CSS class to apply when an <md-icon> component has no icon name, url, or font specified.
	         * The default 'material-icons' value assumes that the material icon font has been loaded as
	         * described at http://google.github.io/material-design-icons/#icon-font-for-the-web
	         */
	        this._defaultFontSetClass = 'material-icons';
	    }
	    /**
	     * Registers an icon by URL in the default namespace.
	     * @param iconName Name under which the icon should be registered.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIcon = function (iconName, url) {
	        return this.addSvgIconInNamespace('', iconName, url);
	    };
	    /**
	     * Registers an icon by URL in the specified namespace.
	     * @param namespace Namespace in which the icon should be registered.
	     * @param iconName Name under which the icon should be registered.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIconInNamespace = function (namespace, iconName, url) {
	        var key = iconKey(namespace, iconName);
	        this._svgIconConfigs.set(key, new SvgIconConfig(url));
	        return this;
	    };
	    /**
	     * Registers an icon set by URL in the default namespace.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIconSet = function (url) {
	        return this.addSvgIconSetInNamespace('', url);
	    };
	    /**
	     * Registers an icon set by URL in the specified namespace.
	     * @param namespace Namespace in which to register the icon set.
	     * @param url
	     */
	    MdIconRegistry.prototype.addSvgIconSetInNamespace = function (namespace, url) {
	        var config = new SvgIconConfig(url);
	        if (this._iconSetConfigs.has(namespace)) {
	            this._iconSetConfigs.get(namespace).push(config);
	        }
	        else {
	            this._iconSetConfigs.set(namespace, [config]);
	        }
	        return this;
	    };
	    /**
	     * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdIcon
	     * component with the alias as the fontSet input will cause the class name to be applied
	     * to the <md-icon> element.
	     *
	     * @param alias Alias for the font.
	     * @param className Class name override to be used instead of the alias.
	     */
	    MdIconRegistry.prototype.registerFontClassAlias = function (alias, className) {
	        if (className === void 0) { className = alias; }
	        this._fontCssClassesByAlias.set(alias, className);
	        return this;
	    };
	    /**
	     * Returns the CSS class name associated with the alias by a previous call to
	     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
	     */
	    MdIconRegistry.prototype.classNameForFontAlias = function (alias) {
	        return this._fontCssClassesByAlias.get(alias) || alias;
	    };
	    /**
	     * Sets the CSS class name to be used for icon fonts when an <md-icon> component does not
	     * have a fontSet input value, and is not loading an icon by name or URL.
	     *
	     * @param className
	     */
	    MdIconRegistry.prototype.setDefaultFontSetClass = function (className) {
	        this._defaultFontSetClass = className;
	        return this;
	    };
	    /**
	     * Returns the CSS class name to be used for icon fonts when an <md-icon> component does not
	     * have a fontSet input value, and is not loading an icon by name or URL.
	     */
	    MdIconRegistry.prototype.getDefaultFontSetClass = function () {
	        return this._defaultFontSetClass;
	    };
	    /**
	     * Returns an Observable that produces the icon (as an <svg> DOM element) from the given URL.
	     * The response from the URL may be cached so this will not always cause an HTTP request, but
	     * the produced element will always be a new copy of the originally fetched icon. (That is,
	     * it will not contain any modifications made to elements previously returned).
	     *
	     * @param safeUrl URL from which to fetch the SVG icon.
	     */
	    MdIconRegistry.prototype.getSvgIconFromUrl = function (safeUrl) {
	        var _this = this;
	        var url = this._sanitizer.sanitize(_angular_core.SecurityContext.RESOURCE_URL, safeUrl);
	        if (this._cachedIconsByUrl.has(url)) {
	            return rxjs_Observable.Observable.of(cloneSvg(this._cachedIconsByUrl.get(url)));
	        }
	        return this._loadSvgIconFromConfig(new SvgIconConfig(url))
	            .do(function (svg) { return _this._cachedIconsByUrl.set(url, svg); })
	            .map(function (svg) { return cloneSvg(svg); });
	    };
	    /**
	     * Returns an Observable that produces the icon (as an <svg> DOM element) with the given name
	     * and namespace. The icon must have been previously registered with addIcon or addIconSet;
	     * if not, the Observable will throw an MdIconNameNotFoundError.
	     *
	     * @param name Name of the icon to be retrieved.
	     * @param namespace Namespace in which to look for the icon.
	     */
	    MdIconRegistry.prototype.getNamedSvgIcon = function (name, namespace) {
	        if (namespace === void 0) { namespace = ''; }
	        // Return (copy of) cached icon if possible.
	        var key = iconKey(namespace, name);
	        if (this._svgIconConfigs.has(key)) {
	            return this._getSvgFromConfig(this._svgIconConfigs.get(key));
	        }
	        // See if we have any icon sets registered for the namespace.
	        var iconSetConfigs = this._iconSetConfigs.get(namespace);
	        if (iconSetConfigs) {
	            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);
	        }
	        return rxjs_Observable.Observable.throw(new MdIconNameNotFoundError(key));
	    };
	    /**
	     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
	     */
	    MdIconRegistry.prototype._getSvgFromConfig = function (config) {
	        if (config.svgElement) {
	            // We already have the SVG element for this icon, return a copy.
	            return rxjs_Observable.Observable.of(cloneSvg(config.svgElement));
	        }
	        else {
	            // Fetch the icon from the config's URL, cache it, and return a copy.
	            return this._loadSvgIconFromConfig(config)
	                .do(function (svg) { return config.svgElement = svg; })
	                .map(function (svg) { return cloneSvg(svg); });
	        }
	    };
	    /**
	     * Attempts to find an icon with the specified name in any of the SVG icon sets.
	     * First searches the available cached icons for a nested element with a matching name, and
	     * if found copies the element to a new <svg> element. If not found, fetches all icon sets
	     * that have not been cached, and searches again after all fetches are completed.
	     * The returned Observable produces the SVG element if possible, and throws
	     * MdIconNameNotFoundError if no icon with the specified name can be found.
	     */
	    MdIconRegistry.prototype._getSvgFromIconSetConfigs = function (name, iconSetConfigs) {
	        var _this = this;
	        // For all the icon set SVG elements we've fetched, see if any contain an icon with the
	        // requested name.
	        var namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
	        if (namedIcon) {
	            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every
	            // time anyway, there's probably not much advantage compared to just always extracting
	            // it from the icon set.
	            return rxjs_Observable.Observable.of(namedIcon);
	        }
	        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't
	        // fetched, fetch them now and look for iconName in the results.
	        var iconSetFetchRequests = iconSetConfigs
	            .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })
	            .map(function (iconSetConfig) {
	            return _this._loadSvgIconSetFromConfig(iconSetConfig)
	                .catch(function (err, caught) {
	                var url = _this._sanitizer.sanitize(_angular_core.SecurityContext.RESOURCE_URL, iconSetConfig.url);
	                // Swallow errors fetching individual URLs so the combined Observable won't
	                // necessarily fail.
	                console.log("Loading icon set URL: " + url + " failed: " + err);
	                return rxjs_Observable.Observable.of(null);
	            })
	                .do(function (svg) {
	                // Cache SVG element.
	                if (svg) {
	                    iconSetConfig.svgElement = svg;
	                }
	            });
	        });
	        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a
	        // cached SVG element (unless the request failed), and we can check again for the icon.
	        return rxjs_Observable.Observable.forkJoin(iconSetFetchRequests)
	            .map(function (ignoredResults) {
	            var foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);
	            if (!foundIcon) {
	                throw new MdIconNameNotFoundError(name);
	            }
	            return foundIcon;
	        });
	    };
	    /**
	     * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
	     * tag matches the specified name. If found, copies the nested element to a new SVG element and
	     * returns it. Returns null if no matching element is found.
	     */
	    MdIconRegistry.prototype._extractIconWithNameFromAnySet = function (iconName, iconSetConfigs) {
	        // Iterate backwards, so icon sets added later have precedence.
	        for (var i = iconSetConfigs.length - 1; i >= 0; i--) {
	            var config = iconSetConfigs[i];
	            if (config.svgElement) {
	                var foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName);
	                if (foundIcon) {
	                    return foundIcon;
	                }
	            }
	        }
	        return null;
	    };
	    /**
	     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
	     * from it.
	     */
	    MdIconRegistry.prototype._loadSvgIconFromConfig = function (config) {
	        var _this = this;
	        return this._fetchUrl(config.url)
	            .map(function (svgText) { return _this._createSvgElementForSingleIcon(svgText); });
	    };
	    /**
	     * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
	     * from it.
	     */
	    MdIconRegistry.prototype._loadSvgIconSetFromConfig = function (config) {
	        var _this = this;
	        // TODO: Document that icons should only be loaded from trusted sources.
	        return this._fetchUrl(config.url)
	            .map(function (svgText) { return _this._svgElementFromString(svgText); });
	    };
	    /**
	     * Creates a DOM element from the given SVG string, and adds default attributes.
	     */
	    MdIconRegistry.prototype._createSvgElementForSingleIcon = function (responseText) {
	        var svg = this._svgElementFromString(responseText);
	        this._setSvgAttributes(svg);
	        return svg;
	    };
	    /**
	     * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
	     * tag matches the specified name. If found, copies the nested element to a new SVG element and
	     * returns it. Returns null if no matching element is found.
	     */
	    MdIconRegistry.prototype._extractSvgIconFromSet = function (iconSet, iconName) {
	        var iconNode = iconSet.querySelector('#' + iconName);
	        if (!iconNode) {
	            return null;
	        }
	        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as
	        // the content of a new <svg> node.
	        if (iconNode.tagName.toLowerCase() == 'svg') {
	            return this._setSvgAttributes(iconNode.cloneNode(true));
	        }
	        // createElement('SVG') doesn't work as expected; the DOM ends up with
	        // the correct nodes, but the SVG content doesn't render. Instead we
	        // have to create an empty SVG node using innerHTML and append its content.
	        // Elements created using DOMParser.parseFromString have the same problem.
	        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display
	        var svg = this._svgElementFromString('<svg></svg>');
	        // Clone the node so we don't remove it from the parent icon set element.
	        svg.appendChild(iconNode.cloneNode(true));
	        return this._setSvgAttributes(svg);
	    };
	    /**
	     * Creates a DOM element from the given SVG string.
	     */
	    MdIconRegistry.prototype._svgElementFromString = function (str) {
	        // TODO: Is there a better way than innerHTML? Renderer doesn't appear to have a method for
	        // creating an element from an HTML string.
	        var div = document.createElement('DIV');
	        div.innerHTML = str;
	        var svg = div.querySelector('svg');
	        if (!svg) {
	            throw new MdIconSvgTagNotFoundError();
	        }
	        return svg;
	    };
	    /**
	     * Sets the default attributes for an SVG element to be used as an icon.
	     */
	    MdIconRegistry.prototype._setSvgAttributes = function (svg) {
	        if (!svg.getAttribute('xmlns')) {
	            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
	        }
	        svg.setAttribute('fit', '');
	        svg.setAttribute('height', '100%');
	        svg.setAttribute('width', '100%');
	        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
	        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
	        return svg;
	    };
	    /**
	     * Returns an Observable which produces the string contents of the given URL. Results may be
	     * cached, so future calls with the same URL may not cause another HTTP request.
	     */
	    MdIconRegistry.prototype._fetchUrl = function (safeUrl) {
	        var _this = this;
	        var url = this._sanitizer.sanitize(_angular_core.SecurityContext.RESOURCE_URL, safeUrl);
	        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
	        // already a request in progress for that URL. It's necessary to call share() on the
	        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
	        if (this._inProgressUrlFetches.has(url)) {
	            return this._inProgressUrlFetches.get(url);
	        }
	        // TODO(jelbourn): for some reason, the `finally` operator "loses" the generic type on the
	        // Observable. Figure out why and fix it.
	        var req = this._http.get(url)
	            .map(function (response) { return response.text(); })
	            .finally(function () {
	            _this._inProgressUrlFetches.delete(url);
	        })
	            .share();
	        this._inProgressUrlFetches.set(url, req);
	        return req;
	    };
	    MdIconRegistry = __decorate$47([
	        _angular_core.Injectable(), 
	        __metadata$47('design:paramtypes', [_angular_http.Http, _angular_platformBrowser.DomSanitizer])
	    ], MdIconRegistry);
	    return MdIconRegistry;
	}());
	/** Clones an SVGElement while preserving type information. */
	function cloneSvg(svg) {
	    return svg.cloneNode(true);
	}
	
	var __extends$12 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$46 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$46 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Exception thrown when an invalid icon name is passed to an md-icon component. */
	var MdIconInvalidNameError = (function (_super) {
	    __extends$12(MdIconInvalidNameError, _super);
	    function MdIconInvalidNameError(iconName) {
	        _super.call(this, "Invalid icon name: \"" + iconName + "\"");
	    }
	    return MdIconInvalidNameError;
	}(MdError));
	/**
	 * Component to display an icon. It can be used in the following ways:
	 * - Specify the svgSrc input to load an SVG icon from a URL. The SVG content is directly inlined
	 *   as a child of the <md-icon> component, so that CSS styles can easily be applied to it.
	 *   The URL is loaded via an XMLHttpRequest, so it must be on the same domain as the page or its
	 *   server must be configured to allow cross-domain requests.
	 *   Example:
	 *     <md-icon svgSrc="assets/arrow.svg"></md-icon>
	 *
	 * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the
	 *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of
	 *   MdIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format
	 *   "[namespace]:[name]", if not the value will be the name of an icon in the default namespace.
	 *   Examples:
	 *     <md-icon svgIcon="left-arrow"></md-icon>
	 *     <md-icon svgIcon="animals:cat"></md-icon>
	 *
	 * - Use a font ligature as an icon by putting the ligature text in the content of the <md-icon>
	 *   component. By default the Material icons font is used as described at
	 *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an
	 *   alternate font by setting the fontSet input to either the CSS class to apply to use the
	 *   desired font, or to an alias previously registered with MdIconRegistry.registerFontClassAlias.
	 *   Examples:
	 *     <md-icon>home</md-icon>
	 *     <md-icon fontSet="myfont">sun</md-icon>
	 *
	 * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the
	 *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a
	 *   CSS class which causes the glyph to be displayed via a :before selector, as in
	 *   https://fortawesome.github.io/Font-Awesome/examples/
	 *   Example:
	 *     <md-icon fontSet="fa" fontIcon="alarm"></md-icon>
	 */
	var MdIcon = (function () {
	    function MdIcon(_elementRef, _renderer, _mdIconRegistry) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._mdIconRegistry = _mdIconRegistry;
	        /** Screenreader label for the icon. */
	        this.hostAriaLabel = '';
	    }
	    Object.defineProperty(MdIcon.prototype, "color", {
	        /** Color of the icon. */
	        get: function () { return this._color; },
	        set: function (value) { this._updateColor(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdIcon.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdIcon.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    /**
	     * Splits an svgIcon binding value into its icon set and icon name components.
	     * Returns a 2-element array of [(icon set), (icon name)].
	     * The separator for the two fields is ':'. If there is no separator, an empty
	     * string is returned for the icon set and the entire value is returned for
	     * the icon name. If the argument is falsy, returns an array of two empty strings.
	     * Throws a MdIconInvalidNameError if the name contains two or more ':' separators.
	     * Examples:
	     *   'social:cake' -> ['social', 'cake']
	     *   'penguin' -> ['', 'penguin']
	     *   null -> ['', '']
	     *   'a:b:c' -> (throws MdIconInvalidNameError)
	     */
	    MdIcon.prototype._splitIconName = function (iconName) {
	        if (!iconName) {
	            return ['', ''];
	        }
	        var parts = iconName.split(':');
	        switch (parts.length) {
	            case 1:
	                // Use default namespace.
	                return ['', parts[0]];
	            case 2:
	                return parts;
	            default:
	                throw new MdIconInvalidNameError(iconName);
	        }
	    };
	    MdIcon.prototype.ngOnChanges = function (changes) {
	        var _this = this;
	        var changedInputs = Object.keys(changes);
	        // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.
	        if (changedInputs.indexOf('svgIcon') != -1 || changedInputs.indexOf('svgSrc') != -1) {
	            if (this.svgIcon) {
	                var _a = this._splitIconName(this.svgIcon), namespace = _a[0], iconName = _a[1];
	                this._mdIconRegistry.getNamedSvgIcon(iconName, namespace).first().subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) { return console.log("Error retrieving icon: " + err); });
	            }
	        }
	        if (this._usingFontIcon()) {
	            this._updateFontIconClasses();
	        }
	        this._updateAriaLabel();
	    };
	    MdIcon.prototype.ngOnInit = function () {
	        // Update font classes because ngOnChanges won't be called if none of the inputs are present,
	        // e.g. <md-icon>arrow</md-icon>. In this case we need to add a CSS class for the default font.
	        if (this._usingFontIcon()) {
	            this._updateFontIconClasses();
	        }
	    };
	    MdIcon.prototype.ngAfterViewChecked = function () {
	        // Update aria label here because it may depend on the projected text content.
	        // (e.g. <md-icon>home</md-icon> should use 'home').
	        this._updateAriaLabel();
	    };
	    MdIcon.prototype._updateAriaLabel = function () {
	        var ariaLabel = this._getAriaLabel();
	        if (ariaLabel && ariaLabel !== this._previousAriaLabel) {
	            this._previousAriaLabel = ariaLabel;
	            this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-label', ariaLabel);
	        }
	    };
	    MdIcon.prototype._getAriaLabel = function () {
	        // If the parent provided an aria-label attribute value, use it as-is. Otherwise look for a
	        // reasonable value from the alt attribute, font icon name, SVG icon name, or (for ligatures)
	        // the text content of the directive.
	        var label = this.hostAriaLabel ||
	            this.alt ||
	            this.fontIcon ||
	            this._splitIconName(this.svgIcon)[1];
	        if (label) {
	            return label;
	        }
	        // The "content" of an SVG icon is not a useful label.
	        if (this._usingFontIcon()) {
	            var text = this._elementRef.nativeElement.textContent;
	            if (text) {
	                return text;
	            }
	        }
	        // TODO: Warn here in dev mode.
	        return null;
	    };
	    MdIcon.prototype._usingFontIcon = function () {
	        return !this.svgIcon;
	    };
	    MdIcon.prototype._setSvgElement = function (svg) {
	        var layoutElement = this._elementRef.nativeElement;
	        // Remove existing child nodes and add the new SVG element.
	        // We would use renderer.detachView(Array.from(layoutElement.childNodes)) here,
	        // but it fails in IE11: https://github.com/angular/angular/issues/6327
	        layoutElement.innerHTML = '';
	        this._renderer.projectNodes(layoutElement, [svg]);
	    };
	    MdIcon.prototype._updateFontIconClasses = function () {
	        if (!this._usingFontIcon()) {
	            return;
	        }
	        var elem = this._elementRef.nativeElement;
	        var fontSetClass = this.fontSet ?
	            this._mdIconRegistry.classNameForFontAlias(this.fontSet) :
	            this._mdIconRegistry.getDefaultFontSetClass();
	        if (fontSetClass != this._previousFontSetClass) {
	            if (this._previousFontSetClass) {
	                this._renderer.setElementClass(elem, this._previousFontSetClass, false);
	            }
	            if (fontSetClass) {
	                this._renderer.setElementClass(elem, fontSetClass, true);
	            }
	            this._previousFontSetClass = fontSetClass;
	        }
	        if (this.fontIcon != this._previousFontIconClass) {
	            if (this._previousFontIconClass) {
	                this._renderer.setElementClass(elem, this._previousFontIconClass, false);
	            }
	            if (this.fontIcon) {
	                this._renderer.setElementClass(elem, this.fontIcon, true);
	            }
	            this._previousFontIconClass = this.fontIcon;
	        }
	    };
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "svgIcon", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "fontSet", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "fontIcon", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "alt", void 0);
	    __decorate$46([
	        _angular_core.Input('aria-label'), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "hostAriaLabel", void 0);
	    __decorate$46([
	        _angular_core.Input(), 
	        __metadata$46('design:type', String)
	    ], MdIcon.prototype, "color", null);
	    MdIcon = __decorate$46([
	        _angular_core.Component({template: '<ng-content></ng-content>',
	            selector: 'md-icon, mat-icon',
	            styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}"],
	            host: {
	                'role': 'img',
	                '[class.mat-icon]': 'true',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$46('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer, MdIconRegistry])
	    ], MdIcon);
	    return MdIcon;
	}());
	function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, http, sanitizer) {
	    return parentRegistry || new MdIconRegistry(http, sanitizer);
	}
	
	var ICON_REGISTRY_PROVIDER = {
	    // If there is already an MdIconRegistry available, use that. Otherwise, provide a new one.
	    provide: MdIconRegistry,
	    deps: [[new _angular_core.Optional(), new _angular_core.SkipSelf(), MdIconRegistry], _angular_http.Http, _angular_platformBrowser.DomSanitizer],
	    useFactory: ICON_REGISTRY_PROVIDER_FACTORY,
	};
	var MdIconModule = (function () {
	    function MdIconModule() {
	    }
	    /** @deprecated */
	    MdIconModule.forRoot = function () {
	        return {
	            ngModule: MdIconModule,
	            providers: [],
	        };
	    };
	    MdIconModule = __decorate$46([
	        _angular_core.NgModule({
	            imports: [_angular_http.HttpModule, CompatibilityModule],
	            exports: [MdIcon, CompatibilityModule],
	            declarations: [MdIcon],
	            providers: [ICON_REGISTRY_PROVIDER],
	        }), 
	        __metadata$46('design:paramtypes', [])
	    ], MdIconModule);
	    return MdIconModule;
	}());
	
	var __extends$14 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$48 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$48 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(josephperrott): Benchpress tests.
	/** A single degree in radians. */
	var DEGREE_IN_RADIANS = Math.PI / 180;
	/** Duration of the indeterminate animation. */
	var DURATION_INDETERMINATE = 667;
	/** Duration of the indeterminate animation. */
	var DURATION_DETERMINATE = 225;
	/** Start animation value of the indeterminate animation */
	var startIndeterminate = 3;
	/** End animation value of the indeterminate animation */
	var endIndeterminate = 80;
	/* Maximum angle for the arc. The angle can't be exactly 360, because the arc becomes hidden. */
	var MAX_ANGLE = 359.99 / 100;
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdProgressSpinnerCssMatStyler = (function () {
	    function MdProgressSpinnerCssMatStyler() {
	    }
	    MdProgressSpinnerCssMatStyler = __decorate$48([
	        _angular_core.Directive({
	            selector: 'md-progress-spinner, mat-progress-spinner',
	            host: {
	                '[class.mat-progress-spinner]': 'true'
	            }
	        }), 
	        __metadata$48('design:paramtypes', [])
	    ], MdProgressSpinnerCssMatStyler);
	    return MdProgressSpinnerCssMatStyler;
	}());
	/**
	 * Directive whose purpose is to add the mat- CSS styling to this selector.
	 */
	var MdProgressCircleCssMatStyler = (function () {
	    function MdProgressCircleCssMatStyler() {
	    }
	    MdProgressCircleCssMatStyler = __decorate$48([
	        _angular_core.Directive({
	            selector: 'md-progress-circle, mat-progress-circle',
	            host: {
	                '[class.mat-progress-circle]': 'true'
	            }
	        }), 
	        __metadata$48('design:paramtypes', [])
	    ], MdProgressCircleCssMatStyler);
	    return MdProgressCircleCssMatStyler;
	}());
	/**
	 * <md-progress-spinner> component.
	 */
	var MdProgressSpinner = (function () {
	    function MdProgressSpinner(_ngZone, _elementRef, _renderer) {
	        this._ngZone = _ngZone;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        /** The id of the last requested animation. */
	        this._lastAnimationId = 0;
	        this._mode = 'determinate';
	        this._color = 'primary';
	    }
	    Object.defineProperty(MdProgressSpinner.prototype, "_ariaValueMin", {
	        /**
	         * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this
	         * because voiceover does not report the progress indicator as indeterminate if the aria min
	         * and/or max value are number values.
	         */
	        get: function () {
	            return this.mode == 'determinate' ? 0 : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "_ariaValueMax", {
	        get: function () {
	            return this.mode == 'determinate' ? 100 : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "interdeterminateInterval", {
	        /** @docs-private */
	        get: function () {
	            return this._interdeterminateInterval;
	        },
	        /** @docs-private */
	        set: function (interval) {
	            clearInterval(this._interdeterminateInterval);
	            this._interdeterminateInterval = interval;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clean up any animations that were running.
	     */
	    MdProgressSpinner.prototype.ngOnDestroy = function () {
	        this._cleanupIndeterminateAnimation();
	    };
	    Object.defineProperty(MdProgressSpinner.prototype, "color", {
	        /** The color of the progress-spinner. Can be primary, accent, or warn. */
	        get: function () { return this._color; },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "value", {
	        /** Value of the progress circle. It is bound to the host as the attribute aria-valuenow. */
	        get: function () {
	            if (this.mode == 'determinate') {
	                return this._value;
	            }
	        },
	        set: function (v) {
	            if (v != null && this.mode == 'determinate') {
	                var newValue = clamp(v);
	                this._animateCircle((this.value || 0), newValue, linearEase, DURATION_DETERMINATE, 0);
	                this._value = newValue;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressSpinner.prototype, "mode", {
	        /**
	         * Mode of the progress circle
	         *
	         * Input must be one of the values from ProgressMode, defaults to 'determinate'.
	         * mode is bound to the host as the attribute host.
	         */
	        get: function () {
	            return this._mode;
	        },
	        set: function (m) {
	            if (m == 'indeterminate') {
	                this._startIndeterminateAnimation();
	            }
	            else {
	                this._cleanupIndeterminateAnimation();
	            }
	            this._mode = m;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Animates the circle from one percentage value to another.
	     *
	     * @param animateFrom The percentage of the circle filled starting the animation.
	     * @param animateTo The percentage of the circle filled ending the animation.
	     * @param ease The easing function to manage the pace of change in the animation.
	     * @param duration The length of time to show the animation, in milliseconds.
	     * @param rotation The starting angle of the circle fill, with 0° represented at the top center
	     *    of the circle.
	     */
	    MdProgressSpinner.prototype._animateCircle = function (animateFrom, animateTo, ease, duration, rotation) {
	        var _this = this;
	        var id = ++this._lastAnimationId;
	        var startTime = Date.now();
	        var changeInValue = animateTo - animateFrom;
	        // No need to animate it if the values are the same
	        if (animateTo === animateFrom) {
	            this._renderArc(animateTo, rotation);
	        }
	        else {
	            var animation_1 = function () {
	                var elapsedTime = Math.max(0, Math.min(Date.now() - startTime, duration));
	                _this._renderArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);
	                // Prevent overlapping animations by checking if a new animation has been called for and
	                // if the animation has lasted longer than the animation duration.
	                if (id === _this._lastAnimationId && elapsedTime < duration) {
	                    requestAnimationFrame(animation_1);
	                }
	            };
	            // Run the animation outside of Angular's zone, in order to avoid
	            // hitting ZoneJS and change detection on each frame.
	            this._ngZone.runOutsideAngular(animation_1);
	        }
	    };
	    /**
	     * Starts the indeterminate animation interval, if it is not already running.
	     */
	    MdProgressSpinner.prototype._startIndeterminateAnimation = function () {
	        var _this = this;
	        var rotationStartPoint = 0;
	        var start = startIndeterminate;
	        var end = endIndeterminate;
	        var duration = DURATION_INDETERMINATE;
	        var animate$$1 = function () {
	            _this._animateCircle(start, end, materialEase, duration, rotationStartPoint);
	            // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.
	            rotationStartPoint = (rotationStartPoint + end) % 100;
	            var temp = start;
	            start = -end;
	            end = -temp;
	        };
	        if (!this.interdeterminateInterval) {
	            this._ngZone.runOutsideAngular(function () {
	                _this.interdeterminateInterval = setInterval(animate$$1, duration + 50, 0, false);
	                animate$$1();
	            });
	        }
	    };
	    /**
	     * Removes interval, ending the animation.
	     */
	    MdProgressSpinner.prototype._cleanupIndeterminateAnimation = function () {
	        this.interdeterminateInterval = null;
	    };
	    /**
	     * Renders the arc onto the SVG element. Proxies `getArc` while setting the proper
	     * DOM attribute on the `<path>`.
	     */
	    MdProgressSpinner.prototype._renderArc = function (currentValue, rotation) {
	        // Caches the path reference so it doesn't have to be looked up every time.
	        var path = this._path = this._path || this._elementRef.nativeElement.querySelector('path');
	        // Ensure that the path was found. This may not be the case if the
	        // animation function fires too early.
	        if (path) {
	            path.setAttribute('d', getSvgArc(currentValue, rotation));
	        }
	    };
	    /**
	     * Updates the color of the progress-spinner by adding the new palette class to the element
	     * and removing the old one.
	     */
	    MdProgressSpinner.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    /** Sets the given palette class on the component element. */
	    MdProgressSpinner.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this._renderer.setElementClass(this._elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    __decorate$48([
	        _angular_core.Input(), 
	        __metadata$48('design:type', String)
	    ], MdProgressSpinner.prototype, "color", null);
	    __decorate$48([
	        _angular_core.Input(),
	        _angular_core.HostBinding('attr.aria-valuenow'), 
	        __metadata$48('design:type', Object)
	    ], MdProgressSpinner.prototype, "value", null);
	    __decorate$48([
	        _angular_core.HostBinding('attr.mode'),
	        _angular_core.Input(), 
	        __metadata$48('design:type', Object)
	    ], MdProgressSpinner.prototype, "mode", null);
	    MdProgressSpinner = __decorate$48([
	        _angular_core.Component({selector: 'md-progress-spinner, mat-progress-spinner, md-progress-circle, mat-progress-circle',
	            host: {
	                'role': 'progressbar',
	                '[attr.aria-valuemin]': '_ariaValueMin',
	                '[attr.aria-valuemax]': '_ariaValueMax'
	            },
	            template: "<svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid meet\"><path></path></svg>",
	            styles: [":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;stroke-width:10px}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}"],
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$48('design:paramtypes', [_angular_core.NgZone, _angular_core.ElementRef, _angular_core.Renderer])
	    ], MdProgressSpinner);
	    return MdProgressSpinner;
	}());
	/**
	 * <md-spinner> component.
	 *
	 * This is a component definition to be used as a convenience reference to create an
	 * indeterminate <md-progress-spinner> instance.
	 */
	var MdSpinner = (function (_super) {
	    __extends$14(MdSpinner, _super);
	    function MdSpinner(elementRef, ngZone, renderer) {
	        _super.call(this, ngZone, elementRef, renderer);
	        this.mode = 'indeterminate';
	    }
	    MdSpinner.prototype.ngOnDestroy = function () {
	        // The `ngOnDestroy` from `MdProgressSpinner` should be called explicitly, because
	        // in certain cases Angular won't call it (e.g. when using AoT and in unit tests).
	        _super.prototype.ngOnDestroy.call(this);
	    };
	    MdSpinner = __decorate$48([
	        _angular_core.Component({selector: 'md-spinner, mat-spinner',
	            host: {
	                'role': 'progressbar',
	                'mode': 'indeterminate',
	                '[class.mat-spinner]': 'true',
	            },
	            template: "<svg viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid meet\"><path></path></svg>",
	            styles: [":host{display:block;height:100px;width:100px;overflow:hidden}:host svg{height:100%;width:100%;transform-origin:center}:host path{fill:transparent;stroke-width:10px}:host[mode=indeterminate] svg{animation-duration:5.25s,2.887s;animation-name:mat-progress-spinner-sporadic-rotate,mat-progress-spinner-linear-rotate;animation-timing-function:cubic-bezier(.35,0,.25,1),linear;animation-iteration-count:infinite;transition:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-sporadic-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}"],
	        }), 
	        __metadata$48('design:paramtypes', [_angular_core.ElementRef, _angular_core.NgZone, _angular_core.Renderer])
	    ], MdSpinner);
	    return MdSpinner;
	}(MdProgressSpinner));
	/**
	 * Module functions.
	 */
	/** Clamps a value to be between 0 and 100. */
	function clamp(v) {
	    return Math.max(0, Math.min(100, v));
	}
	/**
	 * Converts Polar coordinates to Cartesian.
	 */
	function polarToCartesian(radius, pathRadius, angleInDegrees) {
	    var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;
	    return (radius + (pathRadius * Math.cos(angleInRadians))) +
	        ',' + (radius + (pathRadius * Math.sin(angleInRadians)));
	}
	/**
	 * Easing function for linear animation.
	 */
	function linearEase(currentTime, startValue, changeInValue, duration) {
	    return changeInValue * currentTime / duration + startValue;
	}
	/**
	 * Easing function to match material design indeterminate animation.
	 */
	function materialEase(currentTime, startValue, changeInValue, duration) {
	    var time = currentTime / duration;
	    var timeCubed = Math.pow(time, 3);
	    var timeQuad = Math.pow(time, 4);
	    var timeQuint = Math.pow(time, 5);
	    return startValue + changeInValue * ((6 * timeQuint) + (-15 * timeQuad) + (10 * timeCubed));
	}
	/**
	 * Determines the path value to define the arc.  Converting percentage values to to polar
	 * coordinates on the circle, and then to cartesian coordinates in the viewport.
	 *
	 * @param currentValue The current percentage value of the progress circle, the percentage of the
	 *    circle to fill.
	 * @param rotation The starting point of the circle with 0 being the 0 degree point.
	 * @return A string for an SVG path representing a circle filled from the starting point to the
	 *    percentage value provided.
	 */
	function getSvgArc(currentValue, rotation) {
	    var startPoint = rotation || 0;
	    var radius = 50;
	    var pathRadius = 40;
	    var startAngle = startPoint * MAX_ANGLE;
	    var endAngle = currentValue * MAX_ANGLE;
	    var start = polarToCartesian(radius, pathRadius, startAngle);
	    var end = polarToCartesian(radius, pathRadius, endAngle + startAngle);
	    var arcSweep = endAngle < 0 ? 0 : 1;
	    var largeArcFlag;
	    if (endAngle < 0) {
	        largeArcFlag = endAngle >= -180 ? 0 : 1;
	    }
	    else {
	        largeArcFlag = endAngle <= 180 ? 0 : 1;
	    }
	    return "M" + start + "A" + pathRadius + "," + pathRadius + " 0 " + largeArcFlag + "," + arcSweep + " " + end;
	}
	var MdProgressSpinnerModule = (function () {
	    function MdProgressSpinnerModule() {
	    }
	    /** @deprecated */
	    MdProgressSpinnerModule.forRoot = function () {
	        return {
	            ngModule: MdProgressSpinnerModule,
	            providers: []
	        };
	    };
	    MdProgressSpinnerModule = __decorate$48([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [
	                MdProgressSpinner,
	                MdSpinner,
	                CompatibilityModule,
	                MdProgressSpinnerCssMatStyler,
	                MdProgressCircleCssMatStyler
	            ],
	            declarations: [
	                MdProgressSpinner,
	                MdSpinner,
	                MdProgressSpinnerCssMatStyler,
	                MdProgressCircleCssMatStyler
	            ],
	        }), 
	        __metadata$48('design:paramtypes', [])
	    ], MdProgressSpinnerModule);
	    return MdProgressSpinnerModule;
	}());
	
	/** @deprecated */
	
	var __decorate$49 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$49 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(josephperrott): Benchpress tests.
	// TODO(josephperrott): Add ARIA attributes for progressbar "for".
	/**
	 * <md-progress-bar> component.
	 */
	var MdProgressBar = (function () {
	    function MdProgressBar() {
	        /** Color of the progress bar. */
	        this.color = 'primary';
	        this._value = 0;
	        this._bufferValue = 0;
	        /**
	         * Mode of the progress bar.
	         *
	         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
	         * 'determinate'.
	         * Mirrored to mode attribute.
	         */
	        this.mode = 'determinate';
	    }
	    Object.defineProperty(MdProgressBar.prototype, "value", {
	        /** Value of the progressbar. Defaults to zero. Mirrored to aria-valuenow. */
	        get: function () { return this._value; },
	        set: function (v) { this._value = clamp$1(v || 0); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdProgressBar.prototype, "bufferValue", {
	        /** Buffer value of the progress bar. Defaults to zero. */
	        get: function () { return this._bufferValue; },
	        set: function (v) { this._bufferValue = clamp$1(v || 0); },
	        enumerable: true,
	        configurable: true
	    });
	    /** Gets the current transform value for the progress bar's primary indicator. */
	    MdProgressBar.prototype._primaryTransform = function () {
	        var scale = this.value / 100;
	        return { transform: "scaleX(" + scale + ")" };
	    };
	    /**
	     * Gets the current transform value for the progress bar's buffer indicator.  Only used if the
	     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.
	     */
	    MdProgressBar.prototype._bufferTransform = function () {
	        if (this.mode == 'buffer') {
	            var scale = this.bufferValue / 100;
	            return { transform: "scaleX(" + scale + ")" };
	        }
	    };
	    __decorate$49([
	        _angular_core.Input(), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "color", void 0);
	    __decorate$49([
	        _angular_core.Input(),
	        _angular_core.HostBinding('attr.aria-valuenow'), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "value", null);
	    __decorate$49([
	        _angular_core.Input(), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "bufferValue", null);
	    __decorate$49([
	        _angular_core.Input(),
	        _angular_core.HostBinding('attr.mode'), 
	        __metadata$49('design:type', Object)
	    ], MdProgressBar.prototype, "mode", void 0);
	    MdProgressBar = __decorate$49([
	        _angular_core.Component({selector: 'md-progress-bar, mat-progress-bar',
	            host: {
	                'role': 'progressbar',
	                'aria-valuemin': '0',
	                'aria-valuemax': '100',
	                '[class.mat-primary]': 'color == "primary"',
	                '[class.mat-accent]': 'color == "accent"',
	                '[class.mat-warn]': 'color == "warn"',
	                '[class.mat-progress-bar]': 'true',
	            },
	            template: "<div class=\"mat-progress-bar-background mat-progress-bar-element\"></div><div class=\"mat-progress-bar-buffer mat-progress-bar-element\" [ngStyle]=\"_bufferTransform()\"></div><div class=\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\" [ngStyle]=\"_primaryTransform()\"></div><div class=\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\"></div>",
	            styles: [":host{display:block;height:5px;overflow:hidden;position:relative;transform:translateZ(0);transition:opacity 250ms linear;width:100%}:host .mat-progress-bar-element,:host .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}:host .mat-progress-bar-background{background-repeat:repeat-x;background-size:10px 4px;display:none}:host .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}:host .mat-progress-bar-secondary{display:none}:host .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}:host .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}:host[mode=query]{transform:rotateZ(180deg)}:host[mode=query] .mat-progress-bar-fill,:host[mode=indeterminate] .mat-progress-bar-fill{transition:none}:host[mode=query] .mat-progress-bar-primary,:host[mode=indeterminate] .mat-progress-bar-primary{animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}:host[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after,:host[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after{animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}:host[mode=query] .mat-progress-bar-secondary,:host[mode=indeterminate] .mat-progress-bar-secondary{animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}:host[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after,:host[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}:host[mode=buffer] .mat-progress-bar-background{animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}:host-context([dir=rtl]){transform:rotateY(180deg)}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-10px)}}"],
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	        }), 
	        __metadata$49('design:paramtypes', [])
	    ], MdProgressBar);
	    return MdProgressBar;
	}());
	/** Clamps a value to be between two numbers, by default 0 and 100. */
	function clamp$1(v, min, max) {
	    if (min === void 0) { min = 0; }
	    if (max === void 0) { max = 100; }
	    return Math.max(min, Math.min(max, v));
	}
	var MdProgressBarModule = (function () {
	    function MdProgressBarModule() {
	    }
	    /** @deprecated */
	    MdProgressBarModule.forRoot = function () {
	        return {
	            ngModule: MdProgressBarModule,
	            providers: []
	        };
	    };
	    MdProgressBarModule = __decorate$49([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, CompatibilityModule],
	            exports: [MdProgressBar, CompatibilityModule],
	            declarations: [MdProgressBar],
	        }), 
	        __metadata$49('design:paramtypes', [])
	    ], MdProgressBarModule);
	    return MdProgressBarModule;
	}());
	
	var __extends$15 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/** @docs-private */
	var MdInputContainerPlaceholderConflictError = (function (_super) {
	    __extends$15(MdInputContainerPlaceholderConflictError, _super);
	    function MdInputContainerPlaceholderConflictError() {
	        _super.call(this, 'Placeholder attribute and child element were both specified.');
	    }
	    return MdInputContainerPlaceholderConflictError;
	}(MdError));
	/** @docs-private */
	var MdInputContainerUnsupportedTypeError = (function (_super) {
	    __extends$15(MdInputContainerUnsupportedTypeError, _super);
	    function MdInputContainerUnsupportedTypeError(type) {
	        _super.call(this, "Input type \"" + type + "\" isn't supported by md-input-container.");
	    }
	    return MdInputContainerUnsupportedTypeError;
	}(MdError));
	/** @docs-private */
	var MdInputContainerDuplicatedHintError = (function (_super) {
	    __extends$15(MdInputContainerDuplicatedHintError, _super);
	    function MdInputContainerDuplicatedHintError(align) {
	        _super.call(this, "A hint was already declared for 'align=\"" + align + "\"'.");
	    }
	    return MdInputContainerDuplicatedHintError;
	}(MdError));
	/** @docs-private */
	var MdInputContainerMissingMdInputError = (function (_super) {
	    __extends$15(MdInputContainerMissingMdInputError, _super);
	    function MdInputContainerMissingMdInputError() {
	        _super.call(this, 'md-input-container must contain an mdInput directive. Did you forget to add mdInput ' +
	            'to the native input or textarea element?');
	    }
	    return MdInputContainerMissingMdInputError;
	}(MdError));
	
	var __decorate$51 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$51 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$10 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	// Invalid input type. Using one of these will throw an MdInputContainerUnsupportedTypeError.
	var MD_INPUT_INVALID_TYPES = [
	    'button',
	    'checkbox',
	    'color',
	    'file',
	    'hidden',
	    'image',
	    'radio',
	    'range',
	    'reset',
	    'submit'
	];
	var nextUniqueId$1 = 0;
	/**
	 * The placeholder directive. The content can declare this to implement more
	 * complex placeholders.
	 */
	var MdPlaceholder = (function () {
	    function MdPlaceholder() {
	    }
	    MdPlaceholder = __decorate$51([
	        _angular_core.Directive({
	            selector: 'md-placeholder, mat-placeholder'
	        }), 
	        __metadata$51('design:paramtypes', [])
	    ], MdPlaceholder);
	    return MdPlaceholder;
	}());
	/** The hint directive, used to tag content as hint labels (going under the input). */
	var MdHint = (function () {
	    function MdHint() {
	        // Whether to align the hint label at the start or end of the line.
	        this.align = 'start';
	        // Unique ID for the hint. Used for the aria-describedby on the input.
	        this.id = "md-input-hint-" + nextUniqueId$1++;
	    }
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdHint.prototype, "align", void 0);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', String)
	    ], MdHint.prototype, "id", void 0);
	    MdHint = __decorate$51([
	        _angular_core.Directive({
	            selector: 'md-hint, mat-hint',
	            host: {
	                '[class.mat-hint]': 'true',
	                '[class.mat-right]': 'align == "end"',
	                '[attr.id]': 'id',
	            }
	        }), 
	        __metadata$51('design:paramtypes', [])
	    ], MdHint);
	    return MdHint;
	}());
	/** The input directive, used to mark the input that `MdInputContainer` is wrapping. */
	var MdInputDirective = (function () {
	    function MdInputDirective(_elementRef, _renderer, _ngControl) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._ngControl = _ngControl;
	        /** Variables used as cache for getters and setters. */
	        this._type = 'text';
	        this._placeholder = '';
	        this._disabled = false;
	        this._required = false;
	        /** Whether the element is focused or not. */
	        this.focused = false;
	        /**
	         * Emits an event when the placeholder changes so that the `md-input-container` can re-validate.
	         */
	        this._placeholderChange = new _angular_core.EventEmitter();
	        this._neverEmptyInputTypes = [
	            'date',
	            'datetime',
	            'datetime-local',
	            'month',
	            'time',
	            'week'
	        ].filter(function (t) { return getSupportedInputTypes().has(t); });
	        // Force setter to be called in case id was not specified.
	        this.id = this.id;
	    }
	    Object.defineProperty(MdInputDirective.prototype, "disabled", {
	        /** Whether the element is disabled. */
	        get: function () {
	            return this._ngControl ? this._ngControl.disabled : this._disabled;
	        },
	        set: function (value) {
	            this._disabled = coerceBooleanProperty(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "id", {
	        /** Unique id of the element. */
	        get: function () { return this._id; },
	        set: function (value) { this._id = value || this._uid; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(MdInputDirective.prototype, "placeholder", {
	        /** Placeholder attribute of the element. */
	        get: function () { return this._placeholder; },
	        set: function (value) {
	            if (this._placeholder !== value) {
	                this._placeholder = value;
	                this._placeholderChange.emit(this._placeholder);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "required", {
	        /** Whether the element is required. */
	        get: function () { return this._required; },
	        set: function (value) { this._required = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "type", {
	        /** Input type of the element. */
	        get: function () { return this._type; },
	        set: function (value) {
	            this._type = value || 'text';
	            this._validateType();
	            // When using Angular inputs, developers are no longer able to set the properties on the native
	            // input element. To ensure that bindings for `type` work, we need to sync the setter
	            // with the native property. Textarea elements don't support the type property or attribute.
	            if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
	                this._renderer.setElementProperty(this._elementRef.nativeElement, 'type', this._type);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "value", {
	        /** The input element's value. */
	        get: function () { return this._elementRef.nativeElement.value; },
	        set: function (value) { this._elementRef.nativeElement.value = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "empty", {
	        get: function () {
	            return !this._isNeverEmpty() &&
	                (this.value == null || this.value === '') &&
	                // Check if the input contains bad input. If so, we know that it only appears empty because
	                // the value failed to parse. From the user's perspective it is not empty.
	                // TODO(mmalerba): Add e2e test for bad input case.
	                !this._isBadInput();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputDirective.prototype, "_uid", {
	        get: function () { return this._cachedUid = this._cachedUid || "md-input-" + nextUniqueId$1++; },
	        enumerable: true,
	        configurable: true
	    });
	    /** Focuses the input element. */
	    MdInputDirective.prototype.focus = function () { this._renderer.invokeElementMethod(this._elementRef.nativeElement, 'focus'); };
	    MdInputDirective.prototype._onFocus = function () { this.focused = true; };
	    MdInputDirective.prototype._onBlur = function () { this.focused = false; };
	    MdInputDirective.prototype._onInput = function () {
	        // This is a noop function and is used to let Angular know whenever the value changes.
	        // Angular will run a new change detection each time the `input` event has been dispatched.
	        // It's necessary that Angular recognizes the value change, because when floatingLabel
	        // is set to false and Angular forms aren't used, the placeholder won't recognize the
	        // value changes and will not disappear.
	        // Listening to the input event wouldn't be necessary when the input is using the
	        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
	    };
	    /** Make sure the input is a supported type. */
	    MdInputDirective.prototype._validateType = function () {
	        if (MD_INPUT_INVALID_TYPES.indexOf(this._type) !== -1) {
	            throw new MdInputContainerUnsupportedTypeError(this._type);
	        }
	    };
	    MdInputDirective.prototype._isNeverEmpty = function () { return this._neverEmptyInputTypes.indexOf(this._type) !== -1; };
	    MdInputDirective.prototype._isBadInput = function () {
	        return this._elementRef.nativeElement.validity.badInput;
	    };
	    /** Determines if the component host is a textarea. If not recognizable it returns false. */
	    MdInputDirective.prototype._isTextarea = function () {
	        var nativeElement = this._elementRef.nativeElement;
	        return nativeElement ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
	    };
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "disabled", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "id", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "placeholder", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "required", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "type", null);
	    __decorate$51([
	        _angular_core.Output(), 
	        __metadata$51('design:type', Object)
	    ], MdInputDirective.prototype, "_placeholderChange", void 0);
	    MdInputDirective = __decorate$51([
	        _angular_core.Directive({
	            selector: "input[mdInput], textarea[mdInput], input[matInput], textarea[matInput]",
	            host: {
	                '[class.mat-input-element]': 'true',
	                // Native input properties that are overwritten by Angular inputs need to be synced with
	                // the native input element. Otherwise property bindings for those don't work.
	                '[id]': 'id',
	                '[placeholder]': 'placeholder',
	                '[disabled]': 'disabled',
	                '[required]': 'required',
	                '[attr.aria-describedby]': 'ariaDescribedby',
	                '(blur)': '_onBlur()',
	                '(focus)': '_onFocus()',
	                '(input)': '_onInput()',
	            }
	        }),
	        __param$10(2, _angular_core.Optional()), 
	        __metadata$51('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer, _angular_forms.NgControl])
	    ], MdInputDirective);
	    return MdInputDirective;
	}());
	/**
	 * Component that represents a text input. It encapsulates the <input> HTMLElement and
	 * improve on its behaviour, along with styling it according to the Material Design.
	 */
	var MdInputContainer = (function () {
	    function MdInputContainer() {
	        /** Alignment of the input container's content. */
	        this.align = 'start';
	        /** Color of the input divider, based on the theme. */
	        this.dividerColor = 'primary';
	        this._hintLabel = '';
	        // Unique id for the hint label.
	        this._hintLabelId = "md-input-hint-" + nextUniqueId$1++;
	        this._floatPlaceholder = 'auto';
	    }
	    Object.defineProperty(MdInputContainer.prototype, "_shouldAlwaysFloat", {
	        /** Whether the floating label should always float or not. */
	        get: function () { return this._floatPlaceholder === 'always'; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(MdInputContainer.prototype, "_canPlaceholderFloat", {
	        /** Whether the placeholder can float or not. */
	        get: function () { return this._floatPlaceholder !== 'never'; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputContainer.prototype, "hintLabel", {
	        /** Text for the input hint. */
	        get: function () { return this._hintLabel; },
	        set: function (value) {
	            this._hintLabel = value;
	            this._processHints();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdInputContainer.prototype, "floatPlaceholder", {
	        /** Whether the placeholder should always float, never float or float as the user types. */
	        get: function () { return this._floatPlaceholder; },
	        set: function (value) {
	            this._floatPlaceholder = value || 'auto';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdInputContainer.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        if (!this._mdInputChild) {
	            throw new MdInputContainerMissingMdInputError();
	        }
	        this._processHints();
	        this._validatePlaceholders();
	        // Re-validate when things change.
	        this._hintChildren.changes.subscribe(function () { return _this._processHints(); });
	        this._mdInputChild._placeholderChange.subscribe(function () { return _this._validatePlaceholders(); });
	    };
	    /** Determines whether a class from the NgControl should be forwarded to the host element. */
	    MdInputContainer.prototype._shouldForward = function (prop) {
	        var control = this._mdInputChild ? this._mdInputChild._ngControl : null;
	        return control && control[prop];
	    };
	    /** Whether the input has a placeholder. */
	    MdInputContainer.prototype._hasPlaceholder = function () { return !!(this._mdInputChild.placeholder || this._placeholderChild); };
	    /** Focuses the underlying input. */
	    MdInputContainer.prototype._focusInput = function () { this._mdInputChild.focus(); };
	    /**
	     * Ensure that there is only one placeholder (either `input` attribute or child element with the
	     * `md-placeholder` attribute.
	     */
	    MdInputContainer.prototype._validatePlaceholders = function () {
	        if (this._mdInputChild.placeholder && this._placeholderChild) {
	            throw new MdInputContainerPlaceholderConflictError();
	        }
	    };
	    /**
	     * Does any extra processing that is required when handling the hints.
	     */
	    MdInputContainer.prototype._processHints = function () {
	        this._validateHints();
	        this._syncAriaDescribedby();
	    };
	    /**
	     * Ensure that there is a maximum of one of each `<md-hint>` alignment specified, with the
	     * attribute being considered as `align="start"`.
	     */
	    MdInputContainer.prototype._validateHints = function () {
	        var _this = this;
	        if (this._hintChildren) {
	            var startHint_1 = null;
	            var endHint_1 = null;
	            this._hintChildren.forEach(function (hint) {
	                if (hint.align == 'start') {
	                    if (startHint_1 || _this.hintLabel) {
	                        throw new MdInputContainerDuplicatedHintError('start');
	                    }
	                    startHint_1 = hint;
	                }
	                else if (hint.align == 'end') {
	                    if (endHint_1) {
	                        throw new MdInputContainerDuplicatedHintError('end');
	                    }
	                    endHint_1 = hint;
	                }
	            });
	        }
	    };
	    /**
	     * Sets the child input's `aria-describedby` to a space-separated list of the ids
	     * of the currently-specified hints, as well as a generated id for the hint label.
	     */
	    MdInputContainer.prototype._syncAriaDescribedby = function () {
	        var ids = [];
	        var startHint = this._hintChildren ?
	            this._hintChildren.find(function (hint) { return hint.align === 'start'; }) : null;
	        var endHint = this._hintChildren ?
	            this._hintChildren.find(function (hint) { return hint.align === 'end'; }) : null;
	        if (startHint) {
	            ids.push(startHint.id);
	        }
	        else if (this._hintLabel) {
	            ids.push(this._hintLabelId);
	        }
	        if (endHint) {
	            ids.push(endHint.id);
	        }
	        this._mdInputChild.ariaDescribedby = ids.join(' ');
	    };
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "align", void 0);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "dividerColor", void 0);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "hintLabel", null);
	    __decorate$51([
	        _angular_core.Input(), 
	        __metadata$51('design:type', Object)
	    ], MdInputContainer.prototype, "floatPlaceholder", null);
	    __decorate$51([
	        _angular_core.ContentChild(MdInputDirective), 
	        __metadata$51('design:type', MdInputDirective)
	    ], MdInputContainer.prototype, "_mdInputChild", void 0);
	    __decorate$51([
	        _angular_core.ContentChild(MdPlaceholder), 
	        __metadata$51('design:type', MdPlaceholder)
	    ], MdInputContainer.prototype, "_placeholderChild", void 0);
	    __decorate$51([
	        _angular_core.ContentChildren(MdHint), 
	        __metadata$51('design:type', _angular_core.QueryList)
	    ], MdInputContainer.prototype, "_hintChildren", void 0);
	    MdInputContainer = __decorate$51([
	        _angular_core.Component({selector: 'md-input-container, mat-input-container',
	            template: "<div class=\"mat-input-wrapper\"><div class=\"mat-input-table\"><div class=\"mat-input-prefix\"><ng-content select=\"[mdPrefix], [matPrefix], [md-prefix]\"></ng-content></div><div class=\"mat-input-infix\" [class.mat-end]=\"align == 'end'\"><ng-content selector=\"input, textarea\"></ng-content><span class=\"mat-input-placeholder-wrapper\"><label class=\"mat-input-placeholder\" [attr.for]=\"_mdInputChild.id\" [class.mat-empty]=\"_mdInputChild.empty && !_shouldAlwaysFloat\" [class.mat-focused]=\"_mdInputChild.focused\" [class.mat-float]=\"_canPlaceholderFloat\" [class.mat-accent]=\"dividerColor == 'accent'\" [class.mat-warn]=\"dividerColor == 'warn'\" *ngIf=\"_hasPlaceholder()\"><ng-content select=\"md-placeholder, mat-placeholder\"></ng-content>{{_mdInputChild.placeholder}} <span class=\"mat-placeholder-required\" *ngIf=\"_mdInputChild.required\">*</span></label></span></div><div class=\"mat-input-suffix\"><ng-content select=\"[mdSuffix], [matSuffix], [md-suffix]\"></ng-content></div></div><div class=\"mat-input-underline\" [class.mat-disabled]=\"_mdInputChild.disabled\"><span class=\"mat-input-ripple\" [class.mat-focused]=\"_mdInputChild.focused\" [class.mat-accent]=\"dividerColor == 'accent'\" [class.mat-warn]=\"dividerColor == 'warn'\"></span></div><div *ngIf=\"hintLabel != ''\" [attr.id]=\"_hintLabelId\" class=\"mat-hint\">{{hintLabel}}</div><ng-content select=\"md-hint, mat-hint\"></ng-content></div>",
	            styles: [".mat-input-container{display:inline-block;position:relative;font-family:Roboto,\"Helvetica Neue\",sans-serif;line-height:normal;text-align:left}.mat-end .mat-input-element,[dir=rtl] .mat-input-container{text-align:right}.mat-input-wrapper{margin:1em 0;padding-bottom:6px}.mat-input-table{display:inline-table;flex-flow:column;vertical-align:bottom;width:100%}.mat-input-table>*{display:table-cell}.mat-input-infix{position:relative}.mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;width:100%}.mat-input-placeholder,.mat-input-placeholder-wrapper{padding-top:1em;pointer-events:none;position:absolute}[dir=rtl] .mat-end .mat-input-element{text-align:left}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element:-webkit-autofill+.mat-input-placeholder.mat-float{display:block;transform:translateY(-1.35em) scale(.75);width:133.33333%}.mat-input-element::placeholder{color:transparent}.mat-input-element::-moz-placeholder{color:transparent}.mat-input-element::-webkit-input-placeholder{color:transparent}.mat-input-element:-ms-input-placeholder{color:transparent}.mat-input-placeholder{left:0;top:0;font-size:100%;z-index:1;width:100%;display:none;white-space:nowrap;text-overflow:ellipsis;overflow-x:hidden;transform:translateY(0);transform-origin:bottom left;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1)}.mat-input-placeholder.mat-empty{display:block;cursor:text}.mat-input-placeholder.mat-float.mat-focused,.mat-input-placeholder.mat-float:not(.mat-empty){display:block;transform:translateY(-1.35em) scale(.75);width:133.33333%}[dir=rtl] .mat-input-placeholder{transform-origin:bottom right;left:auto;right:0}.mat-input-placeholder-wrapper{left:0;top:-1em;width:100%;overflow:hidden}.mat-input-placeholder-wrapper::after{content:'';display:inline-table}.mat-input-underline{position:absolute;height:1px;width:100%;margin-top:4px;border-top-width:1px;border-top-style:solid}.mat-input-underline.mat-disabled{background-image:linear-gradient(to right,rgba(0,0,0,.26) 0,rgba(0,0,0,.26) 33%,transparent 0);background-size:4px 1px;background-repeat:repeat-x;border-top:0;background-position:0}.mat-input-underline .mat-input-ripple{position:absolute;height:2px;z-index:1;top:-1px;width:100%;transform-origin:top;opacity:0;transform:scaleY(0);transition:transform .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-input-underline .mat-input-ripple.mat-focused{opacity:1;transform:scaleY(1)}.mat-hint{display:block;position:absolute;font-size:75%;bottom:0}.mat-hint.mat-right{right:0}[dir=rtl] .mat-hint{right:0;left:auto}[dir=rtl] .mat-hint.mat-right{right:auto;left:0}.mat-input-prefix,.mat-input-suffix{width:.1px;white-space:nowrap}"],
	            host: {
	                '[class.mat-input-container]': 'true',
	                // Remove align attribute to prevent it from interfering with layout.
	                '[attr.align]': 'null',
	                '[class.ng-untouched]': '_shouldForward("untouched")',
	                '[class.ng-touched]': '_shouldForward("touched")',
	                '[class.ng-pristine]': '_shouldForward("pristine")',
	                '[class.ng-dirty]': '_shouldForward("dirty")',
	                '[class.ng-valid]': '_shouldForward("valid")',
	                '[class.ng-invalid]': '_shouldForward("invalid")',
	                '[class.ng-pending]': '_shouldForward("pending")',
	                '(click)': '_focusInput()',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$51('design:paramtypes', [])
	    ], MdInputContainer);
	    return MdInputContainer;
	}());
	
	var __decorate$52 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$52 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Directive to automatically resize a textarea to fit its content.
	 */
	var MdTextareaAutosize = (function () {
	    function MdTextareaAutosize(_elementRef) {
	        this._elementRef = _elementRef;
	    }
	    Object.defineProperty(MdTextareaAutosize.prototype, "mdAutosizeMinRows", {
	        get: function () {
	            return this.minRows;
	        },
	        set: function (value) {
	            this.minRows = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTextareaAutosize.prototype, "mdAutosizeMaxRows", {
	        get: function () {
	            return this.maxRows;
	        },
	        set: function (value) {
	            this.maxRows = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTextareaAutosize.prototype, "_minHeight", {
	        /** The minimum height of the textarea as determined by minRows. */
	        get: function () {
	            return this.minRows ? this.minRows * this._cachedLineHeight + "px" : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTextareaAutosize.prototype, "_maxHeight", {
	        /** The maximum height of the textarea as determined by maxRows. */
	        get: function () {
	            return this.maxRows ? this.maxRows * this._cachedLineHeight + "px" : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdTextareaAutosize.prototype.ngOnInit = function () {
	        this._cacheTextareaLineHeight();
	        this.resizeToFitContent();
	    };
	    /**
	     * Cache the height of a single-row textarea.
	     *
	     * We need to know how large a single "row" of a textarea is in order to apply minRows and
	     * maxRows. For the initial version, we will assume that the height of a single line in the
	     * textarea does not ever change.
	     */
	    MdTextareaAutosize.prototype._cacheTextareaLineHeight = function () {
	        var textarea = this._elementRef.nativeElement;
	        // Use a clone element because we have to override some styles.
	        var textareaClone = textarea.cloneNode(false);
	        textareaClone.rows = 1;
	        // Use `position: absolute` so that this doesn't cause a browser layout and use
	        // `visibility: hidden` so that nothing is rendered. Clear any other styles that
	        // would affect the height.
	        textareaClone.style.position = 'absolute';
	        textareaClone.style.visibility = 'hidden';
	        textareaClone.style.border = 'none';
	        textareaClone.style.padding = '';
	        textareaClone.style.height = '';
	        textareaClone.style.minHeight = '';
	        textareaClone.style.maxHeight = '';
	        textarea.parentNode.appendChild(textareaClone);
	        this._cachedLineHeight = textareaClone.offsetHeight;
	        textarea.parentNode.removeChild(textareaClone);
	    };
	    /** Resize the textarea to fit its content. */
	    MdTextareaAutosize.prototype.resizeToFitContent = function () {
	        var textarea = this._elementRef.nativeElement;
	        // Reset the textarea height to auto in order to shrink back to its default size.
	        textarea.style.height = 'auto';
	        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
	        textarea.style.height = textarea.scrollHeight + "px";
	    };
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "minRows", void 0);
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "mdAutosizeMinRows", null);
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "maxRows", void 0);
	    __decorate$52([
	        _angular_core.Input(), 
	        __metadata$52('design:type', Number)
	    ], MdTextareaAutosize.prototype, "mdAutosizeMaxRows", null);
	    MdTextareaAutosize = __decorate$52([
	        _angular_core.Directive({
	            selector: 'textarea[md-autosize], textarea[mdTextareaAutosize],' +
	                'textarea[mat-autosize], textarea[matTextareaAutosize]',
	            exportAs: 'mdTextareaAutosize',
	            host: {
	                '(input)': 'resizeToFitContent()',
	                '[style.min-height]': '_minHeight',
	                '[style.max-height]': '_maxHeight',
	            },
	        }), 
	        __metadata$52('design:paramtypes', [_angular_core.ElementRef])
	    ], MdTextareaAutosize);
	    return MdTextareaAutosize;
	}());
	
	var __decorate$50 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$50 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdInputModule = (function () {
	    function MdInputModule() {
	    }
	    /** @deprecated */
	    MdInputModule.forRoot = function () {
	        return {
	            ngModule: MdInputModule,
	            providers: [],
	        };
	    };
	    MdInputModule = __decorate$50([
	        _angular_core.NgModule({
	            declarations: [
	                MdPlaceholder,
	                MdInputContainer,
	                MdHint,
	                MdTextareaAutosize,
	                MdInputDirective
	            ],
	            imports: [
	                _angular_common.CommonModule,
	                _angular_forms.FormsModule,
	                PlatformModule,
	            ],
	            exports: [
	                MdPlaceholder,
	                MdInputContainer,
	                MdHint,
	                MdTextareaAutosize,
	                MdInputDirective
	            ],
	        }), 
	        __metadata$50('design:paramtypes', [])
	    ], MdInputModule);
	    return MdInputModule;
	}());
	
	/**
	 * Configuration used when opening a snack-bar.
	 */
	var MdSnackBarConfig = (function () {
	    function MdSnackBarConfig() {
	        /** The politeness level for the MdAriaLiveAnnouncer announcement. */
	        this.politeness = 'assertive';
	        /** Message to be announced by the MdAriaLiveAnnouncer */
	        this.announcementMessage = '';
	        /** The view container to place the overlay for the snack bar into. */
	        this.viewContainerRef = null;
	        /** The length of time in milliseconds to wait before automatically dismissing the snack bar. */
	        this.duration = 0;
	    }
	    return MdSnackBarConfig;
	}());
	
	// TODO(josephperrott): Implement onAction observable.
	/**
	 * Reference to a snack bar dispatched from the snack bar service.
	 */
	var MdSnackBarRef = (function () {
	    function MdSnackBarRef(instance, containerInstance, _overlayRef) {
	        var _this = this;
	        this._overlayRef = _overlayRef;
	        /** Subject for notifying the user that the snack bar has closed. */
	        this._afterClosed = new rxjs_Subject.Subject();
	        /** Subject for notifying the user that the snack bar action was called. */
	        this._onAction = new rxjs_Subject.Subject();
	        // Sets the readonly instance of the snack bar content component.
	        this._instance = instance;
	        this.containerInstance = containerInstance;
	        // Dismiss snackbar on action.
	        this.onAction().subscribe(function () { return _this.dismiss(); });
	        containerInstance._onExit().subscribe(function () { return _this._finishDismiss(); });
	    }
	    Object.defineProperty(MdSnackBarRef.prototype, "instance", {
	        /** The instance of the component making up the content of the snack bar. */
	        get: function () {
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Dismisses the snack bar. */
	    MdSnackBarRef.prototype.dismiss = function () {
	        if (!this._afterClosed.closed) {
	            this.containerInstance.exit();
	        }
	    };
	    /** Marks the snackbar action clicked. */
	    MdSnackBarRef.prototype._action = function () {
	        if (!this._onAction.closed) {
	            this._onAction.next();
	            this._onAction.complete();
	        }
	    };
	    /** Marks the snackbar as opened */
	    MdSnackBarRef.prototype._open = function () {
	        if (!this._afterOpened.closed) {
	            this._afterOpened.next();
	            this._afterOpened.complete();
	        }
	    };
	    /** Cleans up the DOM after closing. */
	    MdSnackBarRef.prototype._finishDismiss = function () {
	        this._overlayRef.dispose();
	        this._afterClosed.next();
	        this._afterClosed.complete();
	    };
	    /** Gets an observable that is notified when the snack bar is finished closing. */
	    MdSnackBarRef.prototype.afterDismissed = function () {
	        return this._afterClosed.asObservable();
	    };
	    /** Gets an observable that is notified when the snack bar has opened and appeared. */
	    MdSnackBarRef.prototype.afterOpened = function () {
	        return this.containerInstance._onEnter();
	    };
	    /** Gets an observable that is notified when the snack bar action is called. */
	    MdSnackBarRef.prototype.onAction = function () {
	        return this._onAction.asObservable();
	    };
	    return MdSnackBarRef;
	}());
	
	var __extends$17 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Error that is thrown when attempting to attach a snack bar that is already attached.
	 * @docs-private
	 */
	var MdSnackBarContentAlreadyAttached = (function (_super) {
	    __extends$17(MdSnackBarContentAlreadyAttached, _super);
	    function MdSnackBarContentAlreadyAttached() {
	        _super.call(this, 'Attempting to attach snack bar content after content is already attached');
	    }
	    return MdSnackBarContentAlreadyAttached;
	}(MdError));
	
	var __extends$16 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$55 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$55 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// TODO(jelbourn): we can't use constants from animation.ts here because you can't use
	// a text interpolation in anything that is analyzed statically with ngc (for AoT compile).
	var SHOW_ANIMATION = '225ms cubic-bezier(0.4,0.0,1,1)';
	var HIDE_ANIMATION = '195ms cubic-bezier(0.0,0.0,0.2,1)';
	/**
	 * Internal component that wraps user-provided snack bar content.
	 * @docs-private
	 */
	var MdSnackBarContainer = (function (_super) {
	    __extends$16(MdSnackBarContainer, _super);
	    function MdSnackBarContainer(_ngZone, _renderer, _elementRef) {
	        _super.call(this);
	        this._ngZone = _ngZone;
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        /** Subject for notifying that the snack bar has exited from view. */
	        this.onExit = new rxjs_Subject.Subject();
	        /** Subject for notifying that the snack bar has finished entering the view. */
	        this.onEnter = new rxjs_Subject.Subject();
	        /** The state of the snack bar animations. */
	        this.animationState = 'initial';
	    }
	    /** Attach a component portal as content to this snack bar container. */
	    MdSnackBarContainer.prototype.attachComponentPortal = function (portal) {
	        if (this._portalHost.hasAttached()) {
	            throw new MdSnackBarContentAlreadyAttached();
	        }
	        if (this.snackBarConfig.extraClasses) {
	            // Not the most efficient way of adding classes, but the renderer doesn't allow us
	            // to pass in an array or a space-separated list.
	            for (var _i = 0, _a = this.snackBarConfig.extraClasses; _i < _a.length; _i++) {
	                var cssClass = _a[_i];
	                this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, true);
	            }
	        }
	        return this._portalHost.attachComponentPortal(portal);
	    };
	    /** Attach a template portal as content to this snack bar container. */
	    MdSnackBarContainer.prototype.attachTemplatePortal = function (portal) {
	        throw Error('Not yet implemented');
	    };
	    /** Handle end of animations, updating the state of the snackbar. */
	    MdSnackBarContainer.prototype.onAnimationEnd = function (event) {
	        var _this = this;
	        if (event.toState === 'void' || event.toState === 'complete') {
	            this._completeExit();
	        }
	        if (event.toState === 'visible') {
	            this._ngZone.run(function () {
	                _this.onEnter.next();
	                _this.onEnter.complete();
	            });
	        }
	    };
	    /** Begin animation of snack bar entrance into view. */
	    MdSnackBarContainer.prototype.enter = function () {
	        this.animationState = 'visible';
	    };
	    /** Returns an observable resolving when the enter animation completes.  */
	    MdSnackBarContainer.prototype._onEnter = function () {
	        this.animationState = 'visible';
	        return this.onEnter.asObservable();
	    };
	    /** Begin animation of the snack bar exiting from view. */
	    MdSnackBarContainer.prototype.exit = function () {
	        this.animationState = 'complete';
	        return this._onExit();
	    };
	    /** Returns an observable that completes after the closing animation is done. */
	    MdSnackBarContainer.prototype._onExit = function () {
	        return this.onExit.asObservable();
	    };
	    /**
	     * Makes sure the exit callbacks have been invoked when the element is destroyed.
	     */
	    MdSnackBarContainer.prototype.ngOnDestroy = function () {
	        this._completeExit();
	    };
	    /**
	     * Waits for the zone to settle before removing the element. Helps prevent
	     * errors where we end up removing an element which is in the middle of an animation.
	     */
	    MdSnackBarContainer.prototype._completeExit = function () {
	        var _this = this;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this.onExit.next();
	            _this.onExit.complete();
	        });
	    };
	    __decorate$55([
	        _angular_core.ViewChild(PortalHostDirective), 
	        __metadata$55('design:type', PortalHostDirective)
	    ], MdSnackBarContainer.prototype, "_portalHost", void 0);
	    MdSnackBarContainer = __decorate$55([
	        _angular_core.Component({selector: 'snack-bar-container',
	            template: "<template cdkPortalHost></template>",
	            styles: [":host{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12);background:#323232;border-radius:2px;box-sizing:content-box;display:block;height:20px;max-width:568px;min-width:288px;overflow:hidden;padding:14px 24px;transform:translateY(100%)}@media screen and (-ms-high-contrast:active){:host{border:1px solid}}"],
	            host: {
	                'role': 'alert',
	                '[@state]': 'animationState',
	                '(@state.done)': 'onAnimationEnd($event)'
	            },
	            animations: [
	                _angular_core.trigger('state', [
	                    _angular_core.state('initial', _angular_core.style({ transform: 'translateY(100%)' })),
	                    _angular_core.state('visible', _angular_core.style({ transform: 'translateY(0%)' })),
	                    _angular_core.state('complete', _angular_core.style({ transform: 'translateY(100%)' })),
	                    _angular_core.transition('visible => complete', _angular_core.animate(HIDE_ANIMATION)),
	                    _angular_core.transition('initial => visible, void => visible', _angular_core.animate(SHOW_ANIMATION)),
	                ])
	            ],
	        }), 
	        __metadata$55('design:paramtypes', [_angular_core.NgZone, _angular_core.Renderer, _angular_core.ElementRef])
	    ], MdSnackBarContainer);
	    return MdSnackBarContainer;
	}(BasePortalHost));
	
	var __decorate$56 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$56 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * A component used to open as the default snack bar, matching material spec.
	 * This should only be used internally by the snack bar service.
	 */
	var SimpleSnackBar = (function () {
	    function SimpleSnackBar() {
	    }
	    /** Dismisses the snack bar. */
	    SimpleSnackBar.prototype.dismiss = function () {
	        this.snackBarRef._action();
	    };
	    Object.defineProperty(SimpleSnackBar.prototype, "hasAction", {
	        /** If the action button should be shown. */
	        get: function () { return !!this.action; },
	        enumerable: true,
	        configurable: true
	    });
	    SimpleSnackBar = __decorate$56([
	        _angular_core.Component({selector: 'simple-snack-bar',
	            template: "<span class=\"mat-simple-snackbar-message\">{{message}}</span> <button class=\"mat-simple-snackbar-action\" *ngIf=\"hasAction\" (click)=\"dismiss()\">{{action}}</button>",
	            styles: [":host{display:flex;justify-content:space-between;color:#fff;line-height:20px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-simple-snackbar-message{white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis}.mat-simple-snackbar-action{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;background:0 0;margin:-5px 0 0;padding:5px;text-transform:uppercase;color:inherit;line-height:inherit;flex-shrink:0;font-family:inherit;font-size:inherit;font-weight:600}"],
	            host: {
	                '[class.mat-simple-snackbar]': 'true',
	            }
	        }), 
	        __metadata$56('design:paramtypes', [])
	    ], SimpleSnackBar);
	    return SimpleSnackBar;
	}());
	
	/**
	 * Extends an object with the *enumerable* and *own* properties of one or more source objects,
	 * similar to Object.assign.
	 *
	 * @param dest The object which will have properties copied to it.
	 * @param sources The source objects from which properties will be copied.
	 */
	function extendObject(dest) {
	    var sources = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        sources[_i - 1] = arguments[_i];
	    }
	    if (dest == null) {
	        throw TypeError('Cannot convert undefined or null to object');
	    }
	    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
	        var source = sources_1[_a];
	        if (source != null) {
	            for (var key in source) {
	                if (source.hasOwnProperty(key)) {
	                    dest[key] = source[key];
	                }
	            }
	        }
	    }
	    return dest;
	}
	
	var __decorate$54 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$54 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$11 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Service to dispatch Material Design snack bar messages.
	 */
	var MdSnackBar = (function () {
	    function MdSnackBar(_overlay, _live, _parentSnackBar) {
	        this._overlay = _overlay;
	        this._live = _live;
	        this._parentSnackBar = _parentSnackBar;
	    }
	    Object.defineProperty(MdSnackBar.prototype, "_openedSnackBarRef", {
	        /** Reference to the currently opened snackbar at *any* level. */
	        get: function () {
	            return this._parentSnackBar ?
	                this._parentSnackBar._openedSnackBarRef : this._snackBarRefAtThisLevel;
	        },
	        set: function (value) {
	            if (this._parentSnackBar) {
	                this._parentSnackBar._openedSnackBarRef = value;
	            }
	            else {
	                this._snackBarRefAtThisLevel = value;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates and dispatches a snack bar with a custom component for the content, removing any
	     * currently opened snack bars.
	     *
	     * @param component Component to be instantiated.
	     * @param config Extra configuration for the snack bar.
	     */
	    MdSnackBar.prototype.openFromComponent = function (component, config) {
	        var _this = this;
	        config = _applyConfigDefaults(config);
	        var overlayRef = this._createOverlay();
	        var snackBarContainer = this._attachSnackBarContainer(overlayRef, config);
	        var snackBarRef = this._attachSnackbarContent(component, snackBarContainer, overlayRef);
	        // When the snackbar is dismissed, clear the reference to it.
	        snackBarRef.afterDismissed().subscribe(function () {
	            // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
	            if (_this._openedSnackBarRef == snackBarRef) {
	                _this._openedSnackBarRef = null;
	            }
	        });
	        // If a snack bar is already in view, dismiss it and enter the new snack bar after exit
	        // animation is complete.
	        if (this._openedSnackBarRef) {
	            this._openedSnackBarRef.afterDismissed().subscribe(function () {
	                snackBarRef.containerInstance.enter();
	            });
	            this._openedSnackBarRef.dismiss();
	        }
	        else {
	            snackBarRef.containerInstance.enter();
	        }
	        // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.
	        if (config.duration > 0) {
	            snackBarRef.afterOpened().subscribe(function () {
	                setTimeout(function () { return snackBarRef.dismiss(); }, config.duration);
	            });
	        }
	        this._live.announce(config.announcementMessage, config.politeness);
	        this._openedSnackBarRef = snackBarRef;
	        return this._openedSnackBarRef;
	    };
	    /**
	     * Opens a snackbar with a message and an optional action.
	     * @param message The message to show in the snackbar.
	     * @param action The label for the snackbar action.
	     * @param config Additional configuration options for the snackbar.
	     */
	    MdSnackBar.prototype.open = function (message, action, config) {
	        if (action === void 0) { action = ''; }
	        if (config === void 0) { config = {}; }
	        config.announcementMessage = message;
	        var simpleSnackBarRef = this.openFromComponent(SimpleSnackBar, config);
	        simpleSnackBarRef.instance.snackBarRef = simpleSnackBarRef;
	        simpleSnackBarRef.instance.message = message;
	        simpleSnackBarRef.instance.action = action;
	        return simpleSnackBarRef;
	    };
	    /**
	     * Attaches the snack bar container component to the overlay.
	     */
	    MdSnackBar.prototype._attachSnackBarContainer = function (overlayRef, config) {
	        var containerPortal = new ComponentPortal(MdSnackBarContainer, config.viewContainerRef);
	        var containerRef = overlayRef.attach(containerPortal);
	        containerRef.instance.snackBarConfig = config;
	        return containerRef.instance;
	    };
	    /**
	     * Places a new component as the content of the snack bar container.
	     */
	    MdSnackBar.prototype._attachSnackbarContent = function (component, container, overlayRef) {
	        var portal = new ComponentPortal(component);
	        var contentRef = container.attachComponentPortal(portal);
	        return new MdSnackBarRef(contentRef.instance, container, overlayRef);
	    };
	    /**
	     * Creates a new overlay and places it in the correct location.
	     */
	    MdSnackBar.prototype._createOverlay = function () {
	        var state$$1 = new OverlayState();
	        state$$1.positionStrategy = this._overlay.position().global()
	            .centerHorizontally()
	            .bottom('0');
	        return this._overlay.create(state$$1);
	    };
	    MdSnackBar = __decorate$54([
	        _angular_core.Injectable(),
	        __param$11(2, _angular_core.Optional()),
	        __param$11(2, _angular_core.SkipSelf()), 
	        __metadata$54('design:paramtypes', [Overlay, LiveAnnouncer, MdSnackBar])
	    ], MdSnackBar);
	    return MdSnackBar;
	}());
	/**
	 * Applies default options to the snackbar config.
	 * @param config The configuration to which the defaults will be applied.
	 * @returns The new configuration object with defaults applied.
	 */
	function _applyConfigDefaults(config) {
	    return extendObject(new MdSnackBarConfig(), config);
	}
	
	var __decorate$53 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$53 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdSnackBarModule = (function () {
	    function MdSnackBarModule() {
	    }
	    /** @deprecated */
	    MdSnackBarModule.forRoot = function () {
	        return {
	            ngModule: MdSnackBarModule,
	            providers: []
	        };
	    };
	    MdSnackBarModule = __decorate$53([
	        _angular_core.NgModule({
	            imports: [OverlayModule, PortalModule, _angular_common.CommonModule, CompatibilityModule],
	            exports: [MdSnackBarContainer, CompatibilityModule],
	            declarations: [MdSnackBarContainer, SimpleSnackBar],
	            entryComponents: [MdSnackBarContainer, SimpleSnackBar],
	            providers: [MdSnackBar, LIVE_ANNOUNCER_PROVIDER]
	        }), 
	        __metadata$53('design:paramtypes', [])
	    ], MdSnackBarModule);
	    return MdSnackBarModule;
	}());
	
	var __extends$18 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$58 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$58 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Used to flag tab labels for use with the portal directive */
	var MdTabLabel = (function (_super) {
	    __extends$18(MdTabLabel, _super);
	    function MdTabLabel(templateRef, viewContainerRef) {
	        _super.call(this, templateRef, viewContainerRef);
	    }
	    MdTabLabel = __decorate$58([
	        _angular_core.Directive({
	            selector: '[md-tab-label], [mat-tab-label]',
	        }), 
	        __metadata$58('design:paramtypes', [_angular_core.TemplateRef, _angular_core.ViewContainerRef])
	    ], MdTabLabel);
	    return MdTabLabel;
	}(TemplatePortalDirective));
	
	var __decorate$59 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$59 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Used in the `md-tab-group` view to display tab labels */
	var MdTabLabelWrapper = (function () {
	    function MdTabLabelWrapper(elementRef, _renderer) {
	        this.elementRef = elementRef;
	        this._renderer = _renderer;
	        /** Whether the tab label is disabled.  */
	        this._disabled = false;
	    }
	    Object.defineProperty(MdTabLabelWrapper.prototype, "disabled", {
	        /** Whether the element is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    /** Sets focus on the wrapper element */
	    MdTabLabelWrapper.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this.elementRef.nativeElement, 'focus');
	    };
	    MdTabLabelWrapper.prototype.getOffsetLeft = function () {
	        return this.elementRef.nativeElement.offsetLeft;
	    };
	    MdTabLabelWrapper.prototype.getOffsetWidth = function () {
	        return this.elementRef.nativeElement.offsetWidth;
	    };
	    __decorate$59([
	        _angular_core.Input(), 
	        __metadata$59('design:type', Object)
	    ], MdTabLabelWrapper.prototype, "disabled", null);
	    MdTabLabelWrapper = __decorate$59([
	        _angular_core.Directive({
	            selector: '[md-tab-label-wrapper], [mat-tab-label-wrapper]',
	            host: {
	                '[class.mat-tab-disabled]': 'disabled'
	            }
	        }), 
	        __metadata$59('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdTabLabelWrapper);
	    return MdTabLabelWrapper;
	}());
	
	var __decorate$61 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$61 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** The ink-bar is used to display and animate the line underneath the current active tab label. */
	var MdInkBar = (function () {
	    function MdInkBar(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	    }
	    /**
	     * Calculates the styles from the provided element in order to align the ink-bar to that element.
	     * Shows the ink bar if previously set as hidden.
	     * @param element
	     */
	    MdInkBar.prototype.alignToElement = function (element) {
	        this.show();
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'left', this._getLeftPosition(element));
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'width', this._getElementWidth(element));
	    };
	    /** Shows the ink bar. */
	    MdInkBar.prototype.show = function () {
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'visibility', 'visible');
	    };
	    /** Hides the ink bar. */
	    MdInkBar.prototype.hide = function () {
	        this._renderer.setElementStyle(this._elementRef.nativeElement, 'visibility', 'hidden');
	    };
	    /**
	     * Generates the pixel distance from the left based on the provided element in string format.
	     * @param element
	     */
	    MdInkBar.prototype._getLeftPosition = function (element) {
	        return element ? element.offsetLeft + 'px' : '0';
	    };
	    /**
	     * Generates the pixel width from the provided element in string format.
	     * @param element
	     */
	    MdInkBar.prototype._getElementWidth = function (element) {
	        return element ? element.offsetWidth + 'px' : '0';
	    };
	    MdInkBar = __decorate$61([
	        _angular_core.Directive({
	            selector: 'md-ink-bar, mat-ink-bar',
	            host: {
	                '[class.mat-ink-bar]': 'true',
	            },
	        }), 
	        __metadata$61('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdInkBar);
	    return MdInkBar;
	}());
	
	var __extends$19 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$60 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$60 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Navigation component matching the styles of the tab group header.
	 * Provides anchored navigation with animated ink bar.
	 */
	var MdTabNavBar = (function () {
	    function MdTabNavBar() {
	    }
	    /** Notifies the component that the active link has been changed. */
	    MdTabNavBar.prototype.updateActiveLink = function (element) {
	        this._activeLinkChanged = this._activeLinkElement != element;
	        this._activeLinkElement = element;
	    };
	    /** Checks if the active link has been changed and, if so, will update the ink bar. */
	    MdTabNavBar.prototype.ngAfterContentChecked = function () {
	        if (this._activeLinkChanged) {
	            this._inkBar.alignToElement(this._activeLinkElement.nativeElement);
	            this._activeLinkChanged = false;
	        }
	    };
	    __decorate$60([
	        _angular_core.ViewChild(MdInkBar), 
	        __metadata$60('design:type', MdInkBar)
	    ], MdTabNavBar.prototype, "_inkBar", void 0);
	    MdTabNavBar = __decorate$60([
	        _angular_core.Component({selector: '[md-tab-nav-bar], [mat-tab-nav-bar]',
	            template: "<div class=\"mat-tab-links\"><ng-content></ng-content></div><md-ink-bar></md-ink-bar>",
	            styles: [".mat-tab-link,.mat-tab-nav-bar{position:relative;overflow:hidden}.mat-tab-nav-bar{flex-shrink:0}.mat-tab-links{display:flex;position:relative}.mat-tab-link{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;color:currentColor;opacity:.6;min-width:160px;text-align:center;text-decoration:none}.mat-tab-link:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}"],
	            host: {
	                '[class.mat-tab-nav-bar]': 'true',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$60('design:paramtypes', [])
	    ], MdTabNavBar);
	    return MdTabNavBar;
	}());
	/**
	 * Link inside of a `md-tab-nav-bar`.
	 */
	var MdTabLink = (function () {
	    function MdTabLink(_mdTabNavBar, _elementRef) {
	        this._mdTabNavBar = _mdTabNavBar;
	        this._elementRef = _elementRef;
	        this._isActive = false;
	    }
	    Object.defineProperty(MdTabLink.prototype, "active", {
	        /** Whether the link is active. */
	        get: function () { return this._isActive; },
	        set: function (value) {
	            this._isActive = value;
	            if (value) {
	                this._mdTabNavBar.updateActiveLink(this._elementRef);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    __decorate$60([
	        _angular_core.Input(), 
	        __metadata$60('design:type', Boolean)
	    ], MdTabLink.prototype, "active", null);
	    MdTabLink = __decorate$60([
	        _angular_core.Directive({
	            selector: '[md-tab-link], [mat-tab-link]',
	            host: {
	                '[class.mat-tab-link]': 'true',
	            }
	        }), 
	        __metadata$60('design:paramtypes', [MdTabNavBar, _angular_core.ElementRef])
	    ], MdTabLink);
	    return MdTabLink;
	}());
	/**
	 * Simple directive that extends the ripple and matches the selector of the MdTabLink. This
	 * adds the ripple behavior to nav bar labels.
	 */
	var MdTabLinkRipple = (function (_super) {
	    __extends$19(MdTabLinkRipple, _super);
	    function MdTabLinkRipple(elementRef, ngZone, ruler) {
	        _super.call(this, elementRef, ngZone, ruler);
	    }
	    MdTabLinkRipple = __decorate$60([
	        _angular_core.Directive({
	            selector: '[md-tab-link], [mat-tab-link]',
	            host: {
	                '[class.mat-tab-link]': 'true',
	            },
	        }), 
	        __metadata$60('design:paramtypes', [_angular_core.ElementRef, _angular_core.NgZone, ViewportRuler])
	    ], MdTabLinkRipple);
	    return MdTabLinkRipple;
	}(MdRipple));
	
	var __decorate$62 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$62 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdTab = (function () {
	    function MdTab(_viewContainerRef) {
	        this._viewContainerRef = _viewContainerRef;
	        /** The plain text label for the tab, used when there is no template label. */
	        this.textLabel = '';
	        /** The portal that will be the hosted content of the tab */
	        this._contentPortal = null;
	        /**
	         * The relatively indexed position where 0 represents the center, negative is left, and positive
	         * represents the right.
	         */
	        this.position = null;
	        /**
	         * The initial relatively index origin of the tab if it was created and selected after there
	         * was already a selected tab. Provides context of what position the tab should originate from.
	         */
	        this.origin = null;
	        this._disabled = false;
	    }
	    Object.defineProperty(MdTab.prototype, "content", {
	        get: function () { return this._contentPortal; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTab.prototype, "disabled", {
	        get: function () { return this._disabled; },
	        /** Whether the tab is disabled */
	        set: function (value) { this._disabled = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    MdTab.prototype.ngOnInit = function () {
	        this._contentPortal = new TemplatePortal(this._content, this._viewContainerRef);
	    };
	    __decorate$62([
	        _angular_core.ContentChild(MdTabLabel), 
	        __metadata$62('design:type', MdTabLabel)
	    ], MdTab.prototype, "templateLabel", void 0);
	    __decorate$62([
	        _angular_core.ViewChild(_angular_core.TemplateRef), 
	        __metadata$62('design:type', _angular_core.TemplateRef)
	    ], MdTab.prototype, "_content", void 0);
	    __decorate$62([
	        _angular_core.Input('label'), 
	        __metadata$62('design:type', String)
	    ], MdTab.prototype, "textLabel", void 0);
	    __decorate$62([
	        _angular_core.Input(), 
	        __metadata$62('design:type', Boolean), 
	        __metadata$62('design:paramtypes', [Boolean])
	    ], MdTab.prototype, "disabled", null);
	    MdTab = __decorate$62([
	        _angular_core.Component({selector: 'md-tab, mat-tab',
	            template: "<template><ng-content></ng-content></template>",
	        }), 
	        __metadata$62('design:paramtypes', [_angular_core.ViewContainerRef])
	    ], MdTab);
	    return MdTab;
	}());
	
	var __decorate$63 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$63 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$12 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * Wrapper for the contents of a tab.
	 */
	var MdTabBody = (function () {
	    function MdTabBody(_dir, _elementRef, _changeDetectorRef) {
	        this._dir = _dir;
	        this._elementRef = _elementRef;
	        this._changeDetectorRef = _changeDetectorRef;
	        /** Event emitted when the tab begins to animate towards the center as the active tab. */
	        this.onCentering = new _angular_core.EventEmitter();
	        /** Event emitted when the tab completes its animation towards the center. */
	        this.onCentered = new _angular_core.EventEmitter(true);
	        /** Whether the element is allowed to be animated. */
	        this._canBeAnimated = false;
	    }
	    Object.defineProperty(MdTabBody.prototype, "position", {
	        set: function (position) {
	            if (position < 0) {
	                this._position = this._getLayoutDirection() == 'ltr' ? 'left' : 'right';
	            }
	            else if (position > 0) {
	                this._position = this._getLayoutDirection() == 'ltr' ? 'right' : 'left';
	            }
	            else {
	                this._position = 'center';
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabBody.prototype, "origin", {
	        /** The origin position from which this tab should appear when it is centered into view. */
	        set: function (origin) {
	            if (origin == null) {
	                return;
	            }
	            var dir = this._getLayoutDirection();
	            if ((dir == 'ltr' && origin <= 0) || (dir == 'rtl' && origin > 0)) {
	                this._origin = 'left';
	            }
	            else {
	                this._origin = 'right';
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * After initialized, check if the content is centered and has an origin. If so, set the
	     * special position states that transition the tab from the left or right before centering.
	     */
	    MdTabBody.prototype.ngOnInit = function () {
	        if (this._position == 'center' && this._origin) {
	            this._position = this._origin == 'left' ? 'left-origin-center' : 'right-origin-center';
	        }
	    };
	    /**
	     * After the view has been set, check if the tab content is set to the center and attach the
	     * content if it is not already attached.
	     */
	    MdTabBody.prototype.ngAfterViewChecked = function () {
	        if (this._isCenterPosition(this._position) && !this._portalHost.hasAttached()) {
	            this._portalHost.attach(this._content);
	        }
	    };
	    /**
	     * After the content has been checked, determines whether the element should be allowed to
	     * animate. This has to be limited, because under a specific set of circumstances (see #2151),
	     * the animations can be triggered too early, which either crashes Chrome by putting it into an
	     * infinite loop (with Angular < 2.3.0) or throws an error because the element doesn't have a
	     * computed style (with Angular > 2.3.0). This can alternatively be determined by checking the
	     * transform: canBeAnimated = getComputedStyle(element) !== '', however document.contains should
	     * be faster since it doesn't cause a reflow.
	     *
	     * TODO: This can safely be removed after we stop supporting Angular < 2.4.2. The fix landed via
	     * https://github.com/angular/angular/commit/21030e9a1cf30e8101399d8535ed72d847a23ba6
	     */
	    MdTabBody.prototype.ngAfterContentChecked = function () {
	        if (!this._canBeAnimated) {
	            this._canBeAnimated = document.body.contains(this._elementRef.nativeElement);
	            if (this._canBeAnimated) {
	                this._changeDetectorRef.markForCheck();
	            }
	        }
	    };
	    MdTabBody.prototype._onTranslateTabStarted = function (e) {
	        if (this._isCenterPosition(e.toState)) {
	            this.onCentering.emit(this._elementRef.nativeElement.clientHeight);
	        }
	    };
	    MdTabBody.prototype._onTranslateTabComplete = function (e) {
	        // If the end state is that the tab is not centered, then detach the content.
	        if (!this._isCenterPosition(e.toState) && !this._isCenterPosition(this._position)) {
	            this._portalHost.detach();
	        }
	        // If the transition to the center is complete, emit an event.
	        if (this._isCenterPosition(e.toState) && this._isCenterPosition(this._position)) {
	            this.onCentered.emit();
	        }
	    };
	    /** The text direction of the containing app. */
	    MdTabBody.prototype._getLayoutDirection = function () {
	        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
	    };
	    /** Whether the provided position state is considered center, regardless of origin. */
	    MdTabBody.prototype._isCenterPosition = function (position) {
	        return position == 'center' ||
	            position == 'left-origin-center' ||
	            position == 'right-origin-center';
	    };
	    __decorate$63([
	        _angular_core.ViewChild(PortalHostDirective), 
	        __metadata$63('design:type', PortalHostDirective)
	    ], MdTabBody.prototype, "_portalHost", void 0);
	    __decorate$63([
	        _angular_core.Output(), 
	        __metadata$63('design:type', _angular_core.EventEmitter)
	    ], MdTabBody.prototype, "onCentering", void 0);
	    __decorate$63([
	        _angular_core.Output(), 
	        __metadata$63('design:type', _angular_core.EventEmitter)
	    ], MdTabBody.prototype, "onCentered", void 0);
	    __decorate$63([
	        _angular_core.Input('content'), 
	        __metadata$63('design:type', TemplatePortal)
	    ], MdTabBody.prototype, "_content", void 0);
	    __decorate$63([
	        _angular_core.Input('position'), 
	        __metadata$63('design:type', Number), 
	        __metadata$63('design:paramtypes', [Number])
	    ], MdTabBody.prototype, "position", null);
	    __decorate$63([
	        _angular_core.Input('origin'), 
	        __metadata$63('design:type', Number), 
	        __metadata$63('design:paramtypes', [Number])
	    ], MdTabBody.prototype, "origin", null);
	    MdTabBody = __decorate$63([
	        _angular_core.Component({selector: 'md-tab-body, mat-tab-body',
	            template: "<div class=\"mat-tab-body-content\" #content [@translateTab]=\"_canBeAnimated ? _position : null\" (@translateTab.start)=\"_onTranslateTabStarted($event)\" (@translateTab.done)=\"_onTranslateTabComplete($event)\"><template cdkPortalHost></template></div>",
	            host: {
	                '[class.mat-tab-body]': 'true',
	            },
	            animations: [
	                _angular_core.trigger('translateTab', [
	                    _angular_core.state('left', _angular_core.style({ transform: 'translate3d(-100%, 0, 0)' })),
	                    _angular_core.state('left-origin-center', _angular_core.style({ transform: 'translate3d(0, 0, 0)' })),
	                    _angular_core.state('right-origin-center', _angular_core.style({ transform: 'translate3d(0, 0, 0)' })),
	                    _angular_core.state('center', _angular_core.style({ transform: 'translate3d(0, 0, 0)' })),
	                    _angular_core.state('right', _angular_core.style({ transform: 'translate3d(100%, 0, 0)' })),
	                    _angular_core.transition('* => left, * => right, left => center, right => center', _angular_core.animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')),
	                    _angular_core.transition('void => left-origin-center', [
	                        _angular_core.style({ transform: 'translate3d(-100%, 0, 0)' }),
	                        _angular_core.animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')
	                    ]),
	                    _angular_core.transition('void => right-origin-center', [
	                        _angular_core.style({ transform: 'translate3d(100%, 0, 0)' }),
	                        _angular_core.animate('500ms cubic-bezier(0.35, 0, 0.25, 1)')
	                    ])
	                ])
	            ]
	        }),
	        __param$12(0, _angular_core.Optional()), 
	        __metadata$63('design:paramtypes', [Dir, _angular_core.ElementRef, _angular_core.ChangeDetectorRef])
	    ], MdTabBody);
	    return MdTabBody;
	}());
	
	var __decorate$64 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$64 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$13 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * The distance in pixels that will be overshot when scrolling a tab label into view. This helps
	 * provide a small affordance to the label next to it.
	 */
	var EXAGGERATED_OVERSCROLL = 60;
	/**
	 * The header of the tab group which displays a list of all the tabs in the tab group. Includes
	 * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the
	 * width of the header container, then arrows will be displayed to allow the user to scroll
	 * left and right across the header.
	 */
	var MdTabHeader = (function () {
	    function MdTabHeader(_zone, _elementRef, _dir) {
	        this._zone = _zone;
	        this._elementRef = _elementRef;
	        this._dir = _dir;
	        /** The tab index that is focused. */
	        this._focusIndex = 0;
	        /** The distance in pixels that the tab labels should be translated to the left. */
	        this._scrollDistance = 0;
	        /** Whether the header should scroll to the selected index after the view has been checked. */
	        this._selectedIndexChanged = false;
	        /** Whether the controls for pagination should be displayed */
	        this._showPaginationControls = false;
	        /** Whether the tab list can be scrolled more towards the end of the tab label list. */
	        this._disableScrollAfter = true;
	        /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */
	        this._disableScrollBefore = true;
	        this._selectedIndex = 0;
	        /** Event emitted when the option is selected. */
	        this.selectFocusedIndex = new _angular_core.EventEmitter();
	        /** Event emitted when a label is focused. */
	        this.indexFocused = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(MdTabHeader.prototype, "selectedIndex", {
	        get: function () { return this._selectedIndex; },
	        /** The index of the active tab. */
	        set: function (value) {
	            this._selectedIndexChanged = this._selectedIndex != value;
	            this._selectedIndex = value;
	            this._focusIndex = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdTabHeader.prototype.ngAfterContentChecked = function () {
	        // If the number of tab labels have changed, check if scrolling should be enabled
	        if (this._tabLabelCount != this._labelWrappers.length) {
	            this._updatePagination();
	            this._tabLabelCount = this._labelWrappers.length;
	        }
	        // If the selected index has changed, scroll to the label and check if the scrolling controls
	        // should be disabled.
	        if (this._selectedIndexChanged) {
	            this._scrollToLabel(this._selectedIndex);
	            this._checkScrollingControls();
	            this._alignInkBarToSelectedTab();
	            this._selectedIndexChanged = false;
	        }
	        // If the scroll distance has been changed (tab selected, focused, scroll controls activated),
	        // then translate the header to reflect this.
	        if (this._scrollDistanceChanged) {
	            this._updateTabScrollPosition();
	            this._scrollDistanceChanged = false;
	        }
	    };
	    MdTabHeader.prototype._handleKeydown = function (event) {
	        switch (event.keyCode) {
	            case RIGHT_ARROW:
	                this._focusNextTab();
	                break;
	            case LEFT_ARROW:
	                this._focusPreviousTab();
	                break;
	            case ENTER:
	                this.selectFocusedIndex.emit(this.focusIndex);
	                break;
	        }
	    };
	    /**
	     * Aligns the ink bar to the selected tab on load.
	     */
	    MdTabHeader.prototype.ngAfterContentInit = function () {
	        this._alignInkBarToSelectedTab();
	    };
	    /**
	     * Callback for when the MutationObserver detects that the content has changed.
	     */
	    MdTabHeader.prototype._onContentChanges = function () {
	        this._updatePagination();
	        this._alignInkBarToSelectedTab();
	    };
	    /**
	     * Updating the view whether pagination should be enabled or not
	     */
	    MdTabHeader.prototype._updatePagination = function () {
	        this._checkPaginationEnabled();
	        this._checkScrollingControls();
	        this._updateTabScrollPosition();
	    };
	    Object.defineProperty(MdTabHeader.prototype, "focusIndex", {
	        /** Tracks which element has focus; used for keyboard navigation */
	        get: function () { return this._focusIndex; },
	        /** When the focus index is set, we must manually send focus to the correct label */
	        set: function (value) {
	            if (!this._isValidIndex(value) || this._focusIndex == value) {
	                return;
	            }
	            this._focusIndex = value;
	            this.indexFocused.emit(value);
	            this._setTabFocus(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
	     * providing a valid index and return true.
	     */
	    MdTabHeader.prototype._isValidIndex = function (index) {
	        if (!this._labelWrappers) {
	            return true;
	        }
	        var tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;
	        return tab && !tab.disabled;
	    };
	    /**
	     * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
	     * scrolling is enabled.
	     */
	    MdTabHeader.prototype._setTabFocus = function (tabIndex) {
	        if (this._showPaginationControls) {
	            this._scrollToLabel(tabIndex);
	        }
	        if (this._labelWrappers && this._labelWrappers.length) {
	            this._labelWrappers.toArray()[tabIndex].focus();
	            // Do not let the browser manage scrolling to focus the element, this will be handled
	            // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width
	            // should be the full width minus the offset width.
	            var containerEl = this._tabListContainer.nativeElement;
	            var dir = this._getLayoutDirection();
	            if (dir == 'ltr') {
	                containerEl.scrollLeft = 0;
	            }
	            else {
	                containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;
	            }
	        }
	    };
	    /**
	     * Moves the focus towards the beginning or the end of the list depending on the offset provided.
	     * Valid offsets are 1 and -1.
	     */
	    MdTabHeader.prototype._moveFocus = function (offset) {
	        if (this._labelWrappers) {
	            var tabs = this._labelWrappers.toArray();
	            for (var i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {
	                if (this._isValidIndex(i)) {
	                    this.focusIndex = i;
	                    return;
	                }
	            }
	        }
	    };
	    /** Increment the focus index by 1 until a valid tab is found. */
	    MdTabHeader.prototype._focusNextTab = function () {
	        this._moveFocus(this._getLayoutDirection() == 'ltr' ? 1 : -1);
	    };
	    /** Decrement the focus index by 1 until a valid tab is found. */
	    MdTabHeader.prototype._focusPreviousTab = function () {
	        this._moveFocus(this._getLayoutDirection() == 'ltr' ? -1 : 1);
	    };
	    /** The layout direction of the containing app. */
	    MdTabHeader.prototype._getLayoutDirection = function () {
	        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
	    };
	    /** Performs the CSS transformation on the tab list that will cause the list to scroll. */
	    MdTabHeader.prototype._updateTabScrollPosition = function () {
	        var translateX = this.scrollDistance + 'px';
	        if (this._getLayoutDirection() == 'ltr') {
	            translateX = '-' + translateX;
	        }
	        applyCssTransform(this._tabList.nativeElement, "translate3d(" + translateX + ", 0, 0)");
	    };
	    Object.defineProperty(MdTabHeader.prototype, "scrollDistance", {
	        get: function () { return this._scrollDistance; },
	        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */
	        set: function (v) {
	            this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), v));
	            // Mark that the scroll distance has changed so that after the view is checked, the CSS
	            // transformation can move the header.
	            this._scrollDistanceChanged = true;
	            this._checkScrollingControls();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
	     * the end of the list, respectively). The distance to scroll is computed to be a third of the
	     * length of the tab list view window.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._scrollHeader = function (scrollDir) {
	        var viewLength = this._tabListContainer.nativeElement.offsetWidth;
	        // Move the scroll distance one-third the length of the tab list's viewport.
	        this.scrollDistance += (scrollDir == 'before' ? -1 : 1) * viewLength / 3;
	    };
	    /**
	     * Moves the tab list such that the desired tab label (marked by index) is moved into view.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._scrollToLabel = function (labelIndex) {
	        var selectedLabel = this._labelWrappers
	            ? this._labelWrappers.toArray()[labelIndex]
	            : null;
	        if (!selectedLabel) {
	            return;
	        }
	        // The view length is the visible width of the tab labels.
	        var viewLength = this._tabListContainer.nativeElement.offsetWidth;
	        var labelBeforePos, labelAfterPos;
	        if (this._getLayoutDirection() == 'ltr') {
	            labelBeforePos = selectedLabel.getOffsetLeft();
	            labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();
	        }
	        else {
	            labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();
	            labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();
	        }
	        var beforeVisiblePos = this.scrollDistance;
	        var afterVisiblePos = this.scrollDistance + viewLength;
	        if (labelBeforePos < beforeVisiblePos) {
	            // Scroll header to move label to the before direction
	            this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;
	        }
	        else if (labelAfterPos > afterVisiblePos) {
	            // Scroll header to move label to the after direction
	            this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;
	        }
	    };
	    /**
	     * Evaluate whether the pagination controls should be displayed. If the scroll width of the
	     * tab list is wider than the size of the header container, then the pagination controls should
	     * be shown.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._checkPaginationEnabled = function () {
	        this._showPaginationControls =
	            this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
	        if (!this._showPaginationControls) {
	            this.scrollDistance = 0;
	        }
	    };
	    /**
	     * Evaluate whether the before and after controls should be enabled or disabled.
	     * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
	     * before button. If the header is at the end of the list (scroll distance is equal to the
	     * maximum distance we can scroll), then disable the after button.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._checkScrollingControls = function () {
	        // Check if the pagination arrows should be activated.
	        this._disableScrollBefore = this.scrollDistance == 0;
	        this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();
	    };
	    /**
	     * Determines what is the maximum length in pixels that can be set for the scroll distance. This
	     * is equal to the difference in width between the tab list container and tab header container.
	     *
	     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
	     * should be called sparingly.
	     */
	    MdTabHeader.prototype._getMaxScrollDistance = function () {
	        var lengthOfTabList = this._tabList.nativeElement.scrollWidth;
	        var viewLength = this._tabListContainer.nativeElement.offsetWidth;
	        return lengthOfTabList - viewLength;
	    };
	    /** Tells the ink-bar to align itself to the current label wrapper */
	    MdTabHeader.prototype._alignInkBarToSelectedTab = function () {
	        var _this = this;
	        var selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length
	            ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement
	            : null;
	        this._zone.runOutsideAngular(function () {
	            requestAnimationFrame(function () {
	                _this._inkBar.alignToElement(selectedLabelWrapper);
	            });
	        });
	    };
	    __decorate$64([
	        _angular_core.ContentChildren(MdTabLabelWrapper), 
	        __metadata$64('design:type', _angular_core.QueryList)
	    ], MdTabHeader.prototype, "_labelWrappers", void 0);
	    __decorate$64([
	        _angular_core.ViewChild(MdInkBar), 
	        __metadata$64('design:type', MdInkBar)
	    ], MdTabHeader.prototype, "_inkBar", void 0);
	    __decorate$64([
	        _angular_core.ViewChild('tabListContainer'), 
	        __metadata$64('design:type', _angular_core.ElementRef)
	    ], MdTabHeader.prototype, "_tabListContainer", void 0);
	    __decorate$64([
	        _angular_core.ViewChild('tabList'), 
	        __metadata$64('design:type', _angular_core.ElementRef)
	    ], MdTabHeader.prototype, "_tabList", void 0);
	    __decorate$64([
	        _angular_core.Input(), 
	        __metadata$64('design:type', Number), 
	        __metadata$64('design:paramtypes', [Number])
	    ], MdTabHeader.prototype, "selectedIndex", null);
	    __decorate$64([
	        _angular_core.Output(), 
	        __metadata$64('design:type', Object)
	    ], MdTabHeader.prototype, "selectFocusedIndex", void 0);
	    __decorate$64([
	        _angular_core.Output(), 
	        __metadata$64('design:type', Object)
	    ], MdTabHeader.prototype, "indexFocused", void 0);
	    MdTabHeader = __decorate$64([
	        _angular_core.Component({selector: 'md-tab-header, mat-tab-header',
	            template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\" aria-hidden=\"true\" md-ripple [mdRippleDisabled]=\"_disableScrollBefore\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\" (click)=\"_scrollHeader('before')\"><div class=\"mat-tab-header-pagination-chevron\"></div></div><div class=\"mat-tab-label-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\"><div class=\"mat-tab-list\" #tabList role=\"tablist\" (cdkObserveContent)=\"_onContentChanges()\"><div class=\"mat-tab-labels\"><ng-content></ng-content></div><md-ink-bar></md-ink-bar></div></div><div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\" aria-hidden=\"true\" md-ripple [mdRippleDisabled]=\"_disableScrollAfter\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\" (click)=\"_scrollHeader('after')\"><div class=\"mat-tab-header-pagination-chevron\"></div></div>",
	            styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;color:currentColor;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.mat-tab-header-pagination{position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination,.mat-tab-labels{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#ccc}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            host: {
	                'class': 'mat-tab-header',
	                '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
	                '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
	            }
	        }),
	        __param$13(2, _angular_core.Optional()), 
	        __metadata$64('design:paramtypes', [_angular_core.NgZone, _angular_core.ElementRef, Dir])
	    ], MdTabHeader);
	    return MdTabHeader;
	}());
	
	var __decorate$57 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$57 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/** Used to generate unique ID's for each tab component */
	var nextId$2 = 0;
	/** A simple change event emitted on focus or selection changes. */
	var MdTabChangeEvent = (function () {
	    function MdTabChangeEvent() {
	    }
	    return MdTabChangeEvent;
	}());
	/**
	 * Material design tab-group component.  Supports basic tab pairs (label + content) and includes
	 * animated ink-bar, keyboard navigation, and screen reader.
	 * See: https://www.google.com/design/spec/components/tabs.html
	 */
	var MdTabGroup = (function () {
	    function MdTabGroup(_renderer) {
	        this._renderer = _renderer;
	        /** Whether this component has been initialized. */
	        this._isInitialized = false;
	        /** The tab index that should be selected after the content has been checked. */
	        this._indexToSelect = 0;
	        /** Snapshot of the height of the tab body wrapper before another tab is activated. */
	        this._tabBodyWrapperHeight = null;
	        /** Whether the tab group should grow to the size of the active tab */
	        this._dynamicHeight = false;
	        this._selectedIndex = null;
	        /** Position of the tab header. */
	        this.headerPosition = 'above';
	        this._onFocusChange = new _angular_core.EventEmitter();
	        this._onSelectChange = new _angular_core.EventEmitter(true);
	        this._groupId = nextId$2++;
	    }
	    Object.defineProperty(MdTabGroup.prototype, "dynamicHeight", {
	        get: function () { return this._dynamicHeight; },
	        set: function (value) { this._dynamicHeight = coerceBooleanProperty(value); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "_dynamicHeightDeprecated", {
	        /** @deprecated */
	        get: function () { return this._dynamicHeight; },
	        set: function (value) { this._dynamicHeight = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "selectedIndex", {
	        get: function () { return this._selectedIndex; },
	        /** The index of the active tab. */
	        set: function (value) { this._indexToSelect = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "selectedIndexChange", {
	        /** Output to enable support for two-way binding on `selectedIndex`. */
	        get: function () {
	            return this.selectChange.map(function (event) { return event.index; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "focusChange", {
	        /** Event emitted when focus has changed within a tab group. */
	        get: function () {
	            return this._onFocusChange.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTabGroup.prototype, "selectChange", {
	        /** Event emitted when the tab selection has changed. */
	        get: function () {
	            return this._onSelectChange.asObservable();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * After the content is checked, this component knows what tabs have been defined
	     * and what the selected index should be. This is where we can know exactly what position
	     * each tab should be in according to the new selected index, and additionally we know how
	     * a new selected tab should transition in (from the left or right).
	     */
	    MdTabGroup.prototype.ngAfterContentChecked = function () {
	        var _this = this;
	        // Clamp the next selected index to the bounds of 0 and the tabs length. Note the `|| 0`, which
	        // ensures that values like NaN can't get through and which would otherwise throw the
	        // component into an infinite loop (since Math.max(NaN, 0) === NaN).
	        this._indexToSelect =
	            Math.min(this._tabs.length - 1, Math.max(this._indexToSelect || 0, 0));
	        // If there is a change in selected index, emit a change event. Should not trigger if
	        // the selected index has not yet been initialized.
	        if (this._selectedIndex != this._indexToSelect && this._selectedIndex != null) {
	            this._onSelectChange.emit(this._createChangeEvent(this._indexToSelect));
	        }
	        // Setup the position for each tab and optionally setup an origin on the next selected tab.
	        this._tabs.forEach(function (tab, index) {
	            tab.position = index - _this._indexToSelect;
	            // If there is already a selected tab, then set up an origin for the next selected tab
	            // if it doesn't have one already.
	            if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {
	                tab.origin = _this._indexToSelect - _this._selectedIndex;
	            }
	        });
	        this._selectedIndex = this._indexToSelect;
	    };
	    /**
	     * Waits one frame for the view to update, then updates the ink bar
	     * Note: This must be run outside of the zone or it will create an infinite change detection loop.
	     */
	    MdTabGroup.prototype.ngAfterViewChecked = function () {
	        this._isInitialized = true;
	    };
	    MdTabGroup.prototype._focusChanged = function (index) {
	        this._onFocusChange.emit(this._createChangeEvent(index));
	    };
	    MdTabGroup.prototype._createChangeEvent = function (index) {
	        var event = new MdTabChangeEvent;
	        event.index = index;
	        if (this._tabs && this._tabs.length) {
	            event.tab = this._tabs.toArray()[index];
	        }
	        return event;
	    };
	    /** Returns a unique id for each tab label element */
	    MdTabGroup.prototype._getTabLabelId = function (i) {
	        return "md-tab-label-" + this._groupId + "-" + i;
	    };
	    /** Returns a unique id for each tab content element */
	    MdTabGroup.prototype._getTabContentId = function (i) {
	        return "md-tab-content-" + this._groupId + "-" + i;
	    };
	    /**
	     * Sets the height of the body wrapper to the height of the activating tab if dynamic
	     * height property is true.
	     */
	    MdTabGroup.prototype._setTabBodyWrapperHeight = function (tabHeight) {
	        if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
	            return;
	        }
	        this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', this._tabBodyWrapperHeight + 'px');
	        // This conditional forces the browser to paint the height so that
	        // the animation to the new height can have an origin.
	        if (this._tabBodyWrapper.nativeElement.offsetHeight) {
	            this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', tabHeight + 'px');
	        }
	    };
	    /** Removes the height of the tab body wrapper. */
	    MdTabGroup.prototype._removeTabBodyWrapperHeight = function () {
	        this._tabBodyWrapperHeight = this._tabBodyWrapper.nativeElement.clientHeight;
	        this._renderer.setElementStyle(this._tabBodyWrapper.nativeElement, 'height', '');
	    };
	    __decorate$57([
	        _angular_core.ContentChildren(MdTab), 
	        __metadata$57('design:type', _angular_core.QueryList)
	    ], MdTabGroup.prototype, "_tabs", void 0);
	    __decorate$57([
	        _angular_core.ViewChild('tabBodyWrapper'), 
	        __metadata$57('design:type', _angular_core.ElementRef)
	    ], MdTabGroup.prototype, "_tabBodyWrapper", void 0);
	    __decorate$57([
	        _angular_core.Input(), 
	        __metadata$57('design:type', Boolean)
	    ], MdTabGroup.prototype, "dynamicHeight", null);
	    __decorate$57([
	        _angular_core.Input('md-dynamic-height'), 
	        __metadata$57('design:type', Boolean)
	    ], MdTabGroup.prototype, "_dynamicHeightDeprecated", null);
	    __decorate$57([
	        _angular_core.Input(), 
	        __metadata$57('design:type', Number), 
	        __metadata$57('design:paramtypes', [Number])
	    ], MdTabGroup.prototype, "selectedIndex", null);
	    __decorate$57([
	        _angular_core.Input(), 
	        __metadata$57('design:type', String)
	    ], MdTabGroup.prototype, "headerPosition", void 0);
	    __decorate$57([
	        _angular_core.Output(), 
	        __metadata$57('design:type', rxjs_Observable.Observable)
	    ], MdTabGroup.prototype, "selectedIndexChange", null);
	    __decorate$57([
	        _angular_core.Output(), 
	        __metadata$57('design:type', rxjs_Observable.Observable)
	    ], MdTabGroup.prototype, "focusChange", null);
	    __decorate$57([
	        _angular_core.Output(), 
	        __metadata$57('design:type', rxjs_Observable.Observable)
	    ], MdTabGroup.prototype, "selectChange", null);
	    MdTabGroup = __decorate$57([
	        _angular_core.Component({selector: 'md-tab-group, mat-tab-group',
	            template: "<md-tab-header [selectedIndex]=\"selectedIndex\" #tabHeader (indexFocused)=\"_focusChanged($event)\" (selectFocusedIndex)=\"selectedIndex = $event\"><div class=\"mat-tab-label\" role=\"tab\" md-tab-label-wrapper md-ripple *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabLabelId(i)\" [tabIndex]=\"selectedIndex == i ? 0 : -1\" [attr.aria-controls]=\"_getTabContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [class.mat-tab-label-active]=\"selectedIndex == i\" [disabled]=\"tab.disabled\" (click)=\"tabHeader.focusIndex = selectedIndex = i\"><template [ngIf]=\"tab.templateLabel\"><template [cdkPortalHost]=\"tab.templateLabel\"></template></template><template [ngIf]=\"!tab.templateLabel\">{{tab.textLabel}}</template></div></md-tab-header><div class=\"mat-tab-body-wrapper\" #tabBodyWrapper><md-tab-body role=\"tabpanel\" *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabContentId(i)\" [attr.aria-labelledby]=\"_getTabLabelId(i)\" [class.mat-tab-body-active]=\"selectedIndex == i\" [content]=\"tab.content\" [position]=\"tab.position\" [origin]=\"tab.origin\" (onCentered)=\"_removeTabBodyWrapperHeight()\" (onCentering)=\"_setTabBodyWrapperHeight($event)\"></md-tab-body></div>",
	            styles: [":host{display:flex;flex-direction:column;font-family:Roboto,\"Helvetica Neue\",sans-serif}:host.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{line-height:48px;height:48px;padding:0 12px;font-size:14px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-weight:500;cursor:pointer;box-sizing:border-box;color:currentColor;opacity:.6;min-width:160px;text-align:center;position:relative}.mat-tab-label:focus{outline:0;opacity:1}@media (max-width:600px){.mat-tab-label{min-width:72px}}:host[mat-stretch-tabs] .mat-tab-label,:host[md-stretch-tabs] .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{position:absolute;top:0;left:0;right:0;bottom:0;display:block;overflow:hidden}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}:host.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}.mat-tab-disabled{cursor:default;pointer-events:none}"],
	            host: {
	                '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',
	                '[class.mat-tab-group-inverted-header]': 'headerPosition === "below"',
	            }
	        }), 
	        __metadata$57('design:paramtypes', [_angular_core.Renderer])
	    ], MdTabGroup);
	    return MdTabGroup;
	}());
	var MdTabsModule = (function () {
	    function MdTabsModule() {
	    }
	    /** @deprecated */
	    MdTabsModule.forRoot = function () {
	        return {
	            ngModule: MdTabsModule,
	            providers: []
	        };
	    };
	    MdTabsModule = __decorate$57([
	        _angular_core.NgModule({
	            imports: [_angular_common.CommonModule, PortalModule, MdRippleModule, ObserveContentModule],
	            // Don't export all components because some are only to be used internally.
	            exports: [MdTabGroup, MdTabLabel, MdTab, MdTabNavBar, MdTabLink, MdTabLinkRipple],
	            declarations: [MdTabGroup, MdTabLabel, MdTab, MdInkBar, MdTabLabelWrapper,
	                MdTabNavBar, MdTabLink, MdTabBody, MdTabLinkRipple, MdTabHeader],
	            providers: [VIEWPORT_RULER_PROVIDER, SCROLL_DISPATCHER_PROVIDER],
	        }), 
	        __metadata$57('design:paramtypes', [])
	    ], MdTabsModule);
	    return MdTabsModule;
	}());
	
	var __decorate$65 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$65 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdToolbarRow = (function () {
	    function MdToolbarRow() {
	    }
	    MdToolbarRow = __decorate$65([
	        _angular_core.Directive({
	            selector: 'md-toolbar-row, mat-toolbar-row',
	            host: {
	                '[class.mat-toolbar-row]': 'true',
	            },
	        }), 
	        __metadata$65('design:paramtypes', [])
	    ], MdToolbarRow);
	    return MdToolbarRow;
	}());
	var MdToolbar = (function () {
	    function MdToolbar(elementRef, renderer) {
	        this.elementRef = elementRef;
	        this.renderer = renderer;
	    }
	    Object.defineProperty(MdToolbar.prototype, "color", {
	        /** The color of the toolbar. Can be primary, accent, or warn. */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            this._updateColor(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdToolbar.prototype._updateColor = function (newColor) {
	        this._setElementColor(this._color, false);
	        this._setElementColor(newColor, true);
	        this._color = newColor;
	    };
	    MdToolbar.prototype._setElementColor = function (color, isAdd) {
	        if (color != null && color != '') {
	            this.renderer.setElementClass(this.elementRef.nativeElement, "mat-" + color, isAdd);
	        }
	    };
	    __decorate$65([
	        _angular_core.Input(), 
	        __metadata$65('design:type', String)
	    ], MdToolbar.prototype, "color", null);
	    MdToolbar = __decorate$65([
	        _angular_core.Component({selector: 'md-toolbar, mat-toolbar',
	            template: "<div class=\"mat-toolbar-layout\"><md-toolbar-row><ng-content></ng-content></md-toolbar-row><ng-content select=\"md-toolbar-row, mat-toolbar-row\"></ng-content></div>",
	            styles: [".mat-toolbar,.mat-toolbar .mat-toolbar-row{display:flex;box-sizing:border-box;width:100%}.mat-toolbar{font-size:20px;font-weight:500;font-family:Roboto,\"Helvetica Neue\",sans-serif;padding:0 16px;flex-direction:column;min-height:64px}.mat-toolbar .mat-toolbar-row{flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-row{height:64px}@media (max-width:600px) and (orientation:portrait){.mat-toolbar{min-height:56px}.mat-toolbar-row{height:56px}}@media (max-width:960px) and (orientation:landscape){.mat-toolbar{min-height:48px}.mat-toolbar-row{height:48px}}"],
	            host: {
	                '[class.mat-toolbar]': 'true',
	                'role': 'toolbar'
	            },
	            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,
	            encapsulation: _angular_core.ViewEncapsulation.None
	        }), 
	        __metadata$65('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])
	    ], MdToolbar);
	    return MdToolbar;
	}());
	var MdToolbarModule = (function () {
	    function MdToolbarModule() {
	    }
	    /** @deprecated */
	    MdToolbarModule.forRoot = function () {
	        return {
	            ngModule: MdToolbarModule,
	            providers: []
	        };
	    };
	    MdToolbarModule = __decorate$65([
	        _angular_core.NgModule({
	            imports: [CompatibilityModule],
	            exports: [MdToolbar, MdToolbarRow, CompatibilityModule],
	            declarations: [MdToolbar, MdToolbarRow],
	        }), 
	        __metadata$65('design:paramtypes', [])
	    ], MdToolbarModule);
	    return MdToolbarModule;
	}());
	
	var __extends$20 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when a tooltip has an invalid position.
	 * @docs-private
	 */
	var MdTooltipInvalidPositionError = (function (_super) {
	    __extends$20(MdTooltipInvalidPositionError, _super);
	    function MdTooltipInvalidPositionError(position) {
	        _super.call(this, "Tooltip position \"" + position + "\" is invalid.");
	    }
	    return MdTooltipInvalidPositionError;
	}(MdError));
	
	var __decorate$66 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$66 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$14 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/** Time in ms to delay before changing the tooltip visibility to hidden */
	var TOUCHEND_HIDE_DELAY = 1500;
	/** Time in ms to throttle repositioning after scroll events. */
	var SCROLL_THROTTLE_MS = 20;
	/**
	 * Directive that attaches a material design tooltip to the host element. Animates the showing and
	 * hiding of a tooltip provided position (defaults to below the element).
	 *
	 * https://material.google.com/components/tooltips.html
	 */
	var MdTooltip = (function () {
	    function MdTooltip(_overlay, _scrollDispatcher, _elementRef, _viewContainerRef, _ngZone, _dir) {
	        this._overlay = _overlay;
	        this._scrollDispatcher = _scrollDispatcher;
	        this._elementRef = _elementRef;
	        this._viewContainerRef = _viewContainerRef;
	        this._ngZone = _ngZone;
	        this._dir = _dir;
	        this._position = 'below';
	        /** The default delay in ms before showing the tooltip after show is called */
	        this.showDelay = 0;
	        /** The default delay in ms before hiding the tooltip after hide is called */
	        this.hideDelay = 0;
	    }
	    Object.defineProperty(MdTooltip.prototype, "position", {
	        /** Allows the user to define the position of the tooltip relative to the parent element */
	        get: function () { return this._position; },
	        set: function (value) {
	            if (value !== this._position) {
	                this._position = value;
	                // TODO(andrewjs): When the overlay's position can be dynamically changed, do not destroy
	                // the tooltip.
	                if (this._tooltipInstance) {
	                    this._disposeTooltip();
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_positionDeprecated", {
	        /** @deprecated */
	        get: function () { return this._position; },
	        set: function (value) { this._position = value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "message", {
	        /** The message to be displayed in the tooltip */
	        get: function () { return this._message; },
	        set: function (value) {
	            this._message = value;
	            if (this._tooltipInstance) {
	                this._setTooltipMessage(this._message);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_deprecatedMessage", {
	        /** @deprecated */
	        get: function () { return this.message; },
	        set: function (v) { this.message = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matMessage", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.message; },
	        set: function (v) { this.message = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matPosition", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.position; },
	        set: function (v) { this.position = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matHideDelay", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.hideDelay; },
	        set: function (v) { this.hideDelay = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdTooltip.prototype, "_matShowDelay", {
	        // Properties with `mat-` prefix for noconflict mode.
	        get: function () { return this.showDelay; },
	        set: function (v) { this.showDelay = v; },
	        enumerable: true,
	        configurable: true
	    });
	    MdTooltip.prototype.ngOnInit = function () {
	        var _this = this;
	        // When a scroll on the page occurs, update the position in case this tooltip needs
	        // to be repositioned.
	        this.scrollSubscription = this._scrollDispatcher.scrolled(SCROLL_THROTTLE_MS).subscribe(function () {
	            if (_this._overlayRef) {
	                _this._overlayRef.updatePosition();
	            }
	        });
	    };
	    /**
	     * Dispose the tooltip when destroyed.
	     */
	    MdTooltip.prototype.ngOnDestroy = function () {
	        if (this._tooltipInstance) {
	            this._disposeTooltip();
	        }
	        this.scrollSubscription.unsubscribe();
	    };
	    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
	    MdTooltip.prototype.show = function (delay) {
	        if (delay === void 0) { delay = this.showDelay; }
	        if (!this._message || !this._message.trim()) {
	            return;
	        }
	        if (!this._tooltipInstance) {
	            this._createTooltip();
	        }
	        this._setTooltipMessage(this._message);
	        this._tooltipInstance.show(this._position, delay);
	    };
	    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
	    MdTooltip.prototype.hide = function (delay) {
	        if (delay === void 0) { delay = this.hideDelay; }
	        if (this._tooltipInstance) {
	            this._tooltipInstance.hide(delay);
	        }
	    };
	    /** Shows/hides the tooltip */
	    MdTooltip.prototype.toggle = function () {
	        this._isTooltipVisible() ? this.hide() : this.show();
	    };
	    /** Returns true if the tooltip is currently visible to the user */
	    MdTooltip.prototype._isTooltipVisible = function () {
	        return this._tooltipInstance && this._tooltipInstance.isVisible();
	    };
	    /** Create the tooltip to display */
	    MdTooltip.prototype._createTooltip = function () {
	        var _this = this;
	        this._createOverlay();
	        var portal = new ComponentPortal(TooltipComponent, this._viewContainerRef);
	        this._tooltipInstance = this._overlayRef.attach(portal).instance;
	        // Dispose the overlay when finished the shown tooltip.
	        this._tooltipInstance.afterHidden().subscribe(function () {
	            // Check first if the tooltip has already been removed through this components destroy.
	            if (_this._tooltipInstance) {
	                _this._disposeTooltip();
	            }
	        });
	    };
	    /** Create the overlay config and position strategy */
	    MdTooltip.prototype._createOverlay = function () {
	        var _this = this;
	        var origin = this._getOrigin();
	        var position = this._getOverlayPosition();
	        // Create connected position strategy that listens for scroll events to reposition.
	        // After position changes occur and the overlay is clipped by a parent scrollable then
	        // close the tooltip.
	        var strategy = this._overlay.position().connectedTo(this._elementRef, origin, position);
	        strategy.withScrollableContainers(this._scrollDispatcher.getScrollContainers(this._elementRef));
	        strategy.onPositionChange.subscribe(function (change) {
	            if (change.scrollableViewProperties.isOverlayClipped &&
	                _this._tooltipInstance && _this._tooltipInstance.isVisible()) {
	                _this.hide(0);
	            }
	        });
	        var config = new OverlayState();
	        config.positionStrategy = strategy;
	        this._overlayRef = this._overlay.create(config);
	    };
	    /** Disposes the current tooltip and the overlay it is attached to */
	    MdTooltip.prototype._disposeTooltip = function () {
	        this._overlayRef.dispose();
	        this._overlayRef = null;
	        this._tooltipInstance = null;
	    };
	    /** Returns the origin position based on the user's position preference */
	    MdTooltip.prototype._getOrigin = function () {
	        if (this.position == 'above' || this.position == 'below') {
	            return { originX: 'center', originY: this.position == 'above' ? 'top' : 'bottom' };
	        }
	        var isDirectionLtr = !this._dir || this._dir.value == 'ltr';
	        if (this.position == 'left' ||
	            this.position == 'before' && isDirectionLtr ||
	            this.position == 'after' && !isDirectionLtr) {
	            return { originX: 'start', originY: 'center' };
	        }
	        if (this.position == 'right' ||
	            this.position == 'after' && isDirectionLtr ||
	            this.position == 'before' && !isDirectionLtr) {
	            return { originX: 'end', originY: 'center' };
	        }
	        throw new MdTooltipInvalidPositionError(this.position);
	    };
	    /** Returns the overlay position based on the user's preference */
	    MdTooltip.prototype._getOverlayPosition = function () {
	        if (this.position == 'above') {
	            return { overlayX: 'center', overlayY: 'bottom' };
	        }
	        if (this.position == 'below') {
	            return { overlayX: 'center', overlayY: 'top' };
	        }
	        var isLtr = !this._dir || this._dir.value == 'ltr';
	        if (this.position == 'left' ||
	            this.position == 'before' && isLtr ||
	            this.position == 'after' && !isLtr) {
	            return { overlayX: 'end', overlayY: 'center' };
	        }
	        if (this.position == 'right' ||
	            this.position == 'after' && isLtr ||
	            this.position == 'before' && !isLtr) {
	            return { overlayX: 'start', overlayY: 'center' };
	        }
	        throw new MdTooltipInvalidPositionError(this.position);
	    };
	    /** Updates the tooltip message and repositions the overlay according to the new message length */
	    MdTooltip.prototype._setTooltipMessage = function (message) {
	        var _this = this;
	        // Must wait for the message to be painted to the tooltip so that the overlay can properly
	        // calculate the correct positioning based on the size of the text.
	        this._tooltipInstance.message = message;
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            if (_this._tooltipInstance) {
	                _this._overlayRef.updatePosition();
	            }
	        });
	    };
	    __decorate$66([
	        _angular_core.Input('mdTooltipPosition'), 
	        __metadata$66('design:type', String)
	    ], MdTooltip.prototype, "position", null);
	    __decorate$66([
	        _angular_core.Input('tooltip-position'), 
	        __metadata$66('design:type', String)
	    ], MdTooltip.prototype, "_positionDeprecated", null);
	    __decorate$66([
	        _angular_core.Input('mdTooltipShowDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "showDelay", void 0);
	    __decorate$66([
	        _angular_core.Input('mdTooltipHideDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "hideDelay", void 0);
	    __decorate$66([
	        _angular_core.Input('mdTooltip'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "message", null);
	    __decorate$66([
	        _angular_core.Input('md-tooltip'), 
	        __metadata$66('design:type', String)
	    ], MdTooltip.prototype, "_deprecatedMessage", null);
	    __decorate$66([
	        _angular_core.Input('matTooltip'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matMessage", null);
	    __decorate$66([
	        _angular_core.Input('matTooltipPosition'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matPosition", null);
	    __decorate$66([
	        _angular_core.Input('matTooltipHideDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matHideDelay", null);
	    __decorate$66([
	        _angular_core.Input('matTooltipShowDelay'), 
	        __metadata$66('design:type', Object)
	    ], MdTooltip.prototype, "_matShowDelay", null);
	    MdTooltip = __decorate$66([
	        _angular_core.Directive({
	            selector: '[md-tooltip], [mdTooltip], [mat-tooltip], [matTooltip]',
	            host: {
	                '(longpress)': 'show()',
	                '(touchend)': 'hide(' + TOUCHEND_HIDE_DELAY + ')',
	                '(mouseenter)': 'show()',
	                '(mouseleave)': 'hide()',
	            },
	            exportAs: 'mdTooltip',
	        }),
	        __param$14(5, _angular_core.Optional()), 
	        __metadata$66('design:paramtypes', [Overlay, ScrollDispatcher, _angular_core.ElementRef, _angular_core.ViewContainerRef, _angular_core.NgZone, Dir])
	    ], MdTooltip);
	    return MdTooltip;
	}());
	/**
	 * Internal component that wraps the tooltip's content.
	 * @docs-private
	 */
	var TooltipComponent = (function () {
	    function TooltipComponent(_dir, _changeDetectorRef) {
	        this._dir = _dir;
	        this._changeDetectorRef = _changeDetectorRef;
	        /** Property watched by the animation framework to show or hide the tooltip */
	        this._visibility = 'initial';
	        /** Whether interactions on the page should close the tooltip */
	        this._closeOnInteraction = false;
	        /** The transform origin used in the animation for showing and hiding the tooltip */
	        this._transformOrigin = 'bottom';
	        /** Subject for notifying that the tooltip has been hidden from the view */
	        this._onHide = new rxjs_Subject.Subject();
	    }
	    /**
	     * Shows the tooltip with an animation originating from the provided origin
	     * @param position Position of the tooltip.
	     * @param delay Amount of milliseconds to the delay showing the tooltip.
	     */
	    TooltipComponent.prototype.show = function (position, delay) {
	        var _this = this;
	        // Cancel the delayed hide if it is scheduled
	        if (this._hideTimeoutId) {
	            clearTimeout(this._hideTimeoutId);
	        }
	        // Body interactions should cancel the tooltip if there is a delay in showing.
	        this._closeOnInteraction = true;
	        this._setTransformOrigin(position);
	        this._showTimeoutId = setTimeout(function () {
	            _this._visibility = 'visible';
	            // If this was set to true immediately, then a body click that triggers show() would
	            // trigger interaction and close the tooltip right after it was displayed.
	            _this._closeOnInteraction = false;
	            // Mark for check so if any parent component has set the
	            // ChangeDetectionStrategy to OnPush it will be checked anyways
	            _this._changeDetectorRef.markForCheck();
	            setTimeout(function () { _this._closeOnInteraction = true; }, 0);
	        }, delay);
	    };
	    /**
	     * Begins the animation to hide the tooltip after the provided delay in ms.
	     * @param delay Amount of milliseconds to delay showing the tooltip.
	     */
	    TooltipComponent.prototype.hide = function (delay) {
	        var _this = this;
	        // Cancel the delayed show if it is scheduled
	        if (this._showTimeoutId) {
	            clearTimeout(this._showTimeoutId);
	        }
	        this._hideTimeoutId = setTimeout(function () {
	            _this._visibility = 'hidden';
	            _this._closeOnInteraction = false;
	            // Mark for check so if any parent component has set the
	            // ChangeDetectionStrategy to OnPush it will be checked anyways
	            _this._changeDetectorRef.markForCheck();
	        }, delay);
	    };
	    /**
	     * Returns an observable that notifies when the tooltip has been hidden from view
	     */
	    TooltipComponent.prototype.afterHidden = function () {
	        return this._onHide.asObservable();
	    };
	    /**
	     * Whether the tooltip is being displayed
	     */
	    TooltipComponent.prototype.isVisible = function () {
	        return this._visibility === 'visible';
	    };
	    /** Sets the tooltip transform origin according to the tooltip position */
	    TooltipComponent.prototype._setTransformOrigin = function (value) {
	        var isLtr = !this._dir || this._dir.value == 'ltr';
	        switch (value) {
	            case 'before':
	                this._transformOrigin = isLtr ? 'right' : 'left';
	                break;
	            case 'after':
	                this._transformOrigin = isLtr ? 'left' : 'right';
	                break;
	            case 'left':
	                this._transformOrigin = 'right';
	                break;
	            case 'right':
	                this._transformOrigin = 'left';
	                break;
	            case 'above':
	                this._transformOrigin = 'bottom';
	                break;
	            case 'below':
	                this._transformOrigin = 'top';
	                break;
	            default: throw new MdTooltipInvalidPositionError(value);
	        }
	    };
	    TooltipComponent.prototype._afterVisibilityAnimation = function (e) {
	        if (e.toState === 'hidden' && !this.isVisible()) {
	            this._onHide.next();
	        }
	    };
	    /**
	     * Interactions on the HTML body should close the tooltip immediately as defined in the
	     * material design spec.
	     * https://material.google.com/components/tooltips.html#tooltips-interaction
	     */
	    TooltipComponent.prototype._handleBodyInteraction = function () {
	        if (this._closeOnInteraction) {
	            this.hide(0);
	        }
	    };
	    TooltipComponent = __decorate$66([
	        _angular_core.Component({selector: 'md-tooltip-component, mat-tooltip-component',
	            template: "<div class=\"mat-tooltip\" [style.transform-origin]=\"_transformOrigin\" [@state]=\"_visibility\" (@state.done)=\"_afterVisibilityAnimation($event)\">{{message}}</div>",
	            styles: [":host{pointer-events:none}.mat-tooltip{color:#fff;padding:6px 8px;border-radius:2px;font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:10px;margin:14px;max-width:250px}@media screen and (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}"],
	            animations: [
	                _angular_core.trigger('state', [
	                    _angular_core.state('void', _angular_core.style({ transform: 'scale(0)' })),
	                    _angular_core.state('initial', _angular_core.style({ transform: 'scale(0)' })),
	                    _angular_core.state('visible', _angular_core.style({ transform: 'scale(1)' })),
	                    _angular_core.state('hidden', _angular_core.style({ transform: 'scale(0)' })),
	                    _angular_core.transition('* => visible', _angular_core.animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),
	                    _angular_core.transition('* => hidden', _angular_core.animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),
	                ])
	            ],
	            host: {
	                '(body:click)': 'this._handleBodyInteraction()'
	            }
	        }),
	        __param$14(0, _angular_core.Optional()), 
	        __metadata$66('design:paramtypes', [Dir, _angular_core.ChangeDetectorRef])
	    ], TooltipComponent);
	    return TooltipComponent;
	}());
	var MdTooltipModule = (function () {
	    function MdTooltipModule() {
	    }
	    /** @deprecated */
	    MdTooltipModule.forRoot = function () {
	        return {
	            ngModule: MdTooltipModule,
	            providers: []
	        };
	    };
	    MdTooltipModule = __decorate$66([
	        _angular_core.NgModule({
	            imports: [OverlayModule, CompatibilityModule],
	            exports: [MdTooltip, TooltipComponent, CompatibilityModule],
	            declarations: [MdTooltip, TooltipComponent],
	            entryComponents: [TooltipComponent],
	        }), 
	        __metadata$66('design:paramtypes', [])
	    ], MdTooltipModule);
	    return MdTooltipModule;
	}());
	
	var __extends$21 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when menu trigger doesn't have a valid md-menu instance
	 * @docs-private
	 */
	var MdMenuMissingError = (function (_super) {
	    __extends$21(MdMenuMissingError, _super);
	    function MdMenuMissingError() {
	        _super.call(this, "md-menu-trigger: must pass in an md-menu instance.\n\n    Example:\n      <md-menu #menu=\"mdMenu\"></md-menu>\n      <button [mdMenuTriggerFor]=\"menu\"></button>\n    ");
	    }
	    return MdMenuMissingError;
	}(MdError));
	/**
	 * Exception thrown when menu's x-position value isn't valid.
	 * In other words, it doesn't match 'before' or 'after'.
	 * @docs-private
	 */
	var MdMenuInvalidPositionX = (function (_super) {
	    __extends$21(MdMenuInvalidPositionX, _super);
	    function MdMenuInvalidPositionX() {
	        _super.call(this, "x-position value must be either 'before' or after'.\n      Example: <md-menu x-position=\"before\" #menu=\"mdMenu\"></md-menu>\n    ");
	    }
	    return MdMenuInvalidPositionX;
	}(MdError));
	/**
	 * Exception thrown when menu's y-position value isn't valid.
	 * In other words, it doesn't match 'above' or 'below'.
	 * @docs-private
	 */
	var MdMenuInvalidPositionY = (function (_super) {
	    __extends$21(MdMenuInvalidPositionY, _super);
	    function MdMenuInvalidPositionY() {
	        _super.call(this, "y-position value must be either 'above' or below'.\n      Example: <md-menu y-position=\"above\" #menu=\"mdMenu\"></md-menu>\n    ");
	    }
	    return MdMenuInvalidPositionY;
	}(MdError));
	
	var __decorate$69 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$69 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * This directive is intended to be used inside an md-menu tag.
	 * It exists mostly to set the role attribute.
	 */
	var MdMenuItem = (function () {
	    function MdMenuItem(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	    }
	    MdMenuItem.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._elementRef.nativeElement, 'focus');
	    };
	    Object.defineProperty(MdMenuItem.prototype, "disabled", {
	        // this is necessary to support anchors
	        /** Whether the menu item is disabled. */
	        get: function () { return this._disabled; },
	        set: function (value) {
	            this._disabled = (value === false || value === undefined) ? null : true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuItem.prototype, "isAriaDisabled", {
	        /** Sets the aria-disabled property on the menu item. */
	        get: function () { return String(!!this.disabled); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuItem.prototype, "_tabindex", {
	        get: function () { return this.disabled ? '-1' : '0'; },
	        enumerable: true,
	        configurable: true
	    });
	    MdMenuItem.prototype._getHostElement = function () {
	        return this._elementRef.nativeElement;
	    };
	    MdMenuItem.prototype._checkDisabled = function (event) {
	        if (this.disabled) {
	            event.preventDefault();
	            event.stopPropagation();
	        }
	    };
	    __decorate$69([
	        _angular_core.HostBinding('attr.disabled'),
	        _angular_core.Input(), 
	        __metadata$69('design:type', Boolean)
	    ], MdMenuItem.prototype, "disabled", null);
	    __decorate$69([
	        _angular_core.HostBinding('attr.aria-disabled'), 
	        __metadata$69('design:type', String)
	    ], MdMenuItem.prototype, "isAriaDisabled", null);
	    MdMenuItem = __decorate$69([
	        _angular_core.Component({selector: '[md-menu-item], [mat-menu-item]',
	            host: {
	                'role': 'menuitem',
	                '[class.mat-menu-item]': 'true',
	                '(click)': '_checkDisabled($event)',
	                '[attr.tabindex]': '_tabindex'
	            },
	            template: "<ng-content></ng-content><div class=\"mat-menu-ripple\" *ngIf=\"!disabled\" md-ripple [mdRippleTrigger]=\"_getHostElement()\"></div>",
	            exportAs: 'mdMenuItem'
	        }), 
	        __metadata$69('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])
	    ], MdMenuItem);
	    return MdMenuItem;
	}());
	
	/**
	 * Below are all the animations for the md-menu component.
	 * Animation duration and timing values are based on AngularJS Material.
	 */
	/**
	 * This animation controls the menu panel's entry and exit from the page.
	 *
	 * When the menu panel is added to the DOM, it scales in and fades in its border.
	 *
	 * When the menu panel is removed from the DOM, it simply fades out after a brief
	 * delay to display the ripple.
	 */
	// TODO(kara): switch to :enter and :leave once Mobile Safari is sorted out.
	var transformMenu = _angular_core.trigger('transformMenu', [
	    _angular_core.state('showing', _angular_core.style({
	        opacity: 1,
	        transform: "scale(1)"
	    })),
	    _angular_core.transition('void => *', [
	        _angular_core.style({
	            opacity: 0,
	            transform: "scale(0)"
	        }),
	        _angular_core.animate("200ms cubic-bezier(0.25, 0.8, 0.25, 1)")
	    ]),
	    _angular_core.transition('* => void', [
	        _angular_core.animate('50ms 100ms linear', _angular_core.style({ opacity: 0 }))
	    ])
	]);
	/**
	 * This animation fades in the background color and content of the menu panel
	 * after its containing element is scaled in.
	 */
	var fadeInItems = _angular_core.trigger('fadeInItems', [
	    _angular_core.state('showing', _angular_core.style({ opacity: 1 })),
	    _angular_core.transition('void => *', [
	        _angular_core.style({ opacity: 0 }),
	        _angular_core.animate("200ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")
	    ])
	]);
	
	// TODO(kara): prevent-close functionality
	var __decorate$68 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$68 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$15 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var MdMenu = (function () {
	    function MdMenu(posX, posY) {
	        /** Config object to be passed into the menu's ngClass */
	        this._classList = {};
	        /** Position of the menu in the X axis. */
	        this.positionX = 'after';
	        /** Position of the menu in the Y axis. */
	        this.positionY = 'below';
	        this.overlapTrigger = true;
	        /** Event emitted when the menu is closed. */
	        this.close = new _angular_core.EventEmitter();
	        if (posX) {
	            this._setPositionX(posX);
	        }
	        if (posY) {
	            this._setPositionY(posY);
	        }
	        this.setPositionClasses(this.positionX, this.positionY);
	    }
	    MdMenu.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._keyManager = new FocusKeyManager(this.items).withWrap();
	        this._tabSubscription = this._keyManager.tabOut.subscribe(function () {
	            _this._emitCloseEvent();
	        });
	    };
	    MdMenu.prototype.ngOnDestroy = function () {
	        this._tabSubscription.unsubscribe();
	    };
	    Object.defineProperty(MdMenu.prototype, "classList", {
	        /**
	         * This method takes classes set on the host md-menu element and applies them on the
	         * menu template that displays in the overlay container.  Otherwise, it's difficult
	         * to style the containing menu from outside the component.
	         * @param classes list of class names
	         */
	        set: function (classes) {
	            this._classList = classes.split(' ').reduce(function (obj, className) {
	                obj[className] = true;
	                return obj;
	            }, {});
	            this.setPositionClasses(this.positionX, this.positionY);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Focus the first item in the menu. This method is used by the menu trigger
	     * to focus the first item when the menu is opened by the ENTER key.
	     */
	    MdMenu.prototype.focusFirstItem = function () {
	        this._keyManager.setFirstItemActive();
	    };
	    /**
	     * This emits a close event to which the trigger is subscribed. When emitted, the
	     * trigger will close the menu.
	     */
	    MdMenu.prototype._emitCloseEvent = function () {
	        this.close.emit();
	    };
	    MdMenu.prototype._setPositionX = function (pos) {
	        if (pos !== 'before' && pos !== 'after') {
	            throw new MdMenuInvalidPositionX();
	        }
	        this.positionX = pos;
	    };
	    MdMenu.prototype._setPositionY = function (pos) {
	        if (pos !== 'above' && pos !== 'below') {
	            throw new MdMenuInvalidPositionY();
	        }
	        this.positionY = pos;
	    };
	    /**
	     * It's necessary to set position-based classes to ensure the menu panel animation
	     * folds out from the correct direction.
	     */
	    MdMenu.prototype.setPositionClasses = function (posX, posY) {
	        this._classList['mat-menu-before'] = posX == 'before';
	        this._classList['mat-menu-after'] = posX == 'after';
	        this._classList['mat-menu-above'] = posY == 'above';
	        this._classList['mat-menu-below'] = posY == 'below';
	    };
	    __decorate$68([
	        _angular_core.ViewChild(_angular_core.TemplateRef), 
	        __metadata$68('design:type', _angular_core.TemplateRef)
	    ], MdMenu.prototype, "templateRef", void 0);
	    __decorate$68([
	        _angular_core.ContentChildren(MdMenuItem), 
	        __metadata$68('design:type', _angular_core.QueryList)
	    ], MdMenu.prototype, "items", void 0);
	    __decorate$68([
	        _angular_core.Input(), 
	        __metadata$68('design:type', Object)
	    ], MdMenu.prototype, "overlapTrigger", void 0);
	    __decorate$68([
	        _angular_core.Input('class'), 
	        __metadata$68('design:type', String), 
	        __metadata$68('design:paramtypes', [String])
	    ], MdMenu.prototype, "classList", null);
	    __decorate$68([
	        _angular_core.Output(), 
	        __metadata$68('design:type', Object)
	    ], MdMenu.prototype, "close", void 0);
	    MdMenu = __decorate$68([
	        _angular_core.Component({selector: 'md-menu, mat-menu',
	            host: { 'role': 'menu' },
	            template: "<template><div class=\"mat-menu-panel\" [ngClass]=\"_classList\" (keydown)=\"_keyManager.onKeydown($event)\" (click)=\"_emitCloseEvent()\" [@transformMenu]=\"'showing'\"><div class=\"mat-menu-content\" [@fadeInItems]=\"'showing'\"><ng-content></ng-content></div></div></template>",
	            styles: [".mat-menu-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh + 48px)}.mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:left top}.mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:left bottom}.mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:right top}.mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-below{transform-origin:right top}[dir=rtl] .mat-menu-panel.mat-menu-after.mat-menu-above{transform-origin:right bottom}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-below{transform-origin:left top}[dir=rtl] .mat-menu-panel.mat-menu-before.mat-menu-above{transform-origin:left bottom}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content{padding-top:8px;padding-bottom:8px}.mat-menu-item{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:0;border:none;white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;font-size:16px;font-family:Roboto,\"Helvetica Neue\",sans-serif;text-align:start;text-decoration:none;position:relative}.mat-menu-item[disabled]{cursor:default}.mat-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px}button.mat-menu-item{width:100%}.mat-menu-ripple{position:absolute;top:0;left:0;bottom:0;right:0}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            animations: [
	                transformMenu,
	                fadeInItems
	            ],
	            exportAs: 'mdMenu'
	        }),
	        __param$15(0, _angular_core.Attribute('x-position')),
	        __param$15(1, _angular_core.Attribute('y-position')), 
	        __metadata$68('design:paramtypes', [String, String])
	    ], MdMenu);
	    return MdMenu;
	}());
	
	var __decorate$70 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$70 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$16 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * This directive is intended to be used in conjunction with an md-menu tag.  It is
	 * responsible for toggling the display of the provided menu instance.
	 * TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors
	 */
	var MdMenuTrigger = (function () {
	    function MdMenuTrigger(_overlay, _element, _viewContainerRef, _renderer, _dir) {
	        this._overlay = _overlay;
	        this._element = _element;
	        this._viewContainerRef = _viewContainerRef;
	        this._renderer = _renderer;
	        this._dir = _dir;
	        this._menuOpen = false;
	        // tracking input type is necessary so it's possible to only auto-focus
	        // the first item of the list when the menu is opened via the keyboard
	        this._openedByMouse = false;
	        /** Event emitted when the associated menu is opened. */
	        this.onMenuOpen = new _angular_core.EventEmitter();
	        /** Event emitted when the associated menu is closed. */
	        this.onMenuClose = new _angular_core.EventEmitter();
	    }
	    Object.defineProperty(MdMenuTrigger.prototype, "_deprecatedMdMenuTriggerFor", {
	        /** @deprecated */
	        get: function () { return this.menu; },
	        set: function (v) { this.menu = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", {
	        /** @deprecated */
	        get: function () { return this.menu; },
	        set: function (v) { this.menu = v; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdMenuTrigger.prototype, "_matMenuTriggerFor", {
	        // Trigger input for compatibility mode
	        get: function () { return this.menu; },
	        set: function (v) { this.menu = v; },
	        enumerable: true,
	        configurable: true
	    });
	    MdMenuTrigger.prototype.ngAfterViewInit = function () {
	        var _this = this;
	        this._checkMenu();
	        this.menu.close.subscribe(function () { return _this.closeMenu(); });
	    };
	    MdMenuTrigger.prototype.ngOnDestroy = function () { this.destroyMenu(); };
	    Object.defineProperty(MdMenuTrigger.prototype, "menuOpen", {
	        /** Whether the menu is open. */
	        get: function () { return this._menuOpen; },
	        enumerable: true,
	        configurable: true
	    });
	    /** Toggles the menu between the open and closed states. */
	    MdMenuTrigger.prototype.toggleMenu = function () {
	        return this._menuOpen ? this.closeMenu() : this.openMenu();
	    };
	    /** Opens the menu. */
	    MdMenuTrigger.prototype.openMenu = function () {
	        if (!this._menuOpen) {
	            this._createOverlay();
	            this._overlayRef.attach(this._portal);
	            this._subscribeToBackdrop();
	            this._initMenu();
	        }
	    };
	    /** Closes the menu. */
	    MdMenuTrigger.prototype.closeMenu = function () {
	        if (this._overlayRef) {
	            this._overlayRef.detach();
	            this._backdropSubscription.unsubscribe();
	            this._resetMenu();
	        }
	    };
	    /** Removes the menu from the DOM. */
	    MdMenuTrigger.prototype.destroyMenu = function () {
	        if (this._overlayRef) {
	            this._overlayRef.dispose();
	            this._overlayRef = null;
	            this._cleanUpSubscriptions();
	        }
	    };
	    /** Focuses the menu trigger. */
	    MdMenuTrigger.prototype.focus = function () {
	        this._renderer.invokeElementMethod(this._element.nativeElement, 'focus');
	    };
	    Object.defineProperty(MdMenuTrigger.prototype, "dir", {
	        /** The text direction of the containing app. */
	        get: function () {
	            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * This method ensures that the menu closes when the overlay backdrop is clicked.
	     * We do not use first() here because doing so would not catch clicks from within
	     * the menu, and it would fail to unsubscribe properly. Instead, we unsubscribe
	     * explicitly when the menu is closed or destroyed.
	     */
	    MdMenuTrigger.prototype._subscribeToBackdrop = function () {
	        var _this = this;
	        this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
	            _this.closeMenu();
	        });
	    };
	    /**
	     * This method sets the menu state to open and focuses the first item if
	     * the menu was opened via the keyboard.
	     */
	    MdMenuTrigger.prototype._initMenu = function () {
	        this._setIsMenuOpen(true);
	        // Should only set focus if opened via the keyboard, so keyboard users can
	        // can easily navigate menu items. According to spec, mouse users should not
	        // see the focus style.
	        if (!this._openedByMouse) {
	            this.menu.focusFirstItem();
	        }
	    };
	    
	    /**
	     * This method resets the menu when it's closed, most importantly restoring
	     * focus to the menu trigger if the menu was opened via the keyboard.
	     */
	    MdMenuTrigger.prototype._resetMenu = function () {
	        this._setIsMenuOpen(false);
	        // Focus only needs to be reset to the host element if the menu was opened
	        // by the keyboard and manually shifted to the first menu item.
	        if (!this._openedByMouse) {
	            this.focus();
	        }
	        this._openedByMouse = false;
	    };
	    // set state rather than toggle to support triggers sharing a menu
	    MdMenuTrigger.prototype._setIsMenuOpen = function (isOpen) {
	        this._menuOpen = isOpen;
	        this._menuOpen ? this.onMenuOpen.emit() : this.onMenuClose.emit();
	    };
	    /**
	     *  This method checks that a valid instance of MdMenu has been passed into
	     *  mdMenuTriggerFor. If not, an exception is thrown.
	     */
	    MdMenuTrigger.prototype._checkMenu = function () {
	        if (!this.menu) {
	            throw new MdMenuMissingError();
	        }
	    };
	    /**
	     *  This method creates the overlay from the provided menu's template and saves its
	     *  OverlayRef so that it can be attached to the DOM when openMenu is called.
	     */
	    MdMenuTrigger.prototype._createOverlay = function () {
	        if (!this._overlayRef) {
	            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);
	            var config = this._getOverlayConfig();
	            this._subscribeToPositions(config.positionStrategy);
	            this._overlayRef = this._overlay.create(config);
	        }
	    };
	    /**
	     * This method builds the configuration object needed to create the overlay, the OverlayState.
	     * @returns OverlayState
	     */
	    MdMenuTrigger.prototype._getOverlayConfig = function () {
	        var overlayState = new OverlayState();
	        overlayState.positionStrategy = this._getPosition()
	            .withDirection(this.dir);
	        overlayState.hasBackdrop = true;
	        overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
	        overlayState.direction = this.dir;
	        return overlayState;
	    };
	    /**
	     * Listens to changes in the position of the overlay and sets the correct classes
	     * on the menu based on the new position. This ensures the animation origin is always
	     * correct, even if a fallback position is used for the overlay.
	     */
	    MdMenuTrigger.prototype._subscribeToPositions = function (position) {
	        var _this = this;
	        this._positionSubscription = position.onPositionChange.subscribe(function (change) {
	            var posX = change.connectionPair.originX === 'start' ? 'after' : 'before';
	            var posY = change.connectionPair.originY === 'top' ? 'below' : 'above';
	            if (!_this.menu.overlapTrigger) {
	                posY = posY === 'below' ? 'above' : 'below';
	            }
	            _this.menu.setPositionClasses(posX, posY);
	        });
	    };
	    /**
	     * This method builds the position strategy for the overlay, so the menu is properly connected
	     * to the trigger.
	     * @returns ConnectedPositionStrategy
	     */
	    MdMenuTrigger.prototype._getPosition = function () {
	        var _a = this.menu.positionX === 'before' ? ['end', 'start'] : ['start', 'end'], posX = _a[0], fallbackX = _a[1];
	        var _b = this.menu.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], overlayY = _b[0], fallbackOverlayY = _b[1];
	        var originY = overlayY;
	        var fallbackOriginY = fallbackOverlayY;
	        if (!this.menu.overlapTrigger) {
	            originY = overlayY === 'top' ? 'bottom' : 'top';
	            fallbackOriginY = fallbackOverlayY === 'top' ? 'bottom' : 'top';
	        }
	        return this._overlay.position()
	            .connectedTo(this._element, { originX: posX, originY: originY }, { overlayX: posX, overlayY: overlayY })
	            .withFallbackPosition({ originX: fallbackX, originY: originY }, { overlayX: fallbackX, overlayY: overlayY })
	            .withFallbackPosition({ originX: posX, originY: fallbackOriginY }, { overlayX: posX, overlayY: fallbackOverlayY })
	            .withFallbackPosition({ originX: fallbackX, originY: fallbackOriginY }, { overlayX: fallbackX, overlayY: fallbackOverlayY });
	    };
	    MdMenuTrigger.prototype._cleanUpSubscriptions = function () {
	        if (this._backdropSubscription) {
	            this._backdropSubscription.unsubscribe();
	        }
	        if (this._positionSubscription) {
	            this._positionSubscription.unsubscribe();
	        }
	    };
	    MdMenuTrigger.prototype._handleMousedown = function (event) {
	        if (!isFakeMousedownFromScreenReader(event)) {
	            this._openedByMouse = true;
	        }
	    };
	    __decorate$70([
	        _angular_core.Input('md-menu-trigger-for'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "_deprecatedMdMenuTriggerFor", null);
	    __decorate$70([
	        _angular_core.Input('mat-menu-trigger-for'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", null);
	    __decorate$70([
	        _angular_core.Input('matMenuTriggerFor'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "_matMenuTriggerFor", null);
	    __decorate$70([
	        _angular_core.Input('mdMenuTriggerFor'), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "menu", void 0);
	    __decorate$70([
	        _angular_core.Output(), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "onMenuOpen", void 0);
	    __decorate$70([
	        _angular_core.Output(), 
	        __metadata$70('design:type', Object)
	    ], MdMenuTrigger.prototype, "onMenuClose", void 0);
	    MdMenuTrigger = __decorate$70([
	        _angular_core.Directive({
	            selector: "[md-menu-trigger-for], [mat-menu-trigger-for], \n             [mdMenuTriggerFor], [matMenuTriggerFor]",
	            host: {
	                'aria-haspopup': 'true',
	                '(mousedown)': '_handleMousedown($event)',
	                '(click)': 'toggleMenu()',
	            },
	            exportAs: 'mdMenuTrigger'
	        }),
	        __param$16(4, _angular_core.Optional()), 
	        __metadata$70('design:paramtypes', [Overlay, _angular_core.ElementRef, _angular_core.ViewContainerRef, _angular_core.Renderer, Dir])
	    ], MdMenuTrigger);
	    return MdMenuTrigger;
	}());
	
	var __decorate$67 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$67 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdMenuModule = (function () {
	    function MdMenuModule() {
	    }
	    /** @deprecated */
	    MdMenuModule.forRoot = function () {
	        return {
	            ngModule: MdMenuModule,
	            providers: [],
	        };
	    };
	    MdMenuModule = __decorate$67([
	        _angular_core.NgModule({
	            imports: [OverlayModule, _angular_common.CommonModule, MdRippleModule, CompatibilityModule],
	            exports: [MdMenu, MdMenuItem, MdMenuTrigger, CompatibilityModule],
	            declarations: [MdMenu, MdMenuItem, MdMenuTrigger],
	        }), 
	        __metadata$67('design:paramtypes', [])
	    ], MdMenuModule);
	    return MdMenuModule;
	}());
	
	// TODO(jelbourn): resizing
	// TODO(jelbourn): afterOpen and beforeClose
	/**
	 * Reference to a dialog opened via the MdDialog service.
	 */
	var MdDialogRef = (function () {
	    function MdDialogRef(_overlayRef, config) {
	        this._overlayRef = _overlayRef;
	        this.config = config;
	        /** Subject for notifying the user that the dialog has finished closing. */
	        this._afterClosed = new rxjs_Subject.Subject();
	    }
	    /**
	     * Close the dialog.
	     * @param dialogResult Optional result to return to the dialog opener.
	     */
	    MdDialogRef.prototype.close = function (dialogResult) {
	        this._overlayRef.dispose();
	        this._afterClosed.next(dialogResult);
	        this._afterClosed.complete();
	    };
	    /**
	     * Gets an observable that is notified when the dialog is finished closing.
	     */
	    MdDialogRef.prototype.afterClosed = function () {
	        return this._afterClosed.asObservable();
	    };
	    return MdDialogRef;
	}());
	
	var MD_DIALOG_DATA = new _angular_core.OpaqueToken('MdDialogData');
	/** Custom injector type specifically for instantiating components with a dialog. */
	var DialogInjector = (function () {
	    function DialogInjector(_parentInjector, _dialogRef, _data) {
	        this._parentInjector = _parentInjector;
	        this._dialogRef = _dialogRef;
	        this._data = _data;
	    }
	    DialogInjector.prototype.get = function (token, notFoundValue) {
	        if (token === MdDialogRef) {
	            return this._dialogRef;
	        }
	        if (token === MD_DIALOG_DATA && this._data) {
	            return this._data;
	        }
	        return this._parentInjector.get(token, notFoundValue);
	    };
	    return DialogInjector;
	}());
	
	/**
	 * Configuration for opening a modal dialog with the MdDialog service.
	 */
	var MdDialogConfig = (function () {
	    function MdDialogConfig() {
	        /** The ARIA role of the dialog element. */
	        this.role = 'dialog';
	        /** Whether the user can use escape or clicking outside to close a modal. */
	        this.disableClose = false;
	        /** Width of the dialog. */
	        this.width = '';
	        /** Height of the dialog. */
	        this.height = '';
	    }
	    return MdDialogConfig;
	}());
	
	var __extends$23 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Exception thrown when a ComponentPortal is attached to a DomPortalHost without an origin.
	 * @docs-private
	 */
	var MdDialogContentAlreadyAttachedError = (function (_super) {
	    __extends$23(MdDialogContentAlreadyAttachedError, _super);
	    function MdDialogContentAlreadyAttachedError() {
	        _super.call(this, 'Attempting to attach dialog content after content is already attached');
	    }
	    return MdDialogContentAlreadyAttachedError;
	}(MdError));
	
	var __extends$22 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate$73 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$73 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Internal component that wraps user-provided dialog content.
	 * @docs-private
	 */
	var MdDialogContainer = (function (_super) {
	    __extends$22(MdDialogContainer, _super);
	    function MdDialogContainer(_ngZone, _renderer) {
	        _super.call(this);
	        this._ngZone = _ngZone;
	        this._renderer = _renderer;
	        /** Element that was focused before the dialog was opened. Save this to restore upon close. */
	        this._elementFocusedBeforeDialogWasOpened = null;
	    }
	    /**
	     * Attach a ComponentPortal as content to this dialog container.
	     * @param portal Portal to be attached as the dialog content.
	     */
	    MdDialogContainer.prototype.attachComponentPortal = function (portal) {
	        if (this._portalHost.hasAttached()) {
	            throw new MdDialogContentAlreadyAttachedError();
	        }
	        var attachResult = this._portalHost.attachComponentPortal(portal);
	        this._trapFocus();
	        return attachResult;
	    };
	    /**
	     * Attach a TemplatePortal as content to this dialog container.
	     * @param portal Portal to be attached as the dialog content.
	     */
	    MdDialogContainer.prototype.attachTemplatePortal = function (portal) {
	        if (this._portalHost.hasAttached()) {
	            throw new MdDialogContentAlreadyAttachedError();
	        }
	        var attachedResult = this._portalHost.attachTemplatePortal(portal);
	        this._trapFocus();
	        return attachedResult;
	    };
	    /**
	     * Moves the focus inside the focus trap.
	     * @private
	     */
	    MdDialogContainer.prototype._trapFocus = function () {
	        var _this = this;
	        // If were to attempt to focus immediately, then the content of the dialog would not yet be
	        // ready in instances where change detection has to run first. To deal with this, we simply
	        // wait for the microtask queue to be empty.
	        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	            _this._elementFocusedBeforeDialogWasOpened = document.activeElement;
	            _this._focusTrap.focusFirstTabbableElement();
	        });
	    };
	    MdDialogContainer.prototype.ngOnDestroy = function () {
	        var _this = this;
	        // When the dialog is destroyed, return focus to the element that originally had it before
	        // the dialog was opened. Wait for the DOM to finish settling before changing the focus so
	        // that it doesn't end up back on the <body>. Also note that we need the extra check, because
	        // IE can set the `activeElement` to null in some cases.
	        if (this._elementFocusedBeforeDialogWasOpened) {
	            this._ngZone.onMicrotaskEmpty.first().subscribe(function () {
	                _this._renderer.invokeElementMethod(_this._elementFocusedBeforeDialogWasOpened, 'focus');
	            });
	        }
	    };
	    __decorate$73([
	        _angular_core.ViewChild(PortalHostDirective), 
	        __metadata$73('design:type', PortalHostDirective)
	    ], MdDialogContainer.prototype, "_portalHost", void 0);
	    __decorate$73([
	        _angular_core.ViewChild(FocusTrap), 
	        __metadata$73('design:type', FocusTrap)
	    ], MdDialogContainer.prototype, "_focusTrap", void 0);
	    MdDialogContainer = __decorate$73([
	        _angular_core.Component({selector: 'md-dialog-container, mat-dialog-container',
	            template: "<cdk-focus-trap><template cdkPortalHost></template></cdk-focus-trap>",
	            styles: [".mat-dialog-container{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);display:block;padding:24px;border-radius:2px;box-sizing:border-box;overflow:auto;max-width:80vw;width:100%;height:100%}@media screen and (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto}.mat-dialog-title{font-size:20px;font-weight:700;margin:0 0 20px;display:block}.mat-dialog-actions{padding:12px 0;display:flex}.mat-dialog-actions:last-child{margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}"],
	            host: {
	                '[class.mat-dialog-container]': 'true',
	                '[attr.role]': 'dialogConfig?.role',
	            },
	            encapsulation: _angular_core.ViewEncapsulation.None,
	        }), 
	        __metadata$73('design:paramtypes', [_angular_core.NgZone, _angular_core.Renderer])
	    ], MdDialogContainer);
	    return MdDialogContainer;
	}(BasePortalHost));
	
	var __decorate$72 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$72 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$17 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	// TODO(jelbourn): animations
	/**
	 * Service to open Material Design modal dialogs.
	 */
	var MdDialog = (function () {
	    function MdDialog(_overlay, _injector, _parentDialog) {
	        this._overlay = _overlay;
	        this._injector = _injector;
	        this._parentDialog = _parentDialog;
	        this._openDialogsAtThisLevel = [];
	        this._afterAllClosedAtThisLevel = new rxjs_Subject.Subject();
	        this._afterOpenAtThisLevel = new rxjs_Subject.Subject();
	        this._boundKeydown = this._handleKeydown.bind(this);
	        /** Gets an observable that is notified when a dialog has been opened. */
	        this.afterOpen = this._afterOpen.asObservable();
	        /** Gets an observable that is notified when all open dialog have finished closing. */
	        this.afterAllClosed = this._afterAllClosed.asObservable();
	    }
	    Object.defineProperty(MdDialog.prototype, "_openDialogs", {
	        /** Keeps track of the currently-open dialogs. */
	        get: function () {
	            return this._parentDialog ? this._parentDialog._openDialogs : this._openDialogsAtThisLevel;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdDialog.prototype, "_afterOpen", {
	        /** Subject for notifying the user that all open dialogs have finished closing. */
	        get: function () {
	            return this._parentDialog ? this._parentDialog._afterOpen : this._afterOpenAtThisLevel;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdDialog.prototype, "_afterAllClosed", {
	        /** Subject for notifying the user that a dialog has opened. */
	        get: function () {
	            return this._parentDialog ?
	                this._parentDialog._afterAllClosed : this._afterAllClosedAtThisLevel;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Opens a modal dialog containing the given component.
	     * @param componentOrTemplateRef Type of the component to load into the dialog,
	     *     or a TemplateRef to instantiate as the dialog content.
	     * @param config Extra configuration options.
	     * @returns Reference to the newly-opened dialog.
	     */
	    MdDialog.prototype.open = function (componentOrTemplateRef, config) {
	        var _this = this;
	        config = _applyConfigDefaults$1(config);
	        var overlayRef = this._createOverlay(config);
	        var dialogContainer = this._attachDialogContainer(overlayRef, config);
	        var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
	        if (!this._openDialogs.length && !this._parentDialog) {
	            document.addEventListener('keydown', this._boundKeydown);
	        }
	        this._openDialogs.push(dialogRef);
	        dialogRef.afterClosed().subscribe(function () { return _this._removeOpenDialog(dialogRef); });
	        this._afterOpen.next(dialogRef);
	        return dialogRef;
	    };
	    /**
	     * Closes all of the currently-open dialogs.
	     */
	    MdDialog.prototype.closeAll = function () {
	        var i = this._openDialogs.length;
	        while (i--) {
	            // The `_openDialogs` property isn't updated after close until the rxjs subscription
	            // runs on the next microtask, in addition to modifying the array as we're going
	            // through it. We loop through all of them and call close without assuming that
	            // they'll be removed from the list instantaneously.
	            this._openDialogs[i].close();
	        }
	    };
	    /**
	     * Creates the overlay into which the dialog will be loaded.
	     * @param dialogConfig The dialog configuration.
	     * @returns A promise resolving to the OverlayRef for the created overlay.
	     */
	    MdDialog.prototype._createOverlay = function (dialogConfig) {
	        var overlayState = this._getOverlayState(dialogConfig);
	        return this._overlay.create(overlayState);
	    };
	    /**
	     * Attaches an MdDialogContainer to a dialog's already-created overlay.
	     * @param overlay Reference to the dialog's underlying overlay.
	     * @param config The dialog configuration.
	     * @returns A promise resolving to a ComponentRef for the attached container.
	     */
	    MdDialog.prototype._attachDialogContainer = function (overlay, config) {
	        var viewContainer = config ? config.viewContainerRef : null;
	        var containerPortal = new ComponentPortal(MdDialogContainer, viewContainer);
	        var containerRef = overlay.attach(containerPortal);
	        containerRef.instance.dialogConfig = config;
	        return containerRef.instance;
	    };
	    /**
	     * Attaches the user-provided component to the already-created MdDialogContainer.
	     * @param componentOrTemplateRef The type of component being loaded into the dialog,
	     *     or a TemplateRef to instantiate as the content.
	     * @param dialogContainer Reference to the wrapping MdDialogContainer.
	     * @param overlayRef Reference to the overlay in which the dialog resides.
	     * @param config The dialog configuration.
	     * @returns A promise resolving to the MdDialogRef that should be returned to the user.
	     */
	    MdDialog.prototype._attachDialogContent = function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
	        // Create a reference to the dialog we're creating in order to give the user a handle
	        // to modify and close it.
	        var dialogRef = new MdDialogRef(overlayRef, config);
	        if (!config.disableClose) {
	            // When the dialog backdrop is clicked, we want to close it.
	            overlayRef.backdropClick().first().subscribe(function () { return dialogRef.close(); });
	        }
	        // Set the dialogRef to the container so that it can use the ref to close the dialog.
	        dialogContainer.dialogRef = dialogRef;
	        // We create an injector specifically for the component we're instantiating so that it can
	        // inject the MdDialogRef. This allows a component loaded inside of a dialog to close itself
	        // and, optionally, to return a value.
	        var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
	        var dialogInjector = new DialogInjector(userInjector || this._injector, dialogRef, config.data);
	        if (componentOrTemplateRef instanceof _angular_core.TemplateRef) {
	            dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null));
	        }
	        else {
	            var contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, null, dialogInjector));
	            dialogRef.componentInstance = contentRef.instance;
	        }
	        return dialogRef;
	    };
	    /**
	     * Creates an overlay state from a dialog config.
	     * @param dialogConfig The dialog configuration.
	     * @returns The overlay configuration.
	     */
	    MdDialog.prototype._getOverlayState = function (dialogConfig) {
	        var state$$1 = new OverlayState();
	        var strategy = this._overlay.position().global();
	        var position = dialogConfig.position;
	        state$$1.hasBackdrop = true;
	        state$$1.positionStrategy = strategy;
	        if (position && (position.left || position.right)) {
	            position.left ? strategy.left(position.left) : strategy.right(position.right);
	        }
	        else {
	            strategy.centerHorizontally();
	        }
	        if (position && (position.top || position.bottom)) {
	            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
	        }
	        else {
	            strategy.centerVertically();
	        }
	        strategy.width(dialogConfig.width).height(dialogConfig.height);
	        return state$$1;
	    };
	    /**
	     * Removes a dialog from the array of open dialogs.
	     * @param dialogRef Dialog to be removed.
	     */
	    MdDialog.prototype._removeOpenDialog = function (dialogRef) {
	        var index = this._openDialogs.indexOf(dialogRef);
	        if (index > -1) {
	            this._openDialogs.splice(index, 1);
	            // no open dialogs are left, call next on afterAllClosed Subject
	            if (!this._openDialogs.length) {
	                this._afterAllClosed.next();
	                document.removeEventListener('keydown', this._boundKeydown);
	            }
	        }
	    };
	    /**
	     * Handles global key presses while there are open dialogs. Closes the
	     * top dialog when the user presses escape.
	     */
	    MdDialog.prototype._handleKeydown = function (event) {
	        var topDialog = this._openDialogs[this._openDialogs.length - 1];
	        if (event.keyCode === ESCAPE && topDialog && !topDialog.config.disableClose) {
	            topDialog.close();
	        }
	    };
	    MdDialog = __decorate$72([
	        _angular_core.Injectable(),
	        __param$17(2, _angular_core.Optional()),
	        __param$17(2, _angular_core.SkipSelf()), 
	        __metadata$72('design:paramtypes', [Overlay, _angular_core.Injector, MdDialog])
	    ], MdDialog);
	    return MdDialog;
	}());
	/**
	 * Applies default options to the dialog config.
	 * @param dialogConfig Config to be modified.
	 * @returns The new configuration object.
	 */
	function _applyConfigDefaults$1(dialogConfig) {
	    return extendObject(new MdDialogConfig(), dialogConfig);
	}
	
	var __decorate$74 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$74 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Button that will close the current dialog.
	 */
	var MdDialogClose = (function () {
	    function MdDialogClose(dialogRef) {
	        this.dialogRef = dialogRef;
	        /** Screenreader label for the button. */
	        this.ariaLabel = 'Close dialog';
	    }
	    __decorate$74([
	        _angular_core.Input('aria-label'), 
	        __metadata$74('design:type', String)
	    ], MdDialogClose.prototype, "ariaLabel", void 0);
	    MdDialogClose = __decorate$74([
	        _angular_core.Directive({
	            selector: 'button[md-dialog-close], button[mat-dialog-close]',
	            host: {
	                '(click)': 'dialogRef.close()',
	                '[attr.aria-label]': 'ariaLabel',
	                'type': 'button',
	            }
	        }), 
	        __metadata$74('design:paramtypes', [MdDialogRef])
	    ], MdDialogClose);
	    return MdDialogClose;
	}());
	/**
	 * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
	 */
	var MdDialogTitle = (function () {
	    function MdDialogTitle() {
	    }
	    MdDialogTitle = __decorate$74([
	        _angular_core.Directive({
	            selector: '[md-dialog-title], [mat-dialog-title]',
	            host: {
	                '[class.mat-dialog-title]': 'true'
	            }
	        }), 
	        __metadata$74('design:paramtypes', [])
	    ], MdDialogTitle);
	    return MdDialogTitle;
	}());
	/**
	 * Scrollable content container of a dialog.
	 */
	var MdDialogContent = (function () {
	    function MdDialogContent() {
	    }
	    MdDialogContent = __decorate$74([
	        _angular_core.Directive({
	            selector: '[md-dialog-content], md-dialog-content, [mat-dialog-content], mat-dialog-content',
	            host: {
	                '[class.mat-dialog-content]': 'true'
	            }
	        }), 
	        __metadata$74('design:paramtypes', [])
	    ], MdDialogContent);
	    return MdDialogContent;
	}());
	/**
	 * Container for the bottom action buttons in a dialog.
	 * Stays fixed to the bottom when scrolling.
	 */
	var MdDialogActions = (function () {
	    function MdDialogActions() {
	    }
	    MdDialogActions = __decorate$74([
	        _angular_core.Directive({
	            selector: '[md-dialog-actions], md-dialog-actions, [mat-dialog-actions], mat-dialog-actions',
	            host: {
	                '[class.mat-dialog-actions]': 'true'
	            }
	        }), 
	        __metadata$74('design:paramtypes', [])
	    ], MdDialogActions);
	    return MdDialogActions;
	}());
	
	var __decorate$71 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$71 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdDialogModule = (function () {
	    function MdDialogModule() {
	    }
	    /** @deprecated */
	    MdDialogModule.forRoot = function () {
	        return {
	            ngModule: MdDialogModule,
	            providers: [],
	        };
	    };
	    MdDialogModule = __decorate$71([
	        _angular_core.NgModule({
	            imports: [
	                OverlayModule,
	                PortalModule,
	                A11yModule,
	                CompatibilityModule,
	            ],
	            exports: [
	                MdDialogContainer,
	                MdDialogClose,
	                MdDialogTitle,
	                MdDialogContent,
	                MdDialogActions,
	                CompatibilityModule,
	            ],
	            declarations: [
	                MdDialogContainer,
	                MdDialogClose,
	                MdDialogTitle,
	                MdDialogActions,
	                MdDialogContent,
	            ],
	            providers: [
	                MdDialog,
	            ],
	            entryComponents: [MdDialogContainer],
	        }), 
	        __metadata$71('design:paramtypes', [])
	    ], MdDialogModule);
	    return MdDialogModule;
	}());
	
	var __decorate$76 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$76 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	/**
	 * Autocomplete IDs need to be unique across components, so this counter exists outside of
	 * the component definition.
	 */
	var _uniqueAutocompleteIdCounter = 0;
	var MdAutocomplete = (function () {
	    function MdAutocomplete() {
	        /** Whether the autocomplete panel displays above or below its trigger. */
	        this.positionY = 'below';
	        /** Whether the autocomplete panel should be visible, depending on option length. */
	        this.showPanel = false;
	        /** Unique ID to be used by autocomplete trigger's "aria-owns" property. */
	        this.id = "md-autocomplete-" + _uniqueAutocompleteIdCounter++;
	    }
	    /**
	     * Sets the panel scrollTop. This allows us to manually scroll to display
	     * options below the fold, as they are not actually being focused when active.
	     */
	    MdAutocomplete.prototype._setScrollTop = function (scrollTop) {
	        if (this.panel) {
	            this.panel.nativeElement.scrollTop = scrollTop;
	        }
	    };
	    /** Panel should hide itself when the option list is empty. */
	    MdAutocomplete.prototype._setVisibility = function () {
	        var _this = this;
	        Promise.resolve().then(function () { return _this.showPanel = !!_this.options.length; });
	    };
	    /** Sets a class on the panel based on its position (used to set y-offset). */
	    MdAutocomplete.prototype._getClassList = function () {
	        return {
	            'mat-autocomplete-panel-below': this.positionY === 'below',
	            'mat-autocomplete-panel-above': this.positionY === 'above',
	            'mat-autocomplete-visible': this.showPanel,
	            'mat-autocomplete-hidden': !this.showPanel
	        };
	    };
	    __decorate$76([
	        _angular_core.ViewChild(_angular_core.TemplateRef), 
	        __metadata$76('design:type', _angular_core.TemplateRef)
	    ], MdAutocomplete.prototype, "template", void 0);
	    __decorate$76([
	        _angular_core.ViewChild('panel'), 
	        __metadata$76('design:type', _angular_core.ElementRef)
	    ], MdAutocomplete.prototype, "panel", void 0);
	    __decorate$76([
	        _angular_core.ContentChildren(MdOption), 
	        __metadata$76('design:type', _angular_core.QueryList)
	    ], MdAutocomplete.prototype, "options", void 0);
	    __decorate$76([
	        _angular_core.Input(), 
	        __metadata$76('design:type', Function)
	    ], MdAutocomplete.prototype, "displayWith", void 0);
	    MdAutocomplete = __decorate$76([
	        _angular_core.Component({selector: 'md-autocomplete, mat-autocomplete',
	            template: "<template><div class=\"mat-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_getClassList()\" #panel><ng-content></ng-content></div></template>",
	            styles: [".mat-autocomplete-panel{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-height:256px;position:relative}.mat-autocomplete-panel.mat-autocomplete-panel-below{top:6px}.mat-autocomplete-panel.mat-autocomplete-panel-above{top:-24px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}"],
	            encapsulation: _angular_core.ViewEncapsulation.None,
	            exportAs: 'mdAutocomplete',
	            host: {
	                '[class.mat-autocomplete]': 'true'
	            }
	        }), 
	        __metadata$76('design:paramtypes', [])
	    ], MdAutocomplete);
	    return MdAutocomplete;
	}());
	
	var __extends$24 = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ActiveDescendantKeyManager = (function (_super) {
	    __extends$24(ActiveDescendantKeyManager, _super);
	    function ActiveDescendantKeyManager(items) {
	        _super.call(this, items);
	    }
	    /**
	     * This method sets the active item to the item at the specified index.
	     * It also adds active styles to the newly active item and removes active
	     * styles from the previously active item.
	     */
	    ActiveDescendantKeyManager.prototype.setActiveItem = function (index) {
	        if (this.activeItem) {
	            this.activeItem.setInactiveStyles();
	        }
	        _super.prototype.setActiveItem.call(this, index);
	        if (this.activeItem) {
	            this.activeItem.setActiveStyles();
	        }
	    };
	    return ActiveDescendantKeyManager;
	}(ListKeyManager));
	
	var __decorate$77 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$77 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param$18 = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	/**
	 * The following style constants are necessary to save here in order
	 * to properly calculate the scrollTop of the panel. Because we are not
	 * actually focusing the active item, scroll must be handled manually.
	 */
	/** The height of each autocomplete option. */
	var AUTOCOMPLETE_OPTION_HEIGHT = 48;
	/** The total height of the autocomplete panel. */
	var AUTOCOMPLETE_PANEL_HEIGHT = 256;
	/**
	 * Provider that allows the autocomplete to register as a ControlValueAccessor.
	 * @docs-private
	 */
	var MD_AUTOCOMPLETE_VALUE_ACCESSOR = {
	    provide: _angular_forms.NG_VALUE_ACCESSOR,
	    useExisting: _angular_core.forwardRef(function () { return MdAutocompleteTrigger; }),
	    multi: true
	};
	var MdAutocompleteTrigger = (function () {
	    function MdAutocompleteTrigger(_element, _overlay, _viewContainerRef, _dir, _zone, _inputContainer) {
	        this._element = _element;
	        this._overlay = _overlay;
	        this._viewContainerRef = _viewContainerRef;
	        this._dir = _dir;
	        this._zone = _zone;
	        this._inputContainer = _inputContainer;
	        this._panelOpen = false;
	        /** Stream of blur events that should close the panel. */
	        this._blurStream = new rxjs_Subject.Subject();
	        /** View -> model callback called when value changes */
	        this._onChange = function (value) { };
	        /** View -> model callback called when autocomplete has been touched */
	        this._onTouched = function () { };
	    }
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "_matAutocomplete", {
	        /** Property with mat- prefix for no-conflict mode. */
	        get: function () {
	            return this.autocomplete;
	        },
	        set: function (autocomplete) {
	            this.autocomplete = autocomplete;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MdAutocompleteTrigger.prototype.ngAfterContentInit = function () {
	        this._keyManager = new ActiveDescendantKeyManager(this.autocomplete.options).withWrap();
	    };
	    MdAutocompleteTrigger.prototype.ngOnDestroy = function () {
	        if (this._panelPositionSubscription) {
	            this._panelPositionSubscription.unsubscribe();
	        }
	        this._destroyPanel();
	    };
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "panelOpen", {
	        /* Whether or not the autocomplete panel is open. */
	        get: function () {
	            return this._panelOpen;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** Opens the autocomplete suggestion panel. */
	    MdAutocompleteTrigger.prototype.openPanel = function () {
	        if (!this._overlayRef) {
	            this._createOverlay();
	        }
	        if (!this._overlayRef.hasAttached()) {
	            this._overlayRef.attach(this._portal);
	            this._subscribeToClosingActions();
	        }
	        this._panelOpen = true;
	        this._floatPlaceholder('always');
	    };
	    /** Closes the autocomplete suggestion panel. */
	    MdAutocompleteTrigger.prototype.closePanel = function () {
	        if (this._overlayRef && this._overlayRef.hasAttached()) {
	            this._overlayRef.detach();
	        }
	        this._panelOpen = false;
	        this._floatPlaceholder('auto');
	    };
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "panelClosingActions", {
	        /**
	         * A stream of actions that should close the autocomplete panel, including
	         * when an option is selected, on blur, and when TAB is pressed.
	         */
	        get: function () {
	            return rxjs_Observable.Observable.merge.apply(rxjs_Observable.Observable, this.optionSelections.concat([this._blurStream.asObservable(), this._keyManager.tabOut]));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "optionSelections", {
	        /** Stream of autocomplete option selections. */
	        get: function () {
	            return this.autocomplete.options.map(function (option) { return option.onSelect; });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MdAutocompleteTrigger.prototype, "activeOption", {
	        /** The currently active option, coerced to MdOption type. */
	        get: function () {
	            return this._keyManager.activeItem;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the autocomplete's value. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param value New value to be written to the model.
	     */
	    MdAutocompleteTrigger.prototype.writeValue = function (value) {
	        var _this = this;
	        Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });
	    };
	    /**
	     * Saves a callback function to be invoked when the autocomplete's value
	     * changes from user input. Part of the ControlValueAccessor interface
	     * required to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the value changes.
	     */
	    MdAutocompleteTrigger.prototype.registerOnChange = function (fn) {
	        this._onChange = fn;
	    };
	    /**
	     * Saves a callback function to be invoked when the autocomplete is blurred
	     * by the user. Part of the ControlValueAccessor interface required
	     * to integrate with Angular's core forms API.
	     *
	     * @param fn Callback to be triggered when the component has been touched.
	     */
	    MdAutocompleteTrigger.prototype.registerOnTouched = function (fn) {
	        this._onTouched = fn;
	    };
	    MdAutocompleteTrigger.prototype._handleKeydown = function (event) {
	        if (this.activeOption && event.keyCode === ENTER) {
	            this.activeOption._selectViaInteraction();
	        }
	        else {
	            this._keyManager.onKeydown(event);
	            if (event.keyCode === UP_ARROW || event.keyCode === DOWN_ARROW) {
	                this.openPanel();
	                this._scrollToOption();
	            }
	        }
	    };
	    MdAutocompleteTrigger.prototype._handleInput = function (value) {
	        this._onChange(value);
	        this.openPanel();
	    };
	    MdAutocompleteTrigger.prototype._handleBlur = function (newlyFocusedTag) {
	        this._onTouched();
	        // Only emit blur event if the new focus is *not* on an option.
	        if (newlyFocusedTag !== 'MD-OPTION') {
	            this._blurStream.next(null);
	        }
	    };
	    /**
	     * In "auto" mode, the placeholder will animate down as soon as focus is lost.
	     * This causes the value to jump when selecting an option with the mouse.
	     * This method manually floats the placeholder until the panel can be closed.
	     */
	    MdAutocompleteTrigger.prototype._floatPlaceholder = function (state$$1) {
	        if (this._inputContainer) {
	            this._inputContainer.floatPlaceholder = state$$1;
	        }
	    };
	    /**
	     * Given that we are not actually focusing active options, we must manually adjust scroll
	     * to reveal options below the fold. First, we find the offset of the option from the top
	     * of the panel. The new scrollTop will be that offset - the panel height + the option
	     * height, so the active option will be just visible at the bottom of the panel.
	     */
	    MdAutocompleteTrigger.prototype._scrollToOption = function () {
	        var optionOffset = this._keyManager.activeItemIndex * AUTOCOMPLETE_OPTION_HEIGHT;
	        var newScrollTop = Math.max(0, optionOffset - AUTOCOMPLETE_PANEL_HEIGHT + AUTOCOMPLETE_OPTION_HEIGHT);
	        this.autocomplete._setScrollTop(newScrollTop);
	    };
	    /**
	     * This method listens to a stream of panel closing actions and resets the
	     * stream every time the option list changes.
	     */
	    MdAutocompleteTrigger.prototype._subscribeToClosingActions = function () {
	        var _this = this;
	        // When the zone is stable initially, and when the option list changes...
	        rxjs_Observable.Observable.merge(this._zone.onStable.first(), this.autocomplete.options.changes)
	            .switchMap(function () {
	            _this._resetPanel();
	            return _this.panelClosingActions;
	        })
	            .first()
	            .subscribe(function (event) { return _this._setValueAndClose(event); });
	    };
	    /** Destroys the autocomplete suggestion panel. */
	    MdAutocompleteTrigger.prototype._destroyPanel = function () {
	        if (this._overlayRef) {
	            this.closePanel();
	            this._overlayRef.dispose();
	            this._overlayRef = null;
	        }
	    };
	    MdAutocompleteTrigger.prototype._setTriggerValue = function (value) {
	        this._element.nativeElement.value =
	            this.autocomplete.displayWith ? this.autocomplete.displayWith(value) : value;
	    };
	    /**
	    * This method closes the panel, and if a value is specified, also sets the associated
	    * control to that value. It will also mark the control as dirty if this interaction
	    * stemmed from the user.
	    */
	    MdAutocompleteTrigger.prototype._setValueAndClose = function (event) {
	        if (event) {
	            this._setTriggerValue(event.source.value);
	            this._onChange(event.source.value);
	        }
	        this.closePanel();
	    };
	    MdAutocompleteTrigger.prototype._createOverlay = function () {
	        this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);
	        this._overlayRef = this._overlay.create(this._getOverlayConfig());
	    };
	    MdAutocompleteTrigger.prototype._getOverlayConfig = function () {
	        var overlayState = new OverlayState();
	        overlayState.positionStrategy = this._getOverlayPosition();
	        overlayState.width = this._getHostWidth();
	        overlayState.direction = this._dir ? this._dir.value : 'ltr';
	        return overlayState;
	    };
	    MdAutocompleteTrigger.prototype._getOverlayPosition = function () {
	        this._positionStrategy = this._overlay.position().connectedTo(this._element, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
	            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' });
	        this._subscribeToPositionChanges(this._positionStrategy);
	        return this._positionStrategy;
	    };
	    /**
	     * This method subscribes to position changes in the autocomplete panel, so the panel's
	     * y-offset can be adjusted to match the new position.
	     */
	    MdAutocompleteTrigger.prototype._subscribeToPositionChanges = function (strategy) {
	        var _this = this;
	        this._panelPositionSubscription = strategy.onPositionChange.subscribe(function (change) {
	            _this.autocomplete.positionY = change.connectionPair.originY === 'top' ? 'above' : 'below';
	        });
	    };
	    /** Returns the width of the input element, so the panel width can match it. */
	    MdAutocompleteTrigger.prototype._getHostWidth = function () {
	        return this._element.nativeElement.getBoundingClientRect().width;
	    };
	    /** Reset active item to null so arrow events will activate the correct options.*/
	    MdAutocompleteTrigger.prototype._resetActiveItem = function () {
	        this._keyManager.setActiveItem(null);
	    };
	    /**
	     * Resets the active item and re-calculates alignment of the panel in case its size
	     * has changed due to fewer or greater number of options.
	     */
	    MdAutocompleteTrigger.prototype._resetPanel = function () {
	        this._resetActiveItem();
	        this._positionStrategy.recalculateLastPosition();
	        this.autocomplete._setVisibility();
	    };
	    __decorate$77([
	        _angular_core.Input('mdAutocomplete'), 
	        __metadata$77('design:type', MdAutocomplete)
	    ], MdAutocompleteTrigger.prototype, "autocomplete", void 0);
	    __decorate$77([
	        _angular_core.Input('matAutocomplete'), 
	        __metadata$77('design:type', MdAutocomplete)
	    ], MdAutocompleteTrigger.prototype, "_matAutocomplete", null);
	    MdAutocompleteTrigger = __decorate$77([
	        _angular_core.Directive({
	            selector: 'input[mdAutocomplete], input[matAutocomplete]',
	            host: {
	                'role': 'combobox',
	                'autocomplete': 'off',
	                'aria-autocomplete': 'list',
	                'aria-multiline': 'false',
	                '[attr.aria-activedescendant]': 'activeOption?.id',
	                '[attr.aria-expanded]': 'panelOpen.toString()',
	                '[attr.aria-owns]': 'autocomplete?.id',
	                '(focus)': 'openPanel()',
	                '(blur)': '_handleBlur($event.relatedTarget?.tagName)',
	                '(input)': '_handleInput($event.target.value)',
	                '(keydown)': '_handleKeydown($event)',
	            },
	            providers: [MD_AUTOCOMPLETE_VALUE_ACCESSOR]
	        }),
	        __param$18(3, _angular_core.Optional()),
	        __param$18(5, _angular_core.Optional()),
	        __param$18(5, _angular_core.Host()), 
	        __metadata$77('design:paramtypes', [_angular_core.ElementRef, Overlay, _angular_core.ViewContainerRef, Dir, _angular_core.NgZone, MdInputContainer])
	    ], MdAutocompleteTrigger);
	    return MdAutocompleteTrigger;
	}());
	
	var __decorate$75 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$75 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MdAutocompleteModule = (function () {
	    function MdAutocompleteModule() {
	    }
	    /** @deprecated */
	    MdAutocompleteModule.forRoot = function () {
	        return {
	            ngModule: MdAutocompleteModule,
	            providers: [OVERLAY_PROVIDERS]
	        };
	    };
	    MdAutocompleteModule = __decorate$75([
	        _angular_core.NgModule({
	            imports: [MdOptionModule, OverlayModule, CompatibilityModule, _angular_common.CommonModule],
	            exports: [MdAutocomplete, MdOptionModule, MdAutocompleteTrigger, CompatibilityModule],
	            declarations: [MdAutocomplete, MdAutocompleteTrigger],
	        }), 
	        __metadata$75('design:paramtypes', [])
	    ], MdAutocompleteModule);
	    return MdAutocompleteModule;
	}());
	
	var __decorate$30 = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata$30 = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var MATERIAL_MODULES = [
	    MdAutocompleteModule,
	    MdButtonModule,
	    MdButtonToggleModule,
	    MdCardModule,
	    MdChipsModule,
	    MdCheckboxModule,
	    MdDialogModule,
	    MdGridListModule,
	    MdIconModule,
	    MdInputModule,
	    MdListModule,
	    MdMenuModule,
	    MdProgressBarModule,
	    MdProgressSpinnerModule,
	    MdRadioModule,
	    MdRippleModule,
	    MdSelectModule,
	    MdSidenavModule,
	    MdSliderModule,
	    MdSlideToggleModule,
	    MdSnackBarModule,
	    MdTabsModule,
	    MdToolbarModule,
	    MdTooltipModule,
	    OverlayModule,
	    PortalModule,
	    RtlModule,
	    StyleModule,
	    A11yModule,
	    PlatformModule,
	    ProjectionModule,
	    CompatibilityModule,
	    ObserveContentModule
	];
	var MaterialRootModule = (function () {
	    function MaterialRootModule() {
	    }
	    MaterialRootModule = __decorate$30([
	        _angular_core.NgModule({
	            imports: [
	                MdAutocompleteModule.forRoot(),
	                MdButtonModule.forRoot(),
	                MdCardModule.forRoot(),
	                MdChipsModule.forRoot(),
	                MdCheckboxModule.forRoot(),
	                MdGridListModule.forRoot(),
	                MdInputModule.forRoot(),
	                MdListModule.forRoot(),
	                MdProgressBarModule.forRoot(),
	                MdProgressSpinnerModule.forRoot(),
	                MdRippleModule.forRoot(),
	                MdSelectModule.forRoot(),
	                MdSidenavModule.forRoot(),
	                MdTabsModule.forRoot(),
	                MdToolbarModule.forRoot(),
	                PortalModule.forRoot(),
	                ProjectionModule.forRoot(),
	                RtlModule.forRoot(),
	                ObserveContentModule.forRoot(),
	                // These modules include providers.
	                A11yModule.forRoot(),
	                MdButtonToggleModule.forRoot(),
	                MdDialogModule.forRoot(),
	                MdIconModule.forRoot(),
	                MdMenuModule.forRoot(),
	                MdRadioModule.forRoot(),
	                MdSliderModule.forRoot(),
	                MdSlideToggleModule.forRoot(),
	                MdSnackBarModule.forRoot(),
	                MdTooltipModule.forRoot(),
	                PlatformModule.forRoot(),
	                OverlayModule.forRoot(),
	                CompatibilityModule.forRoot(),
	            ],
	            exports: MATERIAL_MODULES,
	        }), 
	        __metadata$30('design:paramtypes', [])
	    ], MaterialRootModule);
	    return MaterialRootModule;
	}());
	var MaterialModule = (function () {
	    function MaterialModule() {
	    }
	    /** @deprecated */
	    MaterialModule.forRoot = function () {
	        return { ngModule: MaterialRootModule };
	    };
	    MaterialModule = __decorate$30([
	        _angular_core.NgModule({
	            imports: MATERIAL_MODULES,
	            exports: MATERIAL_MODULES,
	        }), 
	        __metadata$30('design:paramtypes', [])
	    ], MaterialModule);
	    return MaterialModule;
	}());
	
	exports.MdCoreModule = MdCoreModule;
	exports.Dir = Dir;
	exports.RtlModule = RtlModule;
	exports.ObserveContentModule = ObserveContentModule;
	exports.ObserveContent = ObserveContent;
	exports.MdOptionModule = MdOptionModule;
	exports.MdOption = MdOption;
	exports.Portal = Portal;
	exports.BasePortalHost = BasePortalHost;
	exports.ComponentPortal = ComponentPortal;
	exports.TemplatePortal = TemplatePortal;
	exports.PortalHostDirective = PortalHostDirective;
	exports.TemplatePortalDirective = TemplatePortalDirective;
	exports.PortalModule = PortalModule;
	exports.DomPortalHost = DomPortalHost;
	exports.MdPlatform = Platform;
	exports.Overlay = Overlay;
	exports.OVERLAY_PROVIDERS = OVERLAY_PROVIDERS;
	exports.OverlayContainer = OverlayContainer;
	exports.FullscreenOverlayContainer = FullscreenOverlayContainer;
	exports.OverlayRef = OverlayRef;
	exports.OverlayState = OverlayState;
	exports.ConnectedOverlayDirective = ConnectedOverlayDirective;
	exports.OverlayOrigin = OverlayOrigin;
	exports.OverlayModule = OverlayModule;
	exports.ScrollDispatcher = ScrollDispatcher;
	exports.GestureConfig = GestureConfig;
	exports.MdRipple = MdRipple;
	exports.MdRippleModule = MdRippleModule;
	exports.LiveAnnouncer = LiveAnnouncer;
	exports.LIVE_ANNOUNCER_ELEMENT_TOKEN = LIVE_ANNOUNCER_ELEMENT_TOKEN;
	exports.LIVE_ANNOUNCER_PROVIDER = LIVE_ANNOUNCER_PROVIDER;
	exports.MdLiveAnnouncer = LiveAnnouncer;
	exports.FocusTrap = FocusTrap;
	exports.InteractivityChecker = InteractivityChecker;
	exports.isFakeMousedownFromScreenReader = isFakeMousedownFromScreenReader;
	exports.A11yModule = A11yModule;
	exports.UniqueSelectionDispatcher = UniqueSelectionDispatcher;
	exports.UNIQUE_SELECTION_DISPATCHER_PROVIDER = UNIQUE_SELECTION_DISPATCHER_PROVIDER;
	exports.MdUniqueSelectionDispatcher = UniqueSelectionDispatcher;
	exports.MdLineModule = MdLineModule;
	exports.MdLine = MdLine;
	exports.MdLineSetter = MdLineSetter;
	exports.MdError = MdError;
	exports.coerceBooleanProperty = coerceBooleanProperty;
	exports.coerceNumberProperty = coerceNumberProperty;
	exports.CompatibilityModule = CompatibilityModule;
	exports.NoConflictStyleCompatibilityMode = NoConflictStyleCompatibilityMode;
	exports.DomProjectionHost = DomProjectionHost;
	exports.DomProjection = DomProjection;
	exports.ProjectionModule = ProjectionModule;
	exports.PlatformModule = PlatformModule;
	exports.Platform = Platform;
	exports.getSupportedInputTypes = getSupportedInputTypes;
	exports.ConnectedPositionStrategy = ConnectedPositionStrategy;
	exports.ConnectionPositionPair = ConnectionPositionPair;
	exports.ScrollableViewProperties = ScrollableViewProperties;
	exports.ConnectedOverlayPositionChange = ConnectedOverlayPositionChange;
	exports.SelectionModel = SelectionModel;
	exports.SelectionChange = SelectionChange;
	exports.StyleModule = StyleModule;
	exports.TOUCH_BUFFER_MS = TOUCH_BUFFER_MS;
	exports.FocusOriginMonitor = FocusOriginMonitor;
	exports.CdkFocusClasses = CdkFocusClasses;
	exports.FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY = FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY;
	exports.FOCUS_ORIGIN_MONITOR_PROVIDER = FOCUS_ORIGIN_MONITOR_PROVIDER;
	exports.applyCssTransform = applyCssTransform;
	exports.UP_ARROW = UP_ARROW;
	exports.DOWN_ARROW = DOWN_ARROW;
	exports.RIGHT_ARROW = RIGHT_ARROW;
	exports.LEFT_ARROW = LEFT_ARROW;
	exports.PAGE_UP = PAGE_UP;
	exports.PAGE_DOWN = PAGE_DOWN;
	exports.HOME = HOME;
	exports.END = END;
	exports.ENTER = ENTER;
	exports.SPACE = SPACE;
	exports.TAB = TAB;
	exports.ESCAPE = ESCAPE;
	exports.BACKSPACE = BACKSPACE;
	exports.DELETE = DELETE;
	exports.MATERIAL_COMPATIBILITY_MODE = MATERIAL_COMPATIBILITY_MODE;
	exports.MAT_ELEMENTS_SELECTOR = MAT_ELEMENTS_SELECTOR;
	exports.MD_ELEMENTS_SELECTOR = MD_ELEMENTS_SELECTOR;
	exports.MatPrefixRejector = MatPrefixRejector;
	exports.MdPrefixRejector = MdPrefixRejector;
	exports.AnimationCurves = AnimationCurves;
	exports.AnimationDurations = AnimationDurations;
	exports.MdSelectionModule = MdSelectionModule;
	exports.MdPseudoCheckbox = MdPseudoCheckbox;
	exports.MaterialRootModule = MaterialRootModule;
	exports.MaterialModule = MaterialModule;
	exports.MdAutocompleteModule = MdAutocompleteModule;
	exports.MdAutocomplete = MdAutocomplete;
	exports.AUTOCOMPLETE_OPTION_HEIGHT = AUTOCOMPLETE_OPTION_HEIGHT;
	exports.AUTOCOMPLETE_PANEL_HEIGHT = AUTOCOMPLETE_PANEL_HEIGHT;
	exports.MD_AUTOCOMPLETE_VALUE_ACCESSOR = MD_AUTOCOMPLETE_VALUE_ACCESSOR;
	exports.MdAutocompleteTrigger = MdAutocompleteTrigger;
	exports.MdButtonCssMatStyler = MdButtonCssMatStyler;
	exports.MdRaisedButtonCssMatStyler = MdRaisedButtonCssMatStyler;
	exports.MdIconButtonCssMatStyler = MdIconButtonCssMatStyler;
	exports.MdFabCssMatStyler = MdFabCssMatStyler;
	exports.MdMiniFabCssMatStyler = MdMiniFabCssMatStyler;
	exports.MdButton = MdButton;
	exports.MdAnchor = MdAnchor;
	exports.MdButtonModule = MdButtonModule;
	exports.MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR;
	exports.MdButtonToggleChange = MdButtonToggleChange;
	exports.MdButtonToggleGroup = MdButtonToggleGroup;
	exports.MdButtonToggleGroupMultiple = MdButtonToggleGroupMultiple;
	exports.MdButtonToggle = MdButtonToggle;
	exports.MdButtonToggleModule = MdButtonToggleModule;
	exports.MdCardContent = MdCardContent;
	exports.MdCardTitle = MdCardTitle;
	exports.MdCardSubtitle = MdCardSubtitle;
	exports.MdCardActions = MdCardActions;
	exports.MdCardFooter = MdCardFooter;
	exports.MdCardSmImage = MdCardSmImage;
	exports.MdCardMdImage = MdCardMdImage;
	exports.MdCardLgImage = MdCardLgImage;
	exports.MdCardImage = MdCardImage;
	exports.MdCardXlImage = MdCardXlImage;
	exports.MdCardAvatar = MdCardAvatar;
	exports.MdCard = MdCard;
	exports.MdCardHeader = MdCardHeader;
	exports.MdCardTitleGroup = MdCardTitleGroup;
	exports.MdCardModule = MdCardModule;
	exports.MdChipList = MdChipList;
	exports.MdChipsModule = MdChipsModule;
	exports.MdChip = MdChip;
	exports.MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = MD_CHECKBOX_CONTROL_VALUE_ACCESSOR;
	exports.MdCheckboxChange = MdCheckboxChange;
	exports.MdCheckbox = MdCheckbox;
	exports.MdCheckboxModule = MdCheckboxModule;
	exports.MdDialogModule = MdDialogModule;
	exports.MD_DIALOG_DATA = MD_DIALOG_DATA;
	exports.MdDialog = MdDialog;
	exports.MdDialogContainer = MdDialogContainer;
	exports.MdDialogClose = MdDialogClose;
	exports.MdDialogTitle = MdDialogTitle;
	exports.MdDialogContent = MdDialogContent;
	exports.MdDialogActions = MdDialogActions;
	exports.MdDialogConfig = MdDialogConfig;
	exports.MdDialogRef = MdDialogRef;
	exports.MdGridList = MdGridList;
	exports.MdGridListModule = MdGridListModule;
	exports.MdIconInvalidNameError = MdIconInvalidNameError;
	exports.MdIcon = MdIcon;
	exports.ICON_REGISTRY_PROVIDER_FACTORY = ICON_REGISTRY_PROVIDER_FACTORY;
	exports.ICON_REGISTRY_PROVIDER = ICON_REGISTRY_PROVIDER;
	exports.MdIconModule = MdIconModule;
	exports.MdIconRegistry = MdIconRegistry;
	exports.MdInputModule = MdInputModule;
	exports.MdTextareaAutosize = MdTextareaAutosize;
	exports.MdPlaceholder = MdPlaceholder;
	exports.MdHint = MdHint;
	exports.MdInputDirective = MdInputDirective;
	exports.MdInputContainer = MdInputContainer;
	exports.MdInputContainerPlaceholderConflictError = MdInputContainerPlaceholderConflictError;
	exports.MdInputContainerUnsupportedTypeError = MdInputContainerUnsupportedTypeError;
	exports.MdInputContainerDuplicatedHintError = MdInputContainerDuplicatedHintError;
	exports.MdInputContainerMissingMdInputError = MdInputContainerMissingMdInputError;
	exports.MdListDivider = MdListDivider;
	exports.MdList = MdList;
	exports.MdListCssMatStyler = MdListCssMatStyler;
	exports.MdNavListCssMatStyler = MdNavListCssMatStyler;
	exports.MdDividerCssMatStyler = MdDividerCssMatStyler;
	exports.MdListAvatarCssMatStyler = MdListAvatarCssMatStyler;
	exports.MdListIconCssMatStyler = MdListIconCssMatStyler;
	exports.MdListSubheaderCssMatStyler = MdListSubheaderCssMatStyler;
	exports.MdListItem = MdListItem;
	exports.MdListModule = MdListModule;
	exports.MdMenuTrigger = MdMenuTrigger;
	exports.fadeInItems = fadeInItems;
	exports.transformMenu = transformMenu;
	exports.MdMenu = MdMenu;
	exports.MdMenuItem = MdMenuItem;
	exports.MdMenuModule = MdMenuModule;
	exports.MdProgressBar = MdProgressBar;
	exports.MdProgressBarModule = MdProgressBarModule;
	exports.MdProgressCircle = MdProgressSpinner;
	exports.MdProgressCircleModule = MdProgressSpinnerModule;
	exports.MdProgressSpinnerCssMatStyler = MdProgressSpinnerCssMatStyler;
	exports.MdProgressCircleCssMatStyler = MdProgressCircleCssMatStyler;
	exports.MdProgressSpinner = MdProgressSpinner;
	exports.MdSpinner = MdSpinner;
	exports.MdProgressSpinnerModule = MdProgressSpinnerModule;
	exports.MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR;
	exports.MdRadioChange = MdRadioChange;
	exports.MdRadioGroup = MdRadioGroup;
	exports.MdRadioButton = MdRadioButton;
	exports.MdRadioModule = MdRadioModule;
	exports.MdSelectModule = MdSelectModule;
	exports.fadeInContent = fadeInContent;
	exports.transformPanel = transformPanel;
	exports.transformPlaceholder = transformPlaceholder;
	exports.SELECT_OPTION_HEIGHT = SELECT_OPTION_HEIGHT;
	exports.SELECT_PANEL_MAX_HEIGHT = SELECT_PANEL_MAX_HEIGHT;
	exports.SELECT_MAX_OPTIONS_DISPLAYED = SELECT_MAX_OPTIONS_DISPLAYED;
	exports.SELECT_TRIGGER_HEIGHT = SELECT_TRIGGER_HEIGHT;
	exports.SELECT_OPTION_HEIGHT_ADJUSTMENT = SELECT_OPTION_HEIGHT_ADJUSTMENT;
	exports.SELECT_PANEL_PADDING_X = SELECT_PANEL_PADDING_X;
	exports.SELECT_PANEL_PADDING_Y = SELECT_PANEL_PADDING_Y;
	exports.SELECT_PANEL_VIEWPORT_PADDING = SELECT_PANEL_VIEWPORT_PADDING;
	exports.MdSelectChange = MdSelectChange;
	exports.MdSelect = MdSelect;
	exports.MdDuplicatedSidenavError = MdDuplicatedSidenavError;
	exports.MdSidenavToggleResult = MdSidenavToggleResult;
	exports.MdSidenav = MdSidenav;
	exports.MdSidenavContainer = MdSidenavContainer;
	exports.MdSidenavModule = MdSidenavModule;
	exports.MD_SLIDER_VALUE_ACCESSOR = MD_SLIDER_VALUE_ACCESSOR;
	exports.MdSliderChange = MdSliderChange;
	exports.MdSlider = MdSlider;
	exports.SliderRenderer = SliderRenderer;
	exports.MdSliderModule = MdSliderModule;
	exports.MD_SLIDE_TOGGLE_VALUE_ACCESSOR = MD_SLIDE_TOGGLE_VALUE_ACCESSOR;
	exports.MdSlideToggleChange = MdSlideToggleChange;
	exports.MdSlideToggle = MdSlideToggle;
	exports.MdSlideToggleModule = MdSlideToggleModule;
	exports.MdSnackBarModule = MdSnackBarModule;
	exports.MdSnackBar = MdSnackBar;
	exports.SHOW_ANIMATION = SHOW_ANIMATION;
	exports.HIDE_ANIMATION = HIDE_ANIMATION;
	exports.MdSnackBarContainer = MdSnackBarContainer;
	exports.MdSnackBarConfig = MdSnackBarConfig;
	exports.MdSnackBarRef = MdSnackBarRef;
	exports.SimpleSnackBar = SimpleSnackBar;
	exports.MdInkBar = MdInkBar;
	exports.MdTabBody = MdTabBody;
	exports.MdTabHeader = MdTabHeader;
	exports.MdTabLabelWrapper = MdTabLabelWrapper;
	exports.MdTab = MdTab;
	exports.MdTabLabel = MdTabLabel;
	exports.MdTabChangeEvent = MdTabChangeEvent;
	exports.MdTabGroup = MdTabGroup;
	exports.MdTabsModule = MdTabsModule;
	exports.MdTabNavBar = MdTabNavBar;
	exports.MdTabLink = MdTabLink;
	exports.MdTabLinkRipple = MdTabLinkRipple;
	exports.MdToolbarRow = MdToolbarRow;
	exports.MdToolbar = MdToolbar;
	exports.MdToolbarModule = MdToolbarModule;
	exports.TOUCHEND_HIDE_DELAY = TOUCHEND_HIDE_DELAY;
	exports.SCROLL_THROTTLE_MS = SCROLL_THROTTLE_MS;
	exports.MdTooltip = MdTooltip;
	exports.TooltipComponent = TooltipComponent;
	exports.MdTooltipModule = MdTooltipModule;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },

/***/ 81:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var router_1 = __webpack_require__(82);
	var login_module_1 = __webpack_require__(622);
	var login1_component_1 = __webpack_require__(96);
	var appRoutes = [
	    { path: 'login', component: login1_component_1.Login1Component },
	    { path: '', component: login1_component_1.Login1Component },
	];
	var AppRoutingModule = (function () {
	    function AppRoutingModule() {
	    }
	    return AppRoutingModule;
	}());
	AppRoutingModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            router_1.RouterModule.forRoot(appRoutes, { useHash: true }),
	            login_module_1.appLoginModule,
	        ],
	        declarations: [],
	        exports: [
	            router_1.RouterModule
	        ],
	    }),
	    __metadata("design:paramtypes", [])
	], AppRoutingModule);
	exports.AppRoutingModule = AppRoutingModule;


/***/ },

/***/ 96:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var Login1Component = (function () {
	    function Login1Component() {
	    }
	    return Login1Component;
	}());
	Login1Component = __decorate([
	    core_1.Component({
	        selector: 'login1-form',
	        template: __webpack_require__(97),
	    })
	], Login1Component);
	exports.Login1Component = Login1Component;


/***/ },

/***/ 97:
/***/ function(module, exports) {

	module.exports = "<md-input-container>\n  <input mdInput placeholder=\"Favorite food\" value=\"Sushi\">\n</md-input-container>\n\n";

/***/ },

/***/ 98:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var AppComponent = (function () {
	    function AppComponent() {
	    }
	    return AppComponent;
	}());
	AppComponent = __decorate([
	    core_1.Component({
	        selector: 'my-app',
	        template: "<router-outlet></router-outlet>",
	    })
	], AppComponent);
	exports.AppComponent = AppComponent;


/***/ },

/***/ 99:
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },

/***/ 622:
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var core_1 = __webpack_require__(3);
	var login1_component_1 = __webpack_require__(96);
	var material_1 = __webpack_require__(29);
	var appLoginModule = (function () {
	    function appLoginModule() {
	    }
	    return appLoginModule;
	}());
	appLoginModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            material_1.MaterialModule.forRoot(),
	        ],
	        declarations: [
	            login1_component_1.Login1Component,
	        ],
	        exports: [
	            login1_component_1.Login1Component
	        ],
	    })
	], appLoginModule);
	exports.appLoginModule = appLoginModule;


/***/ }

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcC50cyIsIndlYnBhY2s6Ly8vLi9hcHAvc3JjL2FwcC5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL21hdGVyaWFsL2J1bmRsZXMvbWF0ZXJpYWwudW1kLmpzIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwUm91dGVyTW9kdWxlL2FwcFJvdXRlci5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBMb2dpbk1vZHVsZS9sb2dpbjEuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXBwTG9naW5Nb2R1bGUvbG9naW4xLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHAuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL2FwcC9zcmMvYXNzZXRzL3N0eWxlL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vYXBwL3NyYy9hcHBMb2dpbk1vZHVsZS9sb2dpbi5tb2R1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHlEQUEyRTtBQUMzRSw0Q0FBc0M7QUFJdEMsa0RBQXNCLEVBQUUsQ0FBQyxlQUFlLENBQUMsc0JBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTHBELHFDQUF5RDtBQUN6RCxrREFBMkQ7QUFDM0QsdUNBQTZDO0FBQzdDLHNDQUE4QztBQUc5QyxrREFBb0U7QUFDcEUsK0NBQTZDO0FBRTdDLG9CQUFPLENBQUMsRUFBMkIsQ0FBQyxDQUFDO0FBQ3JDLGlDQUFnQztBQUNoQyxzQkFBYyxFQUFFLENBQUM7QUFDakIsS0FBSTtBQWNKLEtBQWEsU0FBUztLQUNsQjtLQUNBLENBQUM7S0FDTCxnQkFBQztBQUFELEVBQUM7QUFIWSxVQUFTO0tBYnJCLGVBQVEsQ0FBQztTQUNOLE9BQU8sRUFBRTthQUNSLG1CQUFXO2FBQ1Is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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMEIsaUJBQWlCLEVBQUU7QUFDN0MsNEJBQTJCLGNBQWMsRUFBRTtBQUMzQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQW9FLHVDQUF1QywyQkFBMkIsRUFBRSxFQUFFLEVBQUU7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZELDREQUE0RCxFQUFFO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RCwyQ0FBMkMsRUFBRTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQsb0NBQW9DLEVBQUU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsV0FBVztBQUMxQyxxREFBb0QsOEJBQThCLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQStGLHdCQUF3QixFQUFFO0FBQ3pILHVGQUFzRix3QkFBd0IsRUFBRTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBcUYsd0JBQXdCLEVBQUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJELHVDQUF1QyxFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLHlCQUF5QjtBQUNuRSxtQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFxRSx3Q0FBd0MsRUFBRTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxzQ0FBc0MsR0FBRyxxQ0FBcUM7QUFDOUcsaUNBQWdDLG1DQUFtQyxHQUFHLHdDQUF3QztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QiwyQkFBMkI7QUFDbEQsNENBQTJDLHlFQUF5RSxHQUFHLDZFQUE2RTtBQUNwTTtBQUNBO0FBQ0EsaUVBQWdFLHVDQUF1QyxFQUFFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQix1QkFBdUIsRUFBRTtBQUNuRCw4QkFBNkIsNkNBQTZDLEVBQUU7QUFDNUU7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsaURBQWlELEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixvQkFBb0IsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBLDRDQUEyQyxX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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0NBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCw0QkFBNEIsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQStEO0FBQy9EO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUEyRiwyQ0FBMkMsRUFBRTtBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE0RSx1QkFBdUIsRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTBCLG9CQUFvQixFQUFFO0FBQ2hELGdDQUErQiwwQkFBMEIsRUFBRTtBQUMzRDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE0RSxzQkFBc0IsRUFBRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsNEJBQTRCLEVBQUU7QUFDeEQsZ0NBQStCLG9EQUFvRCxFQUFFO0FBQ3JGO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0EseUNBQXdDLHFCQUFxQixpREFBaUQsaUJBQWlCLGVBQWUsb0JBQW9CLHFCQUFxQixtQkFBbUIscUJBQXFCLHNCQUFzQixxQkFBcUIsWUFBWSxrQkFBa0IsV0FBVyxRQUFRLGdEQUFnRCxzQkFBc0IsWUFBWSxPQUFPLE1BQU0sV0FBVyxrQkFBa0Isa0JBQWtCLHdCQUF3QixtQ0FBbUMsaUJBQWlCLG1CQUFtQix3QkFBd0IsNERBQTRELG1CQUFtQiwyQ0FBMkMsb0JBQW9CLHlCQUF5QixxQkFBcUIsUUFBUSxvQkFBb0IsaUJBQWlCLGdCQUFnQixtQ0FBbUMsa0JBQWtCLGVBQWUsZ0RBQWdELFNBQVMsZUFBZSxrQkFBa0IsMERBQTBELGdCQUFnQixpQkFBaUIseURBQXlELGVBQWUsa0JBQWtCLGtCQUFrQixXQUFXLFVBQVUsWUFBWSxhQUFhLGtCQUFrQixVQUFVLG9CQUFvQjtBQUM1dkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxREFBb0QsMEJBQTBCLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQThELGtCQUFrQixFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1Qyx1Q0FBdUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixTQUFTO0FBQ3RDLDhCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLGdtQkFBK2xCLGNBQWM7QUFDN21CLDJFQUEwRSxvR0FBb0csWUFBWSxxQkFBcUIsa0JBQWtCLHNCQUFzQixZQUFZLFVBQVUsc0JBQXNCLG9CQUFvQixrQkFBa0IsMEJBQTBCLGtCQUFrQixNQUFNLE9BQU8sZ0JBQWdCLHVCQUF1QixrQkFBa0IscUJBQXFCLDZCQUE2QixrQkFBa0IsMkJBQTJCLDRCQUE0QixrQkFBa0IsT0FBTyxNQUFNLGdCQUFnQixrQkFBa0Isc0JBQXNCLFVBQVUsa0RBQWtELHVDQUF1QyxVQUFVLDRCQUE0QixrQkFBa0IsVUFBVSxvREFBb0Qsa0JBQWtCLGtCQUFrQixZQUFZLGFBQWEsc0JBQXNCLFdBQVcsWUFBWSw2QkFBNkIsa0JBQWtCLG9CQUFvQixnSkFBZ0osd0JBQXdCLGFBQWEsbUJBQW1CLHVCQUF1QixrQkFBa0IsV0FBVyxZQUFZLGtCQUFrQixpSkFBaUosNkJBQTZCLFVBQVUsZUFBZSxnQkFBZ0IsVUFBVSxrREFBa0QsNElBQTRJLHVCQUF1QixpREFBaUQsV0FBVyxrQkFBa0IsOEJBQThCLFVBQVUsa0RBQWtELGtWQUFrVixVQUFVLHdEQUF3RCxhQUFhLGlEQUFpRCwyQkFBMkIsdURBQXVELHFCQUFxQixxQ0FBcUMsaUJBQWlCLG1CQUFtQixvRUFBb0UsbUJBQW1CLDJDQUEyQyx3QkFBd0IsdUNBQXVDLGlCQUFpQixvQkFBb0IsNkNBQTZDLGFBQWEsdUJBQXVCLFlBQVksZ0JBQWdCLDJDQUEyQyxXQUFXLFNBQVMsU0FBUyxVQUFVLGtEQUFrRCxXQUFXLHNCQUFzQixRQUFRLE1BQU0saURBQWlELFdBQVcsV0FBVyw4Q0FBOEMsV0FBVyxXQUFXLG9CQUFvQixvREFBb0QsV0FBVyxXQUFXLG9CQUFvQixtREFBbUQsV0FBVyxXQUFXLHlDQUF5QywyR0FBMkcsZ0hBQWdILDRCQUE0QixXQUFXLFdBQVcsbURBQW1ELFdBQVcsU0FBUyxRQUFRLCtDQUErQyxZQUFZLFVBQVUsb0RBQW9ELG9EQUFvRCx5QkFBeUIsaUVBQWlFLHdCQUF3QixxQkFBcUIsV0FBVyxpQkFBaUIseUNBQXlDLFVBQVUsUUFBUSxXQUFXLFVBQVUsZ0RBQWdELFVBQVUscUJBQXFCLFNBQVMsT0FBTywrQ0FBK0MsWUFBWSxVQUFVLDRDQUE0QyxZQUFZLFVBQVUsb0JBQW9CLGtEQUFrRCxZQUFZLFVBQVUsb0JBQW9CLGlEQUFpRCxVQUFVLFlBQVksdUNBQXVDLDRHQUE0Ryw0QkFBNEIsVUFBVSxZQUFZLGlEQUFpRCxZQUFZLFFBQVEsU0FBUyw2Q0FBNkMsYUFBYSxXQUFXLHFEQUFxRCxrREFBa0Qsd0JBQXdCLCtEQUErRCx5QkFBeUIscUNBQXFDLE9BQU8sV0FBVyx3REFBd0QsMkJBQTJCLCtJQUErSSxxQkFBcUIsdUZBQXVGLDJCQUEyQjtBQUMxK0s7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCLG1GQUFtRjtBQUM1RyxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLG9CQUFvQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTBCLG9CQUFvQixFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEwQiwyQkFBMkIsRUFBRTtBQUN2RCxnQ0FBK0IsbURBQW1ELEVBQUU7QUFDcEY7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHFCQUFxQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtB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Q0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsYUFBYTtBQUN2RTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLHFCQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsbUJBQW1CLEVBQUU7QUFDL0MsZ0NBQStCLG9DQUFvQyxFQUFFO0FBQ3JFO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEwQixxQkFBcUIsRUFBRTtBQUNqRCxnQ0FBK0Isc0NBQXNDLEVBQUU7QUFDdkU7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0Esc0NBQXFDLGNBQWMsa0JBQWtCLGVBQWUsY0FBYyxrQkFBa0IsZ0JBQWdCLDJCQUEyQixhQUFhLGtCQUFrQixtQkFBbUIsdUJBQXVCLFlBQVksTUFBTSxRQUFRLFNBQVMsT0FBTyxVQUFVLFNBQVMsMEVBQTBFLGFBQWEsbUJBQW1CLFlBQVksV0FBVywyQkFBMkIsZ0JBQWdCLGVBQWUsZUFBZSxrQkFBa0IsT0FBTyxRQUFRLDhGQUE4RixtQkFBbUIsa0JBQWtCLHVCQUF1QixjQUFjLHNCQUFzQiw0SEFBNEgsZUFBZSxtSEFBbUgsU0FBUyxVQUFVLGdCQUFnQixrQkFBa0IsZ0dBQWdHLFlBQVksbUNBQW1DLGFBQWEsc0JBQXNCLFdBQVcsc0JBQXNCLGdCQUFnQiwrRUFBK0UsYUFBYSxxQ0FBcUMsTUFBTSxxQ0FBcUMsU0FBUyxnQ0FBZ0MsbUJBQW1CLDBDQUEwQyxnQkFBZ0Isa0JBQWtCO0FBQ3hoRDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0EscUNBQW9DLGFBQWE7QUFDakQ7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1Qyw2QkFBNkIsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQSxpQ0FBZ0MsNEJBQTRCLHFCQUFxQixrQkFBa0IsWUFBWSxXQUFXO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixvQkFBb0IsRUFBRTtBQUNoRDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNEQsOERBQThEO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDRDQUE0QyxFQUFFO0FBQ3hFO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQSwyQkFBMEIsMkNBQTJDLEVBQUU7QUFDdkU7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTBCLHdCQUF3QixFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMEIsK0JBQStCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQsOEJBQThCLEVBQUU7QUFDMUYsc0VBQXFFLHNDQUFzQyxFQUFFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQThELHFFQUFxRTtBQUNuSTtBQUNBLDJEQUEwRCw0QkFBNEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyx3QkFBd0IsRUFBRTtBQUN6RSw0REFBMkQsK0JBQStCLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFtRSxnQkFBZ0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBLDZCQUE0QixtR0FBbUcsbUJBQW1CLGtCQUFrQix1QkFBdUIsY0FBYyxZQUFZLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGtCQUFrQiwyQkFBMkIsNkNBQTZDLE1BQU0sa0JBQWtCO0FBQ3ZYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSx5RUFBd0UsZ0NBQWdDO0FBQ3hHLHlFQUF3RSw4QkFBOEI7QUFDdEcsMEVBQXlFLGdDQUFnQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixzQkFBc0IsRUFBRTtBQUNsRDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0Esa0NBQWlDO0FBQ2pDLHNFQUFxRSxTQUFTLGlHQUFpRyxRQUFRO0FBQ3ZMLDZCQUE0QixhQUFhLDhCQUE4QixXQUFXLGlCQUFpQixlQUFlLGlEQUFpRCw2QkFBNkIsbUJBQW1CLGtCQUFrQix1QkFBdUIsNEJBQTRCLGVBQWUseUJBQXlCLHNCQUFzQixxQkFBcUIsaUJBQWlCLFVBQVUsWUFBWSxlQUFlLGdCQUFnQixZQUFZLHlCQUF5QixjQUFjLG9CQUFvQixjQUFjLG9CQUFvQixrQkFBa0IsZ0JBQWdCO0FBQzVqQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsOEJBQThCLEVBQUU7QUFDeEUsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQyxhQUFhO0FBQzdDLGlDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHVCQUF1QixFQUFFO0FBQ25ELGdDQUErQiwrQ0FBK0MsRUFBRTtBQUNoRjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQSxzREFBcUQsa0JBQWtCLGdCQUFnQixpQkFBaUIsY0FBYyxlQUFlLGFBQWEsa0JBQWtCLGNBQWMsaUJBQWlCLFlBQVksZUFBZSxlQUFlLGlEQUFpRCxnQkFBZ0IsZUFBZSxzQkFBc0IsbUJBQW1CLFdBQVcsZ0JBQWdCLGtCQUFrQixxQkFBcUIsb0JBQW9CLFVBQVUsVUFBVSx5QkFBeUIsY0FBYyxnQkFBZ0IsYUFBYSxrQkFBa0IsU0FBUyxXQUFXLHlDQUF5Qyw0Q0FBNEMsWUFBWSxNQUFNO0FBQ2pxQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLHVCQUF1QixFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiw0QkFBNEIsRUFBRTtBQUN4RDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsMkJBQTBCLHVCQUF1QixFQUFFO0FBQ25EO0FBQ0EsZ0NBQStCLCtDQUErQyxFQUFFO0FBQ2hGO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLHNFQUFxRSx3Q0FBd0M7QUFDN0csb0ZBQW1GLG9DQUFvQztBQUN2SCxxRkFBb0Ysb0NBQW9DO0FBQ3hILHdFQUF1RSxvQ0FBb0M7QUFDM0csdUVBQXNFLHVDQUF1QztBQUM3RztBQUNBO0FBQ0EsOENBQTZDLHdDQUF3QztBQUNyRjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsdUNBQXVDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiw0QkFBNEIsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQztBQUMzQywyQkFBMEIseUJBQXlCLEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0QsMkJBQTJCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDZCQUE2QixFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QWUsRUFBRTtBQUM1QztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMEIsa0JBQWtCLEVBQUU7QUFDOUMsNEJBQTJCLGVBQWUsRUFBRTtBQUM1QztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdEQUErQywwQkFBMEIsRUFBRTtBQUMzRTtBQUNBLHdEQUF1RCxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBLDJCQUEwQix1QkFBdUIsRUFBRTtBQUNuRDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QXVCO0FBQ3B1QjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXVELDJDQUEyQyxFQUFFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBc0UsMEJBQTBCLEVBQUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsMENBQXlDLHVDQUF1QyxFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXNGLHNDQUFzQyxHQUFHLHFDQUFxQztBQUNwSyxvQ0FBbUMsbUNBQW1DLEdBQUcsd0NBQXdDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQThDLGNBQWM7O0FBRTVELEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0aGZELHFDQUFxRDtBQUNyRCx3Q0FBdUQ7QUFFdkQsK0NBQThEO0FBQzlELGtEQUFrRTtBQUNsRSxLQUFNLFNBQVMsR0FBVztLQUV0QixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLGtDQUFlLEVBQUU7S0FDN0MsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxrQ0FBZSxFQUFFO0VBRTNDLENBQUM7QUFjRixLQUFhLGdCQUFnQjtLQUN6QjtLQUNBLENBQUM7S0FDTCx1QkFBQztBQUFELEVBQUM7QUFIWSxpQkFBZ0I7S0FaNUIsZUFBUSxDQUFDO1NBQ1IsT0FBTyxFQUFFO2FBQ1AscUJBQVksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFDLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDO2FBQ2pELDZCQUFjO1VBQ2Y7U0FDRCxZQUFZLEVBQUUsRUFDYjtTQUNELE9BQU8sRUFBRTthQUNQLHFCQUFZO1VBQ2I7TUFFRixDQUFDOztJQUNXLGdCQUFnQixDQUc1QjtBQUhZLDZDQUFnQjs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCN0IscUNBQXdDO0FBTXhDLEtBQWEsZUFBZTtLQUE1QjtLQUE4QixDQUFDO0tBQUQsc0JBQUM7QUFBRCxFQUFDO0FBQWxCLGdCQUFlO0tBTDNCLGdCQUFTLENBQUM7U0FDVCxRQUFRLEVBQUUsYUFBYTtTQUN2QixRQUFRLEVBQUUsbUJBQU8sQ0FBQyxFQUFlLENBQUM7TUFFbkMsQ0FBQztJQUNXLGVBQWUsQ0FBRztBQUFsQiwyQ0FBZTs7Ozs7Ozs7QUNONUIscUk7Ozs7Ozs7Ozs7Ozs7OztBQ0FBLHFDQUE0QztBQU81QyxLQUFhLFlBQVk7S0FBekI7S0FBNEIsQ0FBQztLQUFELG1CQUFDO0FBQUQsRUFBQztBQUFoQixhQUFZO0tBTHhCLGdCQUFTLENBQUM7U0FDUCxRQUFRLEVBQUUsUUFBUTtTQUNsQixRQUFRLEVBQUcsaUNBQWlDO01BQy9DLENBQUM7SUFFVyxZQUFZLENBQUk7QUFBaEIscUNBQVk7Ozs7Ozs7O0FDUHpCLDBDOzs7Ozs7Ozs7Ozs7Ozs7QUNBQSxxQ0FBeUM7QUFDekMsa0RBQW1EO0FBQ25ELDBDQUFtRDtBQWFuRCxLQUFhLGNBQWM7S0FBM0I7S0FBNkIsQ0FBQztLQUFELHFCQUFDO0FBQUQsRUFBQztBQUFqQixlQUFjO0tBWjFCLGVBQVEsQ0FBQztTQUNULE9BQU8sRUFBRTthQUNSLHlCQUFjLENBQUMsT0FBTyxFQUFFO1VBQ3hCO1NBQ0UsWUFBWSxFQUFFO2FBQ1Ysa0NBQWU7VUFFbEI7U0FDRCxPQUFPLEVBQUM7YUFDSixrQ0FBZTtVQUNsQjtNQUNKLENBQUM7SUFDVyxjQUFjLENBQUc7QUFBakIseUNBQWMiLCJmaWxlIjoiYnVpbGQvanMvYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG5pbXBvcnQge0FwcE1vZHVsZX0gZnJvbSAnLi9hcHAubW9kdWxlJ1xuXG5cblxucGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcC50cyIsImltcG9ydCB7IE5nTW9kdWxlLGVuYWJsZVByb2RNb2RlICB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9ICBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgSHR0cE1vZHVsZSB9ICAgIGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuXG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7QXBwUm91dGluZ01vZHVsZX0gZnJvbSAnLi9hcHBSb3V0ZXJNb2R1bGUvYXBwUm91dGVyLm1vZHVsZSc7XG5pbXBvcnQge0FwcENvbXBvbmVudH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcblxucmVxdWlyZSgnLi9hc3NldHMvc3R5bGUvc3R5bGUuc2NzcycpO1xuLy8gaWYgKGVudmlyb25tZW50LnByb2R1Y3Rpb24pIHtcbmVuYWJsZVByb2RNb2RlKCk7XG4vLyB9XG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICBcdEZvcm1zTW9kdWxlLFxuICAgICAgICBCcm93c2VyTW9kdWxlLFxuICAgICAgICBIdHRwTW9kdWxlLFxuICAgICAgICBBcHBSb3V0aW5nTW9kdWxlLFxuICAgICAgICBcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgIFx0QXBwQ29tcG9uZW50LFxuICAgIF0sXG4gICAgYm9vdHN0cmFwOiBbQXBwQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL3NyYy9hcHAubW9kdWxlLnRzIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjQuOFxuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJyksIHJlcXVpcmUoJ3J4anMvU3ViamVjdCcpLCByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKSwgcmVxdWlyZSgncnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncnhqcy9vcGVyYXRvci90b1Byb21pc2UnLCAncnhqcy9TdWJqZWN0JywgJ3J4anMvT2JzZXJ2YWJsZScsICdyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2UnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5mb3JtcyA9IGdsb2JhbC5uZy5mb3JtcyB8fCB7fSksZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeCxnbG9iYWwuUngsZ2xvYmFsLlJ4Lk9ic2VydmFibGUpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfY29yZSxyeGpzX29wZXJhdG9yX3RvUHJvbWlzZSxyeGpzX1N1YmplY3Qscnhqc19PYnNlcnZhYmxlLHJ4anNfb2JzZXJ2YWJsZV9mcm9tUHJvbWlzZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgY29udHJvbCBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogT25seSB1c2VkIGludGVybmFsbHkgaW4gdGhlIGZvcm1zIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudmFsdWUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC52YWxpZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuaW52YWxpZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wucGVuZGluZyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5lcnJvcnMgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicHJpc3RpbmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5wcmlzdGluZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmRpcnR5IDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC50b3VjaGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInVudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnVudG91Y2hlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmRpc2FibGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5lbmFibGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0YXR1c0NoYW5nZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlQ2hhbmdlcyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wucmVzZXQodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvckNvZGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvckNvZGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnRhaW5zIG11bHRpcGxlIHtcXEBsaW5rIE5nQ29udHJvbH1zLlxuICAgICAqXG4gICAgICogT25seSB1c2VkIGJ5IHRoZSBmb3JtcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29udHJvbENvbnRhaW5lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKENvbnRyb2xDb250YWluZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbnRyb2xDb250YWluZXIoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udHJvbENvbnRhaW5lci5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgZm9ybSB0byB3aGljaCB0aGlzIGNvbnRhaW5lciBiZWxvbmdzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHBhdGggdG8gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQ29udHJvbENvbnRhaW5lcjtcbiAgICB9KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSkpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFcbiAgICAgKiBAcGFyYW0gez99IGJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgICAgcmV0dXJuICFpc0pzT2JqZWN0KG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXG4gICAgICovXG4gICAgdmFyIFN0cmluZ01hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG0xXG4gICAgICAgICAqIEBwYXJhbSB7P30gbTJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIubWVyZ2UgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMobTEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG0xXG4gICAgICAgICAqIEBwYXJhbSB7P30gbTJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gazEgPSBPYmplY3Qua2V5cyhtMSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrMiA9IE9iamVjdC5rZXlzKG0yKTtcbiAgICAgICAgICAgIGlmIChrMS5sZW5ndGggIT0gazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gazFbaV07XG4gICAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFyclxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTGlzdFdyYXBwZXIuZmluZExhc3QgPSBmdW5jdGlvbiAoYXJyLCBjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24oYXJyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsaXN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gaXRlbXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGxpc3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYVxuICAgICAgICAgKiBAcGFyYW0gez99IGJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGxpc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIExpc3RXcmFwcGVyLmZsYXR0ZW4gPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhdEl0ZW0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gTGlzdFdyYXBwZXIuZmxhdHRlbihpdGVtKSA6IGl0ZW07XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoZmxhdCkpLmNvbmNhdChmbGF0SXRlbSk7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNQcm9taXNlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmlzUHJvbWlzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc09ic2VydmFibGUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uaXNPYnNlcnZhYmxlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eUlucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgY2hlY2sgZm9yIHN0cmluZyBoZXJlIHNvIGl0IGFsc28gd29ya3Mgd2l0aCBhcnJheXNcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcnMgZm9yIHZhbGlkYXRvcnMgdG8gYmUgdXNlZCBmb3Ige0BsaW5rIEZvcm1Db250cm9sfXMgaW4gYSBmb3JtLlxuICAgICAqXG4gICAgICogUHJvdmlkZSB0aGlzIHVzaW5nIGBtdWx0aTogdHJ1ZWAgdG8gYWRkIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZm9ybXMvdHMvbmdfdmFsaWRhdG9ycy9uZ192YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbmdfdmFsaWRhdG9ycyd9XG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIE5HX1ZBTElEQVRPUlMgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTmdWYWxpZGF0b3JzJyk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIGZvciBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0byBiZSB1c2VkIGZvciB7QGxpbmsgRm9ybUNvbnRyb2x9c1xuICAgICAqIGluIGEgZm9ybS5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgdGhpcyB1c2luZyBgbXVsdGk6IHRydWVgIHRvIGFkZCB2YWxpZGF0b3JzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBOR19WQUxJREFUT1JTfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIE5HX0FTWU5DX1ZBTElEQVRPUlMgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTmdBc3luY1ZhbGlkYXRvcnMnKTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHNldCBvZiB2YWxpZGF0b3JzIHVzZWQgYnkgZm9ybSBjb250cm9scy5cbiAgICAgKlxuICAgICAqIEEgdmFsaWRhdG9yIGlzIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSB7XFxAbGluayBGb3JtQ29udHJvbH0gb3IgY29sbGVjdGlvbiBvZlxuICAgICAqIGNvbnRyb2xzIGFuZCByZXR1cm5zIGEgbWFwIG9mIGVycm9ycy4gQSBudWxsIG1hcCBtZWFucyB0aGF0IHZhbGlkYXRpb24gaGFzIHBhc3NlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIGxvZ2luQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbChcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZhbGlkYXRvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWYWxpZGF0b3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyBjb250cm9scyB0byBoYXZlIGEgbm9uLWVtcHR5IHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMucmVxdWlyZWQgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHlJbnB1dFZhbHVlKGNvbnRyb2wudmFsdWUpID8geyAncmVxdWlyZWQnOiB0cnVlIH0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbCB2YWx1ZSB0byBiZSB0cnVlLlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMucmVxdWlyZWRUcnVlID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sLnZhbHVlID09PSB0cnVlID8gbnVsbCA6IHsgJ3JlcXVpcmVkJzogdHJ1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWluaW11bSBsZW5ndGguXG4gICAgICAgICAqIEBwYXJhbSB7P30gbWluTGVuZ3RoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIChtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbmd0aCA9IGNvbnRyb2wudmFsdWUgPyBjb250cm9sLnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA8IG1pbkxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIHsgJ21pbmxlbmd0aCc6IHsgJ3JlcXVpcmVkTGVuZ3RoJzogbWluTGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWF4aW11bSBsZW5ndGguXG4gICAgICAgICAqIEBwYXJhbSB7P30gbWF4TGVuZ3RoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1heExlbmd0aCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbmd0aCA9IGNvbnRyb2wudmFsdWUgPyBjb250cm9sLnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA+IG1heExlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIHsgJ21heGxlbmd0aCc6IHsgJ3JlcXVpcmVkTGVuZ3RoJzogbWF4TGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgYSBjb250cm9sIHRvIG1hdGNoIGEgcmVnZXggdG8gaXRzIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhdHRlcm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMucGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvcjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZ2V4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVnZXhTdHI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVnZXhTdHIgPSBcIl5cIiArIHBhdHRlcm4gKyBcIiRcIjtcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnZXhTdHIgPSBwYXR0ZXJuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmVnZXggPSBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHlJbnB1dFZhbHVlKGNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB2YWxpZGF0ZSBlbXB0eSB2YWx1ZXMgdG8gYWxsb3cgb3B0aW9uYWwgY29udHJvbHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBjb250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKSA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICB7ICdwYXR0ZXJuJzogeyAncmVxdWlyZWRQYXR0ZXJuJzogcmVnZXhTdHIsICdhY3R1YWxWYWx1ZSc6IHZhbHVlIH0gfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOby1vcCB2YWxpZGF0b3IuXG4gICAgICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5udWxsVmFsaWRhdG9yID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb3NlIG11bHRpcGxlIHZhbGlkYXRvcnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHVuaW9uXG4gICAgICAgICAqIG9mIHRoZSBpbmRpdmlkdWFsIGVycm9yIG1hcHMuXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlID0gZnVuY3Rpb24gKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdG9ycylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXNlbnRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoaXNQcmVzZW50KTtcbiAgICAgICAgICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbWVyZ2VFcnJvcnMoX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyA9IGZ1bmN0aW9uICh2YWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRvcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgICAgICAgICBpZiAocHJlc2VudFZhbGlkYXRvcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9taXNlcyA9IF9leGVjdXRlQXN5bmNWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKS5tYXAoX2NvbnZlcnRUb1Byb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihfbWVyZ2VFcnJvcnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2NvbnZlcnRUb1Byb21pc2Uob2JqKSB7XG4gICAgICAgIHJldHVybiBpc1Byb21pc2Uob2JqKSA/IG9iaiA6IHJ4anNfb3BlcmF0b3JfdG9Qcm9taXNlLnRvUHJvbWlzZS5jYWxsKG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2KGNvbnRyb2wpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXhlY3V0ZUFzeW5jVmFsaWRhdG9ycyhjb250cm9sLCB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdihjb250cm9sKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXJyYXlPZkVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX21lcmdlRXJyb3JzKGFycmF5T2ZFcnJvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gYXJyYXlPZkVycm9ycy5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGVycm9ycykgPyBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHJlcywgZXJyb3JzKSA6IHJlcztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzKS5sZW5ndGggPT09IDAgPyBudWxsIDogcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcHJvdmlkZSBhIHtAbGluayBDb250cm9sVmFsdWVBY2Nlc3Nvcn0gZm9yIGZvcm0gY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIERlZmF1bHRWYWx1ZUFjY2Vzc29yfSBmb3IgaG93IHRvIGltcGxlbWVudCBvbmUuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIE5HX1ZBTFVFX0FDQ0VTU09SID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nVmFsdWVBY2Nlc3NvcicpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiBhIGNoZWNrYm94IGlucHV0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwicmVtZW1iZXJMb2dpblwiIG5nTW9kZWw+XG4gICAgICogIGBgYFxuICAgICAqXG4gICAgICogIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2hlY2tlZCcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC5jaGVja2VkKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBERUZBVUxUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBEZWZhdWx0VmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyB0aGF0IGlzIHVzZWQgYnkgdGhlXG4gICAgICoge1xcQGxpbmsgTmdNb2RlbH0sIHtcXEBsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtcXEBsaW5rIEZvcm1Db250cm9sTmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInNlYXJjaFF1ZXJ5XCIgbmdNb2RlbD5cbiAgICAgKiAgYGBgXG4gICAgICpcbiAgICAgKiAgXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sTmFtZV0sdGV4dGFyZWFbZm9ybUNvbnRyb2xOYW1lXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtmb3JtQ29udHJvbF0sdGV4dGFyZWFbZm9ybUNvbnRyb2xdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW25nTW9kZWxdLHRleHRhcmVhW25nTW9kZWxdLFtuZ0RlZmF1bHRDb250cm9sXScsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB2c2F2a2luIHJlcGxhY2UgdGhlIGFib3ZlIHNlbGVjdG9yIHdpdGggdGhlIG9uZSBiZWxvdyBpdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMDExIGlzIGltcGxlbWVudGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcjogJ1tuZ0NvbnRyb2xdLFtuZ01vZGVsXSxbbmdGb3JtQ29udHJvbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtERUZBVUxUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0VmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVWYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gICAgICAgIGlmICgoKHZhbGlkYXRvcikpLnZhbGlkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICgodmFsaWRhdG9yKSkudmFsaWRhdGUoYyk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbGlkYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFzeW5jVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoKCh2YWxpZGF0b3IpKS52YWxpZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiAoKHZhbGlkYXRvcikpLnZhbGlkYXRlKGMpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh2YWxpZGF0b3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTlVNQkVSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOdW1iZXJWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIG51bWJlciB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtcXEBsaW5rIE5nTW9kZWx9LCB7XFxAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7XFxAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgWyhuZ01vZGVsKV09XCJhZ2VcIj5cbiAgICAgKiAgYGBgXG4gICAgICovXG4gICAgdmFyIE51bWJlclZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTnVtYmVyVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBuZWVkcyB0byBiZSBub3JtYWxpemVkIGZvciBJRTksIG90aGVyd2lzZSBpdCBpcyBzZXQgdG8gJ251bGwnIHdoZW4gbnVsbFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZFZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCBub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBmbih2YWx1ZSA9PSAnJyA/IG51bGwgOiBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9bnVtYmVyXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOVU1CRVJfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gTnVtYmVyVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgYmFzZSBjbGFzcyB0aGF0IGFsbCBjb250cm9sIGRpcmVjdGl2ZSBleHRlbmQuXG4gICAgICogSXQgYmluZHMgYSB7XFxAbGluayBGb3JtQ29udHJvbH0gb2JqZWN0IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2VkIGludGVybmFsbHkgYnkgQW5ndWxhciBmb3Jtcy5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBOZ0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihOZ0NvbnRyb2wsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nQ29udHJvbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodW5pbXBsZW1lbnRlZCgpKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodW5pbXBsZW1lbnRlZCgpKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdDb250cm9sLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkgeyB9O1xuICAgICAgICByZXR1cm4gTmdDb250cm9sO1xuICAgIH0oQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKSk7XG5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBSQURJT19WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjbGFzcyB1c2VkIGJ5IEFuZ3VsYXIgdG8gdW5jaGVjayByYWRpbyBidXR0b25zIHdpdGggdGhlIG1hdGNoaW5nIG5hbWUuXG4gICAgICovXG4gICAgdmFyIFJhZGlvQ29udHJvbFJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmFkaW9Db250cm9sUmVnaXN0cnkoKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICAgICAqIEBwYXJhbSB7P30gYWNjZXNzb3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY29udHJvbCwgYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycy5wdXNoKFtjb250cm9sLCBhY2Nlc3Nvcl0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhY2Nlc3NvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY2Nlc3Nvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5fYWNjZXNzb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjY2Vzc29yc1tpXVsxXSA9PT0gYWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYWNjZXNzb3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNTYW1lR3JvdXAoYywgYWNjZXNzb3IpICYmIGNbMV0gIT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNbMV0uZmlyZVVuY2hlY2soYWNjZXNzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sUGFpclxuICAgICAgICAgKiBAcGFyYW0gez99IGFjY2Vzc29yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuX2lzU2FtZUdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xQYWlyLCBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgaWYgKCFjb250cm9sUGFpclswXS5jb250cm9sKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sUGFpclswXS5fcGFyZW50ID09PSBhY2Nlc3Nvci5fY29udHJvbC5fcGFyZW50ICYmXG4gICAgICAgICAgICAgICAgY29udHJvbFBhaXJbMV0ubmFtZSA9PT0gYWNjZXNzb3IubmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gUmFkaW9Db250cm9sUmVnaXN0cnk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFdyaXRlcyByYWRpbyBjb250cm9sIHZhbHVlcyBhbmQgbGlzdGVucyB0byByYWRpbyBjb250cm9sIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHtcXEBsaW5rIE5nTW9kZWx9LCB7XFxAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7XFxAbGluayBGb3JtQ29udHJvbE5hbWV9XG4gICAgICogdG8ga2VlcCB0aGUgdmlldyBzeW5jZWQgd2l0aCB0aGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9IG1vZGVsLlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGltcG9ydGVkIHRoZSB7XFxAbGluayBGb3Jtc01vZHVsZX0gb3IgdGhlIHtcXEBsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9LCB0aGlzXG4gICAgICogdmFsdWUgYWNjZXNzb3Igd2lsbCBiZSBhY3RpdmUgb24gYW55IHJhZGlvIGNvbnRyb2wgdGhhdCBoYXMgYSBmb3JtIGRpcmVjdGl2ZS4gWW91IGRvXG4gICAgICogKipub3QqKiBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IgdG8gYWN0aXZhdGUgaXQuXG4gICAgICpcbiAgICAgKiAjIyMgSG93IHRvIHVzZSByYWRpbyBidXR0b25zIHdpdGggZm9ybSBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgcmFkaW8gYnV0dG9ucyBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCB5b3UnbGwgd2FudCB0byBlbnN1cmUgdGhhdCByYWRpbyBidXR0b25zXG4gICAgICogaW4gdGhlIHNhbWUgZ3JvdXAgaGF2ZSB0aGUgc2FtZSBgbmFtZWAgYXR0cmlidXRlLiAgUmFkaW8gYnV0dG9ucyB3aXRoIGRpZmZlcmVudCBgbmFtZWBcbiAgICAgKiBhdHRyaWJ1dGVzIGRvIG5vdCBhZmZlY3QgZWFjaCBvdGhlci5cbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL3JhZGlvQnV0dG9ucy9yYWRpb19idXR0b25fZXhhbXBsZS50cyByZWdpb249J1RlbXBsYXRlRHJpdmVuJ31cbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgcmFkaW8gYnV0dG9ucyBpbiBhIHJlYWN0aXZlIGZvcm0sIHJhZGlvIGJ1dHRvbnMgaW4gdGhlIHNhbWUgZ3JvdXAgc2hvdWxkIGhhdmUgdGhlXG4gICAgICogc2FtZSBgZm9ybUNvbnRyb2xOYW1lYC4gWW91IGNhbiBhbHNvIGFkZCBhIGBuYW1lYCBhdHRyaWJ1dGUsIGJ1dCBpdCdzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVSYWRpb0J1dHRvbnMvcmVhY3RpdmVfcmFkaW9fYnV0dG9uX2V4YW1wbGUudHMgcmVnaW9uPSdSZWFjdGl2ZSd9XG4gICAgICpcbiAgICAgKiAgKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRSZWZcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVnaXN0cnlcbiAgICAgICAgICogQHBhcmFtIHs/fSBfaW5qZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZiwgX3JlZ2lzdHJ5LCBfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSBfcmVnaXN0cnk7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbCA9IHRoaXMuX2luamVjdG9yLmdldChOZ0NvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tOYW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RyeS5hZGQodGhpcy5fY29udHJvbCwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlZ2lzdHJ5LnJlbW92ZSh0aGlzKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdmFsdWUgPT09IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2hlY2tlZCcsIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmbihfdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlZ2lzdHJ5LnNlbGVjdChfdGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuZmlyZVVuY2hlY2sgPSBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy53cml0ZVZhbHVlKHZhbHVlKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2NoZWNrTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUgJiYgdGhpcy5uYW1lICE9PSB0aGlzLmZvcm1Db250cm9sTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93TmFtZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubmFtZSAmJiB0aGlzLmZvcm1Db250cm9sTmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmZvcm1Db250cm9sTmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fdGhyb3dOYW1lRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBJZiB5b3UgZGVmaW5lIGJvdGggYSBuYW1lIGFuZCBhIGZvcm1Db250cm9sTmFtZSBhdHRyaWJ1dGUgb24geW91ciByYWRpbyBidXR0b24sIHRoZWlyIHZhbHVlc1xcbiAgICAgIG11c3QgbWF0Y2guIEV4OiA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIGZvcm1Db250cm9sTmFtZT1cXFwiZm9vZFxcXCIgbmFtZT1cXFwiZm9vZFxcXCI+XFxuICAgIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXJhZGlvXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1yYWRpb11bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQURJT19WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFJhZGlvQ29udHJvbFJlZ2lzdHJ5LCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICdmb3JtQ29udHJvbE5hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUkFOR0VfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhbmdlVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSByYW5nZSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtcXEBsaW5rIE5nTW9kZWx9LCB7XFxAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7XFxAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBbKG5nTW9kZWwpXT1cImFnZVwiID5cbiAgICAgKiAgYGBgXG4gICAgICovXG4gICAgdmFyIFJhbmdlVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSYW5nZVZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBmbih2YWx1ZSA9PSAnJyA/IG51bGwgOiBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPXJhbmdlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9cmFuZ2VdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhbmdlXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQU5HRV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIFJhbmdlVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gU0VMRUNUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmcoaWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZSh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9ICdPYmplY3QnO1xuICAgICAgICByZXR1cm4gKGlkICsgXCI6IFwiICsgdmFsdWUpLnNsaWNlKDAsIDUwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVN0cmluZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2V4dHJhY3RJZCh2YWx1ZVN0cmluZykge1xuICAgICAgICByZXR1cm4gdmFsdWVTdHJpbmcuc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBXcml0ZXMgdmFsdWVzIGFuZCBsaXN0ZW5zIHRvIGNoYW5nZXMgb24gYSBzZWxlY3QgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFVzZWQgYnkge1xcQGxpbmsgTmdNb2RlbH0sIHtcXEBsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtcXEBsaW5rIEZvcm1Db250cm9sTmFtZX1cbiAgICAgKiB0byBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSB7XFxAbGluayBGb3JtQ29udHJvbH0gbW9kZWwuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogSWYgeW91IGhhdmUgaW1wb3J0ZWQgdGhlIHtcXEBsaW5rIEZvcm1zTW9kdWxlfSBvciB0aGUge1xcQGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX0sIHRoaXNcbiAgICAgKiB2YWx1ZSBhY2Nlc3NvciB3aWxsIGJlIGFjdGl2ZSBvbiBhbnkgc2VsZWN0IGNvbnRyb2wgdGhhdCBoYXMgYSBmb3JtIGRpcmVjdGl2ZS4gWW91IGRvXG4gICAgICogKipub3QqKiBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IgdG8gYWN0aXZhdGUgaXQuXG4gICAgICpcbiAgICAgKiAjIyMgSG93IHRvIHVzZSBzZWxlY3QgY29udHJvbHMgd2l0aCBmb3JtIGRpcmVjdGl2ZXNcbiAgICAgKlxuICAgICAqIFRvIHVzZSBhIHNlbGVjdCBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCBzaW1wbHkgYWRkIGFuIGBuZ01vZGVsYCBhbmQgYSBgbmFtZWBcbiAgICAgKiBhdHRyaWJ1dGUgdG8gdGhlIG1haW4gYDxzZWxlY3Q+YCB0YWcuXG4gICAgICpcbiAgICAgKiBJZiB5b3VyIG9wdGlvbiB2YWx1ZXMgYXJlIHNpbXBsZSBzdHJpbmdzLCB5b3UgY2FuIGJpbmQgdG8gdGhlIG5vcm1hbCBgdmFsdWVgIHByb3BlcnR5XG4gICAgICogb24gdGhlIG9wdGlvbi4gIElmIHlvdXIgb3B0aW9uIHZhbHVlcyBoYXBwZW4gdG8gYmUgb2JqZWN0cyAoYW5kIHlvdSdkIGxpa2UgdG8gc2F2ZSB0aGVcbiAgICAgKiBzZWxlY3Rpb24gaW4geW91ciBmb3JtIGFzIGFuIG9iamVjdCksIHVzZSBgbmdWYWx1ZWAgaW5zdGVhZDpcbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL3NlbGVjdENvbnRyb2wvc2VsZWN0X2NvbnRyb2xfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBJbiByZWFjdGl2ZSBmb3JtcywgeW91J2xsIGFsc28gd2FudCB0byBhZGQgeW91ciBmb3JtIGRpcmVjdGl2ZSAoYGZvcm1Db250cm9sTmFtZWAgb3JcbiAgICAgKiBgZm9ybUNvbnRyb2xgKSBvbiB0aGUgbWFpbiBgPHNlbGVjdD5gIHRhZy4gTGlrZSBpbiB0aGUgZm9ybWVyIGV4YW1wbGUsIHlvdSBoYXZlIHRoZVxuICAgICAqIGNob2ljZSBvZiBiaW5kaW5nIHRvIHRoZSAgYHZhbHVlYCBvciBgbmdWYWx1ZWAgcHJvcGVydHkgb24gdGhlIHNlbGVjdCdzIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9yZWFjdGl2ZVNlbGVjdENvbnRyb2wvcmVhY3RpdmVfc2VsZWN0X2NvbnRyb2xfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBOb3RlOiBXZSBsaXN0ZW4gdG8gdGhlICdjaGFuZ2UnIGV2ZW50IGJlY2F1c2UgJ2lucHV0JyBldmVudHMgYXJlbid0IGZpcmVkXG4gICAgICogZm9yIHNlbGVjdHMgaW4gRmlyZWZveCBhbmQgSUU6XG4gICAgICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyNDM1MFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzQ2NjAwNDUvXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYFxcQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFJlZlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gdGhpcy5fZ2V0T3B0aW9uSWQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnc2VsZWN0ZWRJbmRleCcsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlU3RyaW5nID0gX2J1aWxkVmFsdWVTdHJpbmcoaWQsIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlU3RyaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWVTdHJpbmc7XG4gICAgICAgICAgICAgICAgZm4oX3RoaXMuX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fcmVnaXN0ZXJPcHRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5faWRDb3VudGVyKyspLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvbklkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gQXJyYXkuZnJvbSh0aGlzLl9vcHRpb25NYXAua2V5cygpKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb3NlSWRlbnRpY2FsKHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSBfZXh0cmFjdElkKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25NYXAuaGFzKGlkKSA/IHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpIDogdmFsdWVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtmb3JtQ29udHJvbF0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtTRUxFQ1RfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBNYXJrcyBgPG9wdGlvbj5gIGFzIGR5bmFtaWMsIHNvIEFuZ3VsYXIgY2FuIGJlIG5vdGlmaWVkIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogU2VlIGRvY3MgZm9yIHtcXEBsaW5rIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yfSBmb3IgdXNhZ2UgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdTZWxlY3RPcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAgICAgKiBAcGFyYW0gez99IF9zZWxlY3RcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE5nU2VsZWN0T3B0aW9uKF9lbGVtZW50LCBfcmVuZGVyZXIsIF9zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ID0gX3NlbGVjdDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLCBcIm5nVmFsdWVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLnNldCh0aGlzLmlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZS5fc2V0RWxlbWVudFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdvcHRpb24nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTZWxlY3RPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nVmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nVmFsdWUnLF0gfSxdLFxuICAgICAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyd2YWx1ZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1NlbGVjdE9wdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYnVpbGRWYWx1ZVN0cmluZyQxKGlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdmFsdWUgPSBcIidcIiArIHZhbHVlICsgXCInXCI7XG4gICAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIChpZCArIFwiOiBcIiArIHZhbHVlKS5zbGljZSgwLCA1MCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVTdHJpbmdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9leHRyYWN0SWQkMSh2YWx1ZVN0cmluZykge1xuICAgICAgICByZXR1cm4gdmFsdWVTdHJpbmcuc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIG9uIGEgc2VsZWN0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9yZW5kZXJlclxuICAgICAgICAgKiBAcGFyYW0gez99IF9lbGVtZW50UmVmXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25TZWxlY3RlZFN0YXRlU2V0dGVyO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB2YWx1ZXMgdG8gaWRzXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRzXzEgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLl9nZXRPcHRpb25JZCh2KTsgfSk7XG4gICAgICAgICAgICAgICAgb3B0aW9uU2VsZWN0ZWRTdGF0ZVNldHRlciA9IGZ1bmN0aW9uIChvcHQsIG8pIHsgb3B0Ll9zZXRTZWxlY3RlZChpZHNfMS5pbmRleE9mKG8udG9TdHJpbmcoKSkgPiAtMSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25TZWxlY3RlZFN0YXRlU2V0dGVyID0gZnVuY3Rpb24gKG9wdCwgbykgeyBvcHQuX3NldFNlbGVjdGVkKGZhbHNlKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcC5mb3JFYWNoKG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgaWYgKF8uaGFzT3duUHJvcGVydHkoJ3NlbGVjdGVkT3B0aW9ucycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdGlvbnMgPSBfLnNlbGVjdGVkT3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdCA9IG9wdGlvbnMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IF90aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25zID0gKF8ub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHQgPSBvcHRpb25zLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsID0gX3RoaXMuX2dldE9wdGlvblZhbHVlKG9wdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgZm4oc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGlzRGlzYWJsZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fcmVnaXN0ZXJPcHRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwLnNldChpZCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvbklkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gQXJyYXkuZnJvbSh0aGlzLl9vcHRpb25NYXAua2V5cygpKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb3NlSWRlbnRpY2FsKHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLl92YWx1ZSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVTdHJpbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSBfZXh0cmFjdElkJDEodmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbk1hcC5oYXMoaWQpID8gdGhpcy5fb3B0aW9uTWFwLmdldChpZCkuX3ZhbHVlIDogdmFsdWVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xOYW1lXSxzZWxlY3RbbXVsdGlwbGVdW2Zvcm1Db250cm9sXSxzZWxlY3RbbXVsdGlwbGVdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NFTEVDVF9NVUxUSVBMRV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxzZWxlY3QgbXVsdGlwbGUgbmFtZT1cImNpdHlcIiBuZ01vZGVsPlxuICAgICAqICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgYyBvZiBjaXRpZXNcIiBbdmFsdWVdPVwiY1wiPjwvb3B0aW9uPlxuICAgICAqIDwvc2VsZWN0PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2VsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfc2VsZWN0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uKF9lbGVtZW50LCBfcmVuZGVyZXIsIF9zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ID0gX3NlbGVjdDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5fc2VsZWN0Ll9yZWdpc3Rlck9wdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUsIFwibmdWYWx1ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUoX2J1aWxkVmFsdWVTdHJpbmckMSh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyQxKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBzZWxlY3RlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUuX3NldFNlbGVjdGVkID0gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0Ll9vcHRpb25NYXAuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ1ZhbHVlJyxdIH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsndmFsdWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTZWxlY3RNdWx0aXBsZU9wdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRyb2xQYXRoKG5hbWUsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LnBhdGguY29uY2F0KFtuYW1lXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRVcENvbnRyb2woY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGlmICghY29udHJvbClcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ0Nhbm5vdCBmaW5kIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICBpZiAoIWRpci52YWx1ZUFjY2Vzc29yKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTm8gdmFsdWUgYWNjZXNzb3IgZm9yIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGNvbnRyb2wudmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFtjb250cm9sLnZhbGlkYXRvciwgZGlyLnZhbGlkYXRvcl0pO1xuICAgICAgICBjb250cm9sLmFzeW5jVmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW2NvbnRyb2wuYXN5bmNWYWxpZGF0b3IsIGRpci5hc3luY1ZhbGlkYXRvcl0pO1xuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKGNvbnRyb2wudmFsdWUpO1xuICAgICAgICAvLyB2aWV3IC0+IG1vZGVsXG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBkaXIudmlld1RvTW9kZWxVcGRhdGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbC5tYXJrQXNEaXJ0eSgpO1xuICAgICAgICAgICAgY29udHJvbC5zZXRWYWx1ZShuZXdWYWx1ZSwgeyBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdG91Y2hlZFxuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLm1hcmtBc1RvdWNoZWQoKTsgfSk7XG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXJPbkNoYW5nZShmdW5jdGlvbiAobmV3VmFsdWUsIGVtaXRNb2RlbEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBjb250cm9sIC0+IHZpZXdcbiAgICAgICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAgICAgLy8gY29udHJvbCAtPiBuZ01vZGVsXG4gICAgICAgICAgICBpZiAoZW1pdE1vZGVsRXZlbnQpXG4gICAgICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXIudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICBjb250cm9sLnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZShmdW5jdGlvbiAoaXNEaXNhYmxlZCkgeyBkaXIudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZS1ydW4gdmFsaWRhdGlvbiB3aGVuIHZhbGlkYXRvciBiaW5kaW5nIGNoYW5nZXMsIGUuZy4gbWlubGVuZ3RoPTMgLT4gbWlubGVuZ3RoPTRcbiAgICAgICAgZGlyLl9yYXdWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKCgodmFsaWRhdG9yKSkucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSlcbiAgICAgICAgICAgICAgICAoKHZhbGlkYXRvcikpLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGlyLl9yYXdBc3luY1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAoKCh2YWxpZGF0b3IpKS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKVxuICAgICAgICAgICAgICAgICgodmFsaWRhdG9yKSkucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xcbiAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYW5VcENvbnRyb2woY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gX25vQ29udHJvbEVycm9yKGRpcik7IH0pO1xuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZChmdW5jdGlvbiAoKSB7IHJldHVybiBfbm9Db250cm9sRXJyb3IoZGlyKTsgfSk7XG4gICAgICAgIGRpci5fcmF3VmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGlyLl9yYXdBc3luY1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb250cm9sKVxuICAgICAgICAgICAgY29udHJvbC5fY2xlYXJDaGFuZ2VGbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFVwRm9ybUNvbnRhaW5lcihjb250cm9sLCBkaXIpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoY29udHJvbCkpXG4gICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdDYW5ub3QgZmluZCBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgY29udHJvbC52YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW2NvbnRyb2wudmFsaWRhdG9yLCBkaXIudmFsaWRhdG9yXSk7XG4gICAgICAgIGNvbnRyb2wuYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbY29udHJvbC5hc3luY1ZhbGlkYXRvciwgZGlyLmFzeW5jVmFsaWRhdG9yXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbm9Db250cm9sRXJyb3IoZGlyKSB7XG4gICAgICAgIHJldHVybiBfdGhyb3dFcnJvcihkaXIsICdUaGVyZSBpcyBubyBGb3JtQ29udHJvbCBpbnN0YW5jZSBhdHRhY2hlZCB0byBmb3JtIGNvbnRyb2wgZWxlbWVudCB3aXRoJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdGhyb3dFcnJvcihkaXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZUVuZDtcbiAgICAgICAgaWYgKGRpci5wYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSBcInBhdGg6ICdcIiArIGRpci5wYXRoLmpvaW4oJyAtPiAnKSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpci5wYXRoWzBdKSB7XG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gXCJuYW1lOiAnXCIgKyBkaXIucGF0aCArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZUVuZCA9ICd1bnNwZWNpZmllZCBuYW1lIGF0dHJpYnV0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgKyBcIiBcIiArIG1lc3NhZ2VFbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2YWxpZGF0b3JzKSA/IFZhbGlkYXRvcnMuY29tcG9zZSh2YWxpZGF0b3JzLm1hcChub3JtYWxpemVWYWxpZGF0b3IpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodmFsaWRhdG9ycykgPyBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyh2YWxpZGF0b3JzLm1hcChub3JtYWxpemVBc3luY1ZhbGlkYXRvcikpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7P30gdmlld01vZGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB2aWV3TW9kZWwpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmhhc093blByb3BlcnR5KCdtb2RlbCcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFuZ2UgPSBjaGFuZ2VzWydtb2RlbCddO1xuICAgICAgICBpZiAoY2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gIWxvb3NlSWRlbnRpY2FsKHZpZXdNb2RlbCwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIEJVSUxUSU5fQUNDRVNTT1JTID0gW1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IsXG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIF07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZUFjY2Vzc29yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0J1aWx0SW5BY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHJldHVybiBCVUlMVElOX0FDQ0VTU09SUy5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiB2YWx1ZUFjY2Vzc29yLmNvbnN0cnVjdG9yID09PSBhOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlQWNjZXNzb3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZWxlY3RWYWx1ZUFjY2Vzc29yKGRpciwgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgaWYgKCF2YWx1ZUFjY2Vzc29ycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWZhdWx0QWNjZXNzb3I7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWx0aW5BY2Nlc3NvcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VzdG9tQWNjZXNzb3I7XG4gICAgICAgIHZhbHVlQWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2LmNvbnN0cnVjdG9yID09PSBEZWZhdWx0VmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBY2Nlc3NvciA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0J1aWx0SW5BY2Nlc3Nvcih2KSkge1xuICAgICAgICAgICAgICAgIGlmIChidWlsdGluQWNjZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ01vcmUgdGhhbiBvbmUgYnVpbHQtaW4gdmFsdWUgYWNjZXNzb3IgbWF0Y2hlcyBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICAgICAgICAgIGJ1aWx0aW5BY2Nlc3NvciA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQWNjZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ01vcmUgdGhhbiBvbmUgY3VzdG9tIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXMgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgICAgICAgICBjdXN0b21BY2Nlc3NvciA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3VzdG9tQWNjZXNzb3IpXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tQWNjZXNzb3I7XG4gICAgICAgIGlmIChidWlsdGluQWNjZXNzb3IpXG4gICAgICAgICAgICByZXR1cm4gYnVpbHRpbkFjY2Vzc29yO1xuICAgICAgICBpZiAoZGVmYXVsdEFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRBY2Nlc3NvcjtcbiAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTm8gdmFsaWQgdmFsdWUgYWNjZXNzb3IgZm9yIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGJhc2UgY2xhc3MgZm9yIGNvZGUgc2hhcmVkIGJldHdlZW4ge1xcQGxpbmsgTmdNb2RlbEdyb3VwfSBhbmQge1xcQGxpbmsgRm9ybUdyb3VwTmFtZX0uXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRGb3JtR3JvdXAodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVGb3JtR3JvdXAodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUge1xcQGxpbmsgRm9ybUdyb3VwfSBiYWNraW5nIHRoaXMgYmluZGluZy5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldEZvcm1Hcm91cCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgcGF0aCB0byB0aGlzIGNvbnRyb2wgZ3JvdXAuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUge1xcQGxpbmsgRm9ybX0gdG8gd2hpY2ggdGhpcyBncm91cCBiZWxvbmdzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIEFic3RyYWN0Q29udHJvbFN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xTdGF0dXMoY2QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NkID0gY2Q7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1VudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wudW50b3VjaGVkIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wudG91Y2hlZCA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5wcmlzdGluZSA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5kaXJ0eSA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC52YWxpZCA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0ludmFsaWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLmludmFsaWQgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NQZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5wZW5kaW5nIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sU3RhdHVzO1xuICAgIH0oKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250cm9sU3RhdHVzSG9zdCA9IHtcbiAgICAgICAgJ1tjbGFzcy5uZy11bnRvdWNoZWRdJzogJ25nQ2xhc3NVbnRvdWNoZWQnLFxuICAgICAgICAnW2NsYXNzLm5nLXRvdWNoZWRdJzogJ25nQ2xhc3NUb3VjaGVkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnbmdDbGFzc1ByaXN0aW5lJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1kaXJ0eV0nOiAnbmdDbGFzc0RpcnR5JyxcbiAgICAgICAgJ1tjbGFzcy5uZy12YWxpZF0nOiAnbmdDbGFzc1ZhbGlkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICduZ0NsYXNzSW52YWxpZCcsXG4gICAgICAgICdbY2xhc3MubmctcGVuZGluZ10nOiAnbmdDbGFzc1BlbmRpbmcnLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlyZWN0aXZlIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBBbmd1bGFyIGZvcm0gY29udHJvbHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gICAgICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0NvbnRyb2xTdGF0dXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhOZ0NvbnRyb2xTdGF0dXMsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ0NvbnRyb2xTdGF0dXMoY2QpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNkKTtcbiAgICAgICAgfVxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sTmFtZV0sW25nTW9kZWxdLFtmb3JtQ29udHJvbF0nLCBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdDb250cm9sU3RhdHVzLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1cztcbiAgICB9KEFic3RyYWN0Q29udHJvbFN0YXR1cykpO1xuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gQW5ndWxhciBmb3JtIGdyb3VwcyB0aGF0IHNldHMgQ1NTIGNsYXNzZXNcbiAgICAgKiBiYXNlZCBvbiBjb250cm9sIHN0YXR1cyAodmFsaWQvaW52YWxpZC9kaXJ0eS9ldGMpLlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nQ29udHJvbFN0YXR1c0dyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoTmdDb250cm9sU3RhdHVzR3JvdXAsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ0NvbnRyb2xTdGF0dXNHcm91cChjZCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgY2QpO1xuICAgICAgICB9XG4gICAgICAgIE5nQ29udHJvbFN0YXR1c0dyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbZm9ybUdyb3VwTmFtZV0sW2Zvcm1BcnJheU5hbWVdLFtuZ01vZGVsR3JvdXBdLFtmb3JtR3JvdXBdLGZvcm06bm90KFtuZ05vRm9ybV0pLFtuZ0Zvcm1dJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IG5nQ29udHJvbFN0YXR1c0hvc3RcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gTmdDb250cm9sU3RhdHVzR3JvdXA7XG4gICAgfShBYnN0cmFjdENvbnRyb2xTdGF0dXMpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgYnkgZGlyZWN0aXZlcyBhbmQgY29tcG9uZW50cyB0byBlbWl0IGN1c3RvbSBFdmVudHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgYFppcHB5YCBhbHRlcm5hdGl2ZWx5IGVtaXRzIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgd2hlbiBpdHNcbiAgICAgKiB0aXRsZSBnZXRzIGNsaWNrZWQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBcXEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICd6aXBweScsXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgPGRpdiBjbGFzcz1cInppcHB5XCI+XG4gICAgICogICAgIDxkaXYgKGNsaWNrKT1cInRvZ2dsZSgpXCI+VG9nZ2xlPC9kaXY+XG4gICAgICogICAgIDxkaXYgW2hpZGRlbl09XCIhdmlzaWJsZVwiPlxuICAgICAqICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgKiAgICAgPC9kaXY+XG4gICAgICogIDwvZGl2PmB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBaaXBweSB7XG4gICAgICogICB2aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICAgKiAgIFxcQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqICAgXFxAT3V0cHV0KCkgY2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqXG4gICAgICogICB0b2dnbGUoKSB7XG4gICAgICogICAgIHRoaXMudmlzaWJsZSA9ICF0aGlzLnZpc2libGU7XG4gICAgICogICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgKiAgICAgICB0aGlzLm9wZW4uZW1pdChudWxsKTtcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICB0aGlzLmNsb3NlLmVtaXQobnVsbCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnRzIHBheWxvYWQgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZSBwYXJhbWV0ZXIgYCRldmVudGAgb24gdGhlIGNvbXBvbmVudHMgb3V0cHV0IGV2ZW50XG4gICAgICogaGFuZGxlcjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDx6aXBweSAob3Blbik9XCJvbk9wZW4oJGV2ZW50KVwiIChjbG9zZSk9XCJvbkNsb3NlKCRldmVudClcIj48L3ppcHB5PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVXNlcyBSeC5PYnNlcnZhYmxlIGJ1dCBwcm92aWRlcyBhbiBhZGFwdGVyIHRvIG1ha2UgaXQgd29yayBhcyBzcGVjaWZpZWQgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vamh1c2Fpbi9vYnNlcnZhYmxlLXNwZWNcbiAgICAgKlxuICAgICAqIE9uY2UgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWMgaXMgYXZhaWxhYmxlLCBzd2l0Y2ggdG8gaXQuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ1KEV2ZW50RW1pdHRlciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgW0V2ZW50RW1pdHRlcl0sIHdoaWNoIGRlcGVuZGluZyBvbiBbaXNBc3luY10sXG4gICAgICAgICAqIGRlbGl2ZXJzIGV2ZW50cyBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICAgKiBAcGFyYW0gez89fSBpc0FzeW5jXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoaXNBc3luYykge1xuICAgICAgICAgICAgaWYgKGlzQXN5bmMgPT09IHZvaWQgMCkgeyBpc0FzeW5jID0gZmFsc2U7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPSBpc0FzeW5jO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGdlbmVyYXRvck9yTmV4dFxuICAgICAgICAgKiBAcGFyYW0gez89fSBlcnJvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBjb21wbGV0ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjaGVkdWxlckZuO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JGbiA9IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wbGV0ZUZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQgJiYgdHlwZW9mIGdlbmVyYXRvck9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0Lm5leHQodmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uIChlcnIpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikgeyBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoZXJyKTsgfSk7IH0gOiBmdW5jdGlvbiAoZXJyKSB7IGVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBsZXRlKCk7IH0pOyB9IDogZnVuY3Rpb24gKCkgeyBjb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnN1YnNjcmliZS5jYWxsKHRoaXMsIHNjaGVkdWxlckZuLCBlcnJvckZuLCBjb21wbGV0ZUZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9KHJ4anNfU3ViamVjdC5TdWJqZWN0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyB2YWxpZCwgaS5lLiB0aGF0IG5vIGVycm9ycyBleGlzdCBpbiB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gVkFMSUQgPSAnVkFMSUQnO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgaW52YWxpZCwgaS5lLiB0aGF0IGFuIGVycm9yIGV4aXN0cyBpbiB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSU5WQUxJRCA9ICdJTlZBTElEJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIHBlbmRpbmcsIGkuZS4gdGhhdCBhc3luYyB2YWxpZGF0aW9uIGlzIG9jY3VycmluZyBhbmRcbiAgICAgKiBlcnJvcnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUEVORElORyA9ICdQRU5ESU5HJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIGRpc2FibGVkLCBpLmUuIHRoYXQgdGhlIGNvbnRyb2wgaXMgZXhlbXB0IGZyb20gYW5jZXN0b3JcbiAgICAgKiBjYWxjdWxhdGlvbnMgb2YgdmFsaWRpdHkgb3IgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gRElTQUJMRUQgPSAnRElTQUJMRUQnO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAqIEBwYXJhbSB7P30gcGF0aFxuICAgICAqIEBwYXJhbSB7P30gZGVsaW1pdGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZmluZChjb250cm9sLCBwYXRoLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBwYXRoID0gKChwYXRoKSkuc3BsaXQoZGVsaW1pdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEFycmF5ICYmIChwYXRoLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuICgocGF0aCkpLnJlZHVjZShmdW5jdGlvbiAodiwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBGb3JtR3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5jb250cm9sc1tuYW1lXSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBGb3JtQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5hdCgvKiogQHR5cGUgez99ICovIChuYW1lKSkgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCBjb250cm9sKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b09ic2VydmFibGUocikge1xuICAgICAgICByZXR1cm4gaXNQcm9taXNlKHIpID8gcnhqc19vYnNlcnZhYmxlX2Zyb21Qcm9taXNlLmZyb21Qcm9taXNlKHIpIDogcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvZXJjZVRvVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWxpZGF0b3IpID8gY29tcG9zZVZhbGlkYXRvcnModmFsaWRhdG9yKSA6IHZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3luY1ZhbGlkYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29lcmNlVG9Bc3luY1ZhbGlkYXRvcihhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhc3luY1ZhbGlkYXRvcikgPyBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yKSA6IGFzeW5jVmFsaWRhdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIHtcXEBsaW5rIEZvcm1Db250cm9sfSwge1xcQGxpbmsgRm9ybUdyb3VwfSwgYW5kXG4gICAgICoge1xcQGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIEl0IHByb3ZpZGVzIHNvbWUgb2YgdGhlIHNoYXJlZCBiZWhhdmlvciB0aGF0IGFsbCBjb250cm9scyBhbmQgZ3JvdXBzIG9mIGNvbnRyb2xzIGhhdmUsIGxpa2VcbiAgICAgKiBydW5uaW5nIHZhbGlkYXRvcnMsIGNhbGN1bGF0aW5nIHN0YXR1cywgYW5kIHJlc2V0dGluZyBzdGF0ZS4gSXQgYWxzbyBkZWZpbmVzIHRoZSBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gYWxsIHN1Yi1jbGFzc2VzLCBsaWtlIGB2YWx1ZWAsIGB2YWxpZGAsIGFuZCBgZGlydHlgLiBJdCBzaG91bGRuJ3QgYmVcbiAgICAgKiBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RDb250cm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN5bmNWYWxpZGF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbCh2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBhc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC4gVGhlcmUgYXJlIGZvdXIgcG9zc2libGVcbiAgICAgICAgICAgICAqIHZhbGlkYXRpb24gc3RhdHVzZXM6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiAqKlZBTElEKio6ICBjb250cm9sIGhhcyBwYXNzZWQgYWxsIHZhbGlkYXRpb24gY2hlY2tzXG4gICAgICAgICAgICAgKiAqICoqSU5WQUxJRCoqOiBjb250cm9sIGhhcyBmYWlsZWQgYXQgbGVhc3Qgb25lIHZhbGlkYXRpb24gY2hlY2tcbiAgICAgICAgICAgICAqICogKipQRU5ESU5HKio6IGNvbnRyb2wgaXMgaW4gdGhlIG1pZHN0IG9mIGNvbmR1Y3RpbmcgYSB2YWxpZGF0aW9uIGNoZWNrXG4gICAgICAgICAgICAgKiAqICoqRElTQUJMRUQqKjogY29udHJvbCBpcyBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZXNlIHN0YXR1c2VzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIGEgY29udHJvbCBjYW5ub3QgYmVcbiAgICAgICAgICAgICAqIGJvdGggdmFsaWQgQU5EIGludmFsaWQgb3IgaW52YWxpZCBBTkQgZGlzYWJsZWQuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1czsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGB2YWxpZGAgd2hlbiBpdHMgYHN0YXR1cyA9PT0gVkFMSURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG9yZGVyIHRvIGhhdmUgdGhpcyBzdGF0dXMsIHRoZSBjb250cm9sIG11c3QgaGF2ZSBwYXNzZWQgYWxsIGl0c1xuICAgICAgICAgICAgICogdmFsaWRhdGlvbiBjaGVja3MuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gVkFMSUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBpbnZhbGlkYCB3aGVuIGl0cyBgc3RhdHVzID09PSBJTlZBTElEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGhhdmUgZmFpbGVkXG4gICAgICAgICAgICAgKiBhdCBsZWFzdCBvbmUgb2YgaXRzIHZhbGlkYXRpb24gY2hlY2tzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IElOVkFMSUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBwZW5kaW5nYCB3aGVuIGl0cyBgc3RhdHVzID09PSBQRU5ESU5HYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGJlIGluIHRoZVxuICAgICAgICAgICAgICogbWlkZGxlIG9mIGNvbmR1Y3RpbmcgYSB2YWxpZGF0aW9uIGNoZWNrLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT0gUEVORElORzsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBkaXNhYmxlZGAgd2hlbiBpdHMgYHN0YXR1cyA9PT0gRElTQUJMRURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIERpc2FibGVkIGNvbnRyb2xzIGFyZSBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgICAgICAgICAqIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGVpciBhbmNlc3RvclxuICAgICAgICAgICAgICogY29udHJvbHMuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gRElTQUJMRUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBlbmFibGVkYCBhcyBsb25nIGFzIGl0cyBgc3RhdHVzICE9PSBESVNBQkxFRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMsIGl0IGhhcyBhIHN0YXR1cyBvZiBgVkFMSURgLCBgSU5WQUxJRGAsIG9yXG4gICAgICAgICAgICAgKiBgUEVORElOR2AuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyAhPT0gRElTQUJMRUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFueSBlcnJvcnMgZ2VuZXJhdGVkIGJ5IGZhaWxpbmcgdmFsaWRhdGlvbi4gSWYgdGhlcmVcbiAgICAgICAgICAgICAqIGFyZSBubyBlcnJvcnMsIGl0IHdpbGwgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Vycm9yczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBwcmlzdGluZWAgaWYgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgY2hhbmdlZFxuICAgICAgICAgICAgICogdGhlIHZhbHVlIGluIHRoZSBVSS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgcHJvZ3JhbW1hdGljIGNoYW5nZXMgdG8gYSBjb250cm9sJ3MgdmFsdWUgd2lsbFxuICAgICAgICAgICAgICogKm5vdCogbWFyayBpdCBkaXJ0eS5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJpc3RpbmU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZGlydHlgIGlmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICogaW4gdGhlIFVJLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcm9ncmFtbWF0aWMgY2hhbmdlcyB0byBhIGNvbnRyb2wncyB2YWx1ZSB3aWxsXG4gICAgICAgICAgICAgKiAqbm90KiBtYXJrIGl0IGRpcnR5LlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5wcmlzdGluZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgbWFya2VkIGB0b3VjaGVkYCBvbmNlIHRoZSB1c2VyIGhhcyB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90b3VjaGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidW50b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGB1bnRvdWNoZWRgIGlmIHRoZSB1c2VyIGhhcyBub3QgeWV0IHRyaWdnZXJlZFxuICAgICAgICAgICAgICogYSBgYmx1cmAgZXZlbnQgb24gaXQuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLl90b3VjaGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZXZlcnkgdGltZSB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgY2hhbmdlcywgaW5cbiAgICAgICAgICAgICAqIHRoZSBVSSBvciBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZUNoYW5nZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJzdGF0dXNDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZXZlcnkgdGltZSB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2xcbiAgICAgICAgICAgICAqIGlzIHJlLWNhbGN1bGF0ZWQuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1c0NoYW5nZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiAgQ2FsbGluZ1xuICAgICAgICAgKiB0aGlzIHdpbGwgb3ZlcndyaXRlIGFueSBleGlzdGluZyBzeW5jIHZhbGlkYXRvcnMuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmV3VmFsaWRhdG9yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldFZhbGlkYXRvcnMgPSBmdW5jdGlvbiAobmV3VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9IGNvZXJjZVRvVmFsaWRhdG9yKG5ld1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBhc3luYyB2YWxpZGF0b3JzIHRoYXQgYXJlIGFjdGl2ZSBvbiB0aGlzIGNvbnRyb2wuIENhbGxpbmcgdGhpc1xuICAgICAgICAgKiB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgYXN5bmMgdmFsaWRhdG9ycy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWxpZGF0b3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0QXN5bmNWYWxpZGF0b3JzID0gZnVuY3Rpb24gKG5ld1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy5hc3luY1ZhbGlkYXRvciA9IGNvZXJjZVRvQXN5bmNWYWxpZGF0b3IobmV3VmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtcHRpZXMgb3V0IHRoZSBzeW5jIHZhbGlkYXRvciBsaXN0LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5jbGVhclZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7IHRoaXMudmFsaWRhdG9yID0gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtcHRpZXMgb3V0IHRoZSBhc3luYyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuY2xlYXJBc3luY1ZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHRvdWNoZWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYWxzbyBtYXJrIGFsbCBkaXJlY3QgYW5jZXN0b3JzIGFzIGB0b3VjaGVkYCB0byBtYWludGFpblxuICAgICAgICAgKiB0aGUgbW9kZWwuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNUb3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHVudG91Y2hlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGl0IHdpbGwgYWxzbyBtYXJrIGFsbCBjaGlsZHJlbiBhcyBgdW50b3VjaGVkYFxuICAgICAgICAgKiB0byBtYWludGFpbiB0aGUgbW9kZWwsIGFuZCByZS1jYWxjdWxhdGUgdGhlIGB0b3VjaGVkYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1VudG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLm1hcmtBc1VudG91Y2hlZCh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYGRpcnR5YC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIGFsc28gbWFyayBhbGwgZGlyZWN0IGFuY2VzdG9ycyBhcyBgZGlydHlgIHRvIG1haW50YWluXG4gICAgICAgICAqIHRoZSBtb2RlbC5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc0RpcnR5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc0RpcnR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHByaXN0aW5lYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGFueSBjaGlsZHJlbiwgaXQgd2lsbCBhbHNvIG1hcmsgYWxsIGNoaWxkcmVuIGFzIGBwcmlzdGluZWBcbiAgICAgICAgICogdG8gbWFpbnRhaW4gdGhlIG1vZGVsLCBhbmQgcmUtY2FsY3VsYXRlIHRoZSBgcHJpc3RpbmVgIHN0YXR1cyBvZiBhbGwgcGFyZW50XG4gICAgICAgICAqIGNvbnRyb2xzLlxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzUHJpc3RpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5tYXJrQXNQcmlzdGluZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwZW5kaW5nYC5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1BlbmRpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzUGVuZGluZyh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBjb250cm9sLiBUaGlzIG1lYW5zIHRoZSBjb250cm9sIHdpbGwgYmUgZXhlbXB0IGZyb20gdmFsaWRhdGlvbiBjaGVja3MgYW5kXG4gICAgICAgICAqIGV4Y2x1ZGVkIGZyb20gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiBhbnkgcGFyZW50LiBJdHMgc3RhdHVzIGlzIGBESVNBQkxFRGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBjaGlsZHJlbiwgYWxsIGNoaWxkcmVuIHdpbGwgYmUgZGlzYWJsZWQgdG8gbWFpbnRhaW4gdGhlIG1vZGVsLlxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IERJU0FCTEVEO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLmRpc2FibGUoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGVtaXRFdmVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMuZW1pdCh0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuX3N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBbmNlc3RvcnMob25seVNlbGYpO1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VGbikgeyByZXR1cm4gY2hhbmdlRm4odHJ1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCB3aWxsIGJlIGluY2x1ZGVkIGluIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgKiB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIGl0cyBwYXJlbnQuIEl0cyBzdGF0dXMgaXMgcmUtY2FsY3VsYXRlZCBiYXNlZCBvbiBpdHMgdmFsdWUgYW5kXG4gICAgICAgICAqIGl0cyB2YWxpZGF0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiB3aWxsIGJlIGVuYWJsZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBWQUxJRDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLmVuYWJsZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuY2VzdG9ycyhvbmx5U2VsZik7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZUZuKSB7IHJldHVybiBjaGFuZ2VGbihmYWxzZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBvbmx5U2VsZlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlQW5jZXN0b3JzID0gZnVuY3Rpb24gKG9ubHlTZWxmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlVG91Y2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkgeyB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC4gQWJzdHJhY3QgbWV0aG9kIChpbXBsZW1lbnRlZCBpbiBzdWItY2xhc3NlcykuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGNoZXMgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLiBBYnN0cmFjdCBtZXRob2QgKGltcGxlbWVudGVkIGluIHN1Yi1jbGFzc2VzKS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGNvbnRyb2wuIEFic3RyYWN0IG1ldGhvZCAoaW1wbGVtZW50ZWQgaW4gc3ViLWNsYXNzZXMpLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmUtY2FsY3VsYXRlcyB0aGUgdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGFsc28gdXBkYXRlIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgb2YgaXRzIGFuY2VzdG9ycy5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zZXRJbml0aWFsU3RhdHVzKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IHRoaXMuX3J1blZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IFZBTElEIHx8IHRoaXMuX3N0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydW5Bc3luY1ZhbGlkYXRvcihlbWl0RXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbWl0RXZlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzLmVtaXQodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVRyZWVWYWxpZGl0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGVtaXRFdmVudCA9IChfYSA9PT0gdm9pZCAwID8geyBlbWl0RXZlbnQ6IHRydWUgfSA6IF9hKS5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGN0cmwpIHsgcmV0dXJuIGN0cmwuX3VwZGF0ZVRyZWVWYWxpZGl0eSh7IGVtaXRFdmVudDogZW1pdEV2ZW50IH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9zZXRJbml0aWFsU3RhdHVzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9zdGF0dXMgPSB0aGlzLl9hbGxDb250cm9sc0Rpc2FibGVkKCkgPyBESVNBQkxFRCA6IFZBTElEOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3J1blZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvciA/IHRoaXMudmFsaWRhdG9yKHRoaXMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZW1pdEV2ZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9ydW5Bc3luY1ZhbGlkYXRvciA9IGZ1bmN0aW9uIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvYnMgPSB0b09ic2VydmFibGUodGhpcy5hc3luY1ZhbGlkYXRvcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaXNPYnNlcnZhYmxlKG9icykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHRoZSBmb2xsb3dpbmcgdmFsaWRhdG9yIHRvIHJldHVybiBQcm9taXNlIG9yIE9ic2VydmFibGU6IFwiICsgdGhpcy5hc3luY1ZhbGlkYXRvciArIFwiLiBJZiB5b3UgYXJlIHVzaW5nIEZvcm1CdWlsZGVyOyBkaWQgeW91IGZvcmdldCB0byBicmFjZSB5b3VyIHZhbGlkYXRvcnMgaW4gYW4gYXJyYXk/XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBvYnMuc3Vic2NyaWJlKHsgbmV4dDogZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuc2V0RXJyb3JzKHJlcywgeyBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTsgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9jYW5jZWxFeGlzdGluZ1N1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgZXJyb3JzIG9uIGEgZm9ybSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgd2hlbiB2YWxpZGF0aW9ucyBhcmUgcnVuIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCByYXRoZXIgdGhhbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxsaW5nIGBzZXRFcnJvcnNgIHdpbGwgYWxzbyB1cGRhdGUgdGhlIHZhbGlkaXR5IG9mIHRoZSBwYXJlbnQgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNvbnN0IGxvZ2luID0gbmV3IEZvcm1Db250cm9sKFwic29tZUxvZ2luXCIpO1xuICAgICAgICAgKiBsb2dpbi5zZXRFcnJvcnMoe1xuICAgICAgICAgKiAgIFwibm90VW5pcXVlXCI6IHRydWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbChmYWxzZSk7XG4gICAgICAgICAqIGV4cGVjdChsb2dpbi5lcnJvcnMpLnRvRXF1YWwoe1wibm90VW5pcXVlXCI6IHRydWV9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbG9naW4uc2V0VmFsdWUoXCJzb21lT3RoZXJMb2dpblwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KGxvZ2luLnZhbGlkKS50b0VxdWFsKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldEVycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgZW1pdEV2ZW50ID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb250cm9sc0Vycm9ycyhlbWl0RXZlbnQgIT09IGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIGNoaWxkIGNvbnRyb2wgZ2l2ZW4gdGhlIGNvbnRyb2wncyBuYW1lIG9yIHBhdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhdGhzIGNhbiBiZSBwYXNzZWQgaW4gYXMgYW4gYXJyYXkgb3IgYSBzdHJpbmcgZGVsaW1pdGVkIGJ5IGEgZG90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBnZXQgYSBjb250cm9sIG5lc3RlZCB3aXRoaW4gYSBgcGVyc29uYCBzdWItZ3JvdXA6XG4gICAgICAgICAqXG4gICAgICAgICAqICogYHRoaXMuZm9ybS5nZXQoJ3BlcnNvbi5uYW1lJyk7YFxuICAgICAgICAgKlxuICAgICAgICAgKiAtT1ItXG4gICAgICAgICAqXG4gICAgICAgICAqICogYHRoaXMuZm9ybS5nZXQoWydwZXJzb24nLCAnbmFtZSddKTtgXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gX2ZpbmQodGhpcywgcGF0aCwgJy4nKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBwYXRoIGhhcyB0aGUgZXJyb3Igc3BlY2lmaWVkLiBPdGhlcndpc2VcbiAgICAgICAgICogcmV0dXJucyBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgaXQgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIHByZXNlbnQgY29udHJvbC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvckNvZGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRyb2wgPSBwYXRoID8gdGhpcy5nZXQocGF0aCkgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wgJiYgY29udHJvbC5fZXJyb3JzID8gY29udHJvbC5fZXJyb3JzW2Vycm9yQ29kZV0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuIE90aGVyd2lzZVxuICAgICAgICAgKiByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBubyBwYXRoIGlzIGdpdmVuLCBpdCBjaGVja3MgZm9yIHRoZSBlcnJvciBvbiB0aGUgcHJlc2VudCBjb250cm9sLlxuICAgICAgICAgKiBAcGFyYW0gez99IGVycm9yQ29kZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBwYXRoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmhhc0Vycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRFcnJvcihlcnJvckNvZGUsIHBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0cmlldmVzIHRoZSB0b3AtbGV2ZWwgYW5jZXN0b3Igb2YgdGhpcyBjb250cm9sLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHguX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0geC5fcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBlbWl0RXZlbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzID0gZnVuY3Rpb24gKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gdGhpcy5fY2FsY3VsYXRlU3RhdHVzKCk7XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuX3N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVDb250cm9sc0Vycm9ycyhlbWl0RXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2luaXRPYnNlcnZhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fY2FsY3VsYXRlU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsbENvbnRyb2xzRGlzYWJsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRElTQUJMRUQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3JzKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhQRU5ESU5HKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUEVORElORztcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbnlDb250cm9sc0hhdmVTdGF0dXMoSU5WQUxJRCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICByZXR1cm4gVkFMSUQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3RhdHVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc0hhdmVTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuc3RhdHVzID09PSBzdGF0dXM7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZGlydHk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scyhmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC50b3VjaGVkOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlUHJpc3RpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9ICF0aGlzLl9hbnlDb250cm9sc0RpcnR5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVRvdWNoZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gdGhpcy5fYW55Q29udHJvbHNUb3VjaGVkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm9ybVN0YXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9pc0JveGVkVmFsdWUgPSBmdW5jdGlvbiAoZm9ybVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1TdGF0ZSA9PT0gJ29iamVjdCcgJiYgZm9ybVN0YXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPT09IDIgJiYgJ3ZhbHVlJyBpbiBmb3JtU3RhdGUgJiYgJ2Rpc2FibGVkJyBpbiBmb3JtU3RhdGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRhdGlvbiBzdGF0dXMgb2YgYW4gaW5kaXZpZHVhbCBmb3JtIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBJdCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyBvZiBBbmd1bGFyIGZvcm1zLCBhbG9uZyB3aXRoXG4gICAgICoge1xcQGxpbmsgRm9ybUdyb3VwfSBhbmQge1xcQGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7XFxAbGluayBGb3JtQ29udHJvbH0sIHlvdSBjYW4gcGFzcyBpbiBhbiBpbml0aWFsIHZhbHVlIGFzIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sKCdzb21lIHZhbHVlJyk7XG4gICAgICogY29uc29sZS5sb2coY3RybC52YWx1ZSk7ICAgICAvLyAnc29tZSB2YWx1ZSdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbml0aWFsaXplIHRoZSBjb250cm9sIHdpdGggYSBmb3JtIHN0YXRlIG9iamVjdCBvbiBpbnN0YW50aWF0aW9uLFxuICAgICAqIHdoaWNoIGluY2x1ZGVzIGJvdGggdGhlIHZhbHVlIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbCBpcyBkaXNhYmxlZC5cbiAgICAgKiBZb3UgY2FuJ3QgdXNlIHRoZSB2YWx1ZSBrZXkgd2l0aG91dCB0aGUgZGlzYWJsZWQga2V5OyBib3RoIGFyZSByZXF1aXJlZFxuICAgICAqIHRvIHVzZSB0aGlzIHdheSBvZiBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCh7dmFsdWU6ICduL2EnLCBkaXNhYmxlZDogdHJ1ZX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwudmFsdWUpOyAgICAgLy8gJ24vYSdcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnN0YXR1cyk7ICAgLy8gJ0RJU0FCTEVEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVG8gaW5jbHVkZSBhIHN5bmMgdmFsaWRhdG9yIChvciBhbiBhcnJheSBvZiBzeW5jIHZhbGlkYXRvcnMpIHdpdGggdGhlIGNvbnRyb2wsXG4gICAgICogcGFzcyBpdCBpbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBBc3luYyB2YWxpZGF0b3JzIGFyZSBhbHNvIHN1cHBvcnRlZCwgYnV0XG4gICAgICogaGF2ZSB0byBiZSBwYXNzZWQgaW4gc2VwYXJhdGVseSBhcyB0aGUgdGhpcmQgYXJnLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sKCcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICcnXG4gICAgICogY29uc29sZS5sb2coY3RybC5zdGF0dXMpOyAgIC8vICdJTlZBTElEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIGl0cyBzdXBlcmNsYXNzLCB7XFxAbGluayBBYnN0cmFjdENvbnRyb2x9LCBmb3IgbW9yZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUNvbnRyb2wsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSBmb3JtU3RhdGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsaWRhdG9yXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGFzeW5jVmFsaWRhdG9yXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBGb3JtQ29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmb3JtU3RhdGUgPT09IHZvaWQgMCkgeyBmb3JtU3RhdGUgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjb2VyY2VUb1ZhbGlkYXRvcih2YWxpZGF0b3IpLCBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKGFzeW5jVmFsaWRhdG9yKSk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlGb3JtU3RhdGUoZm9ybVN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGZvcm0gY29udHJvbCB0byBgdmFsdWVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgb25seVNlbGZgIGlzIGB0cnVlYCwgdGhpcyBjaGFuZ2Ugd2lsbCBvbmx5IGFmZmVjdCB0aGUgdmFsaWRhdGlvbiBvZiB0aGlzIGBGb3JtQ29udHJvbGBcbiAgICAgICAgICogYW5kIG5vdCBpdHMgcGFyZW50IGNvbXBvbmVudC4gVGhpcyBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGVtaXRFdmVudGAgaXMgYHRydWVgLCB0aGlzXG4gICAgICAgICAqIGNoYW5nZSB3aWxsIGNhdXNlIGEgYHZhbHVlQ2hhbmdlc2AgZXZlbnQgb24gdGhlIGBGb3JtQ29udHJvbGAgdG8gYmUgZW1pdHRlZC4gVGhpcyBkZWZhdWx0c1xuICAgICAgICAgKiB0byB0cnVlIChhcyBpdCBmYWxscyB0aHJvdWdoIHRvIGB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5YCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIGB0cnVlYCwgdGhlIHZpZXcgd2lsbCBiZSBub3RpZmllZCBhYm91dCB0aGUgbmV3IHZhbHVlXG4gICAgICAgICAqIHZpYSBhbiBgb25DaGFuZ2VgIGV2ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIG5vdFxuICAgICAgICAgKiBzcGVjaWZpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0Vmlld1RvTW9kZWxDaGFuZ2VgIGlzIGB0cnVlYCwgYW4gbmdNb2RlbENoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIHRvIHVwZGF0ZSB0aGVcbiAgICAgICAgICogbW9kZWwuICBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIGBlbWl0Vmlld1RvTW9kZWxDaGFuZ2VgIGlzIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudCwgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlID0gX2IuZW1pdE1vZGVsVG9WaWV3Q2hhbmdlLCBlbWl0Vmlld1RvTW9kZWxDaGFuZ2UgPSBfYi5lbWl0Vmlld1RvTW9kZWxDaGFuZ2U7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlLmxlbmd0aCAmJiBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlRm4pIHsgcmV0dXJuIGNoYW5nZUZuKF90aGlzLl92YWx1ZSwgZW1pdFZpZXdUb01vZGVsQ2hhbmdlICE9PSBmYWxzZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGNoZXMgdGhlIHZhbHVlIG9mIGEgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBmdW5jdGlvbmFsbHkgdGhlIHNhbWUgYXMge1xcQGxpbmsgRm9ybUNvbnRyb2wuc2V0VmFsdWV9IGF0IHRoaXMgbGV2ZWwuXG4gICAgICAgICAqIEl0IGV4aXN0cyBmb3Igc3ltbWV0cnkgd2l0aCB7XFxAbGluayBGb3JtR3JvdXAucGF0Y2hWYWx1ZX0gb24gYEZvcm1Hcm91cHNgIGFuZCBgRm9ybUFycmF5c2AsXG4gICAgICAgICAqIHdoZXJlIGl0IGRvZXMgYmVoYXZlIGRpZmZlcmVudGx5LlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGZvcm0gY29udHJvbC4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGl0IGlzIG1hcmtlZCBhcyBgcHJpc3RpbmVgXG4gICAgICAgICAqICogaXQgaXMgbWFya2VkIGFzIGB1bnRvdWNoZWRgXG4gICAgICAgICAqICogdmFsdWUgaXMgc2V0IHRvIG51bGxcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIHRocm91Z2ggYSBzdGFuZGFsb25lXG4gICAgICAgICAqIHZhbHVlIG9yIGEgZm9ybSBzdGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdGVcbiAgICAgICAgICogKHRoZXNlIGFyZSB0aGUgb25seSB0d28gcHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBjYWxjdWxhdGVkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogRXg6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuY29udHJvbC5yZXNldCgnTmFuY3knKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5jb250cm9sLnZhbHVlKTsgIC8vICdOYW5jeSdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIE9SXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmNvbnRyb2wucmVzZXQoe3ZhbHVlOiAnTmFuY3knLCBkaXNhYmxlZDogdHJ1ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wudmFsdWUpOyAgLy8gJ05hbmN5J1xuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGZvcm1TdGF0ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChmb3JtU3RhdGUsIF9hKSB7XG4gICAgICAgICAgICBpZiAoZm9ybVN0YXRlID09PSB2b2lkIDApIHsgZm9ybVN0YXRlID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Rm9ybVN0YXRlKGZvcm1TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLm1hcmtBc1ByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5tYXJrQXNVbnRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlLCB7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hbGxDb250cm9sc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXNhYmxlZDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGNoYW5nZSBldmVudHMuXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlLnB1c2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fY2xlYXJDaGFuZ2VGbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgZGlzYWJsZWQgZXZlbnRzLlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVnaXN0ZXJPbkRpc2FibGVkQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLnB1c2goZm4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm9ybVN0YXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2FwcGx5Rm9ybVN0YXRlID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQm94ZWRWYWx1ZShmb3JtU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtU3RhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgZm9ybVN0YXRlLmRpc2FibGVkID8gdGhpcy5kaXNhYmxlKHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQ29udHJvbDtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdGUgb2YgYSBncm91cCBvZiB7XFxAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBBIGBGb3JtR3JvdXBgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNoaWxkIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnRvIG9uZSBvYmplY3QsXG4gICAgICogd2l0aCBlYWNoIGNvbnRyb2wgbmFtZSBhcyB0aGUga2V5LiAgSXQgY2FsY3VsYXRlcyBpdHMgc3RhdHVzIGJ5IHJlZHVjaW5nIHRoZSBzdGF0dXNlc1xuICAgICAqIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZiB0aGUgY29udHJvbHMgaW4gYSBncm91cCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlXG4gICAgICogZ3JvdXAgYmVjb21lcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogYEZvcm1Hcm91cGAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAgICAgKiBhbG9uZyB3aXRoIHtcXEBsaW5rIEZvcm1Db250cm9sfSBhbmQge1xcQGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7XFxAbGluayBGb3JtR3JvdXB9LCBwYXNzIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZCBjb250cm9scyBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gVGhlIGtleSBmb3IgZWFjaCBjaGlsZCB3aWxsIGJlIHRoZSBuYW1lIHVuZGVyIHdoaWNoIGl0IGlzIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnKSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDsgJ0RyZXcnfVxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0uc3RhdHVzKTsgIC8vICdWQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbmNsdWRlIGdyb3VwLWxldmVsIHZhbGlkYXRvcnMgYXMgdGhlIHNlY29uZCBhcmcsIG9yIGdyb3VwLWxldmVsIGFzeW5jXG4gICAgICogdmFsaWRhdG9ycyBhcyB0aGUgdGhpcmQgYXJnLiBUaGVzZSBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gcGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICogICBwYXNzd29yZDogbmV3IEZvcm1Db250cm9sKCcnLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBwYXNzd29yZENvbmZpcm06IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqIH0sIHBhc3N3b3JkTWF0Y2hWYWxpZGF0b3IpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBwYXNzd29yZE1hdGNoVmFsaWRhdG9yKGc6IEZvcm1Hcm91cCkge1xuICAgICAqICAgIHJldHVybiBnLmdldCgncGFzc3dvcmQnKS52YWx1ZSA9PT0gZy5nZXQoJ3Bhc3N3b3JkQ29uZmlybScpLnZhbHVlXG4gICAgICogICAgICAgPyBudWxsIDogeydtaXNtYXRjaCc6IHRydWV9O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihGb3JtR3JvdXAsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xzXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbGlkYXRvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBhc3luY1ZhbGlkYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwKGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGNvbnRyb2wgd2l0aCB0aGUgZ3JvdXAncyBsaXN0IG9mIGNvbnRyb2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1cGRhdGUgdmFsdWUgb3IgdmFsaWRpdHkgb2YgdGhlIGNvbnRyb2wsIHNvIGZvclxuICAgICAgICAgKiBtb3N0IGNhc2VzIHlvdSdsbCB3YW50IHRvIHVzZSB7XFxAbGluayBGb3JtR3JvdXAuYWRkQ29udHJvbH0gaW5zdGVhZC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZWdpc3RlckNvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdID0gY29udHJvbDtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UodGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgY29udHJvbCB0byB0aGlzIGdyb3VwLlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckNvbnRyb2wobmFtZSwgY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGEgY29udHJvbCBmcm9tIHRoaXMgZ3JvdXAuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW25hbWVdKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgY29udHJvbC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5zZXRDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW25hbWVdKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckNvbnRyb2wobmFtZSwgY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGVyZSBpcyBhbiBlbmFibGVkIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBkaXNhYmxlZCBjb250cm9scy4gSWYgeW91J2QgbGlrZSB0byBjaGVjayBmb3JcbiAgICAgICAgICogZXhpc3RlbmNlIGluIHRoZSBncm91cCBvbmx5LCB1c2Uge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gaW5zdGVhZC5cbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sTmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMuaGFzT3duUHJvcGVydHkoY29udHJvbE5hbWUpICYmIHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHtcXEBsaW5rIEZvcm1Hcm91cH0uIEl0IGFjY2VwdHMgYW4gb2JqZWN0IHRoYXQgbWF0Y2hlc1xuICAgICAgICAgKiAgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ3JvdXAsIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBzdHJpY3QgY2hlY2tzLCBzbyBpdCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnlcbiAgICAgICAgICogdG8gc2V0IHRoZSB2YWx1ZSBvZiBhIGNvbnRyb2wgdGhhdCBkb2Vzbid0IGV4aXN0IG9yIGlmIHlvdSBleGNsdWRlIHRoZVxuICAgICAgICAgKiB2YWx1ZSBvZiBhIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICAgICAqICAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKCksXG4gICAgICAgICAqICAgICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAgICAgKiAgfSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6IG51bGwsIGxhc3Q6IG51bGx9XG4gICAgICAgICAqXG4gICAgICAgICAqICBmb3JtLnNldFZhbHVlKHtmaXJzdDogJ05hbmN5JywgbGFzdDogJ0RyZXcnfSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q6ICdEcmV3J31cbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50KHZhbHVlKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rocm93SWZDb250cm9sTWlzc2luZyhuYW1lKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sc1tuYW1lXS5zZXRWYWx1ZSh2YWx1ZVtuYW1lXSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUGF0Y2hlcyB0aGUgdmFsdWUgb2YgdGhlIHtcXEBsaW5rIEZvcm1Hcm91cH0uIEl0IGFjY2VwdHMgYW4gb2JqZWN0IHdpdGggY29udHJvbFxuICAgICAgICAgKiAgbmFtZXMgYXMga2V5cywgYW5kIHdpbGwgZG8gaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdCBjb250cm9sc1xuICAgICAgICAgKiAgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgSXQgYWNjZXB0cyBib3RoIHN1cGVyLXNldHMgYW5kIHN1Yi1zZXRzIG9mIHRoZSBncm91cCB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgKiAgICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIH0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgZm9ybS5wYXRjaFZhbHVlKHtmaXJzdDogJ05hbmN5J30pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2xzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2xzW25hbWVdLnBhdGNoVmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUge1xcQGxpbmsgRm9ybUdyb3VwfS4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBncm91cCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIFRoZSBncm91cCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiBUaGUgdmFsdWUgb2YgYWxsIGRlc2NlbmRhbnRzIHdpbGwgYmUgbnVsbCBvciBudWxsIG1hcHNcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIGluIGEgbWFwIG9mIHN0YXRlc1xuICAgICAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB5b3VyIGZvcm0sIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLiBUaGUgc3RhdGVcbiAgICAgICAgICogY2FuIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZSBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkXG4gICAgICAgICAqIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5mb3JtLnJlc2V0KHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ30pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmZvcm0udmFsdWUpOyAgLy8ge2ZpcnN0OiAnbmFtZScsIGxhc3Q6ICdsYXN0IG5hbWUnfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBPUiAtXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmZvcm0ucmVzZXQoe1xuICAgICAgICAgKiAgIGZpcnN0OiB7dmFsdWU6ICduYW1lJywgZGlzYWJsZWQ6IHRydWV9LFxuICAgICAgICAgKiAgIGxhc3Q6ICdsYXN0J1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLnZhbHVlKTsgIC8vIHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ31cbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLmdldCgnZmlyc3QnKS5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB7fTsgfVxuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzZXQodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUge1xcQGxpbmsgRm9ybUdyb3VwfSwgaW5jbHVkaW5nIGFueSBkaXNhYmxlZCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91J2QgbGlrZSB0byBpbmNsdWRlIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMsIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyB0aGUgYmVzdCB3YXkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ3JvdXAuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLmdldFJhd1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKHt9LCBmdW5jdGlvbiAoYWNjLCBjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbCBpbnN0YW5jZW9mIEZvcm1Db250cm9sID8gY29udHJvbC52YWx1ZSA6ICgoY29udHJvbCkpLmdldFJhd1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl90aHJvd0lmQ29udHJvbE1pc3NpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICAgIFRoZXJlIGFyZSBubyBmb3JtIGNvbnRyb2xzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGdyb3VwIHlldC4gIElmIHlvdSdyZSB1c2luZyBuZ01vZGVsLFxcbiAgICAgICAgeW91IG1heSB3YW50IHRvIGNoZWNrIG5leHQgdGljayAoZS5nLiB1c2Ugc2V0VGltZW91dCkuXFxuICAgICAgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgZm9ybSBjb250cm9sIHdpdGggbmFtZTogXCIgKyBuYW1lICsgXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb250cm9scykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gY2IoX3RoaXMuY29udHJvbHNba10sIGspOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9zZXRVcENvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KF90aGlzKTtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShfdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWx1ZSA9IHRoaXMuX3JlZHVjZVZhbHVlKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMgfHwgKF90aGlzLmNvbnRhaW5zKG5hbWUpICYmIGNvbmRpdGlvbihjb250cm9sKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKHt9LCBmdW5jdGlvbiAoYWNjLCBjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZCB8fCBfdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSBjb250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGluaXRWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9yZWR1Y2VDaGlsZHJlbiA9IGZ1bmN0aW9uIChpbml0VmFsdWUsIGZuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBpbml0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHsgcmVzID0gZm4ocmVzLCBjb250cm9sLCBuYW1lKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXModGhpcy5jb250cm9scyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xOYW1lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2NvbnRyb2xOYW1lXS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb250cm9scykubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgd2l0aCBuYW1lOiAnXCIgKyBuYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Hcm91cDtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdGUgb2YgYW4gYXJyYXkgb2Yge1xcQGxpbmsgRm9ybUNvbnRyb2x9LFxuICAgICAqIHtcXEBsaW5rIEZvcm1Hcm91cH0gb3Ige1xcQGxpbmsgRm9ybUFycmF5fSBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBBIGBGb3JtQXJyYXlgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNoaWxkIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnRvIGFuIGFycmF5LlxuICAgICAqIEl0IGNhbGN1bGF0ZXMgaXRzIHN0YXR1cyBieSByZWR1Y2luZyB0aGUgc3RhdHVzZXMgb2YgaXRzIGNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgaWYgb25lIG9mXG4gICAgICogdGhlIGNvbnRyb2xzIGluIGEgYEZvcm1BcnJheWAgaXMgaW52YWxpZCwgdGhlIGVudGlyZSBhcnJheSBiZWNvbWVzIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBgRm9ybUFycmF5YCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICAgICAqIGFsb25nIHdpdGgge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGFuZCB7XFxAbGluayBGb3JtR3JvdXB9LlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFdoZW4gaW5zdGFudGlhdGluZyBhIHtcXEBsaW5rIEZvcm1BcnJheX0sIHBhc3MgaW4gYW4gYXJyYXkgb2YgY2hpbGQgY29udHJvbHMgYXMgdGhlIGZpcnN0XG4gICAgICogYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICogICBuZXcgRm9ybUNvbnRyb2woJ05hbmN5JywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgbmV3IEZvcm1Db250cm9sKCdEcmV3JyksXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCAnRHJldyddXG4gICAgICogY29uc29sZS5sb2coYXJyLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5jbHVkZSBhcnJheS1sZXZlbCB2YWxpZGF0b3JzIGFzIHRoZSBzZWNvbmQgYXJnLCBvciBhcnJheS1sZXZlbCBhc3luY1xuICAgICAqIHZhbGlkYXRvcnMgYXMgdGhlIHRoaXJkIGFyZy4gVGhlc2UgY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAqIHRoYXQgY29uc2lkZXJzIHRoZSB2YWx1ZSBvZiBtb3JlIHRoYW4gb25lIGNoaWxkIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiAjIyMgQWRkaW5nIG9yIHJlbW92aW5nIGNvbnRyb2xzXG4gICAgICpcbiAgICAgKiBUbyBjaGFuZ2UgdGhlIGNvbnRyb2xzIGluIHRoZSBhcnJheSwgdXNlIHRoZSBgcHVzaGAsIGBpbnNlcnRgLCBvciBgcmVtb3ZlQXRgIG1ldGhvZHNcbiAgICAgKiBpbiBgRm9ybUFycmF5YCBpdHNlbGYuIFRoZXNlIG1ldGhvZHMgZW5zdXJlIHRoZSBjb250cm9scyBhcmUgcHJvcGVybHkgdHJhY2tlZCBpbiB0aGVcbiAgICAgKiBmb3JtJ3MgaGllcmFyY2h5LiBEbyBub3QgbW9kaWZ5IHRoZSBhcnJheSBvZiBgQWJzdHJhY3RDb250cm9sYHMgdXNlZCB0byBpbnN0YW50aWF0ZVxuICAgICAqIHRoZSBgRm9ybUFycmF5YCBkaXJlY3RseSwgYXMgdGhhdCB3aWxsIHJlc3VsdCBpbiBzdHJhbmdlIGFuZCB1bmV4cGVjdGVkIGJlaGF2aW9yIHN1Y2hcbiAgICAgKiBhcyBicm9rZW4gY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQXJyYXkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihGb3JtQXJyYXksIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xzXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbGlkYXRvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBhc3luY1ZhbGlkYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9ybUFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHNbaW5kZXhdOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGEgbmV3IHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMucHVzaChjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgYSBuZXcge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgY29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoaW5kZXgsIDAsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgY29udHJvbCBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucmVtb3ZlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2luZGV4XSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2luZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlIGFuIGV4aXN0aW5nIGNvbnRyb2wuXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnNldENvbnRyb2wgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2luZGV4XSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2luZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoaW5kZXgsIDAsIGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXkucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlbmd0aCBvZiB0aGUgY29udHJvbCBhcnJheS5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9scy5sZW5ndGg7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSB7XFxAbGluayBGb3JtQXJyYXl9LiBJdCBhY2NlcHRzIGFuIGFycmF5IHRoYXQgbWF0Y2hlc1xuICAgICAgICAgKiAgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgc3RyaWN0IGNoZWNrcywgc28gaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5XG4gICAgICAgICAqIHRvIHNldCB0aGUgdmFsdWUgb2YgYSBjb250cm9sIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICBdKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gW251bGwsIG51bGxdXG4gICAgICAgICAqXG4gICAgICAgICAqICBhcnIuc2V0VmFsdWUoWydOYW5jeScsICdEcmV3J10pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rocm93SWZDb250cm9sTWlzc2luZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLnNldFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUge1xcQGxpbmsgRm9ybUFycmF5fS4gSXQgYWNjZXB0cyBhbiBhcnJheSB0aGF0IG1hdGNoZXMgdGhlXG4gICAgICAgICAqICBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wsIGFuZCB3aWxsIGRvIGl0cyBiZXN0IHRvIG1hdGNoIHRoZSB2YWx1ZXMgdG8gdGhlIGNvcnJlY3RcbiAgICAgICAgICogIGNvbnRyb2xzIGluIHRoZSBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgYXJyYXkgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKCksXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAgICAgKiAgXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFtudWxsLCBudWxsXVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYXJyLnBhdGNoVmFsdWUoWydOYW5jeSddKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gWydOYW5jeScsIG51bGxdXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucGF0Y2hWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkucGF0Y2hWYWx1ZShuZXdWYWx1ZSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSB7XFxAbGluayBGb3JtQXJyYXl9LiBUaGlzIG1lYW5zIGJ5IGRlZmF1bHQ6XG4gICAgICAgICAqXG4gICAgICAgICAqICogVGhlIGFycmF5IGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgcHJpc3RpbmVgXG4gICAgICAgICAqICogVGhlIGFycmF5IGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgdW50b3VjaGVkYFxuICAgICAgICAgKiAqIFRoZSB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgd2lsbCBiZSBudWxsIG9yIG51bGwgbWFwc1xuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc3RhdGVzXG4gICAgICAgICAqIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLiBUaGUgc3RhdGUgY2FuIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZVxuICAgICAgICAgKiBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5hcnIucmVzZXQoWyduYW1lJywgJ2xhc3QgbmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5hcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIE9SIC1cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHRoaXMuYXJyLnJlc2V0KFtcbiAgICAgICAgICogICB7dmFsdWU6ICduYW1lJywgZGlzYWJsZWQ6IHRydWV9LFxuICAgICAgICAgKiAgICdsYXN0J1xuICAgICAgICAgKiBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5hcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLmdldCgwKS5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX18xXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBbXTsgfVxuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc2V0KHZhbHVlW2luZGV4XSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWdncmVnYXRlIHZhbHVlIG9mIHRoZSBhcnJheSwgaW5jbHVkaW5nIGFueSBkaXNhYmxlZCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91J2QgbGlrZSB0byBpbmNsdWRlIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMsIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyB0aGUgYmVzdCB3YXkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmdldFJhd1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMubWFwKGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCA/IGNvbnRyb2wudmFsdWUgOiAoKGNvbnRyb2wpKS5nZXRSYXdWYWx1ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl90aHJvd0lmQ29udHJvbE1pc3NpbmcgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9scy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICAgIFRoZXJlIGFyZSBubyBmb3JtIGNvbnRyb2xzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGFycmF5IHlldC4gIElmIHlvdSdyZSB1c2luZyBuZ01vZGVsLFxcbiAgICAgICAgeW91IG1heSB3YW50IHRvIGNoZWNrIG5leHQgdGljayAoZS5nLiB1c2Ugc2V0VGltZW91dCkuXFxuICAgICAgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmF0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZvcm0gY29udHJvbCBhdCBpbmRleCBcIiArIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sLCBpbmRleCkgeyBjYihjb250cm9sLCBpbmRleCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5jb250cm9scy5maWx0ZXIoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZW5hYmxlZCB8fCBfdGhpcy5kaXNhYmxlZDsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnZhbHVlOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLnNvbWUoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZW5hYmxlZCAmJiBjb25kaXRpb24oY29udHJvbCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3NldFVwQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgYSB2YWx1ZSBmb3IgZm9ybSBjb250cm9sIGF0IGluZGV4OiBcIiArIGkgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNvbnRyb2xzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmVuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmxlbmd0aCA+IDAgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fcmVnaXN0ZXJDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UodGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1BcnJheTtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvcm1EaXJlY3RpdmVQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0Zvcm07IH0pXG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBDcmVhdGVzIGEgdG9wLWxldmVsIHtcXEBsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgYW5kIGJpbmRzIGl0IHRvIGEgZm9ybVxuICAgICAqIHRvIHRyYWNrIGFnZ3JlZ2F0ZSBmb3JtIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBBcyBzb29uIGFzIHlvdSBpbXBvcnQgdGhlIGBGb3Jtc01vZHVsZWAsIHRoaXMgZGlyZWN0aXZlIGJlY29tZXMgYWN0aXZlIGJ5IGRlZmF1bHQgb25cbiAgICAgKiBhbGwgYDxmb3JtPmAgdGFncy4gIFlvdSBkb24ndCBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdGb3JtYCBhcyB0aGUga2V5XG4gICAgICogKGV4OiBgI215Rm9ybT1cIm5nRm9ybVwiYCkuIFRoaXMgaXMgb3B0aW9uYWwsIGJ1dCB1c2VmdWwuICBNYW55IHByb3BlcnRpZXMgZnJvbSB0aGUgdW5kZXJseWluZ1xuICAgICAqIHtcXEBsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgYXJlIGR1cGxpY2F0ZWQgb24gdGhlIGRpcmVjdGl2ZSBpdHNlbGYsIHNvIGEgcmVmZXJlbmNlIHRvIGl0XG4gICAgICogd2lsbCBnaXZlIHlvdSBhY2Nlc3MgdG8gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdHVzIG9mIHRoZSBmb3JtLCBhcyB3ZWxsIGFzXG4gICAgICogdXNlciBpbnRlcmFjdGlvbiBwcm9wZXJ0aWVzIGxpa2UgYGRpcnR5YCBhbmQgYHRvdWNoZWRgLlxuICAgICAqXG4gICAgICogVG8gcmVnaXN0ZXIgY2hpbGQgY29udHJvbHMgd2l0aCB0aGUgZm9ybSwgeW91J2xsIHdhbnQgdG8gdXNlIHtcXEBsaW5rIE5nTW9kZWx9IHdpdGggYVxuICAgICAqIGBuYW1lYCBhdHRyaWJ1dGUuICBZb3UgY2FuIGFsc28gdXNlIHtcXEBsaW5rIE5nTW9kZWxHcm91cH0gaWYgeW91J2QgbGlrZSB0byBjcmVhdGVcbiAgICAgKiBzdWItZ3JvdXBzIHdpdGhpbiB0aGUgZm9ybS5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gbGlzdGVuIHRvIHRoZSBkaXJlY3RpdmUncyBgbmdTdWJtaXRgIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHVzZXIgaGFzXG4gICAgICogdHJpZ2dlcmVkIGEgZm9ybSBzdWJtaXNzaW9uLiBUaGUgYG5nU3VibWl0YCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgZm9ybVxuICAgICAqIHN1Ym1pc3Npb24gZXZlbnQuXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtL3NpbXBsZV9mb3JtX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdGb3JtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoTmdGb3JtLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN5bmNWYWxpZGF0b3JzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ0Zvcm0odmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9XG4gICAgICAgICAgICAgICAgbmV3IEZvcm1Hcm91cCh7fSwgY29tcG9zZVZhbGlkYXRvcnModmFsaWRhdG9ycyksIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwic3VibWl0dGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdWJtaXR0ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJjb250cm9sc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtLmNvbnRyb2xzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBkaXIuX2NvbnRyb2wgPSAoY29udGFpbmVyLnJlZ2lzdGVyQ29udHJvbChkaXIubmFtZSwgZGlyLmNvbnRyb2wpKTtcbiAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2woZGlyLmNvbnRyb2wsIGRpcik7XG4gICAgICAgICAgICAgICAgZGlyLmNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAodGhpcy5mb3JtLmdldChkaXIucGF0aCkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuYWRkRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICAgICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoZ3JvdXAsIGRpcik7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyQ29udHJvbChkaXIubmFtZSwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIGdyb3VwLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5yZW1vdmVGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDb250cm9sKGRpci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmdldEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICh0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnVwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKGRpciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RybCA9IChfdGhpcy5mb3JtLmdldChkaXIucGF0aCkpO1xuICAgICAgICAgICAgICAgIGN0cmwuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuY29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99ICRldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5vblN1Ym1pdCA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLm9uUmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMucmVzZXRGb3JtKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5yZXNldEZvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICB0aGlzLmZvcm0ucmVzZXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHBhdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuX2ZpbmRDb250YWluZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA/ICh0aGlzLmZvcm0uZ2V0KHBhdGgpKSA6IHRoaXMuZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmb3JtOm5vdChbbmdOb0Zvcm1dKTpub3QoW2Zvcm1Hcm91cF0pLG5nRm9ybSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKHN1Ym1pdCknOiAnb25TdWJtaXQoJGV2ZW50KScsICcocmVzZXQpJzogJ29uUmVzZXQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbmdTdWJtaXQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nRm9ybS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIE5nRm9ybTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBFeGFtcGxlcyA9IHtcbiAgICAgICAgZm9ybUNvbnRyb2xOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICA8aW5wdXQgZm9ybUNvbnRyb2xOYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgSW4geW91ciBjbGFzczpcXG5cXG4gICAgdGhpcy5teUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgIGZpcnN0TmFtZTogbmV3IEZvcm1Db250cm9sKClcXG4gICAgfSk7XCIsXG4gICAgICAgIGZvcm1Hcm91cE5hbWU6IFwiXFxuICAgIDxkaXYgW2Zvcm1Hcm91cF09XFxcIm15R3JvdXBcXFwiPlxcbiAgICAgICA8ZGl2IGZvcm1Hcm91cE5hbWU9XFxcInBlcnNvblxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgSW4geW91ciBjbGFzczpcXG5cXG4gICAgdGhpcy5teUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgIHBlcnNvbjogbmV3IEZvcm1Hcm91cCh7IGZpcnN0TmFtZTogbmV3IEZvcm1Db250cm9sKCkgfSlcXG4gICAgfSk7XCIsXG4gICAgICAgIGZvcm1BcnJheU5hbWU6IFwiXFxuICAgIDxkaXYgW2Zvcm1Hcm91cF09XFxcIm15R3JvdXBcXFwiPlxcbiAgICAgIDxkaXYgZm9ybUFycmF5TmFtZT1cXFwiY2l0aWVzXFxcIj5cXG4gICAgICAgIDxkaXYgKm5nRm9yPVxcXCJsZXQgY2l0eSBvZiBjaXR5QXJyYXkuY29udHJvbHM7IGxldCBpPWluZGV4XFxcIj5cXG4gICAgICAgICAgPGlucHV0IFtmb3JtQ29udHJvbE5hbWVdPVxcXCJpXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgSW4geW91ciBjbGFzczpcXG5cXG4gICAgdGhpcy5jaXR5QXJyYXkgPSBuZXcgRm9ybUFycmF5KFtuZXcgRm9ybUNvbnRyb2woJ1NGJyldKTtcXG4gICAgdGhpcy5teUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgY2l0aWVzOiB0aGlzLmNpdHlBcnJheVxcbiAgICB9KTtcIixcbiAgICAgICAgbmdNb2RlbEdyb3VwOiBcIlxcbiAgICA8Zm9ybT5cXG4gICAgICAgPGRpdiBuZ01vZGVsR3JvdXA9XFxcInBlcnNvblxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicGVyc29uLm5hbWVcXFwiIG5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDwvZGl2PlxcbiAgICA8L2Zvcm0+XCIsXG4gICAgICAgIG5nTW9kZWxXaXRoRm9ybUdyb3VwOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJzaG93TW9yZUNvbnRyb2xzXFxcIiBbbmdNb2RlbE9wdGlvbnNdPVxcXCJ7c3RhbmRhbG9uZTogdHJ1ZX1cXFwiPlxcbiAgICA8L2Rpdj5cXG4gIFwiXG4gICAgfTtcblxuICAgIHZhciBUZW1wbGF0ZURyaXZlbkVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlRHJpdmVuRXJyb3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsIGNhbm5vdCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGZvcm0gY29udHJvbHMgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgVHJ5IHVzaW5nXFxuICAgICAgZm9ybUdyb3VwJ3MgcGFydG5lciBkaXJlY3RpdmUgXFxcImZvcm1Db250cm9sTmFtZVxcXCIgaW5zdGVhZC4gIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtQ29udHJvbE5hbWUgKyBcIlxcblxcbiAgICAgIE9yLCBpZiB5b3UnZCBsaWtlIHRvIGF2b2lkIHJlZ2lzdGVyaW5nIHRoaXMgZm9ybSBjb250cm9sLCBpbmRpY2F0ZSB0aGF0IGl0J3Mgc3RhbmRhbG9uZSBpbiBuZ01vZGVsT3B0aW9uczpcXG5cXG4gICAgICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbFdpdGhGb3JtR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLmZvcm1Hcm91cE5hbWVFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsIGNhbm5vdCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGZvcm0gY29udHJvbHMgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXBOYW1lIG9yIGZvcm1BcnJheU5hbWUgZGlyZWN0aXZlLlxcblxcbiAgICAgIE9wdGlvbiAxOiBVc2UgZm9ybUNvbnRyb2xOYW1lIGluc3RlYWQgb2YgbmdNb2RlbCAocmVhY3RpdmUgc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgT3B0aW9uIDI6ICBVcGRhdGUgbmdNb2RlbCdzIHBhcmVudCBiZSBuZ01vZGVsR3JvdXAgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1pc3NpbmdOYW1lRXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgbmdNb2RlbCBpcyB1c2VkIHdpdGhpbiBhIGZvcm0gdGFnLCBlaXRoZXIgdGhlIG5hbWUgYXR0cmlidXRlIG11c3QgYmUgc2V0IG9yIHRoZSBmb3JtXFxuICAgICAgY29udHJvbCBtdXN0IGJlIGRlZmluZWQgYXMgJ3N0YW5kYWxvbmUnIGluIG5nTW9kZWxPcHRpb25zLlxcblxcbiAgICAgIEV4YW1wbGUgMTogPGlucHV0IFsobmdNb2RlbCldPVxcXCJwZXJzb24uZmlyc3ROYW1lXFxcIiBuYW1lPVxcXCJmaXJzdFxcXCI+XFxuICAgICAgRXhhbXBsZSAyOiA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInBlcnNvbi5maXJzdE5hbWVcXFwiIFtuZ01vZGVsT3B0aW9uc109XFxcIntzdGFuZGFsb25lOiB0cnVlfVxcXCI+XCIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsR3JvdXBQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsR3JvdXAgY2Fubm90IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLlxcblxcbiAgICAgIE9wdGlvbiAxOiBVc2UgZm9ybUdyb3VwTmFtZSBpbnN0ZWFkIG9mIG5nTW9kZWxHcm91cCAocmVhY3RpdmUgc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgT3B0aW9uIDI6ICBVc2UgYSByZWd1bGFyIGZvcm0gdGFnIGluc3RlYWQgb2YgdGhlIGZvcm1Hcm91cCBkaXJlY3RpdmUgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGVtcGxhdGVEcml2ZW5FcnJvcnM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2RlbEdyb3VwUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdNb2RlbEdyb3VwOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBDcmVhdGVzIGFuZCBiaW5kcyBhIHtcXEBsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGFzIGEgY2hpbGQgb2Yge1xcQGxpbmsgTmdGb3JtfSAob3IgaW4gb3RoZXIgd29yZHMsXG4gICAgICogd2l0aGluIGA8Zm9ybT5gIHRhZ3MpLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZGlyZWN0aXZlIGlmIHlvdSdkIGxpa2UgdG8gY3JlYXRlIGEgc3ViLWdyb3VwIHdpdGhpbiBhIGZvcm0uIFRoaXMgY2FuXG4gICAgICogY29tZSBpbiBoYW5keSBpZiB5b3Ugd2FudCB0byB2YWxpZGF0ZSBhIHN1Yi1ncm91cCBvZiB5b3VyIGZvcm0gc2VwYXJhdGVseSBmcm9tXG4gICAgICogdGhlIHJlc3Qgb2YgeW91ciBmb3JtLCBvciBpZiBzb21lIHZhbHVlcyBpbiB5b3VyIGRvbWFpbiBtb2RlbCBtYWtlIG1vcmUgc2Vuc2UgdG9cbiAgICAgKiBjb25zdW1lIHRvZ2V0aGVyIGluIGEgbmVzdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFBhc3MgaW4gdGhlIG5hbWUgeW91J2QgbGlrZSB0aGlzIHN1Yi1ncm91cCB0byBoYXZlIGFuZCBpdCB3aWxsIGJlY29tZSB0aGUga2V5XG4gICAgICogZm9yIHRoZSBzdWItZ3JvdXAgaW4gdGhlIGZvcm0ncyBmdWxsIHZhbHVlLiBZb3UgY2FuIGFsc28gZXhwb3J0IHRoZSBkaXJlY3RpdmUgaW50b1xuICAgICAqIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmcgYG5nTW9kZWxHcm91cGAgKGV4OiBgI215R3JvdXA9XCJuZ01vZGVsR3JvdXBcImApLlxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvbmdNb2RlbEdyb3VwL25nX21vZGVsX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ01vZGVsR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChOZ01vZGVsR3JvdXAsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3luY1ZhbGlkYXRvcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kZWxHcm91cChwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWxHcm91cC5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ0Zvcm0pKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxHcm91cFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsR3JvdXAuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nTW9kZWxHcm91cF0nLCBwcm92aWRlcnM6IFttb2RlbEdyb3VwUHJvdmlkZXJdLCBleHBvcnRBczogJ25nTW9kZWxHcm91cCcgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ01vZGVsR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIE5nTW9kZWxHcm91cC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ01vZGVsR3JvdXAnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdNb2RlbEdyb3VwO1xuICAgIH0oQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3JtQ29udHJvbEJpbmRpbmcgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ01vZGVsOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogYG5nTW9kZWxgIGZvcmNlcyBhbiBhZGRpdGlvbmFsIGNoYW5nZSBkZXRlY3Rpb24gcnVuIHdoZW4gaXRzIGlucHV0cyBjaGFuZ2U6XG4gICAgICogRS5nLjpcbiAgICAgKiBgYGBcbiAgICAgKiA8ZGl2Pnt7bXlNb2RlbC52YWxpZH19PC9kaXY+XG4gICAgICogPGlucHV0IFsobmdNb2RlbCldPVwibXlWYWx1ZVwiICNteU1vZGVsPVwibmdNb2RlbFwiPlxuICAgICAqIGBgYFxuICAgICAqIEkuZS4gYG5nTW9kZWxgIGNhbiBleHBvcnQgaXRzZWxmIG9uIHRoZSBlbGVtZW50IGFuZCB0aGVuIGJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLlxuICAgICAqIE5vcm1hbGx5LCB0aGlzIHdvdWxkIHJlc3VsdCBpbiBleHByZXNzaW9ucyBiZWZvcmUgdGhlIGBpbnB1dGAgdGhhdCB1c2UgdGhlIGV4cG9ydGVkIGRpcmVjdGl2ZVxuICAgICAqIHRvIGhhdmUgYW5kIG9sZCB2YWx1ZSBhcyB0aGV5IGhhdmUgYmVlblxuICAgICAqIGRpcnR5IGNoZWNrZWQgYmVmb3JlLiBBcyB0aGlzIGlzIGEgdmVyeSBjb21tb24gY2FzZSBmb3IgYG5nTW9kZWxgLCB3ZSBhZGRlZCB0aGlzIHNlY29uZCBjaGFuZ2VcbiAgICAgKiBkZXRlY3Rpb24gcnVuLlxuICAgICAqXG4gICAgICogTm90ZXM6XG4gICAgICogLSB0aGlzIGlzIGp1c3Qgb25lIGV4dHJhIHJ1biBubyBtYXR0ZXIgaG93IG1hbnkgYG5nTW9kZWxgIGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAqIC0gdGhpcyBpcyBhIGdlbmVyYWwgcHJvYmxlbSB3aGVuIHVzaW5nIGBleHBvcnRBc2AgZm9yIGRpcmVjdGl2ZXMhXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm9taXNlJDEgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBDcmVhdGVzIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIGZyb20gYSBkb21haW4gbW9kZWwgYW5kIGJpbmRzIGl0XG4gICAgICogdG8gYSBmb3JtIGNvbnRyb2wgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFRoZSB7XFxAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2Ugd2lsbCB0cmFjayB0aGUgdmFsdWUsIHVzZXIgaW50ZXJhY3Rpb24sIGFuZFxuICAgICAqIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sIGFuZCBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSBtb2RlbC4gSWYgdXNlZFxuICAgICAqIHdpdGhpbiBhIHBhcmVudCBmb3JtLCB0aGUgZGlyZWN0aXZlIHdpbGwgYWxzbyByZWdpc3RlciBpdHNlbGYgd2l0aCB0aGUgZm9ybSBhcyBhIGNoaWxkXG4gICAgICogY29udHJvbC5cbiAgICAgKlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBieSBpdHNlbGYgb3IgYXMgcGFydCBvZiBhIGxhcmdlciBmb3JtLiBBbGwgeW91IG5lZWQgaXMgdGhlXG4gICAgICogYG5nTW9kZWxgIHNlbGVjdG9yIHRvIGFjdGl2YXRlIGl0LlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyBhIGRvbWFpbiBtb2RlbCBhcyBhbiBvcHRpb25hbCB7XFxAbGluayBcXEBJbnB1dH0uIElmIHlvdSBoYXZlIGEgb25lLXdheSBiaW5kaW5nXG4gICAgICogdG8gYG5nTW9kZWxgIHdpdGggYFtdYCBzeW50YXgsIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZG9tYWluIG1vZGVsIGluIHRoZSBjb21wb25lbnRcbiAgICAgKiBjbGFzcyB3aWxsIHNldCB0aGUgdmFsdWUgaW4gdGhlIHZpZXcuIElmIHlvdSBoYXZlIGEgdHdvLXdheSBiaW5kaW5nIHdpdGggYFsoKV1gIHN5bnRheFxuICAgICAqIChhbHNvIGtub3duIGFzICdiYW5hbmEtYm94IHN5bnRheCcpLCB0aGUgdmFsdWUgaW4gdGhlIFVJIHdpbGwgYWx3YXlzIGJlIHN5bmNlZCBiYWNrIHRvXG4gICAgICogdGhlIGRvbWFpbiBtb2RlbCBpbiB5b3VyIGNsYXNzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBpbnNwZWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhc3NvY2lhdGVkIHtcXEBsaW5rIEZvcm1Db250cm9sfSAobGlrZVxuICAgICAqIHZhbGlkaXR5IHN0YXRlKSwgeW91IGNhbiBhbHNvIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZ1xuICAgICAqIGBuZ01vZGVsYCBhcyB0aGUga2V5IChleDogYCNteVZhcj1cIm5nTW9kZWxcImApLiBZb3UgY2FuIHRoZW4gYWNjZXNzIHRoZSBjb250cm9sIHVzaW5nIHRoZVxuICAgICAqIGRpcmVjdGl2ZSdzIGBjb250cm9sYCBwcm9wZXJ0eSwgYnV0IG1vc3QgcHJvcGVydGllcyB5b3UnbGwgbmVlZCAobGlrZSBgdmFsaWRgIGFuZCBgZGlydHlgKVxuICAgICAqIHdpbGwgZmFsbCB0aHJvdWdoIHRvIHRoZSBjb250cm9sIGFueXdheSwgc28geW91IGNhbiBhY2Nlc3MgdGhlbSBkaXJlY3RseS4gWW91IGNhbiBzZWUgYVxuICAgICAqIGZ1bGwgbGlzdCBvZiBwcm9wZXJ0aWVzIGRpcmVjdGx5IGF2YWlsYWJsZSBpbiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBpcyBhbiBleGFtcGxlIG9mIGEgc2ltcGxlIHN0YW5kYWxvbmUgY29udHJvbCB1c2luZyBgbmdNb2RlbGA6XG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVOZ01vZGVsL3NpbXBsZV9uZ19tb2RlbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIGBuZ01vZGVsYCB3aXRoaW4gYDxmb3JtPmAgdGFncywgeW91J2xsIGFsc28gbmVlZCB0byBzdXBwbHkgYSBgbmFtZWAgYXR0cmlidXRlXG4gICAgICogc28gdGhhdCB0aGUgY29udHJvbCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBwYXJlbnQgZm9ybSB1bmRlciB0aGF0IG5hbWUuXG4gICAgICpcbiAgICAgKiBJdCdzIHdvcnRoIG5vdGluZyB0aGF0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGZvcm0sIHlvdSBvZnRlbiBjYW4gc2tpcCBvbmUtd2F5IG9yXG4gICAgICogdHdvLXdheSBiaW5kaW5nIGJlY2F1c2UgdGhlIHBhcmVudCBmb3JtIHdpbGwgc3luYyB0aGUgdmFsdWUgZm9yIHlvdS4gWW91IGNhbiBhY2Nlc3NcbiAgICAgKiBpdHMgcHJvcGVydGllcyBieSBleHBvcnRpbmcgaXQgaW50byBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ0Zvcm1gIChleDpcbiAgICAgKiBgI2Y9XCJuZ0Zvcm1cImApLiBUaGVuIHlvdSBjYW4gcGFzcyBpdCB3aGVyZSBpdCBuZWVkcyB0byBnbyBvbiBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZG8gbmVlZCB0byBwb3B1bGF0ZSBpbml0aWFsIHZhbHVlcyBpbnRvIHlvdXIgZm9ybSwgdXNpbmcgYSBvbmUtd2F5IGJpbmRpbmcgZm9yXG4gICAgICogYG5nTW9kZWxgIHRlbmRzIHRvIGJlIHN1ZmZpY2llbnQgYXMgbG9uZyBhcyB5b3UgdXNlIHRoZSBleHBvcnRlZCBmb3JtJ3MgdmFsdWUgcmF0aGVyXG4gICAgICogdGhhbiB0aGUgZG9tYWluIG1vZGVsJ3MgdmFsdWUgb24gc3VibWl0LlxuICAgICAqXG4gICAgICogVGFrZSBhIGxvb2sgYXQgYW4gZXhhbXBsZSBvZiB1c2luZyBgbmdNb2RlbGAgd2l0aGluIGEgZm9ybTpcbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm0vc2ltcGxlX2Zvcm1fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBUbyBzZWUgYG5nTW9kZWxgIGV4YW1wbGVzIHdpdGggZGlmZmVyZW50IGZvcm0gY29udHJvbCB0eXBlcywgc2VlOlxuICAgICAqXG4gICAgICogKiBSYWRpbyBidXR0b25zOiB7XFxAbGluayBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqICogU2VsZWN0czoge1xcQGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKipOZ01vZHVsZSoqOiBgRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiAgXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhOZ01vZGVsLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN5bmNWYWxpZGF0b3JzXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVBY2Nlc3NvcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kZWwocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvckVycm9ycygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWdpc3RlcmVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICAgICAgaWYgKCdpc0Rpc2FibGVkJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmZvcm1EaXJlY3RpdmUgJiYgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2wodGhpcyk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250cm9sOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpIDogW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fc2V0VXBDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5faXNTdGFuZGFsb25lKCkgPyB0aGlzLl9zZXRVcFN0YW5kYWxvbmUoKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5faXNTdGFuZGFsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9wYXJlbnQgfHwgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc3RhbmRhbG9uZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3NldFVwU3RhbmRhbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLl9jb250cm9sLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2NoZWNrRm9yRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tOYW1lKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLmZvcm1Hcm91cE5hbWVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nRm9ybSkpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5uYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSAmJiAhdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubWlzc2luZ05hbWVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSQxLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5jb250cm9sLnNldFZhbHVlKHZhbHVlLCB7IGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2UgfSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fdXBkYXRlRGlzYWJsZWQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpc2FibGVkVmFsdWUgPSBjaGFuZ2VzWydpc0Rpc2FibGVkJ10uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNEaXNhYmxlZCA9IGRpc2FibGVkVmFsdWUgPT09ICcnIHx8IChkaXNhYmxlZFZhbHVlICYmIGRpc2FibGVkVmFsdWUgIT09ICdmYWxzZScpO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgJiYgIV90aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbC5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0Rpc2FibGVkICYmIF90aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbC5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nTW9kZWxdOm5vdChbZm9ybUNvbnRyb2xOYW1lXSk6bm90KFtmb3JtQ29udHJvbF0pJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nTW9kZWwnXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdNb2RlbC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIE5nTW9kZWwucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbE9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdNb2RlbDtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgdmFyIFJlYWN0aXZlRXJyb3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVhY3RpdmVFcnJvcnMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5jb250cm9sUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUNvbnRyb2xOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxcblxcbiAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtQ29udHJvbE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLm5nTW9kZWxHcm91cEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Db250cm9sTmFtZSBjYW5ub3QgYmUgdXNlZCB3aXRoIGFuIG5nTW9kZWxHcm91cCBwYXJlbnQuIEl0IGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIHBhcmVudHNcXG4gICAgICAgdGhhdCBhbHNvIGhhdmUgYSBcXFwiZm9ybVxcXCIgcHJlZml4OiBmb3JtR3JvdXBOYW1lLCBmb3JtQXJyYXlOYW1lLCBvciBmb3JtR3JvdXAuXFxuXFxuICAgICAgIE9wdGlvbiAxOiAgVXBkYXRlIHRoZSBwYXJlbnQgdG8gYmUgZm9ybUdyb3VwTmFtZSAocmVhY3RpdmUgZm9ybSBzdHJhdGVneSlcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgICBPcHRpb24gMjogVXNlIG5nTW9kZWwgaW5zdGVhZCBvZiBmb3JtQ29udHJvbE5hbWUgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSlcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5taXNzaW5nRm9ybUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Hcm91cCBleHBlY3RzIGEgRm9ybUdyb3VwIGluc3RhbmNlLiBQbGVhc2UgcGFzcyBvbmUgaW4uXFxuXFxuICAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5ncm91cFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Hcm91cE5hbWUgbXVzdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFlvdSdsbCB3YW50IHRvIGFkZCBhIGZvcm1Hcm91cFxcbiAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cXG5cXG4gICAgICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuYXJyYXlQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtQXJyYXlOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxcblxcbiAgICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUFycmF5TmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlxcbiAgICAgIEl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgd2l0aCBhIHJlYWN0aXZlIGZvcm0gZGlyZWN0aXZlLiBJZiB5b3Ugc2V0IGRpc2FibGVkIHRvIHRydWVcXG4gICAgICB3aGVuIHlvdSBzZXQgdXAgdGhpcyBjb250cm9sIGluIHlvdXIgY29tcG9uZW50IGNsYXNzLCB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHdpbGwgYWN0dWFsbHkgYmUgc2V0IGluIHRoZSBET00gZm9yXFxuICAgICAgeW91LiBXZSByZWNvbW1lbmQgdXNpbmcgdGhpcyBhcHByb2FjaCB0byBhdm9pZCAnY2hhbmdlZCBhZnRlciBjaGVja2VkJyBlcnJvcnMuXFxuICAgICAgIFxcbiAgICAgIEV4YW1wbGU6IFxcbiAgICAgIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcXG4gICAgICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiAnTmFuY3knLCBkaXNhYmxlZDogdHJ1ZX0sIFZhbGlkYXRvcnMucmVxdWlyZWQpLFxcbiAgICAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdEcmV3JywgVmFsaWRhdG9ycy5yZXF1aXJlZClcXG4gICAgICB9KTtcXG4gICAgXCIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVhY3RpdmVFcnJvcnM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3JtQ29udHJvbEJpbmRpbmckMSA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Db250cm9sRGlyZWN0aXZlOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBTeW5jcyBhIHN0YW5kYWxvbmUge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIHRvIGEgZm9ybSBjb250cm9sIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgdGhpcyBkaXJlY3RpdmUgZW5zdXJlcyB0aGF0IGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2UgcHJvZ3JhbW1hdGljYWxseSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IChtb2RlbCAtPiB2aWV3KS4gQ29udmVyc2VseSxcbiAgICAgKiBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IHRocm91Z2ggdXNlciBpbnB1dCB3aWxsIGJlIHJlZmxlY3RlZCBpbiB0aGVcbiAgICAgKiB7XFxAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgKHZpZXcgLT4gbW9kZWwpLlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdGl2ZSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZSBhbmQgbWFuYWdlIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIGRpcmVjdGx5LlxuICAgICAqIFNpbXBseSBjcmVhdGUgYSB7XFxAbGluayBGb3JtQ29udHJvbH0sIHNhdmUgaXQgdG8geW91ciBjb21wb25lbnQgY2xhc3MsIGFuZCBwYXNzIGl0IGludG8gdGhlXG4gICAgICoge1xcQGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBhcyBhIHN0YW5kYWxvbmUgY29udHJvbC4gIFVubGlrZSB7XFxAbGluayBGb3JtQ29udHJvbE5hbWV9LFxuICAgICAqIGl0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCB5b3VyIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBiZSBwYXJ0IG9mIGFueSBwYXJlbnRcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9LCBhbmQgaXQgd29uJ3QgYmUgcmVnaXN0ZXJlZCB0byBhbnkge1xcQGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSB0aGF0XG4gICAgICogZXhpc3RzIGFib3ZlIGl0LlxuICAgICAqXG4gICAgICogKipHZXQgdGhlIHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiB7XFxAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UuIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpblxuICAgICAqIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAqKlNldCB0aGUgdmFsdWUqKjogWW91IGNhbiBwYXNzIGluIGFuIGluaXRpYWwgdmFsdWUgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSB7XFxAbGluayBGb3JtQ29udHJvbH0sXG4gICAgICogb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yXG4gICAgICoge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm1Db250cm9sL3NpbXBsZV9mb3JtX2NvbnRyb2xfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYFxcQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYFJlYWN0aXZlRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiAgXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoRm9ybUNvbnRyb2xEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbGlkYXRvcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBhc3luY1ZhbGlkYXRvcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZUFjY2Vzc29yc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2xEaXJlY3RpdmUodmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBpc0Rpc2FibGVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7IFJlYWN0aXZlRXJyb3JzLmRpc2FibGVkQXR0cldhcm5pbmcoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDb250cm9sQ2hhbmdlZChjaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLmZvcm0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wuZGlzYWJsZWQgJiYgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0uc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5faXNDb250cm9sQ2hhbmdlZCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZm9ybScpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xdJywgcHJvdmlkZXJzOiBbZm9ybUNvbnRyb2xCaW5kaW5nJDFdLCBleHBvcnRBczogJ25nRm9ybScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2Zvcm0nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Db250cm9sJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAndXBkYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQsIGFyZ3M6IFsnbmdNb2RlbENoYW5nZScsXSB9LF0sXG4gICAgICAgICAgICAnaXNEaXNhYmxlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZGlzYWJsZWQnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2xEaXJlY3RpdmU7XG4gICAgfShOZ0NvbnRyb2wpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDEgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUdyb3VwRGlyZWN0aXZlOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBCaW5kcyBhbiBleGlzdGluZyB7XFxAbGluayBGb3JtR3JvdXB9IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgYWNjZXB0cyBhbiBleGlzdGluZyB7XFxAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlLiBJdCB3aWxsIHRoZW4gdXNlIHRoaXNcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHRvIG1hdGNoIGFueSBjaGlsZCB7XFxAbGluayBGb3JtQ29udHJvbH0sIHtcXEBsaW5rIEZvcm1Hcm91cH0sXG4gICAgICogYW5kIHtcXEBsaW5rIEZvcm1BcnJheX0gaW5zdGFuY2VzIHRvIGNoaWxkIHtcXEBsaW5rIEZvcm1Db250cm9sTmFtZX0sIHtcXEBsaW5rIEZvcm1Hcm91cE5hbWV9LFxuICAgICAqIGFuZCB7XFxAbGluayBGb3JtQXJyYXlOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogKipTZXQgdmFsdWUqKjogWW91IGNhbiBzZXQgdGhlIGZvcm0ncyBpbml0aWFsIHZhbHVlIHdoZW4gaW5zdGFudGlhdGluZyB0aGVcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9LCBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHRoZSB7XFxAbGluayBGb3JtR3JvdXB9J3NcbiAgICAgKiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfSBtZXRob2RzLlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBmb3JtLCB5b3UgY2FuIHN1YnNjcmliZVxuICAgICAqIHRvIHRoZSB7XFxAbGluayBGb3JtR3JvdXB9J3Mge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICogaXRzIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBGdXJ0aGVybW9yZSwgeW91IGNhbiBsaXN0ZW4gdG8gdGhlIGRpcmVjdGl2ZSdzIGBuZ1N1Ym1pdGAgZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdXNlciBoYXNcbiAgICAgKiB0cmlnZ2VyZWQgYSBmb3JtIHN1Ym1pc3Npb24uIFRoZSBgbmdTdWJtaXRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBvcmlnaW5hbCBmb3JtXG4gICAgICogc3VibWlzc2lvbiBldmVudC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNyZWF0ZSBmb3JtIGNvbnRyb2xzIGZvciBmaXJzdCBuYW1lIGFuZCBsYXN0IG5hbWUuXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKipOZ01vZHVsZSoqOiB7XFxAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfVxuICAgICAqXG4gICAgICogIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtR3JvdXBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTEoRm9ybUdyb3VwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IF9hc3luY1ZhbGlkYXRvcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Hcm91cERpcmVjdGl2ZShfdmFsaWRhdG9ycywgX2FzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gX3ZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBfYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5nU3VibWl0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JtUHJlc2VudCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2Zvcm0nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbGlkYXRvcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEb21WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3VibWl0dGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdWJtaXR0ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIHNldFVwQ29udHJvbChjdHJsLCBkaXIpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5wdXNoKGRpcik7XG4gICAgICAgICAgICByZXR1cm4gY3RybDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAodGhpcy5mb3JtLmdldChkaXIucGF0aCkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgTGlzdFdyYXBwZXIucmVtb3ZlKHRoaXMuZGlyZWN0aXZlcywgZGlyKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlbW92ZUZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGlyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICh0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5hZGRGb3JtQXJyYXkgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVGb3JtQXJyYXkgPSBmdW5jdGlvbiAoZGlyKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGRpclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRGb3JtQXJyYXkgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAodGhpcy5mb3JtLmdldChkaXIucGF0aCkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXJcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChkaXIsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHJsID0gKHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpKTtcbiAgICAgICAgICAgIGN0cmwuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSAkZXZlbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUub25TdWJtaXQgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdC5lbWl0KCRldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5vblJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0Rm9ybSgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVzZXRGb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgdGhpcy5mb3JtLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZURvbVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdDdHJsID0gX3RoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIuX2NvbnRyb2wgIT09IG5ld0N0cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5VcENvbnRyb2woZGlyLl9jb250cm9sLCBkaXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q3RybClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbChuZXdDdHJsLCBkaXIpO1xuICAgICAgICAgICAgICAgICAgICBkaXIuX2NvbnRyb2wgPSBuZXdDdHJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mb3JtLl91cGRhdGVUcmVlVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5mb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkRm9ybSlcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRGb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb2xkRm9ybSA9IHRoaXMuZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3luYyA9IGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLnZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbdGhpcy5mb3JtLnZhbGlkYXRvciwgc3luY10pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN5bmMgPSBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbdGhpcy5mb3JtLmFzeW5jVmFsaWRhdG9yLCBhc3luY10pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrRm9ybVByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLm1pc3NpbmdGb3JtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKHN1Ym1pdCknOiAnb25TdWJtaXQoJGV2ZW50KScsICcocmVzZXQpJzogJ29uUmVzZXQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2Zvcm0nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Hcm91cCcsXSB9LF0sXG4gICAgICAgICAgICAnbmdTdWJtaXQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvcm1Hcm91cE5hbWVQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtR3JvdXBOYW1lOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBTeW5jcyBhIG5lc3RlZCB7XFxAbGluayBGb3JtR3JvdXB9IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGEgcGFyZW50IHtcXEBsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gKHNlbGVjdG9yOlxuICAgICAqIGBbZm9ybUdyb3VwXWApLlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIG5lc3RlZCB7XFxAbGluayBGb3JtR3JvdXB9IHlvdSB3YW50IHRvIGxpbmssIGFuZFxuICAgICAqIHdpbGwgbG9vayBmb3IgYSB7XFxAbGluayBGb3JtR3JvdXB9IHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlIHBhcmVudFxuICAgICAqIHtcXEBsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgeW91IHBhc3NlZCBpbnRvIHtcXEBsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBOZXN0ZWQgZm9ybSBncm91cHMgY2FuIGNvbWUgaW4gaGFuZHkgd2hlbiB5b3Ugd2FudCB0byB2YWxpZGF0ZSBhIHN1Yi1ncm91cCBvZiBhXG4gICAgICogZm9ybSBzZXBhcmF0ZWx5IGZyb20gdGhlIHJlc3Qgb3Igd2hlbiB5b3UnZCBsaWtlIHRvIGdyb3VwIHRoZSB2YWx1ZXMgb2YgY2VydGFpblxuICAgICAqIGNvbnRyb2xzIGludG8gdGhlaXIgb3duIG5lc3RlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgZ3JvdXAqKjogWW91IGNhbiBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQge1xcQGxpbmsgRm9ybUdyb3VwfSB1c2luZyB0aGVcbiAgICAgKiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2QuIEV4OiBgdGhpcy5mb3JtLmdldCgnbmFtZScpYC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBhY2Nlc3MgaW5kaXZpZHVhbCBjb250cm9scyB3aXRoaW4gdGhlIGdyb3VwIHVzaW5nIGRvdCBzeW50YXguXG4gICAgICogRXg6IGB0aGlzLmZvcm0uZ2V0KCduYW1lLmZpcnN0JylgXG4gICAgICpcbiAgICAgKiAqKkdldCB0aGUgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZVxuICAgICAqIHtcXEBsaW5rIEZvcm1Hcm91cH0uIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogKipTZXQgdGhlIHZhbHVlKio6IFlvdSBjYW4gc2V0IGFuIGluaXRpYWwgdmFsdWUgZm9yIGVhY2ggY2hpbGQgY29udHJvbCB3aGVuIGluc3RhbnRpYXRpbmdcbiAgICAgKiB0aGUge1xcQGxpbmsgRm9ybUdyb3VwfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZ1xuICAgICAqIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBncm91cCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBmb3Jtcy90cy9uZXN0ZWRGb3JtR3JvdXAvbmVzdGVkX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYFxcQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYFJlYWN0aXZlRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwTmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMihGb3JtR3JvdXBOYW1lLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxpZGF0b3JzXG4gICAgICAgICAqIEBwYXJhbSB7P30gYXN5bmNWYWxpZGF0b3JzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBGb3JtR3JvdXBOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwTmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMuZ3JvdXBQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwTmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUdyb3VwTmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtR3JvdXBOYW1lUHJvdmlkZXJdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUdyb3VwTmFtZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIEZvcm1Hcm91cE5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUdyb3VwTmFtZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXBOYW1lO1xuICAgIH0oQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmb3JtQXJyYXlOYW1lUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUFycmF5TmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgU3luY3MgYSBuZXN0ZWQge1xcQGxpbmsgRm9ybUFycmF5fSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7XFxAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBuZXN0ZWQge1xcQGxpbmsgRm9ybUFycmF5fSB5b3Ugd2FudCB0byBsaW5rLCBhbmRcbiAgICAgKiB3aWxsIGxvb2sgZm9yIGEge1xcQGxpbmsgRm9ybUFycmF5fSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZSBwYXJlbnRcbiAgICAgKiB7XFxAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHlvdSBwYXNzZWQgaW50byB7XFxAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogTmVzdGVkIGZvcm0gYXJyYXlzIGNhbiBjb21lIGluIGhhbmR5IHdoZW4geW91IGhhdmUgYSBncm91cCBvZiBmb3JtIGNvbnRyb2xzIGJ1dFxuICAgICAqIHlvdSdyZSBub3Qgc3VyZSBob3cgbWFueSB0aGVyZSB3aWxsIGJlLiBGb3JtIGFycmF5cyBhbGxvdyB5b3UgdG8gY3JlYXRlIG5ld1xuICAgICAqIGZvcm0gY29udHJvbHMgZHluYW1pY2FsbHkuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgYXJyYXkqKjogWW91IGNhbiBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQge1xcQGxpbmsgRm9ybUFycmF5fSB1c2luZyB0aGVcbiAgICAgKiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2Qgb24gdGhlIHBhcmVudCB7XFxAbGluayBGb3JtR3JvdXB9LlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnY2l0aWVzJylgLlxuICAgICAqXG4gICAgICogKipHZXQgdGhlIHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiB7XFxAbGluayBGb3JtQXJyYXl9LiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW4ge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICoqU2V0IHRoZSB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciBlYWNoIGNoaWxkIGNvbnRyb2wgd2hlbiBpbnN0YW50aWF0aW5nXG4gICAgICogdGhlIHtcXEBsaW5rIEZvcm1BcnJheX0sIG9yIHlvdSBjYW4gc2V0IHRoZSB2YWx1ZSBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHRoZVxuICAgICAqIHtcXEBsaW5rIEZvcm1BcnJheX0ncyB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfVxuICAgICAqIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7XFxAbGluayBGb3JtQXJyYXl9J3Mge1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc29cbiAgICAgKiBsaXN0ZW4gdG8gaXRzIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uXG4gICAgICogc3RhdHVzIGlzIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAqKkFkZCBuZXcgY29udHJvbHMqKjogWW91IGNhbiBhZGQgbmV3IGNvbnRyb2xzIHRvIHRoZSB7XFxAbGluayBGb3JtQXJyYXl9IGR5bmFtaWNhbGx5IGJ5XG4gICAgICogY2FsbGluZyBpdHMge1xcQGxpbmsgRm9ybUFycmF5LnB1c2h9IG1ldGhvZC5cbiAgICAgKiAgRXg6IGB0aGlzLmZvcm0uZ2V0KCdjaXRpZXMnKS5wdXNoKG5ldyBGb3JtQ29udHJvbCgpKTtgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgZm9ybXMvdHMvbmVzdGVkRm9ybUFycmF5L25lc3RlZF9mb3JtX2FycmF5X2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBcXEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBSZWFjdGl2ZUZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1BcnJheU5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTIoRm9ybUFycmF5TmFtZSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFzeW5jVmFsaWRhdG9yc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRm9ybUFycmF5TmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVGb3JtQXJyYXkodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm1EaXJlY3RpdmUuZ2V0Rm9ybUFycmF5KHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gKHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlKSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2hhc0ludmFsaWRQYXJlbnQodGhpcy5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmFycmF5UGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1BcnJheU5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1BcnJheU5hbWVdJywgcHJvdmlkZXJzOiBbZm9ybUFycmF5TmFtZVByb3ZpZGVyXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1BcnJheU5hbWUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1BcnJheU5hbWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUFycmF5TmFtZTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhc0ludmFsaWRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIHJldHVybiAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwRGlyZWN0aXZlKSAmJlxuICAgICAgICAgICAgIShwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQXJyYXlOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRyb2xOYW1lQmluZGluZyA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Db250cm9sTmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgU3luY3MgYSB7XFxAbGluayBGb3JtQ29udHJvbH0gaW4gYW4gZXhpc3Rpbmcge1xcQGxpbmsgRm9ybUdyb3VwfSB0byBhIGZvcm0gY29udHJvbFxuICAgICAqIGVsZW1lbnQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzLCB0aGlzIGRpcmVjdGl2ZSBlbnN1cmVzIHRoYXQgYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSB7XFxAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZSBwcm9ncmFtbWF0aWNhbGx5IHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgKG1vZGVsIC0+IHZpZXcpLiBDb252ZXJzZWx5LFxuICAgICAqIGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgdGhyb3VnaCB1c2VyIGlucHV0IHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZVxuICAgICAqIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSAodmlldyAtPiBtb2RlbCkuXG4gICAgICpcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIGEgcGFyZW50IHtcXEBsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gKHNlbGVjdG9yOlxuICAgICAqIGBbZm9ybUdyb3VwXWApLlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIHtcXEBsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSB5b3Ugd2FudCB0b1xuICAgICAqIGxpbmssIGFuZCB3aWxsIGxvb2sgZm9yIGEge1xcQGxpbmsgRm9ybUNvbnRyb2x9IHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlXG4gICAgICogY2xvc2VzdCB7XFxAbGluayBGb3JtR3JvdXB9IG9yIHtcXEBsaW5rIEZvcm1BcnJheX0gYWJvdmUgaXQuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgY29udHJvbCoqOiBZb3UgY2FuIGFjY2VzcyB0aGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9IGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgZGlyZWN0aXZlIGJ5IHVzaW5nIHRoZSB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2QuXG4gICAgICogRXg6IGB0aGlzLmZvcm0uZ2V0KCdmaXJzdCcpO2BcbiAgICAgKlxuICAgICAqICoqR2V0IHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGUge1xcQGxpbmsgRm9ybUNvbnRyb2x9LlxuICAgICAqIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogICoqU2V0IHZhbHVlKio6IFlvdSBjYW4gc2V0IGFuIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBjb250cm9sIHdoZW4gaW5zdGFudGlhdGluZyB0aGVcbiAgICAgKiAge1xcQGxpbmsgRm9ybUNvbnRyb2x9LCBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nXG4gICAgICogIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige1xcQGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiB7XFxAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY3JlYXRlIGZvcm0gY29udHJvbHMgZm9yIGZpcnN0IG5hbWUgYW5kIGxhc3QgbmFtZS5cbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm1Hcm91cC9zaW1wbGVfZm9ybV9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFRvIHNlZSBgZm9ybUNvbnRyb2xOYW1lYCBleGFtcGxlcyB3aXRoIGRpZmZlcmVudCBmb3JtIGNvbnRyb2wgdHlwZXMsIHNlZTpcbiAgICAgKlxuICAgICAqICogUmFkaW8gYnV0dG9uczoge1xcQGxpbmsgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvcn1cbiAgICAgKiAqIFNlbGVjdHM6IHtcXEBsaW5rIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgXFxAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjoge1xcQGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX1cbiAgICAgKlxuICAgICAqICBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUNvbnRyb2xOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEwKEZvcm1Db250cm9sTmFtZSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFzeW5jVmFsaWRhdG9yc1xuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlQWNjZXNzb3JzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBGb3JtQ29udHJvbE5hbWUocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gaXNEaXNhYmxlZFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoaXNEaXNhYmxlZCkgeyBSZWFjdGl2ZUVycm9ycy5kaXNhYmxlZEF0dHJXYXJuaW5nKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWRkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9sKCk7XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS51cGRhdGVNb2RlbCh0aGlzLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRyb2w7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5uZ01vZGVsR3JvdXBFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBEaXJlY3RpdmUpICYmXG4gICAgICAgICAgICAgICAgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtQXJyYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmNvbnRyb2xQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLl9zZXRVcENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkQ29udHJvbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wuZGlzYWJsZWQgJiYgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbE5hbWVdJywgcHJvdmlkZXJzOiBbY29udHJvbE5hbWVCaW5kaW5nXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUNvbnRyb2xOYW1lJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAndXBkYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQsIGFyZ3M6IFsnbmdNb2RlbENoYW5nZScsXSB9LF0sXG4gICAgICAgICAgICAnaXNEaXNhYmxlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZGlzYWJsZWQnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2xOYW1lO1xuICAgIH0oTmdDb250cm9sKSk7XG5cbiAgICB2YXIgX19leHRlbmRzJDEzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUkVRVUlSRURfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlcXVpcmVkVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIENIRUNLQk9YX1JFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gYW55IGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxuICAgICAqIGByZXF1aXJlZGAgYXR0cmlidXRlLCB2aWEgdGhlIHtcXEBsaW5rIE5HX1ZBTElEQVRPUlN9IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGlucHV0IG5hbWU9XCJmdWxsTmFtZVwiIG5nTW9kZWwgcmVxdWlyZWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmVxdWlyZWRWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZXF1aXJlZFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlZCA9IHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIFwiXCIgKyB2YWx1ZSAhPT0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVkID8gVmFsaWRhdG9ycy5yZXF1aXJlZChjKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnOm5vdChbdHlwZT1jaGVja2JveF0pW3JlcXVpcmVkXVtmb3JtQ29udHJvbE5hbWVdLDpub3QoW3R5cGU9Y2hlY2tib3hdKVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xdLDpub3QoW3R5cGU9Y2hlY2tib3hdKVtyZXF1aXJlZF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkVRVUlSRURfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLnJlcXVpcmVkXSc6ICdyZXF1aXJlZCA/IFwiXCIgOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAncmVxdWlyZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvciB0byBjaGVja2JveCBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAgICAgKiBgcmVxdWlyZWRgIGF0dHJpYnV0ZSwgdmlhIHRoZSB7XFxAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwiYWN0aXZlXCIgbmdNb2RlbCByZXF1aXJlZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZCA/IFZhbGlkYXRvcnMucmVxdWlyZWRUcnVlKGMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtyZXF1aXJlZF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbQ0hFQ0tCT1hfUkVRVUlSRURfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLnJlcXVpcmVkXSc6ICdyZXF1aXJlZCA/IFwiXCIgOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICB9KFJlcXVpcmVkVmFsaWRhdG9yKSk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXIgd2hpY2ggYWRkcyB7QGxpbmsgTWluTGVuZ3RoVmFsaWRhdG9yfSB0byB7QGxpbmsgTkdfVkFMSURBVE9SU30uXG4gICAgICpcbiAgICAgKiAjIyBFeGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9mb3Jtcy90cy92YWxpZGF0b3JzL3ZhbGlkYXRvcnMudHMgcmVnaW9uPSdtaW4nfVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIE1JTl9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge1xcQGxpbmsgTWluTGVuZ3RoVmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWVgLFxuICAgICAqIGBmb3JtQ29udHJvbGAsIG9yIGNvbnRyb2wgd2l0aCBgbmdNb2RlbGAgdGhhdCBhbHNvIGhhcyBhIGBtaW5sZW5ndGhgIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBNaW5MZW5ndGhWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5MZW5ndGhWYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoJ21pbmxlbmd0aCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5sZW5ndGggPT0gbnVsbCA/IG51bGwgOiB0aGlzLl92YWxpZGF0b3IoYyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1pbkxlbmd0aChwYXJzZUludCh0aGlzLm1pbmxlbmd0aCwgMTApKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWlubGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFttaW5sZW5ndGhdW2Zvcm1Db250cm9sXSxbbWlubGVuZ3RoXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNSU5fTEVOR1RIX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5taW5sZW5ndGhdJzogJ21pbmxlbmd0aCA/IG1pbmxlbmd0aCA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ21pbmxlbmd0aCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWluTGVuZ3RoVmFsaWRhdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXIgd2hpY2ggYWRkcyB7QGxpbmsgTWF4TGVuZ3RoVmFsaWRhdG9yfSB0byB7QGxpbmsgTkdfVkFMSURBVE9SU30uXG4gICAgICpcbiAgICAgKiAjIyBFeGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9mb3Jtcy90cy92YWxpZGF0b3JzL3ZhbGlkYXRvcnMudHMgcmVnaW9uPSdtYXgnfVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIE1BWF9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heExlbmd0aFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge1xcQGxpbmsgTWF4TGVuZ3RoVmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWUsXG4gICAgICogYGZvcm1Db250cm9sYCxcbiAgICAgKiBvciBjb250cm9sIHdpdGggYG5nTW9kZWxgIHRoYXQgYWxzbyBoYXMgYSBgbWF4bGVuZ3RoYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTWF4TGVuZ3RoVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWF4TGVuZ3RoVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKCdtYXhsZW5ndGgnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4bGVuZ3RoICE9IG51bGwgPyB0aGlzLl92YWxpZGF0b3IoYykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5tYXhMZW5ndGgocGFyc2VJbnQodGhpcy5tYXhsZW5ndGgsIDEwKSk7XG4gICAgICAgIH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21heGxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbF0sW21heGxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUFYX0xFTkdUSF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIubWF4bGVuZ3RoXSc6ICdtYXhsZW5ndGggPyBtYXhsZW5ndGggOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdtYXhsZW5ndGgnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1heExlbmd0aFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFBBVFRFUk5fVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhdHRlcm5WYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgcGF0dGVybmAgdmFsaWRhdG9yIHRvIGFueSBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAgICAgKiBgcGF0dGVybmAgYXR0cmlidXRlLCB2aWEgdGhlIHtcXEBsaW5rIE5HX1ZBTElEQVRPUlN9IGJpbmRpbmcuIFVzZXMgYXR0cmlidXRlIHZhbHVlXG4gICAgICogYXMgdGhlIHJlZ2V4IHRvIHZhbGlkYXRlIENvbnRyb2wgdmFsdWUgYWdhaW5zdC4gIEZvbGxvd3MgcGF0dGVybiBhdHRyaWJ1dGVcbiAgICAgKiBzZW1hbnRpY3M7IGkuZS4gcmVnZXggbXVzdCBtYXRjaCBlbnRpcmUgQ29udHJvbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8aW5wdXQgW25hbWVdPVwiZnVsbE5hbWVcIiBwYXR0ZXJuPVwiW2EtekEtWiBdKlwiIG5nTW9kZWw+XG4gICAgICogYGBgXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFBhdHRlcm5WYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQYXR0ZXJuVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoYW5nZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICgncGF0dGVybicgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gdGhpcy5fdmFsaWRhdG9yKGMpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMucGF0dGVybih0aGlzLnBhdHRlcm4pOyB9O1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbcGF0dGVybl1bZm9ybUNvbnRyb2xOYW1lXSxbcGF0dGVybl1bZm9ybUNvbnRyb2xdLFtwYXR0ZXJuXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtQQVRURVJOX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5wYXR0ZXJuXSc6ICdwYXR0ZXJuID8gcGF0dGVybiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAncGF0dGVybic6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGF0dGVyblZhbGlkYXRvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBDcmVhdGVzIGFuIHtcXEBsaW5rIEFic3RyYWN0Q29udHJvbH0gZnJvbSBhIHVzZXItc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBJdCBpcyBlc3NlbnRpYWxseSBzeW50YWN0aWMgc3VnYXIgdGhhdCBzaG9ydGVucyB0aGUgYG5ldyBGb3JtR3JvdXAoKWAsXG4gICAgICogYG5ldyBGb3JtQ29udHJvbCgpYCwgYW5kIGBuZXcgRm9ybUFycmF5KClgIGJvaWxlcnBsYXRlIHRoYXQgY2FuIGJ1aWxkIHVwIGluIGxhcmdlclxuICAgICAqIGZvcm1zLlxuICAgICAqXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRvIHVzZSwgaW5qZWN0IGBGb3JtQnVpbGRlcmAgaW50byB5b3VyIGNvbXBvbmVudCBjbGFzcy4gWW91IGNhbiB0aGVuIGNhbGwgaXRzIG1ldGhvZHNcbiAgICAgKiBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGZvcm1zL3RzL2Zvcm1CdWlsZGVyL2Zvcm1fYnVpbGRlcl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICAqICoqbnBtIHBhY2thZ2UqKjogYFxcQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAgKiAqKk5nTW9kdWxlKio6IHtcXEBsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9XG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGb3JtQnVpbGRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IHtcXEBsaW5rIEZvcm1Hcm91cH0gd2l0aCB0aGUgZ2l2ZW4gbWFwIG9mIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIFZhbGlkIGtleXMgZm9yIHRoZSBgZXh0cmFgIHBhcmFtZXRlciBtYXAgYXJlIGB2YWxpZGF0b3JgIGFuZCBgYXN5bmNWYWxpZGF0b3JgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgdGhlIHtcXEBsaW5rIEZvcm1Hcm91cH0gY29uc3RydWN0b3IgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sc0NvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0gez89fSBleHRyYVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCBleHRyYSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhID09PSB2b2lkIDApIHsgZXh0cmEgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250cm9scyA9IHRoaXMuX3JlZHVjZUNvbnRyb2xzKGNvbnRyb2xzQ29uZmlnKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbGlkYXRvciA9IGlzUHJlc2VudChleHRyYSkgPyBleHRyYVsndmFsaWRhdG9yJ10gOiBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN5bmNWYWxpZGF0b3IgPSBpc1ByZXNlbnQoZXh0cmEpID8gZXh0cmFbJ2FzeW5jVmFsaWRhdG9yJ10gOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtR3JvdXAoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IHtcXEBsaW5rIEZvcm1Db250cm9sfSB3aXRoIHRoZSBnaXZlbiBgZm9ybVN0YXRlYCxgdmFsaWRhdG9yYCwgYW5kXG4gICAgICAgICAqIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBmb3JtU3RhdGVgIGNhbiBlaXRoZXIgYmUgYSBzdGFuZGFsb25lIHZhbHVlIGZvciB0aGUgZm9ybSBjb250cm9sIG9yIGFuIG9iamVjdFxuICAgICAgICAgKiB0aGF0IGNvbnRhaW5zIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm9ybVN0YXRlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbGlkYXRvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBhc3luY1ZhbGlkYXRvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbiAoZm9ybVN0YXRlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSB7XFxAbGluayBGb3JtQXJyYXl9IGZyb20gdGhlIGdpdmVuIGBjb250cm9sc0NvbmZpZ2AgYXJyYXkgb2ZcbiAgICAgICAgICogY29uZmlndXJhdGlvbiwgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uYWwgYHZhbGlkYXRvcmAgYW5kIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udHJvbHNDb25maWdcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdmFsaWRhdG9yXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGFzeW5jVmFsaWRhdG9yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250cm9scyA9IGNvbnRyb2xzQ29uZmlnLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZUNvbnRyb2woYyk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250cm9sc0NvbmZpZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLl9yZWR1Y2VDb250cm9scyA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRyb2xzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb250cm9sc0NvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sc1tjb250cm9sTmFtZV0gPSBfdGhpcy5fY3JlYXRlQ29udHJvbChjb250cm9sc0NvbmZpZ1tjb250cm9sTmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbHM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRyb2xDb25maWdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIEZvcm1Db250cm9sIHx8IGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBGb3JtR3JvdXAgfHxcbiAgICAgICAgICAgICAgICBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgRm9ybUFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2xDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBjb250cm9sQ29uZmlnWzBdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMSA/IGNvbnRyb2xDb25maWdbMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzeW5jVmFsaWRhdG9yID0gY29udHJvbENvbmZpZy5sZW5ndGggPiAyID8gY29udHJvbENvbmZpZ1syXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCh2YWx1ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKGNvbnRyb2xDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtQnVpbGRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1CdWlsZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBGb3JtQnVpbGRlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFZFUlNJT04gPSBuZXcgX2FuZ3VsYXJfY29yZS5WZXJzaW9uKCcyLjQuOCcpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyA9IFtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24sXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24sXG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IsXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXMsXG4gICAgICAgIE5nQ29udHJvbFN0YXR1c0dyb3VwLFxuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvcixcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IsXG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IsXG4gICAgICAgIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFUyA9IFtOZ01vZGVsLCBOZ01vZGVsR3JvdXAsIE5nRm9ybV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVMgPSBbRm9ybUNvbnRyb2xEaXJlY3RpdmUsIEZvcm1Hcm91cERpcmVjdGl2ZSwgRm9ybUNvbnRyb2xOYW1lLCBGb3JtR3JvdXBOYW1lLCBGb3JtQXJyYXlOYW1lXTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2R1bGUgdXNlZCBmb3Igc2hhcmluZyBkaXJlY3RpdmVzIGJldHdlZW4gRm9ybXNNb2R1bGUgYW5kIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAgICAgKi9cbiAgICB2YXIgSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmcgbW9kdWxlIGZvciBmb3Jtcy5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybXNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGb3Jtc01vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBGb3Jtc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JhZGlvQ29udHJvbFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3Jtc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gRm9ybXNNb2R1bGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmcgbW9kdWxlIGZvciByZWFjdGl2ZSBmb3Jtcy5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmVhY3RpdmVGb3Jtc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlYWN0aXZlRm9ybXNNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbRm9ybUJ1aWxkZXIsIFJhZGlvQ29udHJvbFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBSZWFjdGl2ZUZvcm1zTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICBleHBvcnRzLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlID0gQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLkNvbnRyb2xDb250YWluZXIgPSBDb250cm9sQ29udGFpbmVyO1xuICAgIGV4cG9ydHMuTkdfVkFMVUVfQUNDRVNTT1IgPSBOR19WQUxVRV9BQ0NFU1NPUjtcbiAgICBleHBvcnRzLkRlZmF1bHRWYWx1ZUFjY2Vzc29yID0gRGVmYXVsdFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2wgPSBOZ0NvbnRyb2w7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXMgPSBOZ0NvbnRyb2xTdGF0dXM7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXNHcm91cCA9IE5nQ29udHJvbFN0YXR1c0dyb3VwO1xuICAgIGV4cG9ydHMuTmdGb3JtID0gTmdGb3JtO1xuICAgIGV4cG9ydHMuTmdNb2RlbCA9IE5nTW9kZWw7XG4gICAgZXhwb3J0cy5OZ01vZGVsR3JvdXAgPSBOZ01vZGVsR3JvdXA7XG4gICAgZXhwb3J0cy5SYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yID0gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sRGlyZWN0aXZlID0gRm9ybUNvbnRyb2xEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbE5hbWUgPSBGb3JtQ29udHJvbE5hbWU7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXBEaXJlY3RpdmUgPSBGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5Gb3JtQXJyYXlOYW1lID0gRm9ybUFycmF5TmFtZTtcbiAgICBleHBvcnRzLkZvcm1Hcm91cE5hbWUgPSBGb3JtR3JvdXBOYW1lO1xuICAgIGV4cG9ydHMuTmdTZWxlY3RPcHRpb24gPSBOZ1NlbGVjdE9wdGlvbjtcbiAgICBleHBvcnRzLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5TZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yID0gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLkNoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IgPSBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuTWF4TGVuZ3RoVmFsaWRhdG9yID0gTWF4TGVuZ3RoVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuTWluTGVuZ3RoVmFsaWRhdG9yID0gTWluTGVuZ3RoVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuUGF0dGVyblZhbGlkYXRvciA9IFBhdHRlcm5WYWxpZGF0b3I7XG4gICAgZXhwb3J0cy5SZXF1aXJlZFZhbGlkYXRvciA9IFJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuRm9ybUJ1aWxkZXIgPSBGb3JtQnVpbGRlcjtcbiAgICBleHBvcnRzLkFic3RyYWN0Q29udHJvbCA9IEFic3RyYWN0Q29udHJvbDtcbiAgICBleHBvcnRzLkZvcm1BcnJheSA9IEZvcm1BcnJheTtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sID0gRm9ybUNvbnRyb2w7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXAgPSBGb3JtR3JvdXA7XG4gICAgZXhwb3J0cy5OR19BU1lOQ19WQUxJREFUT1JTID0gTkdfQVNZTkNfVkFMSURBVE9SUztcbiAgICBleHBvcnRzLk5HX1ZBTElEQVRPUlMgPSBOR19WQUxJREFUT1JTO1xuICAgIGV4cG9ydHMuVmFsaWRhdG9ycyA9IFZhbGlkYXRvcnM7XG4gICAgZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbiAgICBleHBvcnRzLkZvcm1zTW9kdWxlID0gRm9ybXNNb2R1bGU7XG4gICAgZXhwb3J0cy5SZWFjdGl2ZUZvcm1zTW9kdWxlID0gUmVhY3RpdmVGb3Jtc01vZHVsZTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gICogQGxpY2Vuc2UgQW5ndWxhciBNYXRlcmlhbCB2Mi4wLjAtYmV0YS4yXG4gICogQ29weXJpZ2h0IChjKSAyMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL21hdGVyaWFsLmFuZ3VsYXIuaW8vXG4gICogTGljZW5zZTogTUlUXG4gICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdAYW5ndWxhci9jb21tb24nKSwgcmVxdWlyZSgncnhqcy9TdWJqZWN0JyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpLCByZXF1aXJlKCdyeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudCcpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9hdWRpdFRpbWUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpLCByZXF1aXJlKCdAYW5ndWxhci9mb3JtcycpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9zdGFydFdpdGgnKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvZmlyc3QnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvaHR0cCcpLCByZXF1aXJlKCdyeGpzL2FkZC9vYnNlcnZhYmxlL2ZvcmtKb2luJyksIHJlcXVpcmUoJ3J4anMvYWRkL29ic2VydmFibGUvb2YnKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvbWFwJyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL2ZpbHRlcicpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9kbycpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9zaGFyZScpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9maW5hbGx5JyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL2NhdGNoJyksIHJlcXVpcmUoJ3J4anMvYWRkL29ic2VydmFibGUvbWVyZ2UnKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAnQGFuZ3VsYXIvY29tbW9uJywgJ3J4anMvU3ViamVjdCcsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnLCAncnhqcy9hZGQvb3BlcmF0b3IvYXVkaXRUaW1lJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInLCAnQGFuZ3VsYXIvZm9ybXMnLCAncnhqcy9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoJywgJ3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0JywgJ0Bhbmd1bGFyL2h0dHAnLCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mb3JrSm9pbicsICdyeGpzL2FkZC9vYnNlcnZhYmxlL29mJywgJ3J4anMvYWRkL29wZXJhdG9yL21hcCcsICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInLCAncnhqcy9hZGQvb3BlcmF0b3IvZG8nLCAncnhqcy9hZGQvb3BlcmF0b3Ivc2hhcmUnLCAncnhqcy9hZGQvb3BlcmF0b3IvZmluYWxseScsICdyeGpzL2FkZC9vcGVyYXRvci9jYXRjaCcsICdyeGpzL2FkZC9vYnNlcnZhYmxlL21lcmdlJywgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcCddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLm1hdGVyaWFsID0gZ2xvYmFsLm5nLm1hdGVyaWFsIHx8IHt9KSxnbG9iYWwubmcuY29yZSxnbG9iYWwubmcuY29tbW9uLGdsb2JhbC5SeCxnbG9iYWwuUngsZ2xvYmFsLlJ4Lk9ic2VydmFibGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIsZ2xvYmFsLm5nLmZvcm1zLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLm5nLmh0dHAsZ2xvYmFsLlJ4Lk9ic2VydmFibGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlLF9hbmd1bGFyX2NvbW1vbixyeGpzX1N1YmplY3Qscnhqc19PYnNlcnZhYmxlLHJ4anNfYWRkX29ic2VydmFibGVfZnJvbUV2ZW50LHJ4anNfYWRkX29wZXJhdG9yX2F1ZGl0VGltZSxfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIsX2FuZ3VsYXJfZm9ybXMscnhqc19hZGRfb3BlcmF0b3Jfc3RhcnRXaXRoLHJ4anNfYWRkX29wZXJhdG9yX2ZpcnN0LF9hbmd1bGFyX2h0dHAscnhqc19hZGRfb2JzZXJ2YWJsZV9mb3JrSm9pbixyeGpzX2FkZF9vYnNlcnZhYmxlX29mLHJ4anNfYWRkX29wZXJhdG9yX21hcCxyeGpzX2FkZF9vcGVyYXRvcl9maWx0ZXIscnhqc19hZGRfb3BlcmF0b3JfZG8scnhqc19hZGRfb3BlcmF0b3Jfc2hhcmUscnhqc19hZGRfb3BlcmF0b3JfZmluYWxseSxyeGpzX2FkZF9vcGVyYXRvcl9jYXRjaCxyeGpzX2FkZF9vYnNlcnZhYmxlX21lcmdlLHJ4anNfYWRkX29wZXJhdG9yX3N3aXRjaE1hcCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBfX2RlY29yYXRlJDIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0gPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgTUFURVJJQUxfQ09NUEFUSUJJTElUWV9NT0RFID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ21kLWNvbXBhdGliaWxpdHktbW9kZScpO1xuLyoqIFNlbGVjdG9yIHRoYXQgbWF0Y2hlcyBhbGwgZWxlbWVudHMgdGhhdCBtYXkgaGF2ZSBzdHlsZSBjb2xsaXNpb25zIHdpdGggQW5ndWxhckpTIE1hdGVyaWFsLiAqL1xudmFyIE1BVF9FTEVNRU5UU19TRUxFQ1RPUiA9IFwiXFxuICBbbWF0LWJ1dHRvbl0sXFxuICBbbWF0LWRpYWxvZy1hY3Rpb25zXSxcXG4gIFttYXQtZGlhbG9nLWNsb3NlXSxcXG4gIFttYXQtZGlhbG9nLWNvbnRlbnRdLFxcbiAgW21hdC1kaWFsb2ctdGl0bGVdLFxcbiAgW21hdC1mYWJdLFxcbiAgW21hdC1pY29uLWJ1dHRvbl0sXFxuICBbbWF0LW1lbnUtdHJpZ2dlci1mb3JdLFxcbiAgW21hdC1taW5pLWZhYl0sXFxuICBbbWF0LXJhaXNlZC1idXR0b25dLFxcbiAgW21hdC10YWItbGFiZWxdLFxcbiAgW21hdC10YWItbGlua10sXFxuICBbbWF0LXRhYi1uYXYtYmFyXSxcXG4gIFttYXRUb29sdGlwXSxcXG4gIG1hdC1hdXRvY29tcGxldGUsXFxuICBtYXQtYnV0dG9uLXRvZ2dsZSxcXG4gIG1hdC1idXR0b24tdG9nZ2xlLWdyb3VwLFxcbiAgbWF0LWJ1dHRvbi10b2dnbGUsXFxuICBtYXQtY2FyZCxcXG4gIG1hdC1jYXJkLWFjdGlvbnMsXFxuICBtYXQtY2FyZC1jb250ZW50LFxcbiAgbWF0LWNhcmQtZm9vdGVyLFxcbiAgbWF0LWNhcmQtaGVhZGVyLFxcbiAgbWF0LWNhcmQtc3VidGl0bGUsXFxuICBtYXQtY2FyZC10aXRsZSxcXG4gIG1hdC1jYXJkLXRpdGxlLWdyb3VwLFxcbiAgbWF0LWNoZWNrYm94LFxcbiAgbWF0LWNoaXAsXFxuICBtYXQtZGlhbG9nLWFjdGlvbnMsXFxuICBtYXQtZGlhbG9nLWNvbnRhaW5lcixcXG4gIG1hdC1kaWFsb2ctY29udGVudCxcXG4gIG1hdC1kaXZpZGVyLFxcbiAgbWF0LWdyaWQtbGlzdCxcXG4gIG1hdC1ncmlkLXRpbGUsXFxuICBtYXQtZ3JpZC10aWxlLWZvb3RlcixcXG4gIG1hdC1ncmlkLXRpbGUtaGVhZGVyLFxcbiAgbWF0LWhpbnQsXFxuICBtYXQtaWNvbixcXG4gIG1hdC1pbmstYmFyLFxcbiAgbWF0LWxpc3QsXFxuICBtYXQtbGlzdC1pdGVtLFxcbiAgbWF0LW1lbnUsXFxuICBtYXQtbmF2LWxpc3QsXFxuICBtYXQtb3B0aW9uLFxcbiAgbWF0LXBsYWNlaG9sZGVyLFxcbiAgbWF0LXByb2dyZXNzLWJhcixcXG4gIG1hdC1wcm9ncmVzcy1jaXJjbGUsXFxuICBtYXQtcHNldWRvLWNoZWNrYm94LFxcbiAgbWF0LXJhZGlvLWJ1dHRvbixcXG4gIG1hdC1yYWRpby1ncm91cCxcXG4gIG1hdC1zZWxlY3QsXFxuICBtYXQtc2lkZW5hdixcXG4gIG1hdC1zaWRlbmF2LWNvbnRhaW5lcixcXG4gIG1hdC1zbGlkZXIsXFxuICBtYXQtc3Bpbm5lcixcXG4gIG1hdC10YWIsXFxuICBtYXQtdGFiLWJvZHksXFxuICBtYXQtdGFiLWhlYWRlcixcXG4gIG1hdC10YWItZ3JvdXAsXFxuICBtYXQtdG9vbGJhclwiO1xuLyoqIFNlbGVjdG9yIHRoYXQgbWF0Y2hlcyBhbGwgZWxlbWVudHMgdGhhdCBtYXkgaGF2ZSBzdHlsZSBjb2xsaXNpb25zIHdpdGggQW5ndWxhckpTIE1hdGVyaWFsLiAqL1xudmFyIE1EX0VMRU1FTlRTX1NFTEVDVE9SID0gXCIgIFxcbiAgW21kLWJ1dHRvbl0sXFxuICBbbWQtZGlhbG9nLWFjdGlvbnNdLFxcbiAgW21kLWRpYWxvZy1jbG9zZV0sXFxuICBbbWQtZGlhbG9nLWNvbnRlbnRdLFxcbiAgW21kLWRpYWxvZy10aXRsZV0sXFxuICBbbWQtZmFiXSxcXG4gIFttZC1pY29uLWJ1dHRvbl0sXFxuICBbbWQtbWVudS10cmlnZ2VyLWZvcl0sXFxuICBbbWQtbWluaS1mYWJdLFxcbiAgW21kLXJhaXNlZC1idXR0b25dLFxcbiAgW21kLXRhYi1sYWJlbF0sXFxuICBbbWQtdGFiLWxpbmtdLFxcbiAgW21kLXRhYi1uYXYtYmFyXSxcXG4gIFttZFRvb2x0aXBdLFxcbiAgbWQtYXV0b2NvbXBsZXRlLFxcbiAgbWQtYnV0dG9uLXRvZ2dsZSxcXG4gIG1kLWJ1dHRvbi10b2dnbGUtZ3JvdXAsXFxuICBtZC1idXR0b24tdG9nZ2xlLFxcbiAgbWQtY2FyZCxcXG4gIG1kLWNhcmQtYWN0aW9ucyxcXG4gIG1kLWNhcmQtY29udGVudCxcXG4gIG1kLWNhcmQtZm9vdGVyLFxcbiAgbWQtY2FyZC1oZWFkZXIsXFxuICBtZC1jYXJkLXN1YnRpdGxlLFxcbiAgbWQtY2FyZC10aXRsZSxcXG4gIG1kLWNhcmQtdGl0bGUtZ3JvdXAsXFxuICBtZC1jaGVja2JveCxcXG4gIG1kLWNoaXAsXFxuICBtZC1kaWFsb2ctYWN0aW9ucyxcXG4gIG1kLWRpYWxvZy1jb250YWluZXIsXFxuICBtZC1kaWFsb2ctY29udGVudCxcXG4gIG1kLWRpdmlkZXIsXFxuICBtZC1ncmlkLWxpc3QsXFxuICBtZC1ncmlkLXRpbGUsXFxuICBtZC1ncmlkLXRpbGUtZm9vdGVyLFxcbiAgbWQtZ3JpZC10aWxlLWhlYWRlcixcXG4gIG1kLWhpbnQsXFxuICBtZC1pY29uLFxcbiAgbWQtaW5rLWJhcixcXG4gIG1kLWxpc3QsXFxuICBtZC1saXN0LWl0ZW0sXFxuICBtZC1tZW51LFxcbiAgbWQtbmF2LWxpc3QsXFxuICBtZC1vcHRpb24sXFxuICBtZC1wbGFjZWhvbGRlcixcXG4gIG1kLXByb2dyZXNzLWJhcixcXG4gIG1kLXByb2dyZXNzLWNpcmNsZSxcXG4gIG1kLXBzZXVkby1jaGVja2JveCxcXG4gIG1kLXJhZGlvLWJ1dHRvbixcXG4gIG1kLXJhZGlvLWdyb3VwLFxcbiAgbWQtc2VsZWN0LFxcbiAgbWQtc2lkZW5hdixcXG4gIG1kLXNpZGVuYXYtY29udGFpbmVyLFxcbiAgbWQtc2xpZGVyLFxcbiAgbWQtc3Bpbm5lcixcXG4gIG1kLXRhYixcXG4gIG1kLXRhYi1ib2R5LFxcbiAgbWQtdGFiLWhlYWRlcixcXG4gIG1kLXRhYi1ncm91cCxcXG4gIG1kLXRvb2xiYXJcIjtcbi8qKiBEaXJlY3RpdmUgdGhhdCBlbmZvcmNlcyB0aGF0IHRoZSBgbWF0LWAgcHJlZml4IGNhbm5vdCBiZSB1c2VkLiAqL1xudmFyIE1hdFByZWZpeFJlamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRQcmVmaXhSZWplY3Rvcihpc0NvbXBhdGliaWxpdHlNb2RlKSB7XG4gICAgICAgIGlmICghaXNDb21wYXRpYmlsaXR5TW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSBcIm1hdC1cIiBwcmVmaXggY2Fubm90IGJlIHVzZWQgb3V0IG9mIG5nLW1hdGVyaWFsIHYxIGNvbXBhdGliaWxpdHkgbW9kZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNYXRQcmVmaXhSZWplY3RvciA9IF9fZGVjb3JhdGUkMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6IE1BVF9FTEVNRU5UU19TRUxFQ1RPUiB9KSxcbiAgICAgICAgX19wYXJhbSgwLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtKDAsIF9hbmd1bGFyX2NvcmUuSW5qZWN0KE1BVEVSSUFMX0NPTVBBVElCSUxJVFlfTU9ERSkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtCb29sZWFuXSlcbiAgICBdLCBNYXRQcmVmaXhSZWplY3Rvcik7XG4gICAgcmV0dXJuIE1hdFByZWZpeFJlamVjdG9yO1xufSgpKTtcbi8qKiBEaXJlY3RpdmUgdGhhdCBlbmZvcmNlcyB0aGF0IHRoZSBgbWQtYCBwcmVmaXggY2Fubm90IGJlIHVzZWQuICovXG52YXIgTWRQcmVmaXhSZWplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcmVmaXhSZWplY3Rvcihpc0NvbXBhdGliaWxpdHlNb2RlKSB7XG4gICAgICAgIGlmIChpc0NvbXBhdGliaWxpdHlNb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGhlIFwibWQtXCIgcHJlZml4IGNhbm5vdCBiZSB1c2VkIGluIG5nLW1hdGVyaWFsIHYxIGNvbXBhdGliaWxpdHkgbW9kZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNZFByZWZpeFJlamVjdG9yID0gX19kZWNvcmF0ZSQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoeyBzZWxlY3RvcjogTURfRUxFTUVOVFNfU0VMRUNUT1IgfSksXG4gICAgICAgIF9fcGFyYW0oMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSgwLCBfYW5ndWxhcl9jb3JlLkluamVjdChNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMignZGVzaWduOnBhcmFtdHlwZXMnLCBbQm9vbGVhbl0pXG4gICAgXSwgTWRQcmVmaXhSZWplY3Rvcik7XG4gICAgcmV0dXJuIE1kUHJlZml4UmVqZWN0b3I7XG59KCkpO1xuLyoqXG4gKiBNb2R1bGUgdGhhdCBlbmZvcmNlcyB0aGUgZGVmYXVsdCBjb21wYXRpYmlsaXR5IG1vZGUgc2V0dGluZ3MuIFdoZW4gdGhpcyBtb2R1bGUgaXMgbG9hZGVkXG4gKiB3aXRob3V0IE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlIGFsc28gYmVpbmcgaW1wb3J0ZWQsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAqIHRoZXJlIGFyZSBhbnkgdXNlcyBvZiB0aGUgYG1hdC1gIHByZWZpeC5cbiAqL1xudmFyIENvbXBhdGliaWxpdHlNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBhdGliaWxpdHlNb2R1bGUoKSB7XG4gICAgfVxuICAgIENvbXBhdGliaWxpdHlNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBDb21wYXRpYmlsaXR5TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbXBhdGliaWxpdHlNb2R1bGUgPSBfX2RlY29yYXRlJDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01hdFByZWZpeFJlamVjdG9yLCBNZFByZWZpeFJlamVjdG9yXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYXRQcmVmaXhSZWplY3RvciwgTWRQcmVmaXhSZWplY3Rvcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIENvbXBhdGliaWxpdHlNb2R1bGUpO1xuICAgIHJldHVybiBDb21wYXRpYmlsaXR5TW9kdWxlO1xufSgpKTtcbi8qKlxuICogTW9kdWxlIHRoYXQgZW5mb3JjZXMgXCJuby1jb25mbGljdFwiIGNvbXBhdGliaWxpdHkgbW9kZSBzZXR0aW5ncy4gV2hlbiB0aGlzIG1vZHVsZSBpcyBsb2FkZWQsXG4gKiBpdCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgdXNlcyBvZiB0aGUgYG1kLWAgcHJlZml4LlxuICovXG52YXIgTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICAgIH1cbiAgICBOb0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZSA9IF9fZGVjb3JhdGUkMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUsIHVzZVZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBOb0NvbmZsaWN0U3R5bGVDb21wYXRpYmlsaXR5TW9kZSk7XG4gICAgcmV0dXJuIE5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFNoYXJlZCBkaXJlY3RpdmUgdG8gY291bnQgbGluZXMgaW5zaWRlIGEgdGV4dCBhcmVhLCBzdWNoIGFzIGEgbGlzdCBpdGVtLlxuICogTGluZSBlbGVtZW50cyBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYSBAQ29udGVudENoaWxkcmVuKE1kTGluZSkgcXVlcnksIHRoZW5cbiAqIGNvdW50ZWQgYnkgY2hlY2tpbmcgdGhlIHF1ZXJ5IGxpc3QncyBsZW5ndGguXG4gKi9cbnZhciBNZExpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGluZSgpIHtcbiAgICB9XG4gICAgTWRMaW5lID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtbGluZV0sIFttYXQtbGluZV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWxpbmVdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGluZSk7XG4gICAgcmV0dXJuIE1kTGluZTtcbn0oKSk7XG4vKipcbiAqIEhlbHBlciB0aGF0IHRha2VzIGEgcXVlcnkgbGlzdCBvZiBsaW5lcyBhbmQgc2V0cyB0aGUgY29ycmVjdCBjbGFzcyBvbiB0aGUgaG9zdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTGluZVNldHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaW5lU2V0dGVyKF9saW5lcywgX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saW5lcyA9IF9saW5lcztcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fc2V0TGluZUNsYXNzKHRoaXMuX2xpbmVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2xpbmVzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9zZXRMaW5lQ2xhc3MoX3RoaXMuX2xpbmVzLmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBNZExpbmVTZXR0ZXIucHJvdG90eXBlLl9zZXRMaW5lQ2xhc3MgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRDbGFzc2VzKCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMiB8fCBjb3VudCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5fc2V0Q2xhc3MoXCJtYXQtXCIgKyBjb3VudCArIFwiLWxpbmVcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY291bnQgPiAzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDbGFzcyhcIm1hdC1tdWx0aS1saW5lXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZExpbmVTZXR0ZXIucHJvdG90eXBlLl9yZXNldENsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldENsYXNzKCdtYXQtMi1saW5lJywgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRDbGFzcygnbWF0LTMtbGluZScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0Q2xhc3MoJ21hdC1tdWx0aS1saW5lJywgZmFsc2UpO1xuICAgIH07XG4gICAgTWRMaW5lU2V0dGVyLnByb3RvdHlwZS5fc2V0Q2xhc3MgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBib29sKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIGNsYXNzTmFtZSwgYm9vbCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRMaW5lU2V0dGVyO1xufSgpKTtcbnZhciBNZExpbmVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGluZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRMaW5lTW9kdWxlID0gX19kZWNvcmF0ZSQxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRMaW5lLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kTGluZV0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGluZU1vZHVsZSk7XG4gICAgcmV0dXJuIE1kTGluZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgdG8gbGlzdGVuIGZvciBjaGFuZ2VzIG9mIGRpcmVjdGlvbiBvZiBwYXJ0IG9mIHRoZSBET00uXG4gKlxuICogQXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhpcyBkaXJlY3RpdmUgaW5zdGVhZCBvZiB0aGUgbmF0aXZlIGF0dHJpYnV0ZSBzbyB0aGF0IE1hdGVyaWFsXG4gKiBjb21wb25lbnRzIGNhbiBsaXN0ZW4gb24gY2hhbmdlcyBvZiBkaXJlY3Rpb24uXG4gKi9cbnZhciBEaXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpcigpIHtcbiAgICAgICAgLyoqIExheW91dCBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQuICovXG4gICAgICAgIHRoaXMuX2RpciA9ICdsdHInO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBkaXJlY3Rpb24gY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5kaXJDaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpci5wcm90b3R5cGUsIFwiZGlyXCIsIHtcbiAgICAgICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5fZGlyO1xuICAgICAgICAgICAgdGhpcy5fZGlyID0gdjtcbiAgICAgICAgICAgIGlmIChvbGQgIT0gdGhpcy5fZGlyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJDaGFuZ2UuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBDdXJyZW50IGxheW91dCBkaXJlY3Rpb24gb2YgdGhlIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXI7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5kaXIgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdkaXInKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgRGlyLnByb3RvdHlwZSwgXCJfZGlyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgRGlyLnByb3RvdHlwZSwgXCJkaXJDaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLmRpcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBEaXIucHJvdG90eXBlLCBcImRpclwiLCBudWxsKTtcbiAgICBEaXIgPSBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tkaXJdJyxcbiAgICAgICAgICAgIC8vIFRPRE8oaGFuc2wpOiBtYXliZSBgJGltcGxpY2l0YCBpc24ndCB0aGUgYmVzdCBvcHRpb24gaGVyZSwgYnV0IGZvciBub3cgdGhhdCdzIHRoZSBiZXN0IHdlIGdvdC5cbiAgICAgICAgICAgIGV4cG9ydEFzOiAnJGltcGxpY2l0J1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBEaXIpO1xuICAgIHJldHVybiBEaXI7XG59KCkpO1xudmFyIFJ0bE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUnRsTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBSdGxNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBSdGxNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBSdGxNb2R1bGUgPSBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGV4cG9ydHM6IFtEaXJdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbRGlyXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBSdGxNb2R1bGUpO1xuICAgIHJldHVybiBSdGxNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgdHJpZ2dlcnMgYSBjYWxsYmFjayB3aGVuZXZlciB0aGUgY29udGVudCBvZlxuICogaXRzIGFzc29jaWF0ZWQgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xudmFyIE9ic2VydmVDb250ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlQ29udGVudChfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIGZvciBlYWNoIGNoYW5nZSBpbiB0aGUgZWxlbWVudCdzIGNvbnRlbnQuICovXG4gICAgICAgIHRoaXMuZXZlbnQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JzZXJ2ZUNvbnRlbnQucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7IHJldHVybiBtdXRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5ldmVudC5lbWl0KCk7IH0pOyB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHtcbiAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2ZUNvbnRlbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ2Nka09ic2VydmVDb250ZW50JyksIFxuICAgICAgICBfX21ldGFkYXRhJDQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE9ic2VydmVDb250ZW50LnByb3RvdHlwZSwgXCJldmVudFwiLCB2b2lkIDApO1xuICAgIE9ic2VydmVDb250ZW50ID0gX19kZWNvcmF0ZSQ0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrT2JzZXJ2ZUNvbnRlbnRdJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBPYnNlcnZlQ29udGVudCk7XG4gICAgcmV0dXJuIE9ic2VydmVDb250ZW50O1xufSgpKTtcbnZhciBPYnNlcnZlQ29udGVudE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZUNvbnRlbnRNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE9ic2VydmVDb250ZW50TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogT2JzZXJ2ZUNvbnRlbnRNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYnNlcnZlQ29udGVudE1vZHVsZSA9IF9fZGVjb3JhdGUkNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW09ic2VydmVDb250ZW50XSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW09ic2VydmVDb250ZW50XVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBPYnNlcnZlQ29udGVudE1vZHVsZSk7XG4gICAgcmV0dXJuIE9ic2VydmVDb250ZW50TW9kdWxlO1xufSgpKTtcblxuLy8gRHVlIHRvIGEgYnVnIGluIHRoZSBDaHJvbWVEcml2ZXIsIEFuZ3VsYXIga2V5Ym9hcmQgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGJ5IGBzZW5kS2V5c2Bcbi8vIGR1cmluZyBFMkUgdGVzdHMgd2hlbiB1c2luZyBkb3Qgbm90YXRpb24gc3VjaCBhcyBgKGtleWRvd24ucmlnaHRBcnJvdylgLiBUbyBnZXQgYXJvdW5kIHRoaXMsXG4vLyB3ZSBhcmUgdGVtcG9yYXJpbHkgdXNpbmcgYSBzaW5nbGUgKGtleWRvd24pIGhhbmRsZXIuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzk0MTlcbnZhciBVUF9BUlJPVyA9IDM4O1xudmFyIERPV05fQVJST1cgPSA0MDtcbnZhciBSSUdIVF9BUlJPVyA9IDM5O1xudmFyIExFRlRfQVJST1cgPSAzNztcbnZhciBQQUdFX1VQID0gMzM7XG52YXIgUEFHRV9ET1dOID0gMzQ7XG52YXIgSE9NRSA9IDM2O1xudmFyIEVORCA9IDM1O1xudmFyIEVOVEVSID0gMTM7XG52YXIgU1BBQ0UgPSAzMjtcbnZhciBUQUIgPSA5O1xudmFyIEVTQ0FQRSA9IDI3O1xudmFyIEJBQ0tTUEFDRSA9IDg7XG52YXIgREVMRVRFID0gNDY7XG5cbi8qKiBDb2VyY2VzIGEgZGF0YS1ib3VuZCB2YWx1ZSAodHlwaWNhbGx5IGEgc3RyaW5nKSB0byBhIGJvb2xlYW4uICovXG5mdW5jdGlvbiBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBcIlwiICsgdmFsdWUgIT09ICdmYWxzZSc7XG59XG5cbi8qKiBGYWRlLWluIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kLiBDYW4gYmUgbW9kaWZpZWQgd2l0aCB0aGUgc3BlZWRGYWN0b3Igb3B0aW9uLiAqL1xudmFyIFJJUFBMRV9TUEVFRF9QWF9QRVJfU0VDT05EID0gMTcwO1xuLyoqIEZhZGUtb3V0IHNwZWVkIGZvciB0aGUgcmlwcGxlcyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgY2FuJ3QgYmUgbW9kaWZpZWQgYnkgdGhlIHNwZWVkRmFjdG9yLiAqL1xudmFyIFJJUFBMRV9GQURFX09VVF9EVVJBVElPTiA9IDYwMDtcbi8qKlxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgKHgsIHkpIHRvIHRoZSBmdXJ0aGVzdCBjb3JuZXIgb2YgYSByZWN0YW5nbGUuXG4gKi9cbnZhciBkaXN0YW5jZVRvRnVydGhlc3RDb3JuZXIgPSBmdW5jdGlvbiAoeCwgeSwgcmVjdCkge1xuICAgIHZhciBkaXN0WCA9IE1hdGgubWF4KE1hdGguYWJzKHggLSByZWN0LmxlZnQpLCBNYXRoLmFicyh4IC0gcmVjdC5yaWdodCkpO1xuICAgIHZhciBkaXN0WSA9IE1hdGgubWF4KE1hdGguYWJzKHkgLSByZWN0LnRvcCksIE1hdGguYWJzKHkgLSByZWN0LmJvdHRvbSkpO1xuICAgIHJldHVybiBNYXRoLnNxcnQoZGlzdFggKiBkaXN0WCArIGRpc3RZICogZGlzdFkpO1xufTtcbi8qKlxuICogSGVscGVyIHNlcnZpY2UgdGhhdCBwZXJmb3JtcyBET00gbWFuaXB1bGF0aW9ucy4gTm90IGludGVuZGVkIHRvIGJlIHVzZWQgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbiAqIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIHJlZmVyZW5jZSB0byB0aGUgcmlwcGxlIGRpcmVjdGl2ZSdzIGhvc3QgZWxlbWVudCBhbmQgYSBtYXAgb2YgRE9NXG4gKiBldmVudCBoYW5kbGVycyB0byBiZSBpbnN0YWxsZWQgb24gdGhlIGVsZW1lbnQgdGhhdCB0cmlnZ2VycyByaXBwbGUgYW5pbWF0aW9ucy5cbiAqIFRoaXMgd2lsbCBldmVudHVhbGx5IGJlY29tZSBhIGN1c3RvbSByZW5kZXJlciBvbmNlIEFuZ3VsYXIgc3VwcG9ydCBleGlzdHMuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBSaXBwbGVSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmlwcGxlUmVuZGVyZXIoX2VsZW1lbnRSZWYsIF9uZ1pvbmUsIF9ydWxlcikge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9ydWxlciA9IF9ydWxlcjtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBkb3duIG9yIG5vdC4gKi9cbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgLyoqIEN1cnJlbnRseSBhY3RpdmUgcmlwcGxlcyB0aGF0IHdpbGwgYmUgY2xvc2VkIG9uIG1vdXNldXAuICovXG4gICAgICAgIHRoaXMuX2FjdGl2ZVJpcHBsZXMgPSBbXTtcbiAgICAgICAgLyoqIEV2ZW50cyB0byBiZSByZWdpc3RlcmVkIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQuICovXG4gICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBSaXBwbGUgY29uZmlnIGZvciBhbGwgcmlwcGxlcyBjcmVhdGVkIGJ5IGV2ZW50cy4gKi9cbiAgICAgICAgdGhpcy5yaXBwbGVDb25maWcgPSB7fTtcbiAgICAgICAgLyoqIFdoZXRoZXIgbW91c2UgcmlwcGxlcyBzaG91bGQgYmUgY3JlYXRlZCBvciBub3QuICovXG4gICAgICAgIHRoaXMucmlwcGxlRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyRWxlbWVudCA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIFNwZWNpZnkgZXZlbnRzIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBvbiB0aGUgdHJpZ2dlci5cbiAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cy5zZXQoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZWRvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuc2V0KCdtb3VzZXVwJywgdGhpcy5vbk1vdXNldXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuc2V0KCdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdXNlIHRoZSBob3N0IGVsZW1lbnQgYXMgdHJpZ2dlciBlbGVtZW50LlxuICAgICAgICB0aGlzLnNldFRyaWdnZXJFbGVtZW50KHRoaXMuX2NvbnRhaW5lckVsZW1lbnQpO1xuICAgIH1cbiAgICAvKiogRmFkZXMgaW4gYSByaXBwbGUgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLiAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5mYWRlSW5SaXBwbGUgPSBmdW5jdGlvbiAocGFnZVgsIHBhZ2VZLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gdGhpcy5fY29udGFpbmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5jZW50ZXJlZCkge1xuICAgICAgICAgICAgcGFnZVggPSBjb250YWluZXJSZWN0LmxlZnQgKyBjb250YWluZXJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgICAgIHBhZ2VZID0gY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBzY3JvbGwgdmFsdWVzIGZyb20gdGhlIGNvb3JkaW5hdGVzIGJlY2F1c2UgY2FsY3VsYXRpb25zIGJlbG93XG4gICAgICAgICAgICAvLyBhcmUgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCByZWN0YW5nbGUuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9ydWxlci5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBwYWdlWCAtPSBzY3JvbGxQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgcGFnZVkgLT0gc2Nyb2xsUG9zaXRpb24udG9wO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYWRpdXMgPSBjb25maWcucmFkaXVzIHx8IGRpc3RhbmNlVG9GdXJ0aGVzdENvcm5lcihwYWdlWCwgcGFnZVksIGNvbnRhaW5lclJlY3QpO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSAxIC8gKGNvbmZpZy5zcGVlZEZhY3RvciB8fCAxKSAqIChyYWRpdXMgLyBSSVBQTEVfU1BFRURfUFhfUEVSX1NFQ09ORCk7XG4gICAgICAgIHZhciBvZmZzZXRYID0gcGFnZVggLSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgIHZhciBvZmZzZXRZID0gcGFnZVkgLSBjb250YWluZXJSZWN0LnRvcDtcbiAgICAgICAgdmFyIHJpcHBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnbWF0LXJpcHBsZS1lbGVtZW50Jyk7XG4gICAgICAgIHJpcHBsZS5zdHlsZS5sZWZ0ID0gKG9mZnNldFggLSByYWRpdXMpICsgXCJweFwiO1xuICAgICAgICByaXBwbGUuc3R5bGUudG9wID0gKG9mZnNldFkgLSByYWRpdXMpICsgXCJweFwiO1xuICAgICAgICByaXBwbGUuc3R5bGUuaGVpZ2h0ID0gcmFkaXVzICogMiArIFwicHhcIjtcbiAgICAgICAgcmlwcGxlLnN0eWxlLndpZHRoID0gcmFkaXVzICogMiArIFwicHhcIjtcbiAgICAgICAgLy8gSWYgdGhlIGNvbG9yIGlzIG5vdCBzZXQsIHRoZSBkZWZhdWx0IENTUyBjb2xvciB3aWxsIGJlIHVzZWQuXG4gICAgICAgIHJpcHBsZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb25maWcuY29sb3I7XG4gICAgICAgIHJpcHBsZS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArIFwic1wiO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHJpcHBsZSk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGJyb3dzZXIgZG9lcyBub3QgcmVjYWxjdWxhdGUgdGhlIHN0eWxlcyBvZiBkeW5hbWljYWxseSBjcmVhdGVkXG4gICAgICAgIC8vIHJpcHBsZSBlbGVtZW50cy4gVGhpcyBpcyBjcml0aWNhbCBiZWNhdXNlIHRoZW4gdGhlIGBzY2FsZWAgd291bGQgbm90IGFuaW1hdGUgcHJvcGVybHkuXG4gICAgICAgIHRoaXMuX2VuZm9yY2VTdHlsZVJlY2FsY3VsYXRpb24ocmlwcGxlKTtcbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxKSc7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSByaXBwbGUgdG8gYmUgZmFkZWQgaW4uIE9uY2UgaXQncyBmYWRlZCBpbiwgdGhlIHJpcHBsZSBjYW4gYmUgaGlkZGVuIGltbWVkaWF0ZWx5XG4gICAgICAgIC8vIGlmIHRoZSBtb3VzZSBpcyByZWxlYXNlZC5cbiAgICAgICAgdGhpcy5ydW5UaW1lb3V0T3V0c2lkZVpvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2lzTW91c2Vkb3duID8gX3RoaXMuX2FjdGl2ZVJpcHBsZXMucHVzaChyaXBwbGUpIDogX3RoaXMuZmFkZU91dFJpcHBsZShyaXBwbGUpO1xuICAgICAgICB9LCBkdXJhdGlvbiAqIDEwMDApO1xuICAgIH07XG4gICAgLyoqIEZhZGVzIG91dCBhIHJpcHBsZSBlbGVtZW50LiAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5mYWRlT3V0UmlwcGxlID0gZnVuY3Rpb24gKHJpcHBsZSkge1xuICAgICAgICByaXBwbGUuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gUklQUExFX0ZBREVfT1VUX0RVUkFUSU9OICsgXCJtc1wiO1xuICAgICAgICByaXBwbGUuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgLy8gT25jZSB0aGUgcmlwcGxlIGZhZGVkIG91dCwgdGhlIHJpcHBsZSBjYW4gYmUgc2FmZWx5IHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAgICB0aGlzLnJ1blRpbWVvdXRPdXRzaWRlWm9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByaXBwbGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyaXBwbGUpO1xuICAgICAgICB9LCBSSVBQTEVfRkFERV9PVVRfRFVSQVRJT04pO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIHRyaWdnZXIgZWxlbWVudCBhbmQgcmVnaXN0ZXJzIHRoZSBtb3VzZSBldmVudHMuICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLnNldFRyaWdnZXJFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBwcmV2aW91c2x5IHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmbiwgdHlwZSkgeyByZXR1cm4gX3RoaXMuX3RyaWdnZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IG51bGwsIHJlZ2lzdGVyIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIHRyaWdnZXIgZWxlbWVudC5cbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZm4sIHR5cGUpIHsgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbGVtZW50ID0gZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKiBMaXN0ZW5lciBiZWluZyBjYWxsZWQgb24gbW91c2Vkb3duIGV2ZW50LiAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5vbk1vdXNlZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5yaXBwbGVEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzTW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mYWRlSW5SaXBwbGUoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZLCB0aGlzLnJpcHBsZUNvbmZpZyk7XG4gICAgfTtcbiAgICAvKiogTGlzdGVuZXIgYmVpbmcgY2FsbGVkIG9uIG1vdXNldXAgZXZlbnQuICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLm9uTW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyaXBwbGUpIHsgcmV0dXJuIF90aGlzLmZhZGVPdXRSaXBwbGUocmlwcGxlKTsgfSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVJpcHBsZXMgPSBbXTtcbiAgICB9O1xuICAgIC8qKiBMaXN0ZW5lciBiZWluZyBjYWxsZWQgb24gbW91c2VsZWF2ZSBldmVudC4gKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNNb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZXVwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSdW5zIGEgdGltZW91dCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUgdG8gYXZvaWQgdHJpZ2dlcmluZyB0aGUgY2hhbmdlIGRldGVjdGlvbi4gKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUucnVuVGltZW91dE91dHNpZGVab25lID0gZnVuY3Rpb24gKGZuLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNldFRpbWVvdXQoZm4sIGRlbGF5KTsgfSk7XG4gICAgfTtcbiAgICAvKiogRW5mb3JjZXMgYSBzdHlsZSByZWNhbGN1bGF0aW9uIG9mIGEgRE9NIGVsZW1lbnQgYnkgY29tcHV0aW5nIGl0cyBzdHlsZXMuICovXG4gICAgLy8gVE9ETyhkZXZ2ZXJzaW9uKTogTW92ZSBpbnRvIGdsb2JhbCB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5fZW5mb3JjZVN0eWxlUmVjYWxjdWxhdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIEVuZm9yY2UgYSBzdHlsZSByZWNhbGN1bGF0aW9uIGJ5IGNhbGxpbmcgYGdldENvbXB1dGVkU3R5bGVgIGFuZCBhY2Nlc3NpbmcgYW55IHByb3BlcnR5LlxuICAgICAgICAvLyBDYWxsaW5nIGBnZXRQcm9wZXJ0eVZhbHVlYCBpcyBpbXBvcnRhbnQgdG8gbGV0IG9wdGltaXplcnMga25vdyB0aGF0IHRoaXMgaXMgbm90IGEgbm9vcC5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNWQ1MmZiMDgxYjM1NzBjODFlM2FcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnb3BhY2l0eScpO1xuICAgIH07XG4gICAgcmV0dXJuIFJpcHBsZVJlbmRlcmVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogVGltZSBpbiBtcyB0byB0aHJvdHRsZSB0aGUgc2Nyb2xsaW5nIGV2ZW50cyBieSBkZWZhdWx0LiAqL1xudmFyIERFRkFVTFRfU0NST0xMX1RJTUUgPSAyMDtcbi8qKlxuICogU2VydmljZSBjb250YWluZWQgYWxsIHJlZ2lzdGVyZWQgU2Nyb2xsYWJsZSByZWZlcmVuY2VzIGFuZCBlbWl0cyBhbiBldmVudCB3aGVuIGFueSBvbmUgb2YgdGhlXG4gKiBTY3JvbGxhYmxlIHJlZmVyZW5jZXMgZW1pdCBhIHNjcm9sbGVkIGV2ZW50LlxuICovXG52YXIgU2Nyb2xsRGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nyb2xsRGlzcGF0Y2hlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IGEgcmVnaXN0ZXJlZCBzY3JvbGxhYmxlIHJlZmVyZW5jZSBlbGVtZW50IGhhcyBiZWVuIHNjcm9sbGVkLiAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxlZCA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIGFsbCB0aGUgc2Nyb2xsYWJsZSByZWZlcmVuY2VzIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZSBhbmQgdGhlaXJcbiAgICAgICAgICogc2Nyb2xsIGV2ZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBCeSBkZWZhdWx0LCBub3RpZnkgYSBzY3JvbGwgZXZlbnQgd2hlbiB0aGUgZG9jdW1lbnQgaXMgc2Nyb2xsZWQgb3IgdGhlIHdpbmRvdyBpcyByZXNpemVkLlxuICAgICAgICByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5mcm9tRXZlbnQod2luZG93LmRvY3VtZW50LCAnc2Nyb2xsJykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9ub3RpZnkoKTsgfSk7XG4gICAgICAgIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX25vdGlmeSgpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgU2Nyb2xsYWJsZSB3aXRoIHRoZSBzZXJ2aWNlIGFuZCBsaXN0ZW5zIGZvciBpdHMgc2Nyb2xsZWQgZXZlbnRzLiBXaGVuIHRoZVxuICAgICAqIHNjcm9sbGFibGUgaXMgc2Nyb2xsZWQsIHRoZSBzZXJ2aWNlIGVtaXRzIHRoZSBldmVudCBpbiBpdHMgc2Nyb2xsZWQgb2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY3JvbGxhYmxlIFNjcm9sbGFibGUgaW5zdGFuY2UgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JvbGxTdWJzY3JpcHRpb24gPSBzY3JvbGxhYmxlLmVsZW1lbnRTY3JvbGxlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fbm90aWZ5KCk7IH0pO1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVSZWZlcmVuY2VzLnNldChzY3JvbGxhYmxlLCBzY3JvbGxTdWJzY3JpcHRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVyZWdpc3RlcnMgYSBTY3JvbGxhYmxlIHJlZmVyZW5jZSBhbmQgdW5zdWJzY3JpYmVzIGZyb20gaXRzIHNjcm9sbCBldmVudCBvYnNlcnZhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjcm9sbGFibGUgU2Nyb2xsYWJsZSBpbnN0YW5jZSB0byBiZSBkZXJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgU2Nyb2xsRGlzcGF0Y2hlci5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZ2V0KHNjcm9sbGFibGUpLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZGVsZXRlKHNjcm9sbGFibGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgYW4gZXZlbnQgd2hlbmV2ZXIgYW55IG9mIHRoZSByZWdpc3RlcmVkIFNjcm9sbGFibGVcbiAgICAgKiByZWZlcmVuY2VzIChvciB3aW5kb3csIGRvY3VtZW50LCBvciBib2R5KSBmaXJlIGEgc2Nyb2xsZWQgZXZlbnQuIENhbiBwcm92aWRlIGEgdGltZSBpbiBtc1xuICAgICAqIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IFwidGhyb3R0bGVcIiB0aW1lLlxuICAgICAqL1xuICAgIFNjcm9sbERpc3BhdGNoZXIucHJvdG90eXBlLnNjcm9sbGVkID0gZnVuY3Rpb24gKGF1ZGl0VGltZUluTXMpIHtcbiAgICAgICAgaWYgKGF1ZGl0VGltZUluTXMgPT09IHZvaWQgMCkgeyBhdWRpdFRpbWVJbk1zID0gREVGQVVMVF9TQ1JPTExfVElNRTsgfVxuICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIDBtcyBkZWxheSwgcmV0dXJuIHRoZSBvYnNlcnZhYmxlIHdpdGhvdXQgYXVkaXRUaW1lIHNpbmNlIGl0IGRvZXMgYWRkXG4gICAgICAgIC8vIGEgcGVyY2VwdGlibGUgZGVsYXkgaW4gcHJvY2Vzc2luZyBvdmVyaGVhZC5cbiAgICAgICAgaWYgKGF1ZGl0VGltZUluTXMgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbGVkLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxlZC5hc09ic2VydmFibGUoKS5hdWRpdFRpbWUoYXVkaXRUaW1lSW5Ncyk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBTY3JvbGxhYmxlcyB0aGF0IGNvbnRhaW4gdGhlIHByb3ZpZGVkIGVsZW1lbnQuICovXG4gICAgU2Nyb2xsRGlzcGF0Y2hlci5wcm90b3R5cGUuZ2V0U2Nyb2xsQ29udGFpbmVycyA9IGZ1bmN0aW9uIChlbGVtZW50UmVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JvbGxpbmdDb250YWluZXJzID0gW107XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaXB0aW9uLCBzY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2Nyb2xsYWJsZUNvbnRhaW5zRWxlbWVudChzY3JvbGxhYmxlLCBlbGVtZW50UmVmKSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbGluZ0NvbnRhaW5lcnMucHVzaChzY3JvbGxhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzY3JvbGxpbmdDb250YWluZXJzO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBTY3JvbGxhYmxlLiAqL1xuICAgIFNjcm9sbERpc3BhdGNoZXIucHJvdG90eXBlLnNjcm9sbGFibGVDb250YWluc0VsZW1lbnQgPSBmdW5jdGlvbiAoc2Nyb2xsYWJsZSwgZWxlbWVudFJlZikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIHNjcm9sbGFibGVFbGVtZW50ID0gc2Nyb2xsYWJsZS5nZXRFbGVtZW50UmVmKCkubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gVHJhdmVyc2UgdGhyb3VnaCB0aGUgZWxlbWVudCBwYXJlbnRzIHVudGlsIHdlIHJlYWNoIG51bGwsIGNoZWNraW5nIGlmIGFueSBvZiB0aGUgZWxlbWVudHNcbiAgICAgICAgLy8gYXJlIHRoZSBzY3JvbGxhYmxlJ3MgZWxlbWVudC5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT0gc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgfTtcbiAgICAvKiogU2VuZHMgYSBub3RpZmljYXRpb24gdGhhdCBhIHNjcm9sbCBldmVudCBoYXMgYmVlbiBmaXJlZC4gKi9cbiAgICBTY3JvbGxEaXNwYXRjaGVyLnByb3RvdHlwZS5fbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxlZC5uZXh0KCk7XG4gICAgfTtcbiAgICBTY3JvbGxEaXNwYXRjaGVyID0gX19kZWNvcmF0ZSQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgU2Nyb2xsRGlzcGF0Y2hlcik7XG4gICAgcmV0dXJuIFNjcm9sbERpc3BhdGNoZXI7XG59KCkpO1xuZnVuY3Rpb24gU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyKSB7XG4gICAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IFNjcm9sbERpc3BhdGNoZXIoKTtcbn1cbnZhciBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgU2Nyb2xsRGlzcGF0Y2hlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgZGVwczogW1tuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpLCBTY3JvbGxEaXNwYXRjaGVyXV0sXG4gICAgdXNlRmFjdG9yeTogU0NST0xMX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWVxufTtcblxudmFyIF9fZGVjb3JhdGUkNyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFNpbXBsZSB1dGlsaXR5IGZvciBnZXR0aW5nIHRoZSBib3VuZHMgb2YgdGhlIGJyb3dzZXIgdmlld3BvcnQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBWaWV3cG9ydFJ1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGVyKHNjcm9sbERpc3BhdGNoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSW5pdGlhbGx5IGNhY2hlIHRoZSBkb2N1bWVudCByZWN0YW5nbGUuXG4gICAgICAgIHRoaXMuX2NhY2hlVmlld3BvcnRHZW9tZXRyeSgpO1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gc2Nyb2xsIGFuZCByZXNpemUgZXZlbnRzIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHJlY3RhbmdsZSBvbiBjaGFuZ2VzLlxuICAgICAgICBzY3JvbGxEaXNwYXRjaGVyLnNjcm9sbGVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jYWNoZVZpZXdwb3J0R2VvbWV0cnkoKTsgfSk7XG4gICAgfVxuICAgIC8qKiBHZXRzIGEgQ2xpZW50UmVjdCBmb3IgdGhlIHZpZXdwb3J0J3MgYm91bmRzLiAqL1xuICAgIFZpZXdwb3J0UnVsZXIucHJvdG90eXBlLmdldFZpZXdwb3J0UmVjdCA9IGZ1bmN0aW9uIChkb2N1bWVudFJlY3QpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50UmVjdCA9PT0gdm9pZCAwKSB7IGRvY3VtZW50UmVjdCA9IHRoaXMuX2RvY3VtZW50UmVjdDsgfVxuICAgICAgICAvLyBVc2UgdGhlIGRvY3VtZW50IGVsZW1lbnQncyBib3VuZGluZyByZWN0IHJhdGhlciB0aGFuIHRoZSB3aW5kb3cgc2Nyb2xsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gKGUuZy4gcGFnZVlPZmZzZXQsIHNjcm9sbFkpIGR1ZSB0byBpbiBpc3N1ZSBpbiBDaHJvbWUgYW5kIElFIHdoZXJlIHdpbmRvdyBzY3JvbGxcbiAgICAgICAgLy8gcHJvcGVydGllcyBhbmQgY2xpZW50IGNvb3JkaW5hdGVzIChib3VuZGluZ0NsaWVudFJlY3QsIGNsaWVudFgvWSwgZXRjLikgYXJlIGluIGRpZmZlcmVudFxuICAgICAgICAvLyBjb25jZXB0dWFsIHZpZXdwb3J0cy4gVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIHRoZXNlIHZpZXdwb3J0cyBhcmUgZXF1aXZhbGVudCwgYnV0IHRoZXlcbiAgICAgICAgLy8gY2FuIGRpc2FncmVlIHdoZW4gdGhlIHBhZ2UgaXMgcGluY2gtem9vbWVkIChvbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCB0b3VjaCkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00ODkyMDYjYzRcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBkb2N1bWVudEVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgYm9keSBiZWNhdXNlLCBieSBkZWZhdWx0ICh3aXRob3V0IGEgY3NzIHJlc2V0KVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZ2l2ZSB0aGUgZG9jdW1lbnQgYm9keSBhbiA4cHggbWFyZ2luLCB3aGljaCBpcyBub3QgaW5jbHVkZWQgaW5cbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuXG4gICAgICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbihkb2N1bWVudFJlY3QpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogc2Nyb2xsUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbGVmdDogc2Nyb2xsUG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogc2Nyb2xsUG9zaXRpb24udG9wICsgaGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IHNjcm9sbFBvc2l0aW9uLmxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgKHRvcCwgbGVmdCkgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWN0XG4gICAgICovXG4gICAgVmlld3BvcnRSdWxlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uIChkb2N1bWVudFJlY3QpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50UmVjdCA9PT0gdm9pZCAwKSB7IGRvY3VtZW50UmVjdCA9IHRoaXMuX2RvY3VtZW50UmVjdDsgfVxuICAgICAgICAvLyBUaGUgdG9wLWxlZnQtY29ybmVyIG9mIHRoZSB2aWV3cG9ydCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIGJvZHksIG5vcm1hbGx5IGp1c3QgKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkuIEhvd2V2ZXIsIENocm9tZSBhbmQgRmlyZWZveCBkaXNhZ3JlZSBhYm91dFxuICAgICAgICAvLyB3aGV0aGVyIGBkb2N1bWVudC5ib2R5YCBvciBgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50YCBpcyB0aGUgc2Nyb2xsZWQgZWxlbWVudCwgc28gcmVhZGluZ1xuICAgICAgICAvLyBgc2Nyb2xsVG9wYCBhbmQgYHNjcm9sbExlZnRgIGlzIGluY29uc2lzdGVudC4gSG93ZXZlciwgdXNpbmcgdGhlIGJvdW5kaW5nIHJlY3Qgb2ZcbiAgICAgICAgLy8gYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAgd29ya3MgY29uc2lzdGVudGx5LCB3aGVyZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCB2YWx1ZXMgd2lsbFxuICAgICAgICAvLyBlcXVhbCBuZWdhdGl2ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICB2YXIgdG9wID0gLWRvY3VtZW50UmVjdC50b3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgd2luZG93LnNjcm9sbFkgfHwgMDtcbiAgICAgICAgdmFyIGxlZnQgPSAtZG9jdW1lbnRSZWN0LmxlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IHdpbmRvdy5zY3JvbGxYIHx8IDA7XG4gICAgICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gICAgfTtcbiAgICAvKiogQ2FjaGVzIHRoZSBsYXRlc3QgY2xpZW50IHJlY3RhbmdsZSBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudC4gKi9cbiAgICBWaWV3cG9ydFJ1bGVyLnByb3RvdHlwZS5fY2FjaGVWaWV3cG9ydEdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICBWaWV3cG9ydFJ1bGVyID0gX19kZWNvcmF0ZSQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1Njcm9sbERpc3BhdGNoZXJdKVxuICAgIF0sIFZpZXdwb3J0UnVsZXIpO1xuICAgIHJldHVybiBWaWV3cG9ydFJ1bGVyO1xufSgpKTtcbmZ1bmN0aW9uIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSX0ZBQ1RPUlkocGFyZW50UnVsZXIsIHNjcm9sbERpc3BhdGNoZXIpIHtcbiAgICByZXR1cm4gcGFyZW50UnVsZXIgfHwgbmV3IFZpZXdwb3J0UnVsZXIoc2Nyb2xsRGlzcGF0Y2hlcik7XG59XG52YXIgVklFV1BPUlRfUlVMRVJfUFJPVklERVIgPSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIFZpZXdwb3J0UnVsZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBWaWV3cG9ydFJ1bGVyLFxuICAgIGRlcHM6IFtbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYoKSwgVmlld3BvcnRSdWxlcl0sIFNjcm9sbERpc3BhdGNoZXJdLFxuICAgIHVzZUZhY3Rvcnk6IFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSX0ZBQ1RPUllcbn07XG5cbnZhciBfX2RlY29yYXRlJDYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kUmlwcGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJpcHBsZShlbGVtZW50UmVmLCBuZ1pvbmUsIHJ1bGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIHRoZSByYWRpdXMgaW4gcGl4ZWxzIG9mIGZvcmVncm91bmQgcmlwcGxlcyB3aGVuIGZ1bGx5IGV4cGFuZGVkLiBJZiB1bnNldCwgdGhlIHJhZGl1c1xuICAgICAgICAgKiB3aWxsIGJlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHJpcHBsZSB0byB0aGUgZnVydGhlc3QgY29ybmVyIG9mIHRoZSBob3N0IGVsZW1lbnQnc1xuICAgICAgICAgKiBib3VuZGluZyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIHRoZSBub3JtYWwgZHVyYXRpb24gb2YgcmlwcGxlIGFuaW1hdGlvbnMgaXMgZGl2aWRlZCBieSB0aGlzIHZhbHVlLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgICogc2V0dGluZyBpdCB0byAwLjUgd2lsbCBjYXVzZSB0aGUgYW5pbWF0aW9ucyB0byB0YWtlIHR3aWNlIGFzIGxvbmcuXG4gICAgICAgICAqIEEgY2hhbmdlZCBzcGVlZEZhY3RvciB3aWxsIG5vdCBtb2RpZnkgdGhlIGZhZGUtb3V0IGR1cmF0aW9uIG9mIHRoZSByaXBwbGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcGVlZEZhY3RvciA9IDE7XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyID0gbmV3IFJpcHBsZVJlbmRlcmVyKGVsZW1lbnRSZWYsIG5nWm9uZSwgcnVsZXIpO1xuICAgIH1cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1sndHJpZ2dlciddICYmIHRoaXMudHJpZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuc2V0VHJpZ2dlckVsZW1lbnQodGhpcy50cmlnZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5yaXBwbGVEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZUNvbmZpZygpO1xuICAgIH07XG4gICAgTWRSaXBwbGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBTZXQgdGhlIHRyaWdnZXIgZWxlbWVudCB0byBudWxsIHRvIGNsZWFudXAgYWxsIGxpc3RlbmVycy5cbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuc2V0VHJpZ2dlckVsZW1lbnQobnVsbCk7XG4gICAgfTtcbiAgICAvKiogTGF1bmNoZXMgYSBtYW51YWwgcmlwcGxlIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uICovXG4gICAgTWRSaXBwbGUucHJvdG90eXBlLmxhdW5jaCA9IGZ1bmN0aW9uIChwYWdlWCwgcGFnZVksIGNvbmZpZykge1xuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5mYWRlSW5SaXBwbGUocGFnZVgsIHBhZ2VZLCBjb25maWcpO1xuICAgIH07XG4gICAgLyoqIFVwZGF0ZXMgdGhlIHJpcHBsZSBjb25maWd1cmF0aW9uIHdpdGggdGhlIGlucHV0IHZhbHVlcy4gKi9cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUuX3VwZGF0ZVJpcHBsZUNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIucmlwcGxlQ29uZmlnID0ge1xuICAgICAgICAgICAgY2VudGVyZWQ6IHRoaXMuY2VudGVyZWQsXG4gICAgICAgICAgICBzcGVlZEZhY3RvcjogdGhpcy5zcGVlZEZhY3RvcixcbiAgICAgICAgICAgIHJhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvclxuICAgICAgICB9O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRSaXBwbGVUcmlnZ2VyJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmlwcGxlLnByb3RvdHlwZSwgXCJ0cmlnZ2VyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRSaXBwbGVDZW50ZXJlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcImNlbnRlcmVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRSaXBwbGVEaXNhYmxlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRSaXBwbGVSYWRpdXMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcInJhZGl1c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kUmlwcGxlU3BlZWRGYWN0b3InKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNignZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcInNwZWVkRmFjdG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRSaXBwbGVDb2xvcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFJpcHBsZS5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFJpcHBsZVVuYm91bmRlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcInVuYm91bmRlZFwiLCB2b2lkIDApO1xuICAgIE1kUmlwcGxlID0gX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtcmlwcGxlXSwgW21hdC1yaXBwbGVdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yaXBwbGVdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJpcHBsZS11bmJvdW5kZWRdJzogJ3VuYm91bmRlZCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIFZpZXdwb3J0UnVsZXJdKVxuICAgIF0sIE1kUmlwcGxlKTtcbiAgICByZXR1cm4gTWRSaXBwbGU7XG59KCkpO1xudmFyIE1kUmlwcGxlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJpcHBsZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRSaXBwbGVNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFJpcHBsZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kUmlwcGxlTW9kdWxlID0gX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRSaXBwbGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRSaXBwbGVdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbVklFV1BPUlRfUlVMRVJfUFJPVklERVIsIFNDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRSaXBwbGVNb2R1bGUpO1xuICAgIHJldHVybiBNZFJpcHBsZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBPcHRpb24gSURzIG5lZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyBjb21wb25lbnRzLCBzbyB0aGlzIGNvdW50ZXIgZXhpc3RzIG91dHNpZGUgb2ZcbiAqIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xudmFyIF91bmlxdWVJZENvdW50ZXIgPSAwO1xuLyoqIEV2ZW50IG9iamVjdCBlbWl0dGVkIGJ5IE1kT3B0aW9uIHdoZW4gc2VsZWN0ZWQuICovXG52YXIgTWRPcHRpb25TZWxlY3RFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRPcHRpb25TZWxlY3RFdmVudChzb3VyY2UsIGlzVXNlcklucHV0KSB7XG4gICAgICAgIGlmIChpc1VzZXJJbnB1dCA9PT0gdm9pZCAwKSB7IGlzVXNlcklucHV0ID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuaXNVc2VySW5wdXQgPSBpc1VzZXJJbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIE1kT3B0aW9uU2VsZWN0RXZlbnQ7XG59KCkpO1xuLyoqXG4gKiBTaW5nbGUgb3B0aW9uIGluc2lkZSBvZiBhIGA8bWQtc2VsZWN0PmAgZWxlbWVudC5cbiAqL1xudmFyIE1kT3B0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE9wdGlvbihfZWxlbWVudCwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLiAgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faWQgPSBcIm1kLW9wdGlvbi1cIiArIF91bmlxdWVJZENvdW50ZXIrKztcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkLiAqL1xuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE9wdGlvbi5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKiogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgb3B0aW9uLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRPcHRpb24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIG9wdGlvbiBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRPcHRpb24ucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvcHRpb24gaXMgY3VycmVudGx5IHNlbGVjdGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kT3B0aW9uLnByb3RvdHlwZSwgXCJhY3RpdmVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIG9wdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlIGFuZCByZWFkeSB0byBiZSBzZWxlY3RlZC5cbiAgICAgICAgICogQW4gYWN0aXZlIG9wdGlvbiBkaXNwbGF5cyBzdHlsZXMgYXMgaWYgaXQgaXMgZm9jdXNlZCwgYnV0IHRoZVxuICAgICAgICAgKiBmb2N1cyBpcyBhY3R1YWxseSByZXRhaW5lZCBzb21ld2hlcmUgZWxzZS4gVGhpcyBjb21lcyBpbiBoYW5keVxuICAgICAgICAgKiBmb3IgY29tcG9uZW50cyBsaWtlIGF1dG9jb21wbGV0ZSB3aGVyZSBmb2N1cyBtdXN0IHJlbWFpbiBvbiB0aGUgaW5wdXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE9wdGlvbi5wcm90b3R5cGUsIFwidmlld1ZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXNwbGF5ZWQgdmFsdWUgb2YgdGhlIG9wdGlvbi4gSXQgaXMgbmVjZXNzYXJ5IHRvIHNob3cgdGhlIHNlbGVjdGVkIG9wdGlvbiBpbiB0aGVcbiAgICAgICAgICogc2VsZWN0J3MgdHJpZ2dlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyhrYXJhKTogQWRkIGlucHV0IHByb3BlcnR5IGFsdGVybmF0aXZlIGZvciBub2RlIGVudnMuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SG9zdEVsZW1lbnQoKS50ZXh0Q29udGVudC50cmltKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBTZWxlY3RzIHRoZSBvcHRpb24uICovXG4gICAgTWRPcHRpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0LmVtaXQobmV3IE1kT3B0aW9uU2VsZWN0RXZlbnQodGhpcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIC8qKiBEZXNlbGVjdHMgdGhlIG9wdGlvbi4gKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogU2V0cyBmb2N1cyBvbnRvIHRoaXMgb3B0aW9uLiAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLl9nZXRIb3N0RWxlbWVudCgpLCAnZm9jdXMnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgZGlzcGxheSBzdHlsZXMgb24gdGhlIG9wdGlvbiB0byBtYWtlIGl0IGFwcGVhclxuICAgICAqIGFjdGl2ZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciBzbyBrZXlcbiAgICAgKiBldmVudHMgd2lsbCBkaXNwbGF5IHRoZSBwcm9wZXIgb3B0aW9ucyBhcyBhY3RpdmUgb24gYXJyb3cga2V5IGV2ZW50cy5cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuc2V0QWN0aXZlU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYWN0aXZlID0gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZW1vdmVzIGRpc3BsYXkgc3R5bGVzIG9uIHRoZSBvcHRpb24gdGhhdCBtYWRlIGl0IGFwcGVhclxuICAgICAqIGFjdGl2ZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciBzbyBrZXlcbiAgICAgKiBldmVudHMgd2lsbCBkaXNwbGF5IHRoZSBwcm9wZXIgb3B0aW9ucyBhcyBhY3RpdmUgb24gYXJyb3cga2V5IGV2ZW50cy5cbiAgICAgKi9cbiAgICBNZE9wdGlvbi5wcm90b3R5cGUuc2V0SW5hY3RpdmVTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hY3RpdmUgPSBmYWxzZTsgfSk7XG4gICAgfTtcbiAgICAvKiogRW5zdXJlcyB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkIHdoZW4gYWN0aXZhdGVkIGZyb20gdGhlIGtleWJvYXJkLiAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5faGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIG9wdGlvbiB3aGlsZSBpbmRpY2F0aW5nIHRoZSBzZWxlY3Rpb24gY2FtZSBmcm9tIHRoZSB1c2VyLiBVc2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QncyB2aWV3IC0+IG1vZGVsIGNhbGxiYWNrIHNob3VsZCBiZSBpbnZva2VkLlxuICAgICAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5fc2VsZWN0VmlhSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vblNlbGVjdC5lbWl0KG5ldyBNZE9wdGlvblNlbGVjdEV2ZW50KHRoaXMsIHRydWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIGNvcnJlY3QgdGFiaW5kZXggZm9yIHRoZSBvcHRpb24gZGVwZW5kaW5nIG9uIGRpc2FibGVkIHN0YXRlLiAqL1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5fZ2V0VGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gJy0xJyA6ICcwJztcbiAgICB9O1xuICAgIE1kT3B0aW9uLnByb3RvdHlwZS5fZ2V0SG9zdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kT3B0aW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRPcHRpb24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kT3B0aW9uLnByb3RvdHlwZSwgXCJvblNlbGVjdFwiLCB2b2lkIDApO1xuICAgIE1kT3B0aW9uID0gX19kZWNvcmF0ZSQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtb3B0aW9uLCBtYXQtb3B0aW9uJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICdbYXR0ci50YWJpbmRleF0nOiAnX2dldFRhYkluZGV4KCknLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAgICAgICAgICdbaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtZGlzYWJsZWRdJzogJ2Rpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LW9wdGlvbi1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19zZWxlY3RWaWFJbnRlcmFjdGlvbigpJyxcbiAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LW9wdGlvbl0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjxkaXYgY2xhc3M9XFxcIm1hdC1vcHRpb24tcmlwcGxlXFxcIiAqbmdJZj1cXFwiIWRpc2FibGVkXFxcIiBtZC1yaXBwbGUgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZE9wdGlvbik7XG4gICAgcmV0dXJuIE1kT3B0aW9uO1xufSgpKTtcbnZhciBNZE9wdGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRPcHRpb25Nb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kT3B0aW9uTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRPcHRpb25Nb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZE9wdGlvbk1vZHVsZSA9IF9fZGVjb3JhdGUkNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW01kUmlwcGxlTW9kdWxlLCBfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZE9wdGlvbl0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZE9wdGlvbl1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRPcHRpb25Nb2R1bGUpO1xuICAgIHJldHVybiBNZE9wdGlvbk1vZHVsZTtcbn0oKSk7XG5cbi8vIFRPRE8oa2FyYSk6IFJldmlzaXQgd2h5IGVycm9yIG1lc3NhZ2VzIGFyZSBub3QgYmVpbmcgcHJvcGVybHkgc2V0LlxudmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogV3JhcHBlciBhcm91bmQgRXJyb3IgdGhhdCBzZXRzIHRoZSBlcnJvciBtZXNzYWdlLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDMoTWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEVycm9yKHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE1kRXJyb3I7XG59KEVycm9yKSk7XG5cbnZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIG51bGwgcG9ydGFsIHRvIGEgaG9zdC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE51bGxQb3J0YWxFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIoTnVsbFBvcnRhbEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bGxQb3J0YWxFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ011c3QgcHJvdmlkZSBhIHBvcnRhbCB0byBhdHRhY2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIE51bGxQb3J0YWxFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBhdHRhY2ggYSBwb3J0YWwgdG8gYSBob3N0IHRoYXQgaXMgYWxyZWFkeSBhdHRhY2hlZC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFBvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0hvc3QgYWxyZWFkeSBoYXMgYSBwb3J0YWwgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIFBvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhbiBhbHJlYWR5LWRpc3Bvc2VkIGhvc3QuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBQb3J0YWxIb3N0QWxyZWFkeURpc3Bvc2VkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyKFBvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQb3J0YWxIb3N0QWxyZWFkeURpc3Bvc2VkRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdUaGlzIFBvcnRhbEhvc3QgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gUG9ydGFsSG9zdEFscmVhZHlEaXNwb3NlZEVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhbiB1bmtub3duIHBvcnRhbCB0eXBlLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgVW5rbm93blBvcnRhbFR5cGVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIoVW5rbm93blBvcnRhbFR5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmtub3duUG9ydGFsVHlwZUVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0ZW1wdGluZyB0byBhdHRhY2ggYW4gdW5rbm93biBQb3J0YWwgdHlwZS4gJyArXG4gICAgICAgICAgICAnQmFzZVBvcnRhbEhvc3QgYWNjZXB0cyBlaXRoZXIgYSBDb21wb25lbnRQb3J0YWwgb3IgYSBUZW1wbGF0ZVBvcnRhbC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFVua25vd25Qb3J0YWxUeXBlRXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgcG9ydGFsIHRvIGEgbnVsbCBob3N0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTnVsbFBvcnRhbEhvc3RFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIoTnVsbFBvcnRhbEhvc3RFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOdWxsUG9ydGFsSG9zdEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0ZW1wdGluZyB0byBhdHRhY2ggYSBwb3J0YWwgdG8gYSBudWxsIFBvcnRhbEhvc3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE51bGxQb3J0YWxIb3N0RXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gZGV0YWNoIGEgcG9ydGFsIHRoYXQgaXMgbm90IGF0dGFjaGVkLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTm9Qb3J0YWxBdHRhY2hlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihOb1BvcnRhbEF0dGFjaGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9Qb3J0YWxBdHRhY2hlZEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0ZW1wdGluZyB0byBkZXRhY2ggYSBwb3J0YWwgdGhhdCBpcyBub3QgYXR0YWNoZWQgdG8gYSBob3N0Jyk7XG4gICAgfVxuICAgIHJldHVybiBOb1BvcnRhbEF0dGFjaGVkRXJyb3I7XG59KE1kRXJyb3IpKTtcblxudmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQSBgUG9ydGFsYCBpcyBzb21ldGhpbmcgdGhhdCB5b3Ugd2FudCB0byByZW5kZXIgc29tZXdoZXJlIGVsc2UuXG4gKiBJdCBjYW4gYmUgYXR0YWNoIHRvIC8gZGV0YWNoZWQgZnJvbSBhIGBQb3J0YWxIb3N0YC5cbiAqL1xudmFyIFBvcnRhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9ydGFsKCkge1xuICAgIH1cbiAgICAvKiogQXR0YWNoIHRoaXMgcG9ydGFsIHRvIGEgaG9zdC4gKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgIGlmIChob3N0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOdWxsUG9ydGFsSG9zdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3QuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRIb3N0ID0gaG9zdDtcbiAgICAgICAgcmV0dXJuIGhvc3QuYXR0YWNoKHRoaXMpO1xuICAgIH07XG4gICAgLyoqIERldGFjaCB0aGlzIHBvcnRhbCBmcm9tIGl0cyBob3N0ICovXG4gICAgUG9ydGFsLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBob3N0ID0gdGhpcy5fYXR0YWNoZWRIb3N0O1xuICAgICAgICBpZiAoaG9zdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9Qb3J0YWxBdHRhY2hlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRIb3N0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGhvc3QuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsLnByb3RvdHlwZSwgXCJpc0F0dGFjaGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyBwb3J0YWwgaXMgYXR0YWNoZWQgdG8gYSBob3N0LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hlZEhvc3QgIT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUG9ydGFsSG9zdCByZWZlcmVuY2Ugd2l0aG91dCBwZXJmb3JtaW5nIGBhdHRhY2goKWAuIFRoaXMgaXMgdXNlZCBkaXJlY3RseSBieVxuICAgICAqIHRoZSBQb3J0YWxIb3N0IHdoZW4gaXQgaXMgcGVyZm9ybWluZyBhbiBgYXR0YWNoKClgIG9yIGBkZXRhY2goKWAuXG4gICAgICovXG4gICAgUG9ydGFsLnByb3RvdHlwZS5zZXRBdHRhY2hlZEhvc3QgPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICB0aGlzLl9hdHRhY2hlZEhvc3QgPSBob3N0O1xuICAgIH07XG4gICAgcmV0dXJuIFBvcnRhbDtcbn0oKSk7XG4vKipcbiAqIEEgYENvbXBvbmVudFBvcnRhbGAgaXMgYSBwb3J0YWwgdGhhdCBpbnN0YW50aWF0ZXMgc29tZSBDb21wb25lbnQgdXBvbiBhdHRhY2htZW50LlxuICovXG52YXIgQ29tcG9uZW50UG9ydGFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDb21wb25lbnRQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50UG9ydGFsKGNvbXBvbmVudCwgdmlld0NvbnRhaW5lclJlZiwgaW5qZWN0b3IpIHtcbiAgICAgICAgaWYgKHZpZXdDb250YWluZXJSZWYgPT09IHZvaWQgMCkgeyB2aWV3Q29udGFpbmVyUmVmID0gbnVsbDsgfVxuICAgICAgICBpZiAoaW5qZWN0b3IgPT09IHZvaWQgMCkgeyBpbmplY3RvciA9IG51bGw7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBDb21wb25lbnRQb3J0YWw7XG59KFBvcnRhbCkpO1xuLyoqXG4gKiBBIGBUZW1wbGF0ZVBvcnRhbGAgaXMgYSBwb3J0YWwgdGhhdCByZXByZXNlbnRzIHNvbWUgZW1iZWRkZWQgdGVtcGxhdGUgKFRlbXBsYXRlUmVmKS5cbiAqL1xudmFyIFRlbXBsYXRlUG9ydGFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUZW1wbGF0ZVBvcnRhbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBvcnRhbCh0ZW1wbGF0ZSwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgbG9jYWxzIGZvciB0aGUgaW5zdGFudGlhdGVkIGVtYmVkZGVkIHZpZXcuXG4gICAgICAgICAqIFRoZXNlIGxvY2FscyBjYW4gYmUgc2VlbiBhcyBcImV4cG9ydHNcIiBmb3IgdGhlIHRlbXBsYXRlLCBzdWNoIGFzIGhvdyBuZ0ZvciBoYXNcbiAgICAgICAgICogaW5kZXggLyBldmVudCAvIG9kZC5cbiAgICAgICAgICogU2VlIGh0dHBzOi8vYW5ndWxhci5pby9kb2NzL3RzL2xhdGVzdC9hcGkvY29yZS9FbWJlZGRlZFZpZXdSZWYtY2xhc3MuaHRtbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb2NhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbXBsYXRlUG9ydGFsLnByb3RvdHlwZSwgXCJvcmlnaW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlUmVmLmVsZW1lbnRSZWY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRlbXBsYXRlUG9ydGFsLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoaG9zdCwgbG9jYWxzKSB7XG4gICAgICAgIHRoaXMubG9jYWxzID0gbG9jYWxzID09IG51bGwgPyBuZXcgTWFwKCkgOiBsb2NhbHM7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmF0dGFjaC5jYWxsKHRoaXMsIGhvc3QpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQb3J0YWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUG9ydGFsO1xufShQb3J0YWwpKTtcbi8qKlxuICogUGFydGlhbCBpbXBsZW1lbnRhdGlvbiBvZiBQb3J0YWxIb3N0IHRoYXQgb25seSBkZWFscyB3aXRoIGF0dGFjaGluZyBlaXRoZXIgYVxuICogQ29tcG9uZW50UG9ydGFsIG9yIGEgVGVtcGxhdGVQb3J0YWwuXG4gKi9cbnZhciBCYXNlUG9ydGFsSG9zdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVBvcnRhbEhvc3QoKSB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoaXMgaG9zdCBoYXMgYWxyZWFkeSBiZWVuIHBlcm1hbmVudGx5IGRpc3Bvc2VkLiAqL1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoaXMgaG9zdCBoYXMgYW4gYXR0YWNoZWQgcG9ydGFsLiAqL1xuICAgIEJhc2VQb3J0YWxIb3N0LnByb3RvdHlwZS5oYXNBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaGVkUG9ydGFsICE9IG51bGw7XG4gICAgfTtcbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBpZiAocG9ydGFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOdWxsUG9ydGFsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUG9ydGFsQWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBvcnRhbEhvc3RBbHJlYWR5RGlzcG9zZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3J0YWwgaW5zdGFuY2VvZiBDb21wb25lbnRQb3J0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gcG9ydGFsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9ydGFsIGluc3RhbmNlb2YgVGVtcGxhdGVQb3J0YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaGVkUG9ydGFsID0gcG9ydGFsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoVGVtcGxhdGVQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVW5rbm93blBvcnRhbFR5cGVFcnJvcigpO1xuICAgIH07XG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkUG9ydGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFBvcnRhbC5zZXRBdHRhY2hlZEhvc3QobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZUZuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VGbigpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUZuID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuc2V0RGlzcG9zZUZuID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VGbiA9IGZuO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VQb3J0YWxIb3N0O1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogRGlyZWN0aXZlIHZlcnNpb24gb2YgYSBgVGVtcGxhdGVQb3J0YWxgLiBCZWNhdXNlIHRoZSBkaXJlY3RpdmUgKmlzKiBhIFRlbXBsYXRlUG9ydGFsLFxuICogdGhlIGRpcmVjdGl2ZSBpbnN0YW5jZSBpdHNlbGYgY2FuIGJlIGF0dGFjaGVkIHRvIGEgaG9zdCwgZW5hYmxpbmcgZGVjbGFyYXRpdmUgdXNlIG9mIHBvcnRhbHMuXG4gKlxuICogVXNhZ2U6XG4gKiA8dGVtcGxhdGUgcG9ydGFsICNncmVldGluZz5cbiAqICAgPHA+IEhlbGxvIHt7bmFtZX19IDwvcD5cbiAqIDwvdGVtcGxhdGU+XG4gKi9cbnZhciBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG4gICAgVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstcG9ydGFsXSwgW3BvcnRhbF0nLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdjZGtQb3J0YWwnLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmXSlcbiAgICBdLCBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlO1xufShUZW1wbGF0ZVBvcnRhbCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgdmVyc2lvbiBvZiBhIFBvcnRhbEhvc3QuIEJlY2F1c2UgdGhlIGRpcmVjdGl2ZSAqaXMqIGEgUG9ydGFsSG9zdCwgcG9ydGFscyBjYW4gYmVcbiAqIGRpcmVjdGx5IGF0dGFjaGVkIHRvIGl0LCBlbmFibGluZyBkZWNsYXJhdGl2ZSB1c2UuXG4gKlxuICogVXNhZ2U6XG4gKiA8dGVtcGxhdGUgW2Nka1BvcnRhbEhvc3RdPVwiZ3JlZXRpbmdcIj48L3RlbXBsYXRlPlxuICovXG52YXIgUG9ydGFsSG9zdERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBvcnRhbEhvc3REaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9ydGFsSG9zdERpcmVjdGl2ZShfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiX2RlcHJlY2F0ZWRQb3J0YWxcIiwge1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBvcnRhbDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLnBvcnRhbCA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb3J0YWxIb3N0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwb3J0YWxcIiwge1xuICAgICAgICAvKiogUG9ydGFsIGFzc29jaWF0ZWQgd2l0aCB0aGUgUG9ydGFsIGhvc3QuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBsYWNlQXR0YWNoZWRQb3J0YWwocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZ2l2ZW4gQ29tcG9uZW50UG9ydGFsIHRvIHRoaXMgUG9ydGFsSG9zdCB1c2luZyB0aGUgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIHBvcnRhbCBob3N0LlxuICAgICAqL1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLmF0dGFjaENvbXBvbmVudFBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgcG9ydGFsLnNldEF0dGFjaGVkSG9zdCh0aGlzKTtcbiAgICAgICAgLy8gSWYgdGhlIHBvcnRhbCBzcGVjaWZpZXMgYW4gb3JpZ2luLCB1c2UgdGhhdCBhcyB0aGUgbG9naWNhbCBsb2NhdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIGluIHRoZSBhcHBsaWNhdGlvbiB0cmVlLiBPdGhlcndpc2UgdXNlIHRoZSBsb2NhdGlvbiBvZiB0aGlzIFBvcnRhbEhvc3QuXG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVyUmVmID0gcG9ydGFsLnZpZXdDb250YWluZXJSZWYgIT0gbnVsbCA/XG4gICAgICAgICAgICBwb3J0YWwudmlld0NvbnRhaW5lclJlZiA6XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB2YXIgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShwb3J0YWwuY29tcG9uZW50KTtcbiAgICAgICAgdmFyIHJlZiA9IHZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnksIHZpZXdDb250YWluZXJSZWYubGVuZ3RoLCBwb3J0YWwuaW5qZWN0b3IgfHwgdmlld0NvbnRhaW5lclJlZi5wYXJlbnRJbmplY3Rvcik7XG4gICAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZi5kZXN0cm95KCk7IH0pO1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBUZW1wbGF0ZVBvcnRhbCB0byB0aGlzIFBvcnRsSG9zdCBhcyBhbiBlbWJlZGRlZCBWaWV3LlxuICAgICAqIEBwYXJhbSBwb3J0YWwgUG9ydGFsIHRvIGJlIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwb3J0YWwuc2V0QXR0YWNoZWRIb3N0KHRoaXMpO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhwb3J0YWwudGVtcGxhdGVSZWYpO1xuICAgICAgICB0aGlzLnNldERpc3Bvc2VGbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jbGVhcigpOyB9KTtcbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IHJldHVybiBsb2NhbHMgZnJvbSB2aWV3XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICAvKiogRGV0YWNoZXMgdGhlIGN1cnJlbnRseSBhdHRhY2hlZCBQb3J0YWwgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIGF0dGFjaGVzIHRoZSBnaXZlbiBQb3J0YWwuICovXG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUuX3JlcGxhY2VBdHRhY2hlZFBvcnRhbCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoKHApO1xuICAgICAgICAgICAgdGhpcy5fcG9ydGFsID0gcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgncG9ydGFsSG9zdCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBQb3J0YWxIb3N0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZFBvcnRhbFwiLCBudWxsKTtcbiAgICBQb3J0YWxIb3N0RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrUG9ydGFsSG9zdF0sIFtwb3J0YWxIb3N0XScsXG4gICAgICAgICAgICBpbnB1dHM6IFsncG9ydGFsOiBjZGtQb3J0YWxIb3N0J11cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWZdKVxuICAgIF0sIFBvcnRhbEhvc3REaXJlY3RpdmUpO1xuICAgIHJldHVybiBQb3J0YWxIb3N0RGlyZWN0aXZlO1xufShCYXNlUG9ydGFsSG9zdCkpO1xudmFyIFBvcnRhbE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9ydGFsTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBQb3J0YWxNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBQb3J0YWxNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQb3J0YWxNb2R1bGUgPSBfX2RlY29yYXRlJDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGV4cG9ydHM6IFtUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSwgUG9ydGFsSG9zdERpcmVjdGl2ZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSwgUG9ydGFsSG9zdERpcmVjdGl2ZV0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIFBvcnRhbE1vZHVsZSk7XG4gICAgcmV0dXJuIFBvcnRhbE1vZHVsZTtcbn0oKSk7XG5cbi8qKlxuICogT3ZlcmxheVN0YXRlIGlzIGEgYmFnIG9mIHZhbHVlcyBmb3IgZWl0aGVyIHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gb3IgY3VycmVudCBzdGF0ZSBvZiBhblxuICogb3ZlcmxheS5cbiAqL1xudmFyIE92ZXJsYXlTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheVN0YXRlKCkge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgb3ZlcmxheSBoYXMgYSBiYWNrZHJvcC4gKi9cbiAgICAgICAgdGhpcy5oYXNCYWNrZHJvcCA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VzdG9tIGNsYXNzIHRvIGFkZCB0byB0aGUgYmFja2Ryb3AgKiovXG4gICAgICAgIHRoaXMuYmFja2Ryb3BDbGFzcyA9ICdjZGstb3ZlcmxheS1kYXJrLWJhY2tkcm9wJztcbiAgICAgICAgLyoqIFRoZSBkaXJlY3Rpb24gb2YgdGhlIHRleHQgaW4gdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2x0cic7XG4gICAgfVxuICAgIHJldHVybiBPdmVybGF5U3RhdGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBIFBvcnRhbEhvc3QgZm9yIGF0dGFjaGluZyBwb3J0YWxzIHRvIGFuIGFyYml0cmFyeSBET00gZWxlbWVudCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyXG4gKiBhcHBsaWNhdGlvbiBjb250ZXh0LlxuICpcbiAqIFRoaXMgaXMgdGhlIG9ubHkgcGFydCBvZiB0aGUgcG9ydGFsIGNvcmUgdGhhdCBkaXJlY3RseSB0b3VjaGVzIHRoZSBET00uXG4gKi9cbnZhciBEb21Qb3J0YWxIb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkNChEb21Qb3J0YWxIb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvbVBvcnRhbEhvc3QoX2hvc3REb21FbGVtZW50LCBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfYXBwUmVmLCBfZGVmYXVsdEluamVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9ob3N0RG9tRWxlbWVudCA9IF9ob3N0RG9tRWxlbWVudDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fYXBwUmVmID0gX2FwcFJlZjtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEluamVjdG9yID0gX2RlZmF1bHRJbmplY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBnaXZlbiBDb21wb25lbnRQb3J0YWwgdG8gRE9NIGVsZW1lbnQgdXNpbmcgdGhlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5cbiAgICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZFxuICAgICAqL1xuICAgIERvbVBvcnRhbEhvc3QucHJvdG90eXBlLmF0dGFjaENvbXBvbmVudFBvcnRhbCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkocG9ydGFsLmNvbXBvbmVudCk7XG4gICAgICAgIHZhciBjb21wb25lbnRSZWY7XG4gICAgICAgIC8vIElmIHRoZSBwb3J0YWwgc3BlY2lmaWVzIGEgVmlld0NvbnRhaW5lclJlZiwgd2Ugd2lsbCB1c2UgdGhhdCBhcyB0aGUgYXR0YWNobWVudCBwb2ludFxuICAgICAgICAvLyBmb3IgdGhlIGNvbXBvbmVudCAoaW4gdGVybXMgb2YgQW5ndWxhcidzIGNvbXBvbmVudCB0cmVlLCBub3QgcmVuZGVyaW5nKS5cbiAgICAgICAgLy8gV2hlbiB0aGUgVmlld0NvbnRhaW5lclJlZiBpcyBtaXNzaW5nLCB3ZSB1c2UgdGhlIGZhY3RvcnkgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQgZGlyZWN0bHlcbiAgICAgICAgLy8gYW5kIHRoZW4gbWFudWFsbHkgYXR0YWNoIHRoZSB2aWV3IHRvIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgaWYgKHBvcnRhbC52aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgICAgICBjb21wb25lbnRSZWYgPSBwb3J0YWwudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSwgcG9ydGFsLnZpZXdDb250YWluZXJSZWYubGVuZ3RoLCBwb3J0YWwuaW5qZWN0b3IgfHwgcG9ydGFsLnZpZXdDb250YWluZXJSZWYucGFyZW50SW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5zZXREaXNwb3NlRm4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50UmVmLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRSZWYgPSBjb21wb25lbnRGYWN0b3J5LmNyZWF0ZShwb3J0YWwuaW5qZWN0b3IgfHwgdGhpcy5fZGVmYXVsdEluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcFJlZi5hdHRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgICAgICAgICB0aGlzLnNldERpc3Bvc2VGbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FwcFJlZi5kZXRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBpbnN0YW50aWF0ZWQsIHNvIHdlIG1vdmUgaXQgdG8gdGhlIGxvY2F0aW9uIGluIHRoZSBET01cbiAgICAgICAgLy8gd2hlcmUgd2Ugd2FudCBpdCB0byBiZSByZW5kZXJlZC5cbiAgICAgICAgdGhpcy5faG9zdERvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fZ2V0Q29tcG9uZW50Um9vdE5vZGUoY29tcG9uZW50UmVmKSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBhIHRlbXBsYXRlIHBvcnRhbCB0byB0aGUgRE9NIGFzIGFuIGVtYmVkZGVkIHZpZXcuXG4gICAgICogQHBhcmFtIHBvcnRhbCBQb3J0YWwgdG8gYmUgYXR0YWNoZWQuXG4gICAgICovXG4gICAgRG9tUG9ydGFsSG9zdC5wcm90b3R5cGUuYXR0YWNoVGVtcGxhdGVQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB2aWV3Q29udGFpbmVyID0gcG9ydGFsLnZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHZhciB2aWV3UmVmID0gdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcocG9ydGFsLnRlbXBsYXRlUmVmKTtcbiAgICAgICAgLy8gVGhlIG1ldGhvZCBgY3JlYXRlRW1iZWRkZWRWaWV3YCB3aWxsIGFkZCB0aGUgdmlldyBhcyBhIGNoaWxkIG9mIHRoZSB2aWV3Q29udGFpbmVyLlxuICAgICAgICAvLyBCdXQgZm9yIHRoZSBEb21Qb3J0YWxIb3N0IHRoZSB2aWV3IGNhbiBiZSBhZGRlZCBldmVyeXdoZXJlIGluIHRoZSBET00gKGUuZyBPdmVybGF5IENvbnRhaW5lcilcbiAgICAgICAgLy8gVG8gbW92ZSB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIGhvc3QgZWxlbWVudC4gV2UganVzdCByZS1hcHBlbmQgdGhlIGV4aXN0aW5nIHJvb3Qgbm9kZXMuXG4gICAgICAgIHZpZXdSZWYucm9vdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJvb3ROb2RlKSB7IHJldHVybiBfdGhpcy5faG9zdERvbUVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdE5vZGUpOyB9KTtcbiAgICAgICAgdGhpcy5zZXREaXNwb3NlRm4oKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHZpZXdDb250YWluZXIuaW5kZXhPZih2aWV3UmVmKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyLnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IFJldHVybiBsb2NhbHMgZnJvbSB2aWV3LlxuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIG91dCBhIHBvcnRhbCBmcm9tIHRoZSBET00uXG4gICAgICovXG4gICAgRG9tUG9ydGFsSG9zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9ob3N0RG9tRWxlbWVudC5wYXJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvc3REb21FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5faG9zdERvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogR2V0cyB0aGUgcm9vdCBIVE1MRWxlbWVudCBmb3IgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudC4gKi9cbiAgICBEb21Qb3J0YWxIb3N0LnByb3RvdHlwZS5fZ2V0Q29tcG9uZW50Um9vdE5vZGUgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWYuaG9zdFZpZXcucm9vdE5vZGVzWzBdO1xuICAgIH07XG4gICAgcmV0dXJuIERvbVBvcnRhbEhvc3Q7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIGFuIG92ZXJsYXkgdGhhdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggdGhlIE92ZXJsYXkgc2VydmljZS5cbiAqIFVzZWQgdG8gbWFuaXB1bGF0ZSBvciBkaXNwb3NlIG9mIHNhaWQgb3ZlcmxheS5cbiAqL1xudmFyIE92ZXJsYXlSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlSZWYoX3BvcnRhbEhvc3QsIF9wYW5lLCBfc3RhdGUsIF9uZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fcG9ydGFsSG9zdCA9IF9wb3J0YWxIb3N0O1xuICAgICAgICB0aGlzLl9wYW5lID0gX3BhbmU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gX3N0YXRlO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcENsaWNrID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPdmVybGF5UmVmLnByb3RvdHlwZSwgXCJvdmVybGF5RWxlbWVudFwiLCB7XG4gICAgICAgIC8qKiBUaGUgb3ZlcmxheSdzIEhUTUwgZWxlbWVudCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYW5lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgb3ZlcmxheSB0byBhIHBvcnRhbCBpbnN0YW5jZSBhbmQgYWRkcyB0aGUgYmFja2Ryb3AuXG4gICAgICogQHBhcmFtIHBvcnRhbCBQb3J0YWwgaW5zdGFuY2UgdG8gd2hpY2ggdG8gYXR0YWNoIHRoZSBvdmVybGF5LlxuICAgICAqIEByZXR1cm5zIFRoZSBwb3J0YWwgYXR0YWNobWVudCByZXN1bHQuXG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuaGFzQmFja2Ryb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaEJhY2tkcm9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dGFjaFJlc3VsdCA9IHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoKHBvcnRhbCk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFuZSBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHN0YXRlIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIC8vIEVuYWJsZSBwb2ludGVyIGV2ZW50cyBmb3IgdGhlIG92ZXJsYXkgcGFuZSBlbGVtZW50LlxuICAgICAgICB0aGlzLl90b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICByZXR1cm4gYXR0YWNoUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgYW4gb3ZlcmxheSBmcm9tIGEgcG9ydGFsLlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gZGV0YWNoZWQuXG4gICAgICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZXRhY2hCYWNrZHJvcCgpO1xuICAgICAgICAvLyBXaGVuIHRoZSBvdmVybGF5IGlzIGRldGFjaGVkLCB0aGUgcGFuZSBlbGVtZW50IHNob3VsZCBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG90aGVyd2lzZSB0aGUgcGFuZSBlbGVtZW50IHdpbGwgY292ZXIgdGhlIHBhZ2UgYW5kIGRpc2FibGVcbiAgICAgICAgLy8gcG9pbnRlciBldmVudHMgdGhlcmVmb3JlLiBEZXBlbmRzIG9uIHRoZSBwb3NpdGlvbiBzdHJhdGVneSBhbmQgdGhlIGFwcGxpZWQgcGFuZSBib3VuZGFyaWVzLlxuICAgICAgICB0aGlzLl90b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuZGV0YWNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgdGhlIG92ZXJsYXkgZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5wb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5wb3NpdGlvblN0cmF0ZWd5LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZXRhY2hCYWNrZHJvcCgpO1xuICAgICAgICB0aGlzLl9wb3J0YWxIb3N0LmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBvdmVybGF5IGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmhhc0F0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsSG9zdC5oYXNBdHRhY2hlZCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiB0aGUgYmFja2Ryb3AgaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5iYWNrZHJvcENsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2Ryb3BDbGljay5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgY29uZmlnIG9mIHRoZSBvdmVybGF5LlxuICAgICAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYmFzZWQgb24gdGhlIHBvc2l0aW9uIHN0cmF0ZWd5LiAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneS5hcHBseSh0aGlzLl9wYW5lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFVwZGF0ZXMgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBvdmVybGF5IHBhbmVsLiAqKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS51cGRhdGVEaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhbmUuc2V0QXR0cmlidXRlKCdkaXInLCB0aGlzLl9zdGF0ZS5kaXJlY3Rpb24pO1xuICAgIH07XG4gICAgLyoqIFVwZGF0ZXMgdGhlIHNpemUgb2YgdGhlIG92ZXJsYXkgYmFzZWQgb24gdGhlIG92ZXJsYXkgY29uZmlnLiAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS53aWR0aCB8fCB0aGlzLl9zdGF0ZS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS53aWR0aCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5oZWlnaHQgfHwgdGhpcy5fc3RhdGUuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5lLnN0eWxlLmhlaWdodCA9IGZvcm1hdENzc1VuaXQodGhpcy5fc3RhdGUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdGUubWluV2lkdGggfHwgdGhpcy5fc3RhdGUubWluV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbmUuc3R5bGUubWluV2lkdGggPSBmb3JtYXRDc3NVbml0KHRoaXMuX3N0YXRlLm1pbldpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdGUubWluSGVpZ2h0IHx8IHRoaXMuX3N0YXRlLm1pbkhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS5taW5IZWlnaHQgPSBmb3JtYXRDc3NVbml0KHRoaXMuX3N0YXRlLm1pbkhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBUb2dnbGVzIHRoZSBwb2ludGVyIGV2ZW50cyBmb3IgdGhlIG92ZXJsYXkgcGFuZSBlbGVtZW50LiAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLl90b2dnbGVQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKGVuYWJsZVBvaW50ZXIpIHtcbiAgICAgICAgdGhpcy5fcGFuZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gZW5hYmxlUG9pbnRlciA/ICdhdXRvJyA6ICdub25lJztcbiAgICB9O1xuICAgIC8qKiBBdHRhY2hlcyBhIGJhY2tkcm9wIGZvciB0aGlzIG92ZXJsYXkuICovXG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuX2F0dGFjaEJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LWJhY2tkcm9wJyk7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuX3N0YXRlLmJhY2tkcm9wQ2xhc3MpO1xuICAgICAgICAvLyBJbnNlcnQgdGhlIGJhY2tkcm9wIGJlZm9yZSB0aGUgcGFuZSBpbiB0aGUgRE9NIG9yZGVyLFxuICAgICAgICAvLyBpbiBvcmRlciB0byBoYW5kbGUgc3RhY2tlZCBvdmVybGF5cyBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5fcGFuZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9iYWNrZHJvcEVsZW1lbnQsIHRoaXMuX3BhbmUpO1xuICAgICAgICAvLyBGb3J3YXJkIGJhY2tkcm9wIGNsaWNrcyBzdWNoIHRoYXQgdGhlIGNvbnN1bWVyIG9mIHRoZSBvdmVybGF5IGNhbiBwZXJmb3JtIHdoYXRldmVyXG4gICAgICAgIC8vIGFjdGlvbiBkZXNpcmVkIHdoZW4gc3VjaCBhIGNsaWNrIG9jY3VycyAodXN1YWxseSBjbG9zaW5nIHRoZSBvdmVybGF5KS5cbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2JhY2tkcm9wQ2xpY2submV4dChudWxsKTsgfSk7XG4gICAgICAgIC8vIEFkZCBjbGFzcyB0byBmYWRlLWluIHRoZSBiYWNrZHJvcCBhZnRlciBvbmUgZnJhbWUuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2JhY2tkcm9wRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9iYWNrZHJvcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnY2RrLW92ZXJsYXktYmFja2Ryb3Atc2hvd2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBEZXRhY2hlcyB0aGUgYmFja2Ryb3AgKGlmIGFueSkgYXNzb2NpYXRlZCB3aXRoIHRoZSBvdmVybGF5LiAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLl9kZXRhY2hCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGJhY2tkcm9wVG9EZXRhY2ggPSB0aGlzLl9iYWNrZHJvcEVsZW1lbnQ7XG4gICAgICAgIGlmIChiYWNrZHJvcFRvRGV0YWNoKSB7XG4gICAgICAgICAgICB2YXIgZmluaXNoRGV0YWNoXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgbWF5IG5vdCBiZSBhdHRhY2hlZCB0byBhbnl0aGluZyBpbiBjZXJ0YWluIGNhc2VzIChlLmcuIHVuaXQgdGVzdHMpLlxuICAgICAgICAgICAgICAgIGlmIChiYWNrZHJvcFRvRGV0YWNoICYmIGJhY2tkcm9wVG9EZXRhY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYmFja2Ryb3BUb0RldGFjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgYSBuZXcgcG9ydGFsIGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoaXMgb3ZlcmxheSBzaW5jZSB3ZSBzdGFydGVkXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIGJhY2tkcm9wLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCBvbmx5IGNsZWFyIHRoZSBiYWNrZHJvcCByZWZlcmVuY2UgaWYgaXRcbiAgICAgICAgICAgICAgICAvLyBpcyBzdGlsbCB0aGUgc2FtZSBpbnN0YW5jZSB0aGF0IHdlIHN0YXJ0ZWQgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYmFja2Ryb3BFbGVtZW50ID09IGJhY2tkcm9wVG9EZXRhY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2guY2xhc3NMaXN0LnJlbW92ZSgnY2RrLW92ZXJsYXktYmFja2Ryb3Atc2hvd2luZycpO1xuICAgICAgICAgICAgYmFja2Ryb3BUb0RldGFjaC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX3N0YXRlLmJhY2tkcm9wQ2xhc3MpO1xuICAgICAgICAgICAgYmFja2Ryb3BUb0RldGFjaC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZmluaXNoRGV0YWNoXzEpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGJhY2tkcm9wIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zaXRpb24sIHRoZSBgdHJhbnNpdGlvbmVuZGAgZXZlbnQgd29uJ3QgZmlyZS5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBtYWtlIGl0IHVuY2xpY2thYmxlIGFuZCB3ZSB0cnkgdG8gcmVtb3ZlIGl0IGFmdGVyIGEgZGVsYXkuXG4gICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAvLyBSdW4gdGhpcyBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmUgYmVjYXVzZSB0aGVyZSdzIG5vdGhpbmcgdGhhdCBBbmd1bGFyIGNhcmVzIGFib3V0LlxuICAgICAgICAgICAgLy8gSWYgaXQgd2VyZSB0byBydW4gaW5zaWRlIHRoZSBBbmd1bGFyIHpvbmUsIGV2ZXJ5IHRlc3QgdGhhdCB1c2VkIE92ZXJsYXkgd291bGQgaGF2ZSB0byBiZVxuICAgICAgICAgICAgLy8gZWl0aGVyIGFzeW5jIG9yIGZha2VBc3luYy5cbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmaW5pc2hEZXRhY2hfMSwgNTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcmxheVJlZjtcbn0oKSk7XG5mdW5jdGlvbiBmb3JtYXRDc3NVbml0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IHZhbHVlICsgXCJweFwiO1xufVxuXG52YXIgX19kZWNvcmF0ZSQxMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMiA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKiBUaGUgcG9pbnRzIG9mIHRoZSBvcmlnaW4gZWxlbWVudCBhbmQgdGhlIG92ZXJsYXkgZWxlbWVudCB0byBjb25uZWN0LiAqL1xudmFyIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIob3JpZ2luLCBvdmVybGF5KSB7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IG9yaWdpbi5vcmlnaW5YO1xuICAgICAgICB0aGlzLm9yaWdpblkgPSBvcmlnaW4ub3JpZ2luWTtcbiAgICAgICAgdGhpcy5vdmVybGF5WCA9IG92ZXJsYXkub3ZlcmxheVg7XG4gICAgICAgIHRoaXMub3ZlcmxheVkgPSBvdmVybGF5Lm92ZXJsYXlZO1xuICAgIH1cbiAgICByZXR1cm4gQ29ubmVjdGlvblBvc2l0aW9uUGFpcjtcbn0oKSk7XG4vKipcbiAqIFNldCBvZiBwcm9wZXJ0aWVzIHJlZ2FyZGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG9yaWdpbiBhbmQgb3ZlcmxheSByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcbiAqIHdpdGggcmVzcGVjdCB0byB0aGUgY29udGFpbmluZyBTY3JvbGxhYmxlIGVsZW1lbnRzLlxuICpcbiAqIFRoZSBvdmVybGF5IGFuZCBvcmlnaW4gYXJlIGNsaXBwZWQgaWYgYW55IHBhcnQgb2YgdGhlaXIgYm91bmRpbmcgY2xpZW50IHJlY3RhbmdsZSBleGNlZWRzIHRoZVxuICogYm91bmRzIG9mIGFueSBvbmUgb2YgdGhlIHN0cmF0ZWd5J3MgU2Nyb2xsYWJsZSdzIGJvdW5kaW5nIGNsaWVudCByZWN0YW5nbGUuXG4gKlxuICogVGhlIG92ZXJsYXkgYW5kIG9yaWdpbiBhcmUgb3V0c2lkZSB2aWV3IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAgYmV0d2VlbiB0aGVpciBib3VuZGluZyBjbGllbnRcbiAqIHJlY3RhbmdsZSBhbmQgYW55IG9uZSBvZiB0aGUgc3RyYXRlZ3kncyBTY3JvbGxhYmxlJ3MgYm91bmRpbmcgY2xpZW50IHJlY3RhbmdsZS5cbiAqXG4gKiAgICAgICAtLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tLS1cbiAqICAgICAgIHwgb3V0c2lkZSB8ICAgICAgICAgICAgICAgICAgICB8IGNsaXBwZWQgfFxuICogICAgICAgfCAgdmlldyAgIHwgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgICAgICB8ICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgfCAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgIC0tLS0tLS0tLS0gICAgICAgICAgICAgICB8ICAgICAtLS0tLS0tLS0tLSAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfCAgICAgIFNjcm9sbGFibGUgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICAgICBTY3JvbGxhYmxlICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG52YXIgU2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMoKSB7XG4gICAgfVxuICAgIHJldHVybiBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXM7XG59KCkpO1xuLyoqIFRoZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBieSB0aGUgc3RyYXRlZ3kgd2hlbiBhIGZhbGxiYWNrIHBvc2l0aW9uIGlzIHVzZWQuICovXG52YXIgQ29ubmVjdGVkT3ZlcmxheVBvc2l0aW9uQ2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2UoY29ubmVjdGlvblBhaXIsIHNjcm9sbGFibGVWaWV3UHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25QYWlyID0gY29ubmVjdGlvblBhaXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2UgPSBfX2RlY29yYXRlJDEzKFtcbiAgICAgICAgX19wYXJhbSQyKDEsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDEzKCdkZXNpZ246cGFyYW10eXBlcycsIFtDb25uZWN0aW9uUG9zaXRpb25QYWlyLCBTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXNdKVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZSk7XG4gICAgcmV0dXJuIENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZTtcbn0oKSk7XG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgcG9zaXRpb25pbmcgb3ZlcmxheXMuIFVzaW5nIHRoaXMgc3RyYXRlZ3ksIGFuIG92ZXJsYXkgaXMgZ2l2ZW4gYW5cbiAqIGltcGxpY2l0IHBvc2l0aW9uIHJlbGF0aXZlIHNvbWUgb3JpZ2luIGVsZW1lbnQuIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBkZWZpbmVkIGluIHRlcm1zIG9mXG4gKiBhIHBvaW50IG9uIHRoZSBvcmlnaW4gZWxlbWVudCB0aGF0IGlzIGNvbm5lY3RlZCB0byBhIHBvaW50IG9uIHRoZSBvdmVybGF5IGVsZW1lbnQuIEZvciBleGFtcGxlLFxuICogYSBiYXNpYyBkcm9wZG93biBpcyBjb25uZWN0aW5nIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIG9yaWdpbiB0byB0aGUgdG9wLWxlZnQgY29ybmVyXG4gKiBvZiB0aGUgb3ZlcmxheS5cbiAqL1xudmFyIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3koX2Nvbm5lY3RlZFRvLCBfb3JpZ2luUG9zLCBfb3ZlcmxheVBvcywgX3ZpZXdwb3J0UnVsZXIpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkVG8gPSBfY29ubmVjdGVkVG87XG4gICAgICAgIHRoaXMuX29yaWdpblBvcyA9IF9vcmlnaW5Qb3M7XG4gICAgICAgIHRoaXMuX292ZXJsYXlQb3MgPSBfb3ZlcmxheVBvcztcbiAgICAgICAgdGhpcy5fdmlld3BvcnRSdWxlciA9IF92aWV3cG9ydFJ1bGVyO1xuICAgICAgICB0aGlzLl9kaXIgPSAnbHRyJztcbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgb3ZlcmxheSBjb25uZWN0aW9uIHBvaW50IG9uIHRoZSB4LWF4aXMgKi9cbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IDA7XG4gICAgICAgIC8qKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeS1heGlzICovXG4gICAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuICAgICAgICAvKiogVGhlIFNjcm9sbGFibGUgY29udGFpbmVycyB1c2VkIHRvIGNoZWNrIHNjcm9sbGFibGUgdmlldyBwcm9wZXJ0aWVzIG9uIHBvc2l0aW9uIGNoYW5nZS4gKi9cbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlcyA9IFtdO1xuICAgICAgICAvKiogT3JkZXJlZCBsaXN0IG9mIHByZWZlcnJlZCBwb3NpdGlvbnMsIGZyb20gbW9zdCB0byBsZWFzdCBkZXNpcmFibGUuICovXG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblBvc2l0aW9uQ2hhbmdlID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX29yaWdpbiA9IHRoaXMuX2Nvbm5lY3RlZFRvLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMud2l0aEZhbGxiYWNrUG9zaXRpb24oX29yaWdpblBvcywgX292ZXJsYXlQb3MpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUsIFwiX2lzUnRsXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBSVEwgY29udGV4dCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXIgPT09ICdydGwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUsIFwib25Qb3NpdGlvbkNoYW5nZVwiLCB7XG4gICAgICAgIC8qKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBjb25uZWN0aW9uIHBvaW50IGNoYW5nZXMuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uUG9zaXRpb25DaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZSwgXCJwb3NpdGlvbnNcIiwge1xuICAgICAgICAvKiogT3JkZXJlZCBsaXN0IG9mIHByZWZlcnJlZCBwb3NpdGlvbnMsIGZyb20gbW9zdCB0byBsZWFzdCBkZXNpcmFibGUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVG8gYmUgdXNlZCB0byBmb3IgYW55IGNsZWFudXAgYWZ0ZXIgdGhlIGVsZW1lbnQgZ2V0cyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBlbGVtZW50LCB1c2luZyB3aGljaGV2ZXIgcHJlZmVycmVkIHBvc2l0aW9uIHJlbGF0aXZlXG4gICAgICogdG8gdGhlIG9yaWdpbiBmaXRzIG9uLXNjcmVlbi5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRvIGFwcGx5IHRoZSBDU1Mgc3R5bGVzLlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gdGhlIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIENhY2hlIHRoZSBvdmVybGF5IHBhbmUgZWxlbWVudCBpbiBjYXNlIHJlLWNhbGN1bGF0aW5nIHBvc2l0aW9uIGlzIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLl9wYW5lID0gZWxlbWVudDtcbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgYm91bmRpbmcgcmVjdHMgZm9yIHRoZSBvcmlnaW4gYW5kIHRoZSBvdmVybGF5IHRvIGRldGVybWluZSBob3cgdG8gcG9zaXRpb25cbiAgICAgICAgLy8gdGhlIG92ZXJsYXkgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbi5cbiAgICAgICAgdmFyIG9yaWdpblJlY3QgPSB0aGlzLl9vcmlnaW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBvdmVybGF5UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIC8vIFdlIHVzZSB0aGUgdmlld3BvcnQgcmVjdCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHBvc2l0aW9uIHdvdWxkIGdvIG9mZi1zY3JlZW4uXG4gICAgICAgIHZhciB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgICAgICAvLyBGYWxsYmFjayBwb2ludCBpZiBub25lIG9mIHRoZSBmYWxsYmFja3MgZml0IGludG8gdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgZmFsbGJhY2tQb2ludCA9IG51bGw7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcGxhY2UgdGhlIG92ZXJsYXkgaW4gdGhlIGZpcnN0IG9mIHRoZSBwcmVmZXJyZWQgcG9zaXRpb25zIHN1Y2ggdGhhdCB0aGVcbiAgICAgICAgLy8gb3ZlcmxheSBmaXRzIG9uLXNjcmVlbi5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBfYVtfaV07XG4gICAgICAgICAgICAvLyBHZXQgdGhlICh4LCB5KSBwb2ludCBvZiBjb25uZWN0aW9uIG9uIHRoZSBvcmlnaW4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIGdldCB0aGVcbiAgICAgICAgICAgIC8vICh0b3AsIGxlZnQpIGNvb3JkaW5hdGUgZm9yIHRoZSBvdmVybGF5IGF0IGBwb3NgLlxuICAgICAgICAgICAgdmFyIG9yaWdpblBvaW50ID0gdGhpcy5fZ2V0T3JpZ2luQ29ubmVjdGlvblBvaW50KG9yaWdpblJlY3QsIHBvcyk7XG4gICAgICAgICAgICB2YXIgb3ZlcmxheVBvaW50ID0gdGhpcy5fZ2V0T3ZlcmxheVBvaW50KG9yaWdpblBvaW50LCBvdmVybGF5UmVjdCwgdmlld3BvcnRSZWN0LCBwb3MpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG92ZXJsYXkgaW4gdGhlIGNhbGN1bGF0ZWQgcG9zaXRpb24gZml0cyBvbi1zY3JlZW4sIHB1dCBpdCB0aGVyZSBhbmQgd2UncmUgZG9uZS5cbiAgICAgICAgICAgIGlmIChvdmVybGF5UG9pbnQuZml0c0luVmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudCwgb3ZlcmxheVBvaW50KTtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGNvbm5lY3RlZCBwb3NpdGlvbiBpbiBjYXNlIHRoZSBwb3NpdGlvbiBuZWVkcyB0byBiZSByZS1jYWxjdWxhdGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RDb25uZWN0ZWRQb3NpdGlvbiA9IHBvcztcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCB0aGUgcG9zaXRpb24gaGFzIGJlZW4gY2hhbmdlZCBhbG9uZyB3aXRoIGl0cyBjaGFuZ2UgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gdGhpcy5nZXRTY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uQ2hhbmdlID0gbmV3IENvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbkNoYW5nZShwb3MsIHNjcm9sbGFibGVWaWV3UHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Qb3NpdGlvbkNoYW5nZS5uZXh0KHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZhbGxiYWNrUG9pbnQgfHwgZmFsbGJhY2tQb2ludC52aXNpYmxlQXJlYSA8IG92ZXJsYXlQb2ludC52aXNpYmxlQXJlYSkge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrUG9pbnQgPSBvdmVybGF5UG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm9uZSBvZiB0aGUgcHJlZmVycmVkIHBvc2l0aW9ucyB3ZXJlIGluIHRoZSB2aWV3cG9ydCwgdGFrZSB0aGUgb25lXG4gICAgICAgIC8vIHdpdGggdGhlIGxhcmdlc3QgdmlzaWJsZSBhcmVhLlxuICAgICAgICB0aGlzLl9zZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudCwgZmFsbGJhY2tQb2ludCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHJlLWFsaWducyB0aGUgb3ZlcmxheSBlbGVtZW50IHdpdGggdGhlIHRyaWdnZXIgaW4gaXRzIGxhc3QgY2FsY3VsYXRlZCBwb3NpdGlvbixcbiAgICAgKiBldmVuIGlmIGEgcG9zaXRpb24gaGlnaGVyIGluIHRoZSBcInByZWZlcnJlZCBwb3NpdGlvbnNcIiBsaXN0IHdvdWxkIG5vdyBmaXQuIFRoaXNcbiAgICAgKiBhbGxvd3Mgb25lIHRvIHJlLWFsaWduIHRoZSBwYW5lbCB3aXRob3V0IGNoYW5naW5nIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcGFuZWwuXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUucmVjYWxjdWxhdGVMYXN0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnaW5SZWN0ID0gdGhpcy5fb3JpZ2luLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb3ZlcmxheVJlY3QgPSB0aGlzLl9wYW5lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgdmlld3BvcnRSZWN0ID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFJlY3QoKTtcbiAgICAgICAgdmFyIG9yaWdpblBvaW50ID0gdGhpcy5fZ2V0T3JpZ2luQ29ubmVjdGlvblBvaW50KG9yaWdpblJlY3QsIHRoaXMuX2xhc3RDb25uZWN0ZWRQb3NpdGlvbik7XG4gICAgICAgIHZhciBvdmVybGF5UG9pbnQgPSB0aGlzLl9nZXRPdmVybGF5UG9pbnQob3JpZ2luUG9pbnQsIG92ZXJsYXlSZWN0LCB2aWV3cG9ydFJlY3QsIHRoaXMuX2xhc3RDb25uZWN0ZWRQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbih0aGlzLl9wYW5lLCBvdmVybGF5UG9pbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBvZiBTY3JvbGxhYmxlIGNvbnRhaW5lcnMgdGhhdCBob3N0IHRoZSBvcmlnaW4gZWxlbWVudCBzbyB0aGF0XG4gICAgICogb24gcmVwb3NpdGlvbiB3ZSBjYW4gZXZhbHVhdGUgaWYgaXQgb3IgdGhlIG92ZXJsYXkgaGFzIGJlZW4gY2xpcHBlZCBvciBvdXRzaWRlIHZpZXcuIEV2ZXJ5XG4gICAgICogU2Nyb2xsYWJsZSBtdXN0IGJlIGFuIGFuY2VzdG9yIGVsZW1lbnQgb2YgdGhlIHN0cmF0ZWd5J3Mgb3JpZ2luIGVsZW1lbnQuXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2l0aFNjcm9sbGFibGVDb250YWluZXJzID0gZnVuY3Rpb24gKHNjcm9sbGFibGVzKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZXMgPSBzY3JvbGxhYmxlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgcHJlZmVycmVkIGZhbGxiYWNrIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSBvcmlnaW5Qb3NcbiAgICAgKiBAcGFyYW0gb3ZlcmxheVBvc1xuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpdGhGYWxsYmFja1Bvc2l0aW9uID0gZnVuY3Rpb24gKG9yaWdpblBvcywgb3ZlcmxheVBvcykge1xuICAgICAgICB0aGlzLl9wcmVmZXJyZWRQb3NpdGlvbnMucHVzaChuZXcgQ29ubmVjdGlvblBvc2l0aW9uUGFpcihvcmlnaW5Qb3MsIG92ZXJsYXlQb3MpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsYXlvdXQgZGlyZWN0aW9uIHNvIHRoZSBvdmVybGF5J3MgcG9zaXRpb24gY2FuIGJlIGFkanVzdGVkIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSBkaXIgTmV3IGxheW91dCBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2l0aERpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgdGhpcy5fZGlyID0gZGlyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYW4gb2Zmc2V0IGZvciB0aGUgb3ZlcmxheSdzIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHgtYXhpc1xuICAgICAqIEBwYXJhbSBvZmZzZXQgTmV3IG9mZnNldCBpbiB0aGUgWCBheGlzLlxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLndpdGhPZmZzZXRYID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYW4gb2Zmc2V0IGZvciB0aGUgb3ZlcmxheSdzIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHktYXhpc1xuICAgICAqIEBwYXJhbSAgb2Zmc2V0IE5ldyBvZmZzZXQgaW4gdGhlIFkgYXhpcy5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS53aXRoT2Zmc2V0WSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBob3Jpem9udGFsICh4KSBcInN0YXJ0XCIgZGltZW5zaW9uIGJhc2VkIG9uIHdoZXRoZXIgdGhlIG92ZXJsYXkgaXMgaW4gYW4gUlRMIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHJlY3RcbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0U3RhcnRYID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnRsID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhvcml6b250YWwgKHgpIFwiZW5kXCIgZGltZW5zaW9uIGJhc2VkIG9uIHdoZXRoZXIgdGhlIG92ZXJsYXkgaXMgaW4gYW4gUlRMIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHJlY3RcbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0RW5kWCA9IGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1J0bCA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSAoeCwgeSkgY29vcmRpbmF0ZSBvZiBhIGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIG9yaWdpbiBiYXNlZCBvbiBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSBvcmlnaW5SZWN0XG4gICAgICogQHBhcmFtIHBvc1xuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQgPSBmdW5jdGlvbiAob3JpZ2luUmVjdCwgcG9zKSB7XG4gICAgICAgIHZhciBvcmlnaW5TdGFydFggPSB0aGlzLl9nZXRTdGFydFgob3JpZ2luUmVjdCk7XG4gICAgICAgIHZhciBvcmlnaW5FbmRYID0gdGhpcy5fZ2V0RW5kWChvcmlnaW5SZWN0KTtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIGlmIChwb3Mub3JpZ2luWCA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgeCA9IG9yaWdpblN0YXJ0WCArIChvcmlnaW5SZWN0LndpZHRoIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gcG9zLm9yaWdpblggPT0gJ3N0YXJ0JyA/IG9yaWdpblN0YXJ0WCA6IG9yaWdpbkVuZFg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHk7XG4gICAgICAgIGlmIChwb3Mub3JpZ2luWSA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgeSA9IG9yaWdpblJlY3QudG9wICsgKG9yaWdpblJlY3QuaGVpZ2h0IC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gcG9zLm9yaWdpblkgPT0gJ3RvcCcgPyBvcmlnaW5SZWN0LnRvcCA6IG9yaWdpblJlY3QuYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlICh4LCB5KSBjb29yZGluYXRlIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIG92ZXJsYXkgZ2l2ZW4gYSBnaXZlbiBwb3NpdGlvbiBhbmRcbiAgICAgKiBvcmlnaW4gcG9pbnQgdG8gd2hpY2ggdGhlIG92ZXJsYXkgc2hvdWxkIGJlIGNvbm5lY3RlZCwgYXMgd2VsbCBhcyBob3cgbXVjaCBvZiB0aGUgZWxlbWVudFxuICAgICAqIHdvdWxkIGJlIGluc2lkZSB0aGUgdmlld3BvcnQgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0T3ZlcmxheVBvaW50ID0gZnVuY3Rpb24gKG9yaWdpblBvaW50LCBvdmVybGF5UmVjdCwgdmlld3BvcnRSZWN0LCBwb3MpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSAob3ZlcmxheVN0YXJ0WCwgb3ZlcmxheVN0YXJ0WSksIHRoZSBzdGFydCBvZiB0aGUgcG90ZW50aWFsIG92ZXJsYXkgcG9zaXRpb25cbiAgICAgICAgLy8gcmVsYXRpdmUgdG8gdGhlIG9yaWdpbiBwb2ludC5cbiAgICAgICAgdmFyIG92ZXJsYXlTdGFydFg7XG4gICAgICAgIGlmIChwb3Mub3ZlcmxheVggPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFggPSAtb3ZlcmxheVJlY3Qud2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcy5vdmVybGF5WCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgb3ZlcmxheVN0YXJ0WCA9IHRoaXMuX2lzUnRsID8gLW92ZXJsYXlSZWN0LndpZHRoIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFggPSB0aGlzLl9pc1J0bCA/IDAgOiAtb3ZlcmxheVJlY3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXJsYXlTdGFydFk7XG4gICAgICAgIGlmIChwb3Mub3ZlcmxheVkgPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFkgPSAtb3ZlcmxheVJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFkgPSBwb3Mub3ZlcmxheVkgPT0gJ3RvcCcgPyAwIDogLW92ZXJsYXlSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgKHgsIHkpIGNvb3JkaW5hdGVzIG9mIHRoZSBvdmVybGF5LlxuICAgICAgICB2YXIgeCA9IG9yaWdpblBvaW50LnggKyBvdmVybGF5U3RhcnRYICsgdGhpcy5fb2Zmc2V0WDtcbiAgICAgICAgdmFyIHkgPSBvcmlnaW5Qb2ludC55ICsgb3ZlcmxheVN0YXJ0WSArIHRoaXMuX29mZnNldFk7XG4gICAgICAgIC8vIEhvdyBtdWNoIHRoZSBvdmVybGF5IHdvdWxkIG92ZXJmbG93IGF0IHRoaXMgcG9zaXRpb24sIG9uIGVhY2ggc2lkZS5cbiAgICAgICAgdmFyIGxlZnRPdmVyZmxvdyA9IDAgLSB4O1xuICAgICAgICB2YXIgcmlnaHRPdmVyZmxvdyA9ICh4ICsgb3ZlcmxheVJlY3Qud2lkdGgpIC0gdmlld3BvcnRSZWN0LndpZHRoO1xuICAgICAgICB2YXIgdG9wT3ZlcmZsb3cgPSAwIC0geTtcbiAgICAgICAgdmFyIGJvdHRvbU92ZXJmbG93ID0gKHkgKyBvdmVybGF5UmVjdC5oZWlnaHQpIC0gdmlld3BvcnRSZWN0LmhlaWdodDtcbiAgICAgICAgLy8gVmlzaWJsZSBwYXJ0cyBvZiB0aGUgZWxlbWVudCBvbiBlYWNoIGF4aXMuXG4gICAgICAgIHZhciB2aXNpYmxlV2lkdGggPSB0aGlzLl9zdWJ0cmFjdE92ZXJmbG93cyhvdmVybGF5UmVjdC53aWR0aCwgbGVmdE92ZXJmbG93LCByaWdodE92ZXJmbG93KTtcbiAgICAgICAgdmFyIHZpc2libGVIZWlnaHQgPSB0aGlzLl9zdWJ0cmFjdE92ZXJmbG93cyhvdmVybGF5UmVjdC5oZWlnaHQsIHRvcE92ZXJmbG93LCBib3R0b21PdmVyZmxvdyk7XG4gICAgICAgIC8vIFRoZSBhcmVhIG9mIHRoZSBlbGVtZW50IHRoYXQncyB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuICAgICAgICB2YXIgdmlzaWJsZUFyZWEgPSB2aXNpYmxlV2lkdGggKiB2aXNpYmxlSGVpZ2h0O1xuICAgICAgICB2YXIgZml0c0luVmlld3BvcnQgPSAob3ZlcmxheVJlY3Qud2lkdGggKiBvdmVybGF5UmVjdC5oZWlnaHQpID09PSB2aXNpYmxlQXJlYTtcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSwgZml0c0luVmlld3BvcnQ6IGZpdHNJblZpZXdwb3J0LCB2aXNpYmxlQXJlYTogdmlzaWJsZUFyZWEgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcgcHJvcGVydGllcyBvZiB0aGUgdHJpZ2dlciBhbmQgb3ZlcmxheSwgaW5jbHVkaW5nIHdoZXRoZXIgdGhleSBhcmUgY2xpcHBlZFxuICAgICAqIG9yIGNvbXBsZXRlbHkgb3V0c2lkZSB0aGUgdmlldyBvZiBhbnkgb2YgdGhlIHN0cmF0ZWd5J3Mgc2Nyb2xsYWJsZXMuXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0U2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9yaWdpbkJvdW5kcyA9IHRoaXMuX2dldEVsZW1lbnRCb3VuZHModGhpcy5fb3JpZ2luKTtcbiAgICAgICAgdmFyIG92ZXJsYXlCb3VuZHMgPSB0aGlzLl9nZXRFbGVtZW50Qm91bmRzKG92ZXJsYXkpO1xuICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyQm91bmRzID0gdGhpcy5zY3JvbGxhYmxlcy5tYXAoZnVuY3Rpb24gKHNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0RWxlbWVudEJvdW5kcyhzY3JvbGxhYmxlLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc09yaWdpbkNsaXBwZWQ6IHRoaXMuaXNFbGVtZW50Q2xpcHBlZChvcmlnaW5Cb3VuZHMsIHNjcm9sbENvbnRhaW5lckJvdW5kcyksXG4gICAgICAgICAgICBpc09yaWdpbk91dHNpZGVWaWV3OiB0aGlzLmlzRWxlbWVudE91dHNpZGVWaWV3KG9yaWdpbkJvdW5kcywgc2Nyb2xsQ29udGFpbmVyQm91bmRzKSxcbiAgICAgICAgICAgIGlzT3ZlcmxheUNsaXBwZWQ6IHRoaXMuaXNFbGVtZW50Q2xpcHBlZChvdmVybGF5Qm91bmRzLCBzY3JvbGxDb250YWluZXJCb3VuZHMpLFxuICAgICAgICAgICAgaXNPdmVybGF5T3V0c2lkZVZpZXc6IHRoaXMuaXNFbGVtZW50T3V0c2lkZVZpZXcob3ZlcmxheUJvdW5kcywgc2Nyb2xsQ29udGFpbmVyQm91bmRzKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGNvbXBsZXRlbHkgb3V0IG9mIHRoZSB2aWV3IG9mIGFueSBvZiB0aGUgY29udGFpbmVycy4gKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5pc0VsZW1lbnRPdXRzaWRlVmlldyA9IGZ1bmN0aW9uIChlbGVtZW50Qm91bmRzLCBjb250YWluZXJzQm91bmRzKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJzQm91bmRzLnNvbWUoZnVuY3Rpb24gKGNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgdmFyIG91dHNpZGVBYm92ZSA9IGVsZW1lbnRCb3VuZHMuYm90dG9tIDwgY29udGFpbmVyQm91bmRzLnRvcDtcbiAgICAgICAgICAgIHZhciBvdXRzaWRlQmVsb3cgPSBlbGVtZW50Qm91bmRzLnRvcCA+IGNvbnRhaW5lckJvdW5kcy5ib3R0b207XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUxlZnQgPSBlbGVtZW50Qm91bmRzLnJpZ2h0IDwgY29udGFpbmVyQm91bmRzLmxlZnQ7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZVJpZ2h0ID0gZWxlbWVudEJvdW5kcy5sZWZ0ID4gY29udGFpbmVyQm91bmRzLnJpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIG91dHNpZGVBYm92ZSB8fCBvdXRzaWRlQmVsb3cgfHwgb3V0c2lkZUxlZnQgfHwgb3V0c2lkZVJpZ2h0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGNsaXBwZWQgYnkgYW55IG9mIHRoZSBjb250YWluZXJzLiAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmlzRWxlbWVudENsaXBwZWQgPSBmdW5jdGlvbiAoZWxlbWVudEJvdW5kcywgY29udGFpbmVyc0JvdW5kcykge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyc0JvdW5kcy5zb21lKGZ1bmN0aW9uIChjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBjbGlwcGVkQWJvdmUgPSBlbGVtZW50Qm91bmRzLnRvcCA8IGNvbnRhaW5lckJvdW5kcy50b3A7XG4gICAgICAgICAgICB2YXIgY2xpcHBlZEJlbG93ID0gZWxlbWVudEJvdW5kcy5ib3R0b20gPiBjb250YWluZXJCb3VuZHMuYm90dG9tO1xuICAgICAgICAgICAgdmFyIGNsaXBwZWRMZWZ0ID0gZWxlbWVudEJvdW5kcy5sZWZ0IDwgY29udGFpbmVyQm91bmRzLmxlZnQ7XG4gICAgICAgICAgICB2YXIgY2xpcHBlZFJpZ2h0ID0gZWxlbWVudEJvdW5kcy5yaWdodCA+IGNvbnRhaW5lckJvdW5kcy5yaWdodDtcbiAgICAgICAgICAgIHJldHVybiBjbGlwcGVkQWJvdmUgfHwgY2xpcHBlZEJlbG93IHx8IGNsaXBwZWRMZWZ0IHx8IGNsaXBwZWRSaWdodDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQaHlzaWNhbGx5IHBvc2l0aW9ucyB0aGUgb3ZlcmxheSBlbGVtZW50IHRvIHRoZSBnaXZlbiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHBhcmFtIG92ZXJsYXlQb2ludFxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9zZXRFbGVtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgb3ZlcmxheVBvaW50KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IG92ZXJsYXlQb2ludC54ICsgJ3B4JztcbiAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBvdmVybGF5UG9pbnQueSArICdweCc7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgYm91bmRpbmcgcG9zaXRpb25zIG9mIHRoZSBwcm92aWRlZCBlbGVtZW50IHdpdGggcmVzcGVjdCB0byB0aGUgdmlld3BvcnQuICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuX2dldEVsZW1lbnRCb3VuZHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgYm91bmRpbmdDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogYm91bmRpbmdDbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QubGVmdCArIGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgIGJvdHRvbTogYm91bmRpbmdDbGllbnRSZWN0LnRvcCArIGJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBib3VuZGluZ0NsaWVudFJlY3QubGVmdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHRoZSBhbW91bnQgdGhhdCBhbiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIG9uIGFuIGF4aXMgZnJvbSBpdCdzIGxlbmd0aC5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fc3VidHJhY3RPdmVyZmxvd3MgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBvdmVyZmxvd3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG92ZXJmbG93c1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmZsb3dzLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudFZhbHVlLCBjdXJyZW50T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgLSBNYXRoLm1heChjdXJyZW50T3ZlcmZsb3csIDApO1xuICAgICAgICB9LCBsZW5ndGgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG59KCkpO1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIHBvc2l0aW9uaW5nIG92ZXJsYXlzLiBVc2luZyB0aGlzIHN0cmF0ZWd5LCBhbiBvdmVybGF5IGlzIGdpdmVuIGFuXG4gKiBleHBsaWNpdCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYnJvd3NlcidzIHZpZXdwb3J0LiBXZSB1c2UgZmxleGJveCwgaW5zdGVhZCBvZlxuICogdHJhbnNmb3JtcywgaW4gb3JkZXIgdG8gYXZvaWQgaXNzdWVzIHdpdGggc3VicGl4ZWwgcmVuZGVyaW5nIHdoaWNoIGNhbiBjYXVzZSB0aGVcbiAqIGVsZW1lbnQgdG8gYmVjb21lIGJsdXJyeS5cbiAqL1xudmFyIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3koKSB7XG4gICAgICAgIHRoaXMuX2Nzc1Bvc2l0aW9uID0gJ3N0YXRpYyc7XG4gICAgICAgIHRoaXMuX3RvcE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9ib3R0b21PZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fbGVmdE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9yaWdodE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9hbGlnbkl0ZW1zID0gJyc7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJyc7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gJyc7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB0b3Agb2Zmc2V0LlxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ib3R0b21PZmZzZXQgPSAnJztcbiAgICAgICAgdGhpcy5fdG9wT2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnZmxleC1zdGFydCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCBob3Jpem9udGFsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgbGVmdCBvZmZzZXQuXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUubGVmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yaWdodE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9sZWZ0T2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCB2ZXJ0aWNhbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IGJvdHRvbSBvZmZzZXQuXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuYm90dG9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RvcE9mZnNldCA9ICcnO1xuICAgICAgICB0aGlzLl9ib3R0b21PZmZzZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtcyA9ICdmbGV4LWVuZCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmlnaHQgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkuIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgTmV3IHJpZ2h0IG9mZnNldC5cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5yaWdodCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sZWZ0T2Zmc2V0ID0gJyc7XG4gICAgICAgIHRoaXMuX3JpZ2h0T2Zmc2V0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gJ2ZsZXgtZW5kJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvdmVybGF5IHdpZHRoIGFuZCBjbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IHdpZHRoLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgd2lkdGggZm9yIHRoZSBvdmVybGF5XG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICAgICAgLy8gV2hlbiB0aGUgd2lkdGggaXMgMTAwJSwgd2Ugc2hvdWxkIHJlc2V0IHRoZSBgbGVmdGAgYW5kIHRoZSBvZmZzZXQsXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGZsdXNoIGFnYWluc3QgdGhlIHZpZXdwb3J0IGVkZ2UuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQoJzBweCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3ZlcmxheSBoZWlnaHQgYW5kIGNsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgaGVpZ2h0IGZvciB0aGUgb3ZlcmxheVxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgLy8gV2hlbiB0aGUgaGVpZ2h0IGlzIDEwMCUsIHdlIHNob3VsZCByZXNldCB0aGUgYHRvcGAgYW5kIHRoZSBvZmZzZXQsXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGZsdXNoIGFnYWluc3QgdGhlIHZpZXdwb3J0IGVkZ2UuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgICB0aGlzLnRvcCgnMHB4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIHRoZSBvdmVybGF5IGhvcml6b250YWxseSB3aXRoIGFuIG9wdGlvbmFsIG9mZnNldC5cbiAgICAgKiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IGhvcml6b250YWwgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE92ZXJsYXkgb2Zmc2V0IGZyb20gdGhlIGhvcml6b250YWwgY2VudGVyLlxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmNlbnRlckhvcml6b250YWxseSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9ICcnOyB9XG4gICAgICAgIHRoaXMubGVmdChvZmZzZXQpO1xuICAgICAgICB0aGlzLl9qdXN0aWZ5Q29udGVudCA9ICdjZW50ZXInO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENlbnRlcnMgdGhlIG92ZXJsYXkgdmVydGljYWxseSB3aXRoIGFuIG9wdGlvbmFsIG9mZnNldC5cbiAgICAgKiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IHZlcnRpY2FsIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCBPdmVybGF5IG9mZnNldCBmcm9tIHRoZSB2ZXJ0aWNhbCBjZW50ZXIuXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuY2VudGVyVmVydGljYWxseSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9ICcnOyB9XG4gICAgICAgIHRoaXMudG9wKG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2FsaWduSXRlbXMgPSAnY2VudGVyJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byB3aGljaCB0byBhcHBseSB0aGUgQ1NTLlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVkIHdoZW4gdGhlIHN0eWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAgICAgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fd3JhcHBlcikge1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGhpcy5fd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdjZGstZ2xvYmFsLW92ZXJsYXktd3JhcHBlcicpO1xuICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl93cmFwcGVyLCBlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlcyA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHZhciBwYXJlbnRTdHlsZXMgPSBlbGVtZW50LnBhcmVudE5vZGUuc3R5bGU7XG4gICAgICAgIHN0eWxlcy5wb3NpdGlvbiA9IHRoaXMuX2Nzc1Bvc2l0aW9uO1xuICAgICAgICBzdHlsZXMubWFyZ2luVG9wID0gdGhpcy5fdG9wT2Zmc2V0O1xuICAgICAgICBzdHlsZXMubWFyZ2luTGVmdCA9IHRoaXMuX2xlZnRPZmZzZXQ7XG4gICAgICAgIHN0eWxlcy5tYXJnaW5Cb3R0b20gPSB0aGlzLl9ib3R0b21PZmZzZXQ7XG4gICAgICAgIHN0eWxlcy5tYXJnaW5SaWdodCA9IHRoaXMuX3JpZ2h0T2Zmc2V0O1xuICAgICAgICBzdHlsZXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgc3R5bGVzLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgcGFyZW50U3R5bGVzLmp1c3RpZnlDb250ZW50ID0gdGhpcy5fanVzdGlmeUNvbnRlbnQ7XG4gICAgICAgIHBhcmVudFN0eWxlcy5hbGlnbkl0ZW1zID0gdGhpcy5fYWxpZ25JdGVtcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHdyYXBwZXIgZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dyYXBwZXIgJiYgdGhpcy5fd3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fd3JhcHBlcik7XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3k7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQxMiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqIEJ1aWxkZXIgZm9yIG92ZXJsYXkgcG9zaXRpb24gc3RyYXRlZ3kuICovXG52YXIgT3ZlcmxheVBvc2l0aW9uQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheVBvc2l0aW9uQnVpbGRlcihfdmlld3BvcnRSdWxlcikge1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyID0gX3ZpZXdwb3J0UnVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnbG9iYWwgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICovXG4gICAgT3ZlcmxheVBvc2l0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2xvYmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWxhdGl2ZSBwb3NpdGlvbiBzdHJhdGVneS5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFJlZlxuICAgICAqIEBwYXJhbSBvcmlnaW5Qb3NcbiAgICAgKiBAcGFyYW0gb3ZlcmxheVBvc1xuICAgICAqL1xuICAgIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIucHJvdG90eXBlLmNvbm5lY3RlZFRvID0gZnVuY3Rpb24gKGVsZW1lbnRSZWYsIG9yaWdpblBvcywgb3ZlcmxheVBvcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3koZWxlbWVudFJlZiwgb3JpZ2luUG9zLCBvdmVybGF5UG9zLCB0aGlzLl92aWV3cG9ydFJ1bGVyKTtcbiAgICB9O1xuICAgIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgPSBfX2RlY29yYXRlJDEyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDEyKCdkZXNpZ246cGFyYW10eXBlcycsIFtWaWV3cG9ydFJ1bGVyXSlcbiAgICBdLCBPdmVybGF5UG9zaXRpb25CdWlsZGVyKTtcbiAgICByZXR1cm4gT3ZlcmxheVBvc2l0aW9uQnVpbGRlcjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDE0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFRoZSBPdmVybGF5Q29udGFpbmVyIGlzIHRoZSBjb250YWluZXIgaW4gd2hpY2ggYWxsIG92ZXJsYXlzIHdpbGwgbG9hZC5cbiAqIEl0IHNob3VsZCBiZSBwcm92aWRlZCBpbiB0aGUgcm9vdCBjb21wb25lbnQgdG8gZW5zdXJlIGl0IGlzIHByb3Blcmx5IHNoYXJlZC5cbiAqL1xudmFyIE92ZXJsYXlDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlDb250YWluZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIG92ZXJsYXkgY29udGFpbmVyIGVsZW1lbnQuICBJdCB3aWxsIGxhemlseVxuICAgICAqIGNyZWF0ZSB0aGUgZWxlbWVudCB0aGUgZmlyc3QgdGltZSAgaXQgaXMgY2FsbGVkIHRvIGZhY2lsaXRhdGUgdXNpbmdcbiAgICAgKiB0aGUgY29udGFpbmVyIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgICAgKiBAcmV0dXJucyB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBPdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5nZXRDb250YWluZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBvdmVybGF5IGNvbnRhaW5lciBlbGVtZW50LCB3aGljaCBpcyBzaW1wbHkgYSBkaXZcbiAgICAgKiB3aXRoIHRoZSAnY2RrLW92ZXJsYXktY29udGFpbmVyJyBjbGFzcyBvbiB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICAgKi9cbiAgICBPdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5fY3JlYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjZGstb3ZlcmxheS1jb250YWluZXInKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyO1xuICAgIH07XG4gICAgT3ZlcmxheUNvbnRhaW5lciA9IF9fZGVjb3JhdGUkMTQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgT3ZlcmxheUNvbnRhaW5lcik7XG4gICAgcmV0dXJuIE92ZXJsYXlDb250YWluZXI7XG59KCkpO1xuZnVuY3Rpb24gT1ZFUkxBWV9DT05UQUlORVJfUFJPVklERVJfRkFDVE9SWShwYXJlbnRDb250YWluZXIpIHtcbiAgICByZXR1cm4gcGFyZW50Q29udGFpbmVyIHx8IG5ldyBPdmVybGF5Q29udGFpbmVyKCk7XG59XG5cbnZhciBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIE92ZXJsYXlDb250YWluZXIgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBPdmVybGF5Q29udGFpbmVyLFxuICAgIGRlcHM6IFtbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYoKSwgT3ZlcmxheUNvbnRhaW5lcl1dLFxuICAgIHVzZUZhY3Rvcnk6IE9WRVJMQVlfQ09OVEFJTkVSX1BST1ZJREVSX0ZBQ1RPUllcbn07XG5cbnZhciBfX2RlY29yYXRlJDExID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDExID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogTmV4dCBvdmVybGF5IHVuaXF1ZSBJRC4gKi9cbnZhciBuZXh0VW5pcXVlSWQgPSAwO1xuLyoqIFRoZSBkZWZhdWx0IHN0YXRlIGZvciBuZXdseSBjcmVhdGVkIG92ZXJsYXlzLiAqL1xudmFyIGRlZmF1bHRTdGF0ZSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbi8qKlxuICogU2VydmljZSB0byBjcmVhdGUgT3ZlcmxheXMuIE92ZXJsYXlzIGFyZSBkeW5hbWljYWxseSBhZGRlZCBwaWVjZXMgb2YgZmxvYXRpbmcgVUksIG1lYW50IHRvIGJlXG4gKiB1c2VkIGFzIGEgbG93LWxldmVsIGJ1aWxkaW5nIGJ1aWxkaW5nIGJsb2NrIGZvciBvdGhlciBjb21wb25lbnRzLiBEaWFsb2dzLCB0b29sdGlwcywgbWVudXMsXG4gKiBzZWxlY3RzLCBldGMuIGNhbiBhbGwgYmUgYnVpbHQgdXNpbmcgb3ZlcmxheXMuIFRoZSBzZXJ2aWNlIHNob3VsZCBwcmltYXJpbHkgYmUgdXNlZCBieSBhdXRob3JzXG4gKiBvZiByZS11c2FibGUgY29tcG9uZW50cyByYXRoZXIgdGhhbiBkZXZlbG9wZXJzIGJ1aWxkaW5nIGVuZC11c2VyIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBBbiBvdmVybGF5ICppcyogYSBQb3J0YWxIb3N0LCBzbyBhbnkga2luZCBvZiBQb3J0YWwgY2FuIGJlIGxvYWRlZCBpbnRvIG9uZS5cbiAqL1xudmFyIE92ZXJsYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXkoX292ZXJsYXlDb250YWluZXIsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9wb3NpdGlvbkJ1aWxkZXIsIF9hcHBSZWYsIF9pbmplY3RvciwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9vdmVybGF5Q29udGFpbmVyID0gX292ZXJsYXlDb250YWluZXI7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQnVpbGRlciA9IF9wb3NpdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMuX2FwcFJlZiA9IF9hcHBSZWY7XG4gICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHRvIGFwcGx5IHRvIHRoZSBvdmVybGF5LlxuICAgICAqIEByZXR1cm5zIFJlZmVyZW5jZSB0byB0aGUgY3JlYXRlZCBvdmVybGF5LlxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSQkMSkge1xuICAgICAgICBpZiAoc3RhdGUkJDEgPT09IHZvaWQgMCkgeyBzdGF0ZSQkMSA9IGRlZmF1bHRTdGF0ZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlT3ZlcmxheVJlZih0aGlzLl9jcmVhdGVQYW5lRWxlbWVudCgpLCBzdGF0ZSQkMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcG9zaXRpb24gYnVpbGRlciB0aGF0IGNhbiBiZSB1c2VkLCB2aWEgZmx1ZW50IEFQSSxcbiAgICAgKiB0byBjb25zdHJ1Y3QgYW5kIGNvbmZpZ3VyZSBhIHBvc2l0aW9uIHN0cmF0ZWd5LlxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25CdWlsZGVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgRE9NIGVsZW1lbnQgZm9yIGFuIG92ZXJsYXkgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIG92ZXJsYXkgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm5zIE5ld2x5LWNyZWF0ZWQgcGFuZSBlbGVtZW50XG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuX2NyZWF0ZVBhbmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFuZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwYW5lLmlkID0gXCJjZGstb3ZlcmxheS1cIiArIG5leHRVbmlxdWVJZCsrO1xuICAgICAgICBwYW5lLmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LXBhbmUnKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lci5nZXRDb250YWluZXJFbGVtZW50KCkuYXBwZW5kQ2hpbGQocGFuZSk7XG4gICAgICAgIHJldHVybiBwYW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9tUG9ydGFsSG9zdCBpbnRvIHdoaWNoIHRoZSBvdmVybGF5IGNvbnRlbnQgY2FuIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gcGFuZSBUaGUgRE9NIGVsZW1lbnQgdG8gdHVybiBpbnRvIGEgcG9ydGFsIGhvc3QuXG4gICAgICogQHJldHVybnMgQSBwb3J0YWwgaG9zdCBmb3IgdGhlIGdpdmVuIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLl9jcmVhdGVQb3J0YWxIb3N0ID0gZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3J0YWxIb3N0KHBhbmUsIHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgdGhpcy5fYXBwUmVmLCB0aGlzLl9pbmplY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE92ZXJsYXlSZWYgZm9yIGFuIG92ZXJsYXkgaW4gdGhlIGdpdmVuIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBwYW5lIERPTSBlbGVtZW50IGZvciB0aGUgb3ZlcmxheVxuICAgICAqIEBwYXJhbSBzdGF0ZVxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5UmVmID0gZnVuY3Rpb24gKHBhbmUsIHN0YXRlJCQxKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3ZlcmxheVJlZih0aGlzLl9jcmVhdGVQb3J0YWxIb3N0KHBhbmUpLCBwYW5lLCBzdGF0ZSQkMSwgdGhpcy5fbmdab25lKTtcbiAgICB9O1xuICAgIE92ZXJsYXkgPSBfX2RlY29yYXRlJDExKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDExKCdkZXNpZ246cGFyYW10eXBlcycsIFtPdmVybGF5Q29udGFpbmVyLCBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgT3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgX2FuZ3VsYXJfY29yZS5BcHBsaWNhdGlvblJlZiwgX2FuZ3VsYXJfY29yZS5JbmplY3RvciwgX2FuZ3VsYXJfY29yZS5OZ1pvbmVdKVxuICAgIF0sIE92ZXJsYXkpO1xuICAgIHJldHVybiBPdmVybGF5O1xufSgpKTtcbi8qKiBQcm92aWRlcnMgZm9yIE92ZXJsYXkgYW5kIGl0cyByZWxhdGVkIGluamVjdGFibGVzLiAqL1xudmFyIE9WRVJMQVlfUFJPVklERVJTID0gW1xuICAgIE92ZXJsYXksXG4gICAgT3ZlcmxheVBvc2l0aW9uQnVpbGRlcixcbiAgICBWSUVXUE9SVF9SVUxFUl9QUk9WSURFUixcbiAgICBTQ1JPTExfRElTUEFUQ0hFUl9QUk9WSURFUixcbiAgICBPVkVSTEFZX0NPTlRBSU5FUl9QUk9WSURFUixcbl07XG5cbnZhciBfX2RlY29yYXRlJDE1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHdoZW4gdGhlIGRpcmVjdGl2ZSdzIGVsZW1lbnQgaXMgc2Nyb2xsZWQuIFJlZ2lzdGVycyBpdHNlbGYgd2l0aCB0aGVcbiAqIFNjcm9sbERpc3BhdGNoZXIgc2VydmljZSB0byBpbmNsdWRlIGl0c2VsZiBhcyBwYXJ0IG9mIGl0cyBjb2xsZWN0aW9uIG9mIHNjcm9sbGluZyBldmVudHMgdGhhdCBpdFxuICogY2FuIGJlIGxpc3RlbmVkIHRvIHRocm91Z2ggdGhlIHNlcnZpY2UuXG4gKi9cbnZhciBTY3JvbGxhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxhYmxlKF9lbGVtZW50UmVmLCBfc2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fc2Nyb2xsID0gX3Njcm9sbDtcbiAgICB9XG4gICAgU2Nyb2xsYWJsZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbC5yZWdpc3Rlcih0aGlzKTtcbiAgICB9O1xuICAgIFNjcm9sbGFibGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zY3JvbGwuZGVyZWdpc3Rlcih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW4gYSBzY3JvbGwgZXZlbnQgaXMgZmlyZWQgb24gdGhlIGhvc3QgZWxlbWVudC5cbiAgICAgKi9cbiAgICBTY3JvbGxhYmxlLnByb3RvdHlwZS5lbGVtZW50U2Nyb2xsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5mcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnc2Nyb2xsJyk7XG4gICAgfTtcbiAgICBTY3JvbGxhYmxlLnByb3RvdHlwZS5nZXRFbGVtZW50UmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZjtcbiAgICB9O1xuICAgIFNjcm9sbGFibGUgPSBfX2RlY29yYXRlJDE1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrLXNjcm9sbGFibGVdJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgU2Nyb2xsRGlzcGF0Y2hlcl0pXG4gICAgXSwgU2Nyb2xsYWJsZSk7XG4gICAgcmV0dXJuIFNjcm9sbGFibGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQxMCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKiBEZWZhdWx0IHNldCBvZiBwb3NpdGlvbnMgZm9yIHRoZSBvdmVybGF5LiBGb2xsb3dzIHRoZSBiZWhhdmlvciBvZiBhIGRyb3Bkb3duLiAqL1xudmFyIGRlZmF1bHRQb3NpdGlvbkxpc3QgPSBbXG4gICAgbmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIoeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAnYm90dG9tJyB9LCB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ3RvcCcgfSksXG4gICAgbmV3IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIoeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAndG9wJyB9LCB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScgfSksXG5dO1xuLyoqXG4gKiBEaXJlY3RpdmUgYXBwbGllZCB0byBhbiBlbGVtZW50IHRvIG1ha2UgaXQgdXNhYmxlIGFzIGFuIG9yaWdpbiBmb3IgYW4gT3ZlcmxheSB1c2luZyBhXG4gKiBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LlxuICovXG52YXIgT3ZlcmxheU9yaWdpbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3ZlcmxheU9yaWdpbihlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgfVxuICAgIE92ZXJsYXlPcmlnaW4gPSBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrLW92ZXJsYXktb3JpZ2luXSwgW292ZXJsYXktb3JpZ2luXScsXG4gICAgICAgICAgICBleHBvcnRBczogJ2Nka092ZXJsYXlPcmlnaW4nLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgT3ZlcmxheU9yaWdpbik7XG4gICAgcmV0dXJuIE92ZXJsYXlPcmlnaW47XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgdG8gZmFjaWxpdGF0ZSBkZWNsYXJhdGl2ZSBjcmVhdGlvbiBvZiBhbiBPdmVybGF5IHVzaW5nIGEgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5cbiAqL1xudmFyIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE8oamVsYm91cm4pOiBpbnB1dHMgZm9yIHNpemUsIHNjcm9sbCBiZWhhdmlvciwgYW5pbWF0aW9uLCBldGMuXG4gICAgZnVuY3Rpb24gQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZShfb3ZlcmxheSwgdGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYsIF9kaXIpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhc0JhY2tkcm9wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29mZnNldFggPSAwO1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYmFja2Ryb3AgaXMgY2xpY2tlZC4gKi9cbiAgICAgICAgdGhpcy5iYWNrZHJvcENsaWNrID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLiAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gYXR0YWNoZWQuICovXG4gICAgICAgIHRoaXMuYXR0YWNoID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIG92ZXJsYXkgaGFzIGJlZW4gZGV0YWNoZWQuICovXG4gICAgICAgIHRoaXMuZGV0YWNoID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9mZnNldFhcIiwge1xuICAgICAgICAvKiogVGhlIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBvdmVybGF5IGNvbm5lY3Rpb24gcG9pbnQgb24gdGhlIHgtYXhpcyAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXRYO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvZmZzZXRYKSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uLndpdGhPZmZzZXRYKG9mZnNldFgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0WVwiLCB7XG4gICAgICAgIC8qKiBUaGUgb2Zmc2V0IGluIHBpeGVscyBmb3IgdGhlIG92ZXJsYXkgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgeS1heGlzICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldFkpIHtcbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSBvZmZzZXRZO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24ud2l0aE9mZnNldFkob2Zmc2V0WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoYXNCYWNrZHJvcFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBzaG91bGQgYXR0YWNoIGEgYmFja2Ryb3AuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0JhY2tkcm9wO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5faGFzQmFja2Ryb3AgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3BlblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA/IHRoaXMuX2F0dGFjaE92ZXJsYXkoKSA6IHRoaXMuX2RldGFjaE92ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuX29wZW4gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm92ZXJsYXlSZWZcIiwge1xuICAgICAgICAvKiogVGhlIGFzc29jaWF0ZWQgb3ZlcmxheSByZWZlcmVuY2UuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXJcIiwge1xuICAgICAgICAvKiogVGhlIGVsZW1lbnQncyBsYXlvdXQgZGlyZWN0aW9uLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lPdmVybGF5KCk7XG4gICAgfTtcbiAgICAvKiogQ3JlYXRlcyBhbiBvdmVybGF5ICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2NyZWF0ZU92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wb3NpdGlvbnMgfHwgIXRoaXMucG9zaXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBkZWZhdWx0UG9zaXRpb25MaXN0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZSh0aGlzLl9idWlsZENvbmZpZygpKTtcbiAgICB9O1xuICAgIC8qKiBCdWlsZHMgdGhlIG92ZXJsYXkgY29uZmlnIGJhc2VkIG9uIHRoZSBkaXJlY3RpdmUncyBpbnB1dHMgKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fYnVpbGRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdmVybGF5Q29uZmlnID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy53aWR0aCB8fCB0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb25maWcuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggfHwgdGhpcy5taW5XaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3ZlcmxheUNvbmZpZy5taW5XaWR0aCA9IHRoaXMubWluV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluSGVpZ2h0IHx8IHRoaXMubWluSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLm1pbkhlaWdodCA9IHRoaXMubWluSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIG92ZXJsYXlDb25maWcuaGFzQmFja2Ryb3AgPSB0aGlzLmhhc0JhY2tkcm9wO1xuICAgICAgICBpZiAodGhpcy5iYWNrZHJvcENsYXNzKSB7XG4gICAgICAgICAgICBvdmVybGF5Q29uZmlnLmJhY2tkcm9wQ2xhc3MgPSB0aGlzLmJhY2tkcm9wQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgIG92ZXJsYXlDb25maWcucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgICAgICBvdmVybGF5Q29uZmlnLmRpcmVjdGlvbiA9IHRoaXMuZGlyO1xuICAgICAgICByZXR1cm4gb3ZlcmxheUNvbmZpZztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBzdHJhdGVneSBvZiB0aGUgb3ZlcmxheSB0byBiZSBzZXQgb24gdGhlIG92ZXJsYXkgY29uZmlnICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2NyZWF0ZVBvc2l0aW9uU3RyYXRlZ3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uc1swXTtcbiAgICAgICAgdmFyIG9yaWdpblBvaW50ID0geyBvcmlnaW5YOiBwb3Mub3JpZ2luWCwgb3JpZ2luWTogcG9zLm9yaWdpblkgfTtcbiAgICAgICAgdmFyIG92ZXJsYXlQb2ludCA9IHsgb3ZlcmxheVg6IHBvcy5vdmVybGF5WCwgb3ZlcmxheVk6IHBvcy5vdmVybGF5WSB9O1xuICAgICAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgICAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLm9yaWdpbi5lbGVtZW50UmVmLCBvcmlnaW5Qb2ludCwgb3ZlcmxheVBvaW50KVxuICAgICAgICAgICAgLndpdGhEaXJlY3Rpb24odGhpcy5kaXIpXG4gICAgICAgICAgICAud2l0aE9mZnNldFgodGhpcy5vZmZzZXRYKVxuICAgICAgICAgICAgLndpdGhPZmZzZXRZKHRoaXMub2Zmc2V0WSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZVBvc2l0aW9uQ2hhbmdlcyhzdHJhdGVneSk7XG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICB9O1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9oYW5kbGVQb3NpdGlvbkNoYW5nZXMgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RyYXRlZ3kud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiB0aGlzLnBvc2l0aW9uc1tpXS5vcmlnaW5YLCBvcmlnaW5ZOiB0aGlzLnBvc2l0aW9uc1tpXS5vcmlnaW5ZIH0sIHsgb3ZlcmxheVg6IHRoaXMucG9zaXRpb25zW2ldLm92ZXJsYXlYLCBvdmVybGF5WTogdGhpcy5wb3NpdGlvbnNbaV0ub3ZlcmxheVkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHBvcykgeyByZXR1cm4gX3RoaXMucG9zaXRpb25DaGFuZ2UuZW1pdChwb3MpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBBdHRhY2hlcyB0aGUgb3ZlcmxheSBhbmQgc3Vic2NyaWJlcyB0byBiYWNrZHJvcCBjbGlja3MgaWYgYmFja2Ryb3AgZXhpc3RzICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2F0dGFjaE92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaCh0aGlzLl90ZW1wbGF0ZVBvcnRhbCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzQmFja2Ryb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uID0gdGhpcy5fb3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5iYWNrZHJvcENsaWNrLmVtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRGV0YWNoZXMgdGhlIG92ZXJsYXkgYW5kIHVuc3Vic2NyaWJlcyB0byBiYWNrZHJvcCBjbGlja3MgaWYgYmFja2Ryb3AgZXhpc3RzICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2RldGFjaE92ZXJsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2guZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIERlc3Ryb3lzIHRoZSBvdmVybGF5IGNyZWF0ZWQgYnkgdGhpcyBkaXJlY3RpdmUuICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUuX2Rlc3Ryb3lPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT3ZlcmxheU9yaWdpbilcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmlnaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBBcnJheSlcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwb3NpdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0WFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib2Zmc2V0WVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm1pbldpZHRoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcIm1pbkhlaWdodFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJiYWNrZHJvcENsYXNzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcImhhc0JhY2tkcm9wXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcGVuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYmFja2Ryb3BDbGlja1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwicG9zaXRpb25DaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLCBcImF0dGFjaFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGV0YWNoXCIsIHZvaWQgMCk7XG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGstY29ubmVjdGVkLW92ZXJsYXldLCBbY29ubmVjdGVkLW92ZXJsYXldJyxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnY2RrQ29ubmVjdGVkT3ZlcmxheSdcbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMSgzLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxMCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT3ZlcmxheSwgX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCBEaXJdKVxuICAgIF0sIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUpO1xuICAgIHJldHVybiBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlO1xufSgpKTtcbnZhciBPdmVybGF5TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5TW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBPdmVybGF5TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPdmVybGF5TW9kdWxlID0gX19kZWNvcmF0ZSQxMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW1BvcnRhbE1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSwgT3ZlcmxheU9yaWdpbiwgU2Nyb2xsYWJsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLCBPdmVybGF5T3JpZ2luLCBTY3JvbGxhYmxlXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW09WRVJMQVlfUFJPVklERVJTXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE92ZXJsYXlNb2R1bGUpO1xuICAgIHJldHVybiBPdmVybGF5TW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8vIFdoZXRoZXIgdGhlIGN1cnJlbnQgcGxhdGZvcm0gc3VwcG9ydHMgdGhlIFY4IEJyZWFrIEl0ZXJhdG9yLiBUaGUgVjggY2hlY2tcbi8vIGlzIG5lY2Vzc2FyeSB0byBkZXRlY3QgYWxsIEJsaW5rIGJhc2VkIGJyb3dzZXJzLlxudmFyIGhhc1Y4QnJlYWtJdGVyYXRvciA9IHR5cGVvZiAod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICh3aW5kb3cuSW50bCAmJiB3aW5kb3cuSW50bC52OEJyZWFrSXRlcmF0b3IpIDpcbiAgICAodHlwZW9mIChJbnRsKSAhPT0gJ3VuZGVmaW5lZCcgJiYgSW50bC52OEJyZWFrSXRlcmF0b3IpO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGRldGVjdCB0aGUgY3VycmVudCBwbGF0Zm9ybSBieSBjb21wYXJpbmcgdGhlIHVzZXJBZ2VudCBzdHJpbmdzIGFuZFxuICogY2hlY2tpbmcgYnJvd3Nlci1zcGVjaWZpYyBnbG9iYWwgcHJvcGVydGllcy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFBsYXRmb3JtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybSgpIHtcbiAgICAgICAgLyoqIExheW91dCBFbmdpbmVzICovXG4gICAgICAgIHRoaXMuRURHRSA9IC8oZWRnZSkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICB0aGlzLlRSSURFTlQgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAvLyBFZGdlSFRNTCBhbmQgVHJpZGVudCBtb2NrIEJsaW5rIHNwZWNpZmljIHRoaW5ncyBhbmQgbmVlZCB0byBleGNsdWRlZCBmcm9tIHRoaXMgY2hlY2suXG4gICAgICAgIHRoaXMuQkxJTksgPSAhISh3aW5kb3cuY2hyb21lIHx8IGhhc1Y4QnJlYWtJdGVyYXRvcikgJiYgISFDU1MgJiYgIXRoaXMuRURHRSAmJiAhdGhpcy5UUklERU5UO1xuICAgICAgICAvLyBXZWJraXQgaXMgcGFydCBvZiB0aGUgdXNlckFnZW50IGluIEVkZ2VIVE1MIEJsaW5rIGFuZCBUcmlkZW50LCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IFdlYmtpdCBydW5zIHN0YW5kYWxvbmUgYW5kIGlzIG5vdCB1c2UgYXMgYW5vdGhlciBlbmdpbmVzIGJhc2UuXG4gICAgICAgIHRoaXMuV0VCS0lUID0gL0FwcGxlV2ViS2l0L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhdGhpcy5CTElOSyAmJiAhdGhpcy5FREdFICYmICF0aGlzLlRSSURFTlQ7XG4gICAgICAgIC8qKiBCcm93c2VycyBhbmQgUGxhdGZvcm0gVHlwZXMgKi9cbiAgICAgICAgdGhpcy5JT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuICAgICAgICAvLyBJdCdzIGRpZmZpY3VsdCB0byBkZXRlY3QgdGhlIHBsYWluIEdlY2tvIGVuZ2luZSwgYmVjYXVzZSBtb3N0IG9mIHRoZSBicm93c2VycyBpZGVudGlmeVxuICAgICAgICAvLyB0aGVtIHNlbGYgYXMgR2Vja28tbGlrZSBicm93c2VycyBhbmQgbW9kaWZ5IHRoZSB1c2VyQWdlbnQncyBhY2NvcmRpbmcgdG8gdGhhdC5cbiAgICAgICAgLy8gU2luY2Ugd2Ugb25seSBjb3ZlciBvbmUgZXhwbGljaXQgRmlyZWZveCBjYXNlLCB3ZSBjYW4gc2ltcGx5IGNoZWNrIGZvciBGaXJlZm94XG4gICAgICAgIC8vIGluc3RlYWQgb2YgaGF2aW5nIGFuIHVuc3RhYmxlIGNoZWNrIGZvciBHZWNrby5cbiAgICAgICAgdGhpcy5GSVJFRk9YID0gLyhmaXJlZm94fG1pbmVmaWVsZCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAvLyBUcmlkZW50IG9uIG1vYmlsZSBhZGRzIHRoZSBhbmRyb2lkIHBsYXRmb3JtIHRvIHRoZSB1c2VyQWdlbnQgdG8gdHJpY2sgZGV0ZWN0aW9ucy5cbiAgICAgICAgdGhpcy5BTkRST0lEID0gL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLlRSSURFTlQ7XG4gICAgfVxuICAgIFBsYXRmb3JtID0gX19kZWNvcmF0ZSQxOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBQbGF0Zm9ybSk7XG4gICAgcmV0dXJuIFBsYXRmb3JtO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVGhlIEludGVyYWN0aXZpdHlDaGVja2VyIGxlYW5zIGhlYXZpbHkgb24gdGhlIGFsbHkuanMgYWNjZXNzaWJpbGl0eSB1dGlsaXRpZXMuXG4gKiBNZXRob2RzIGxpa2UgYGlzVGFiYmFibGVgIGFyZSBvbmx5IGNvdmVyaW5nIHNwZWNpZmljIGVkZ2UtY2FzZXMgZm9yIHRoZSBicm93c2VycyB3aGljaCBhcmVcbiAqIHN1cHBvcnRlZC5cbiAqL1xuLyoqXG4gKiBVdGlsaXR5IGZvciBjaGVja2luZyB0aGUgaW50ZXJhY3Rpdml0eSBvZiBhbiBlbGVtZW50LCBzdWNoIGFzIHdoZXRoZXIgaXMgaXMgZm9jdXNhYmxlIG9yXG4gKiB0YWJiYWJsZS5cbiAqL1xudmFyIEludGVyYWN0aXZpdHlDaGVja2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGl2aXR5Q2hlY2tlcihfcGxhdGZvcm0pIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQuXG4gICAgICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBUaGlzIGRvZXMgbm90IGNhcHR1cmUgc29tZSBjYXNlcywgc3VjaCBhcyBhIG5vbi1mb3JtIGNvbnRyb2wgd2l0aCBhIGRpc2FibGVkIGF0dHJpYnV0ZSBvclxuICAgICAgICAvLyBhIGZvcm0gY29udHJvbCBpbnNpZGUgb2YgYSBkaXNhYmxlZCBmb3JtLCBidXQgc2hvdWxkIGNhcHR1cmUgdGhlIG1vc3QgY29tbW9uIGNhc2VzLlxuICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyB2aXNpYmxlIGZvciB0aGUgcHVycG9zZXMgb2YgaW50ZXJhY3Rpdml0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBjYXB0dXJlIHN0YXRlcyBsaWtlIGBkaXNwbGF5OiBub25lYCBhbmQgYHZpc2liaWxpdHk6IGhpZGRlbmAsIGJ1dCBub3QgdGhpbmdzIGxpa2VcbiAgICAgKiBiZWluZyBjbGlwcGVkIGJ5IGFuIGBvdmVyZmxvdzogaGlkZGVuYCBwYXJlbnQgb3IgYmVpbmcgb3V0c2lkZSB0aGUgdmlld3BvcnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUuXG4gICAgICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBoYXNHZW9tZXRyeShlbGVtZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnZpc2liaWxpdHkgPT09ICd2aXNpYmxlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGNhbiBiZSByZWFjaGVkIHZpYSBUYWIga2V5LlxuICAgICAqIEFzc3VtZXMgdGhhdCB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWQgd2l0aCBpc0ZvY3VzYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRhYmJhYmxlLlxuICAgICAqL1xuICAgIEludGVyYWN0aXZpdHlDaGVja2VyLnByb3RvdHlwZS5pc1RhYmJhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGZyYW1lRWxlbWVudCA9IGdldFdpbmRvdyhlbGVtZW50KS5mcmFtZUVsZW1lbnQ7XG4gICAgICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBmcmFtZVR5cGUgPSBmcmFtZUVsZW1lbnQgJiYgZnJhbWVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAvLyBGcmFtZSBlbGVtZW50cyBpbmhlcml0IHRoZWlyIHRhYmluZGV4IG9udG8gYWxsIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGdldFRhYkluZGV4VmFsdWUoZnJhbWVFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZWJraXQgYW5kIEJsaW5rIGNvbnNpZGVyIGFueXRoaW5nIGluc2lkZSBvZiBhbiA8b2JqZWN0PiBlbGVtZW50IGFzIG5vbi10YWJiYWJsZS5cbiAgICAgICAgICAgIGlmICgodGhpcy5fcGxhdGZvcm0uQkxJTksgfHwgdGhpcy5fcGxhdGZvcm0uV0VCS0lUKSAmJiBmcmFtZVR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Via2l0IGFuZCBCbGluayBkaXNhYmxlIHRhYmJpbmcgdG8gYW4gZWxlbWVudCBpbnNpZGUgb2YgYW4gaW52aXNpYmxlIGZyYW1lLlxuICAgICAgICAgICAgaWYgKCh0aGlzLl9wbGF0Zm9ybS5CTElOSyB8fCB0aGlzLl9wbGF0Zm9ybS5XRUJLSVQpICYmICF0aGlzLmlzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHRhYkluZGV4VmFsdWUgPSBnZXRUYWJJbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFiSW5kZXhWYWx1ZSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnaWZyYW1lJykge1xuICAgICAgICAgICAgLy8gVGhlIGZyYW1lcyBtYXkgYmUgdGFiYmFibGUgZGVwZW5kaW5nIG9uIGNvbnRlbnQsIGJ1dCBpdCdzIG5vdCBwb3NzaWJseSB0byByZWxpYWJseVxuICAgICAgICAgICAgLy8gaW52ZXN0aWdhdGUgdGhlIGNvbnRlbnQgb2YgdGhlIGZyYW1lcy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpIHtcbiAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0IGFuIDxhdWRpbz4gZWxlbWVudCB3aXRob3V0IHRoZSBjb250cm9scyBlbmFibGVkIGlzIG5vdCB0YWJiYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wbGF0Zm9ybS5CTElOSykge1xuICAgICAgICAgICAgICAgIC8vIEluIEJsaW5rIDxhdWRpbyBjb250cm9scz4gZWxlbWVudHMgYXJlIGFsd2F5cyB0YWJiYWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykgJiYgdGhpcy5fcGxhdGZvcm0uVFJJREVOVCkge1xuICAgICAgICAgICAgICAgIC8vIEluIFRyaWRlbnQgYSA8dmlkZW8+IGVsZW1lbnQgd2l0aG91dCB0aGUgY29udHJvbHMgZW5hYmxlZCBpcyBub3QgdGFiYmFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGxhdGZvcm0uQkxJTksgfHwgdGhpcy5fcGxhdGZvcm0uRklSRUZPWCkge1xuICAgICAgICAgICAgICAgIC8vIEluIENocm9tZSBhbmQgRmlyZWZveCA8dmlkZW8gY29udHJvbHM+IGVsZW1lbnRzIGFyZSBhbHdheXMgdGFiYmFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0JyAmJiAodGhpcy5fcGxhdGZvcm0uQkxJTksgfHwgdGhpcy5fcGxhdGZvcm0uV0VCS0lUKSkge1xuICAgICAgICAgICAgLy8gSW4gYWxsIEJsaW5rIGFuZCBXZWJLaXQgYmFzZWQgYnJvd3NlcnMgPG9iamVjdD4gZWxlbWVudHMgYXJlIG5ldmVyIHRhYmJhYmxlLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGlPUyB0aGUgYnJvd3NlciBvbmx5IGNvbnNpZGVycyBzb21lIHNwZWNpZmljIGVsZW1lbnRzIGFzIHRhYmJhYmxlLlxuICAgICAgICBpZiAodGhpcy5fcGxhdGZvcm0uV0VCS0lUICYmIHRoaXMuX3BsYXRmb3JtLklPUyAmJiAhaXNQb3RlbnRpYWxseVRhYmJhYmxlSU9TKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQudGFiSW5kZXggPj0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGNhbiBiZSBmb2N1c2VkIGJ5IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZm9jdXNhYmxlLlxuICAgICAqL1xuICAgIEludGVyYWN0aXZpdHlDaGVja2VyLnByb3RvdHlwZS5pc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIFBlcmZvcm0gY2hlY2tzIGluIG9yZGVyIG9mIGxlZnQgdG8gbW9zdCBleHBlbnNpdmUuXG4gICAgICAgIC8vIEFnYWluLCBuYWl2ZSBhcHByb2FjaCB0aGF0IGRvZXMgbm90IGNhcHR1cmUgbWFueSBlZGdlIGNhc2VzIGFuZCBicm93c2VyIHF1aXJrcy5cbiAgICAgICAgcmV0dXJuIGlzUG90ZW50aWFsbHlGb2N1c2FibGUoZWxlbWVudCkgJiYgIXRoaXMuaXNEaXNhYmxlZChlbGVtZW50KSAmJiB0aGlzLmlzVmlzaWJsZShlbGVtZW50KTtcbiAgICB9O1xuICAgIEludGVyYWN0aXZpdHlDaGVja2VyID0gX19kZWNvcmF0ZSQxOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbUGxhdGZvcm1dKVxuICAgIF0sIEludGVyYWN0aXZpdHlDaGVja2VyKTtcbiAgICByZXR1cm4gSW50ZXJhY3Rpdml0eUNoZWNrZXI7XG59KCkpO1xuLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBoYXMgYW55IGdlb21ldHJ5IC8gcmVjdGFuZ2xlcy4gKi9cbmZ1bmN0aW9uIGhhc0dlb21ldHJ5KGVsZW1lbnQpIHtcbiAgICAvLyBVc2UgbG9naWMgZnJvbSBqUXVlcnkgdG8gY2hlY2sgZm9yIGFuIGludmlzaWJsZSBlbGVtZW50LlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvY3NzL2hpZGRlblZpc2libGVTZWxlY3RvcnMuanMjTDEyXG4gICAgcmV0dXJuICEhKGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQncyAgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlRm9ybUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgPT09ICdpbnB1dCcgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8XG4gICAgICAgIG5vZGVOYW1lID09PSAnYnV0dG9uJyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJztcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiA8aW5wdXQgdHlwZT1cImhpZGRlblwiPi4gKi9cbmZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0lucHV0RWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50LnR5cGUgPT0gJ2hpZGRlbic7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gYW5jaG9yIHRoYXQgaGFzIGFuIGhyZWYgYXR0cmlidXRlLiAqL1xuZnVuY3Rpb24gaXNBbmNob3JXaXRoSHJlZihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGlzQW5jaG9yRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaHJlZicpO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGlucHV0IGVsZW1lbnQuICovXG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUgPT0gJ2lucHV0Jztcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiBhbmNob3IgZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGlzQW5jaG9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAnYSc7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaGFzIGEgdmFsaWQgdGFiaW5kZXguICovXG5mdW5jdGlvbiBoYXNWYWxpZFRhYkluZGV4KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpIHx8IGVsZW1lbnQudGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIC8vIElFMTEgcGFyc2VzIHRhYmluZGV4PVwiXCIgYXMgdGhlIHZhbHVlIFwiLTMyNzY4XCJcbiAgICBpZiAodGFiSW5kZXggPT0gJy0zMjc2OCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gISEodGFiSW5kZXggJiYgIWlzTmFOKHBhcnNlSW50KHRhYkluZGV4LCAxMCkpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyc2VkIHRhYmluZGV4IGZyb20gdGhlIGVsZW1lbnQgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVcbiAqIGV2YWx1YXRlZCB0YWJpbmRleCBmcm9tIHRoZSBicm93c2VycyBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFiSW5kZXhWYWx1ZShlbGVtZW50KSB7XG4gICAgaWYgKCFoYXNWYWxpZFRhYkluZGV4KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTZWUgYnJvd3NlciBpc3N1ZSBpbiBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG4gICAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcbiAgICByZXR1cm4gaXNOYU4odGFiSW5kZXgpID8gLTEgOiB0YWJJbmRleDtcbn1cbi8qKiBDaGVja3Mgd2hldGhlciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaXMgcG90ZW50aWFsbHkgdGFiYmFibGUgb24gaU9TICovXG5mdW5jdGlvbiBpc1BvdGVudGlhbGx5VGFiYmFibGVJT1MoZWxlbWVudCkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgaW5wdXRUeXBlID0gbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbWVudC50eXBlO1xuICAgIHJldHVybiBpbnB1dFR5cGUgPT09ICd0ZXh0J1xuICAgICAgICB8fCBpbnB1dFR5cGUgPT09ICdwYXNzd29yZCdcbiAgICAgICAgfHwgbm9kZU5hbWUgPT09ICdzZWxlY3QnXG4gICAgICAgIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBwb3RlbnRpYWxseSBmb2N1c2FibGUgd2l0aG91dCB0YWtpbmcgY3VycmVudCB2aXNpYmxlL2Rpc2FibGVkIHN0YXRlXG4gKiBpbnRvIGFjY291bnQuXG4gKi9cbmZ1bmN0aW9uIGlzUG90ZW50aWFsbHlGb2N1c2FibGUoZWxlbWVudCkge1xuICAgIC8vIElucHV0cyBhcmUgcG90ZW50aWFsbHkgZm9jdXNhYmxlICp1bmxlc3MqIHRoZXkncmUgdHlwZT1cImhpZGRlblwiLlxuICAgIGlmIChpc0hpZGRlbklucHV0KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTmF0aXZlRm9ybUVsZW1lbnQoZWxlbWVudCkgfHxcbiAgICAgICAgaXNBbmNob3JXaXRoSHJlZihlbGVtZW50KSB8fFxuICAgICAgICBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgfHxcbiAgICAgICAgaGFzVmFsaWRUYWJJbmRleChlbGVtZW50KTtcbn1cbi8qKiBHZXRzIHRoZSBwYXJlbnQgd2luZG93IG9mIGEgRE9NIG5vZGUgd2l0aCByZWdhcmRzIG9mIGJlaW5nIGluc2lkZSBvZiBhbiBpZnJhbWUuICovXG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xufVxuXG52YXIgX19kZWNvcmF0ZSQxNyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxNyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIHJlZ2lvbi5cbiAqXG4gKiBOT1RFOiBUaGlzIGRpcmVjdGl2ZSBjdXJyZW50bHkgdXNlcyBhIHZlcnkgc2ltcGxlIChuYWl2ZSkgYXBwcm9hY2ggdG8gZm9jdXMgdHJhcHBpbmcuXG4gKiBJdCBhc3N1bWVzIHRoYXQgdGhlIHRhYiBvcmRlciBpcyB0aGUgc2FtZSBhcyBET00gb3JkZXIsIHdoaWNoIGlzIG5vdCBuZWNlc3NhcmlseSB0cnVlLlxuICogVGhpbmdzIGxpa2UgdGFiSW5kZXggPiAwLCBmbGV4IGBvcmRlcmAsIGFuZCBzaGFkb3cgcm9vdHMgY2FuIGNhdXNlIHRvIHR3byB0byBtaXNhbGlnbi5cbiAqIFRoaXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgbW9yZSBpbnRlbGxpZ2VudCBzb2x1dGlvbiBiZWZvcmUgdGhlIGxpYnJhcnkgaXMgY29uc2lkZXJlZCBzdGFibGUuXG4gKi9cbnZhciBGb2N1c1RyYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvY3VzVHJhcChfY2hlY2tlciwgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9jaGVja2VyID0gX2NoZWNrZXI7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb2N1c1RyYXAucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGZvY3VzIHRyYXAgaXMgYWN0aXZlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIG1pY3JvdGFzayBxdWV1ZSB0byBlbXB0eSwgdGhlbiBmb2N1c2VzIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXNcbiAgICAgKiB0cmFwIHJlZ2lvbi5cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnRXaGVuUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgbWljcm90YXNrIHF1ZXVlIHRvIGVtcHR5LCB0aGVuIGZvY3VzZXMgdGhlIGxhc3QgdGFiYmFibGUgZWxlbWVudCB3aXRoaW4gdGhlIGZvY3VzXG4gICAgICogdHJhcCByZWdpb24uXG4gICAgICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5mb2N1c0xhc3RUYWJiYWJsZUVsZW1lbnRXaGVuUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1cyB0cmFwIHJlZ2lvbi5cbiAgICAgKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMudHJhcHBlZENvbnRlbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIHJlZGlyZWN0VG9FbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcignW2Nkay1mb2N1cy1zdGFydF0nKSB8fFxuICAgICAgICAgICAgdGhpcy5fZ2V0Rmlyc3RUYWJiYWJsZUVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICAgICAgICBpZiAocmVkaXJlY3RUb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIGxhc3QgdGFiYmFibGUgZWxlbWVudCB3aXRoaW4gdGhlIGZvY3VzIHRyYXAgcmVnaW9uLlxuICAgICAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLnRyYXBwZWRDb250ZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHZhciBmb2N1c1RhcmdldHMgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbY2RrLWZvY3VzLWVuZF0nKTtcbiAgICAgICAgdmFyIHJlZGlyZWN0VG9FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGZvY3VzVGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50ID0gZm9jdXNUYXJnZXRzW2ZvY3VzVGFyZ2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50ID0gdGhpcy5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudChyb290RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZGlyZWN0VG9FbGVtZW50KSB7XG4gICAgICAgICAgICByZWRpcmVjdFRvRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogR2V0IHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IGZyb20gYSBET00gc3VidHJlZSAoaW5jbHVzaXZlKS4gKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLl9nZXRGaXJzdFRhYmJhYmxlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja2VyLmlzRm9jdXNhYmxlKHJvb3QpICYmIHRoaXMuX2NoZWNrZXIuaXNUYWJiYWJsZShyb290KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0ZSBpbiBET00gb3JkZXIuXG4gICAgICAgIHZhciBjaGlsZENvdW50ID0gcm9vdC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGFiYmFibGVDaGlsZCA9IHRoaXMuX2dldEZpcnN0VGFiYmFibGVFbGVtZW50KHJvb3QuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiYmFibGVDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBHZXQgdGhlIGxhc3QgdGFiYmFibGUgZWxlbWVudCBmcm9tIGEgRE9NIHN1YnRyZWUgKGluY2x1c2l2ZSkuICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudCA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja2VyLmlzRm9jdXNhYmxlKHJvb3QpICYmIHRoaXMuX2NoZWNrZXIuaXNUYWJiYWJsZShyb290KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0ZSBpbiByZXZlcnNlIERPTSBvcmRlci5cbiAgICAgICAgZm9yICh2YXIgaSA9IHJvb3QuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciB0YWJiYWJsZUNoaWxkID0gdGhpcy5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudChyb290LmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhYmJhYmxlQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoJ3RyYXBwZWRDb250ZW50JyksIFxuICAgICAgICBfX21ldGFkYXRhJDE3KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZilcbiAgICBdLCBGb2N1c1RyYXAucHJvdG90eXBlLCBcInRyYXBwZWRDb250ZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBGb2N1c1RyYXAucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIEZvY3VzVHJhcCA9IF9fZGVjb3JhdGUkMTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdjZGstZm9jdXMtdHJhcCwgZm9jdXMtdHJhcCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2ICpuZ0lmPVxcXCIhZGlzYWJsZWRcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiAoZm9jdXMpPVxcXCJmb2N1c0xhc3RUYWJiYWJsZUVsZW1lbnQoKVxcXCI+PC9kaXY+PGRpdiAjdHJhcHBlZENvbnRlbnQgY2xhc3M9XFxcImNkay1mb2N1cy10cmFwLWNvbnRlbnRcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48ZGl2ICpuZ0lmPVxcXCIhZGlzYWJsZWRcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiAoZm9jdXMpPVxcXCJmb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KClcXFwiPjwvZGl2PlwiLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW0ludGVyYWN0aXZpdHlDaGVja2VyLCBfYW5ndWxhcl9jb3JlLk5nWm9uZV0pXG4gICAgXSwgRm9jdXNUcmFwKTtcbiAgICByZXR1cm4gRm9jdXNUcmFwO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMjAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDMgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTiA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdsaXZlQW5ub3VuY2VyRWxlbWVudCcpO1xudmFyIExpdmVBbm5vdW5jZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpdmVBbm5vdW5jZXIoZWxlbWVudFRva2VuKSB7XG4gICAgICAgIC8vIFdlIGluamVjdCB0aGUgbGl2ZSBlbGVtZW50IGFzIGBhbnlgIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBjYW5ub3QgcmVmZXJlbmNlXG4gICAgICAgIC8vIGJyb3dzZXIgZ2xvYmFscyAoSFRNTEVsZW1lbnQpIG9uIG5vbi1icm93c2VyIGVudmlyb25tZW50cywgc2luY2UgaGF2aW5nIGEgY2xhc3MgZGVjb3JhdG9yXG4gICAgICAgIC8vIGNhdXNlcyBUeXBlU2NyaXB0IHRvIHByZXNlcnZlIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgdHlwZXMuXG4gICAgICAgIHRoaXMuX2xpdmVFbGVtZW50ID0gZWxlbWVudFRva2VuIHx8IHRoaXMuX2NyZWF0ZUxpdmVFbGVtZW50KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFubm91bmNlcyBhIG1lc3NhZ2UgdG8gc2NyZWVucmVhZGVycy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIGFubm91bmNlZCB0byB0aGUgc2NyZWVucmVhZGVyXG4gICAgICogQHBhcmFtIHBvbGl0ZW5lc3MgVGhlIHBvbGl0ZW5lc3Mgb2YgdGhlIGFubm91bmNlciBlbGVtZW50XG4gICAgICovXG4gICAgTGl2ZUFubm91bmNlci5wcm90b3R5cGUuYW5ub3VuY2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgcG9saXRlbmVzcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocG9saXRlbmVzcyA9PT0gdm9pZCAwKSB7IHBvbGl0ZW5lc3MgPSAncG9saXRlJzsgfVxuICAgICAgICB0aGlzLl9saXZlRWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAvLyBUT0RPOiBlbnN1cmUgY2hhbmdpbmcgdGhlIHBvbGl0ZW5lc3Mgd29ya3Mgb24gYWxsIGVudmlyb25tZW50cyB3ZSBzdXBwb3J0LlxuICAgICAgICB0aGlzLl9saXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsIHBvbGl0ZW5lc3MpO1xuICAgICAgICAvLyBUaGlzIDEwMG1zIHRpbWVvdXQgaXMgbmVjZXNzYXJ5IGZvciBzb21lIGJyb3dzZXIgKyBzY3JlZW4tcmVhZGVyIGNvbWJpbmF0aW9uczpcbiAgICAgICAgLy8gLSBCb3RoIEpBV1MgYW5kIE5WREEgb3ZlciBJRTExIHdpbGwgbm90IGFubm91bmNlIGFueXRoaW5nIHdpdGhvdXQgYSBub24temVybyB0aW1lb3V0LlxuICAgICAgICAvLyAtIFdpdGggQ2hyb21lIGFuZCBJRTExIHdpdGggTlZEQSBvciBKQVdTLCBhIHJlcGVhdGVkIChpZGVudGljYWwpIG1lc3NhZ2Ugd29uJ3QgYmUgcmVhZCBhXG4gICAgICAgIC8vICAgc2Vjb25kIHRpbWUgd2l0aG91dCBjbGVhcmluZyBhbmQgdGhlbiB1c2luZyBhIG5vbi16ZXJvIGRlbGF5LlxuICAgICAgICAvLyAodXNpbmcgSkFXUyAxNyBhdCB0aW1lIG9mIHRoaXMgd3JpdGluZykuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2xpdmVFbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTsgfSwgMTAwKTtcbiAgICB9O1xuICAgIC8qKiBSZW1vdmVzIHRoZSBhcmlhLWxpdmUgZWxlbWVudCBmcm9tIHRoZSBET00uICovXG4gICAgTGl2ZUFubm91bmNlci5wcm90b3R5cGUuX3JlbW92ZUxpdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGl2ZUVsZW1lbnQgJiYgdGhpcy5fbGl2ZUVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9saXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpdmVBbm5vdW5jZXIucHJvdG90eXBlLl9jcmVhdGVMaXZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpdmVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBsaXZlRWwuY2xhc3NMaXN0LmFkZCgnY2RrLXZpc3VhbGx5LWhpZGRlbicpO1xuICAgICAgICBsaXZlRWwuc2V0QXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XG4gICAgICAgIGxpdmVFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaXZlRWwpO1xuICAgICAgICByZXR1cm4gbGl2ZUVsO1xuICAgIH07XG4gICAgTGl2ZUFubm91bmNlciA9IF9fZGVjb3JhdGUkMjAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSxcbiAgICAgICAgX19wYXJhbSQzKDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kMygwLCBfYW5ndWxhcl9jb3JlLkluamVjdChMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOKSksIFxuICAgICAgICBfX21ldGFkYXRhJDIwKCdkZXNpZ246cGFyYW10eXBlcycsIFtPYmplY3RdKVxuICAgIF0sIExpdmVBbm5vdW5jZXIpO1xuICAgIHJldHVybiBMaXZlQW5ub3VuY2VyO1xufSgpKTtcbmZ1bmN0aW9uIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSX0ZBQ1RPUlkocGFyZW50RGlzcGF0Y2hlciwgbGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm4gcGFyZW50RGlzcGF0Y2hlciB8fCBuZXcgTGl2ZUFubm91bmNlcihsaXZlRWxlbWVudCk7XG59XG5cbnZhciBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgTGl2ZUFubm91bmNlciBhdmFpbGFibGUsIHVzZSB0aGF0LiBPdGhlcndpc2UsIHByb3ZpZGUgYSBuZXcgb25lLlxuICAgIHByb3ZpZGU6IExpdmVBbm5vdW5jZXIsXG4gICAgZGVwczogW1xuICAgICAgICBbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYoKSwgTGl2ZUFubm91bmNlcl0sXG4gICAgICAgIFtuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5JbmplY3QoTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTildXG4gICAgXSxcbiAgICB1c2VGYWN0b3J5OiBMSVZFX0FOTk9VTkNFUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcztcbi8qKiBAcmV0dXJucyBUaGUgaW5wdXQgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZElucHV0VHlwZXMoKSB7XG4gICAgaWYgKCFzdXBwb3J0ZWRJbnB1dFR5cGVzKSB7XG4gICAgICAgIHZhciBmZWF0dXJlVGVzdElucHV0XzEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBzdXBwb3J0ZWRJbnB1dFR5cGVzID0gbmV3IFNldChbXG4gICAgICAgICAgICAvLyBgY29sb3JgIG11c3QgY29tZSBmaXJzdC4gQ2hyb21lIDU2IHNob3dzIGEgd2FybmluZyBpZiB3ZSBjaGFuZ2UgdGhlIHR5cGUgdG8gYGNvbG9yYCBhZnRlclxuICAgICAgICAgICAgLy8gZmlyc3QgY2hhbmdpbmcgaXQgdG8gc29tZXRoaW5nIGVsc2U6XG4gICAgICAgICAgICAvLyBUaGUgc3BlY2lmaWVkIHZhbHVlIFwiXCIgZG9lcyBub3QgY29uZm9ybSB0byB0aGUgcmVxdWlyZWQgZm9ybWF0LlxuICAgICAgICAgICAgLy8gVGhlIGZvcm1hdCBpcyBcIiNycmdnYmJcIiB3aGVyZSByciwgZ2csIGJiIGFyZSB0d28tZGlnaXQgaGV4YWRlY2ltYWwgbnVtYmVycy5cbiAgICAgICAgICAgICdjb2xvcicsXG4gICAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAgICdjaGVja2JveCcsXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnZGF0ZXRpbWUtbG9jYWwnLFxuICAgICAgICAgICAgJ2VtYWlsJyxcbiAgICAgICAgICAgICdmaWxlJyxcbiAgICAgICAgICAgICdoaWRkZW4nLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICdwYXNzd29yZCcsXG4gICAgICAgICAgICAncmFkaW8nLFxuICAgICAgICAgICAgJ3JhbmdlJyxcbiAgICAgICAgICAgICdyZXNldCcsXG4gICAgICAgICAgICAnc2VhcmNoJyxcbiAgICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgICAgJ3RlbCcsXG4gICAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgICAndGltZScsXG4gICAgICAgICAgICAndXJsJyxcbiAgICAgICAgICAgICd3ZWVrJyxcbiAgICAgICAgXS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmZWF0dXJlVGVzdElucHV0XzEuc2V0QXR0cmlidXRlKCd0eXBlJywgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVUZXN0SW5wdXRfMS50eXBlID09PSB2YWx1ZTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkSW5wdXRUeXBlcztcbn1cblxudmFyIF9fZGVjb3JhdGUkMjEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBQbGF0Zm9ybU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhdGZvcm1Nb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIFBsYXRmb3JtTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogUGxhdGZvcm1Nb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUGxhdGZvcm1Nb2R1bGUgPSBfX2RlY29yYXRlJDIxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBwcm92aWRlcnM6IFtQbGF0Zm9ybV1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDIxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIFBsYXRmb3JtTW9kdWxlKTtcbiAgICByZXR1cm4gUGxhdGZvcm1Nb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQxNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxNiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIEExMXlNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEExMXlNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIEExMXlNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBBMTF5TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEExMXlNb2R1bGUgPSBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZSwgUGxhdGZvcm1Nb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbRm9jdXNUcmFwXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtGb2N1c1RyYXBdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbSW50ZXJhY3Rpdml0eUNoZWNrZXIsIExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgQTExeU1vZHVsZSk7XG4gICAgcmV0dXJuIEExMXlNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQyMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBzaG93cyBhIHNpbXBsaWZpZWQgY2hlY2tib3ggd2l0aG91dCBpbmNsdWRpbmcgYW55IGtpbmQgb2YgXCJyZWFsXCIgY2hlY2tib3guXG4gKiBNZWFudCB0byBiZSB1c2VkIHdoZW4gdGhlIGNoZWNrYm94IGlzIHB1cmVseSBkZWNvcmF0aXZlIGFuZCBhIGxhcmdlIG51bWJlciBvZiB0aGVtIHdpbGwgYmVcbiAqIGluY2x1ZGVkLCBzdWNoIGFzIGZvciB0aGUgb3B0aW9ucyBpbiBhIG11bHRpLXNlbGVjdC4gVXNlcyBubyBTVkdzIG9yIGNvbXBsZXggYW5pbWF0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBiZSBjb21wbGV0ZWx5IGludmlzaWJsZSB0byBzY3JlZW4tcmVhZGVyIHVzZXJzLiBUaGlzIGlzICpub3QqXG4gKiBpbnRlcmNoYW5nZWFibGUgd2l0aCA8bWQtY2hlY2tib3g+IGFuZCBzaG91bGQgKm5vdCogYmUgdXNlZCBpZiB0aGUgdXNlciB3b3VsZCBkaXJlY3RseSBpbnRlcmFjdFxuICogd2l0aCB0aGUgY2hlY2tib3guIFRoZSBwc2V1ZG8tY2hlY2tib3ggc2hvdWxkIG9ubHkgYmUgdXNlZCBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2ZcbiAqIG1vcmUgY29tcGxleCBjb21wb25lbnRzIHRoYXQgYXBwcm9wcmlhdGVseSBoYW5kbGUgc2VsZWN0ZWQgLyBjaGVja2VkIHN0YXRlLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRQc2V1ZG9DaGVja2JveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQc2V1ZG9DaGVja2JveChfZWxlbWVudFJlZiwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKiBEaXNwbGF5IHN0YXRlIG9mIHRoZSBjaGVja2JveC4gKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9ICd1bmNoZWNrZWQnO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgZGlzYWJsZWQuICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xvciA9ICdhY2NlbnQnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQc2V1ZG9DaGVja2JveC5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKiogQ29sb3Igb2YgdGhlIGNoZWNrYm94LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKG5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgdGhpcy5jb2xvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhuYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRQc2V1ZG9DaGVja2JveC5wcm90b3R5cGUsIFwic3RhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kUHNldWRvQ2hlY2tib3gucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQyMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUHNldWRvQ2hlY2tib3gucHJvdG90eXBlLCBcImNvbG9yXCIsIG51bGwpO1xuICAgIE1kUHNldWRvQ2hlY2tib3ggPSBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe2VuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcHNldWRvLWNoZWNrYm94LCBtYXQtcHNldWRvLWNoZWNrYm94JyxcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1wc2V1ZG8tY2hlY2tib3h7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtib3JkZXI6MnB4IHNvbGlkO2JvcmRlci1yYWRpdXM6MnB4O2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjpib3JkZXItY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKSxiYWNrZ3JvdW5kLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsMCwuMiwuMSl9Lm1hdC1wc2V1ZG8tY2hlY2tib3g6OmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO29wYWNpdHk6MDtjb250ZW50OicnO2JvcmRlci1ib3R0b206MnB4IHNvbGlkIGN1cnJlbnRDb2xvcjt0cmFuc2l0aW9uOm9wYWNpdHkgOTBtcyBjdWJpYy1iZXppZXIoMCwwLC4yLC4xKX0ubWF0LXBzZXVkby1jaGVja2JveC1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdH0ubWF0LXBzZXVkby1jaGVja2JveC1pbmRldGVybWluYXRlOjphZnRlcnt0b3A6OXB4O2xlZnQ6MnB4O3dpZHRoOjE2cHg7b3BhY2l0eToxfS5tYXQtcHNldWRvLWNoZWNrYm94LWNoZWNrZWQ6OmFmdGVye3RvcDo1cHg7bGVmdDozcHg7d2lkdGg6MTJweDtoZWlnaHQ6NXB4O2JvcmRlci1sZWZ0OjJweCBzb2xpZCBjdXJyZW50Q29sb3I7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO29wYWNpdHk6MX1cIl0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJycsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZV0nOiAnc3RhdGUgPT09IFwiaW5kZXRlcm1pbmF0ZVwiJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZF0nOiAnc3RhdGUgPT09IFwiY2hlY2tlZFwiJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFBzZXVkb0NoZWNrYm94KTtcbiAgICByZXR1cm4gTWRQc2V1ZG9DaGVja2JveDtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDIyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDIyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRTZWxlY3Rpb25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2VsZWN0aW9uTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZFNlbGVjdGlvbk1vZHVsZSA9IF9fZGVjb3JhdGUkMjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFBzZXVkb0NoZWNrYm94XSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUHNldWRvQ2hlY2tib3hdXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFNlbGVjdGlvbk1vZHVsZSk7XG4gICAgcmV0dXJuIE1kU2VsZWN0aW9uTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMjQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8vIFwiUG9seWZpbGxcIiBmb3IgYE5vZGUucmVwbGFjZVdpdGgoKWAuXG4vLyBjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NoaWxkTm9kZS9yZXBsYWNlV2l0aFxuZnVuY3Rpb24gX3JlcGxhY2VXaXRoKHRvUmVwbGFjZUVsLCBvdGhlckVsKSB7XG4gICAgdG9SZXBsYWNlRWwucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQob3RoZXJFbCwgdG9SZXBsYWNlRWwpO1xufVxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbnZhciBEb21Qcm9qZWN0aW9uSG9zdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9tUHJvamVjdGlvbkhvc3QocmVmKSB7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cbiAgICBEb21Qcm9qZWN0aW9uSG9zdCA9IF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay1kb20tcHJvamVjdGlvbi1ob3N0J1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgRG9tUHJvamVjdGlvbkhvc3QpO1xuICAgIHJldHVybiBEb21Qcm9qZWN0aW9uSG9zdDtcbn0oKSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIERvbVByb2plY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvbVByb2plY3Rpb24oKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3QgYW4gZWxlbWVudCBpbnRvIGEgaG9zdCBlbGVtZW50LlxuICAgICAqIFJlcGxhY2UgYSBob3N0IGVsZW1lbnQgYnkgYW5vdGhlciBlbGVtZW50LiBUaGlzIGFsc28gcmVwbGFjZXMgdGhlIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50XG4gICAgICogYnkgdGhlIGNoaWxkcmVuIG9mIHRoZSBob3N0LlxuICAgICAqXG4gICAgICogSXQgc2hvdWxkIGJlIHVzZWQgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICBAQ29tcG9uZW50KHtcbiAgICAgKiAgICAgdGVtcGxhdGU6IGA8ZGl2PlxuICAgICAqICAgICAgIDxjZGstZG9tLXByb2plY3Rpb24taG9zdD5cbiAgICAgKiAgICAgICAgIDxkaXY+b3RoZXI8L2Rpdj5cbiAgICAgKiAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgKiAgICAgICA8L2Nkay1kb20tcHJvamVjdGlvbi1ob3N0PlxuICAgICAqICAgICA8L2Rpdj5gXG4gICAgICogICB9KVxuICAgICAqICAgY2xhc3MgQ21wdCB7XG4gICAgICogICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3Byb2plY3RvcjogRG9tUHJvamVjdGlvbiwgcHJpdmF0ZSBfZWw6IEVsZW1lbnRSZWYpIHt9XG4gICAgICogICAgIG5nT25Jbml0KCkgeyB0aGlzLl9wcm9qZWN0b3IucHJvamVjdCh0aGlzLl9lbCwgdGhpcy5fcHJvamVjdG9yKTsgfVxuICAgICAqICAgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBjb21wb25lbnQgd2lsbCBtb3ZlIHRoZSBjb250ZW50IG9mIHRoZSBlbGVtZW50IGl0J3MgYXBwbGllZCB0byBpbiB0aGUgb3V0ZXIgZGl2LiBCZWNhdXNlXG4gICAgICogYHByb2plY3QoKWAgYWxzbyBtb3ZlIHRoZSBjaGlsZHJlbiBvZiB0aGUgaG9zdCBpbnNpZGUgdGhlIHByb2plY3RlZCBlbGVtZW50LCB0aGUgZWxlbWVudCB3aWxsXG4gICAgICogY29udGFpbiB0aGUgYDxkaXY+b3RoZXI8L2Rpdj5gIEhUTUwgYXMgd2VsbCBhcyBpdHMgb3duIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogTm90ZTogd2l0aG91dCBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmAgdGhlIHByb2plY3Rpb24gd2lsbCBwcm9qZWN0IGFuIGVtcHR5IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVmIEVsZW1lbnRSZWYgdG8gYmUgcHJvamVjdGVkLlxuICAgICAqIEBwYXJhbSBob3N0IFByb2plY3Rpb24gaG9zdCBpbnRvIHdoaWNoIHRvIHByb2plY3QgdGhlIGBFbGVtZW50UmVmYC5cbiAgICAgKi9cbiAgICBEb21Qcm9qZWN0aW9uLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gKHJlZiwgaG9zdCkge1xuICAgICAgICB2YXIgcHJvamVjdGVkRWwgPSByZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIGhvc3RFbCA9IGhvc3QucmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gcHJvamVjdGVkRWwuY2hpbGROb2RlcztcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1swXTtcbiAgICAgICAgLy8gV2UgaG9pc3QgYWxsIG9mIHRoZSBwcm9qZWN0ZWQgZWxlbWVudCdzIGNoaWxkcmVuIG91dCBpbnRvIHRoZSBwcm9qZWN0ZWQgZWxlbWVudHMgcG9zaXRpb25cbiAgICAgICAgLy8gYmVjYXVzZSB3ZSAqb25seSogd2FudCB0byBtb3ZlIHRoZSBwcm9qZWN0ZWQgZWxlbWVudCBhbmQgbm90IGl0cyBjaGlsZHJlbi5cbiAgICAgICAgX3JlcGxhY2VXaXRoKHByb2plY3RlZEVsLCBjaGlsZCk7XG4gICAgICAgIHZhciBsID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZXNbMF0sIGNoaWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7IC8vIG5leHRTaWJsaW5nIGlzIG5vdyB0aGUgY2hpbGROb2Rlc1swXS5cbiAgICAgICAgfVxuICAgICAgICAvLyBJbnNlcnQgYWxsIGhvc3QgY2hpbGRyZW4gdW5kZXIgdGhlIHByb2plY3RlZEVsLCB0aGVuIHJlcGxhY2UgaG9zdCBieSBjb21wb25lbnQuXG4gICAgICAgIGwgPSBob3N0RWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIHByb2plY3RlZEVsLmFwcGVuZENoaWxkKGhvc3RFbC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVwbGFjZVdpdGgoaG9zdEVsLCBwcm9qZWN0ZWRFbCk7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIGhvc3QgaXMgcmVwbGFjZWQgYnkgdGhlIGNvbXBvbmVudC4gTm90aGluZyBlbHNlIHRvIGJlIGRvbmUuXG4gICAgfTtcbiAgICBEb21Qcm9qZWN0aW9uID0gX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBEb21Qcm9qZWN0aW9uKTtcbiAgICByZXR1cm4gRG9tUHJvamVjdGlvbjtcbn0oKSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIFByb2plY3Rpb25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb2plY3Rpb25Nb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIFByb2plY3Rpb25Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBQcm9qZWN0aW9uTW9kdWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUHJvamVjdGlvbk1vZHVsZSA9IF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGV4cG9ydHM6IFtEb21Qcm9qZWN0aW9uSG9zdF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtEb21Qcm9qZWN0aW9uSG9zdF0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtEb21Qcm9qZWN0aW9uXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDI0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIFByb2plY3Rpb25Nb2R1bGUpO1xuICAgIHJldHVybiBQcm9qZWN0aW9uTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDI1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDI1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFRoZSBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lciBpcyB0aGUgYWx0ZXJuYXRpdmUgdG8gT3ZlcmxheUNvbnRhaW5lclxuICogdGhhdCBzdXBwb3J0cyBjb3JyZWN0IGRpc3BsYXlpbmcgb2Ygb3ZlcmxheSBlbGVtZW50cyBpbiBGdWxsc2NyZWVuIG1vZGVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3JlcXVlc3RGdWxsU2NyZWVuXG4gKiBJdCBzaG91bGQgYmUgcHJvdmlkZWQgaW4gdGhlIHJvb3QgY29tcG9uZW50IHRoYXQgd2F5OlxuICogcHJvdmlkZXJzOiBbXG4gKiAgIHtwcm92aWRlOiBPdmVybGF5Q29udGFpbmVyLCB1c2VDbGFzczogRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXJ9XG4gKiBdLFxuICovXG52YXIgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ1KEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRhaW5lci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRGb3JGdWxsc2NyZWVuQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX2FkZEZ1bGxzY3JlZW5DaGFuZ2VMaXN0ZW5lcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYWRqdXN0UGFyZW50Rm9yRnVsbHNjcmVlbkNoYW5nZSgpOyB9KTtcbiAgICB9O1xuICAgIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5fYWRqdXN0UGFyZW50Rm9yRnVsbHNjcmVlbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bGxzY3JlZW5FbGVtZW50ID0gdGhpcy5nZXRGdWxsc2NyZWVuRWxlbWVudCgpO1xuICAgICAgICB2YXIgcGFyZW50ID0gZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lckVsZW1lbnQpO1xuICAgIH07XG4gICAgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLl9hZGRGdWxsc2NyZWVuQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbmFibGVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbmFibGVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ01TRnVsbHNjcmVlbkNoYW5nZScsIGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcGFnZSBpcyBwdXQgaW50byBmdWxsc2NyZWVuIG1vZGUsIGEgc3BlY2lmaWMgZWxlbWVudCBpcyBzcGVjaWZpZWQuXG4gICAgICogT25seSB0aGF0IGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbiBhcmUgdmlzaWJsZSB3aGVuIGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAqL1xuICAgIEZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5nZXRGdWxsc2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lciA9IF9fZGVjb3JhdGUkMjUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXIpO1xuICAgIHJldHVybiBGdWxsc2NyZWVuT3ZlcmxheUNvbnRhaW5lcjtcbn0oT3ZlcmxheUNvbnRhaW5lcikpO1xuXG52YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkMjYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qIEFkanVzdHMgY29uZmlndXJhdGlvbiBvZiBvdXIgZ2VzdHVyZSBsaWJyYXJ5LCBIYW1tZXIuICovXG52YXIgR2VzdHVyZUNvbmZpZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDYoR2VzdHVyZUNvbmZpZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHZXN0dXJlQ29uZmlnKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5faGFtbWVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuSGFtbWVyIDogbnVsbDtcbiAgICAgICAgLyogTGlzdCBvZiBuZXcgZXZlbnQgbmFtZXMgdG8gYWRkIHRvIHRoZSBnZXN0dXJlIHN1cHBvcnQgbGlzdCAqL1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuX2hhbW1lciA/IFtcbiAgICAgICAgICAgICdsb25ncHJlc3MnLFxuICAgICAgICAgICAgJ3NsaWRlJyxcbiAgICAgICAgICAgICdzbGlkZXN0YXJ0JyxcbiAgICAgICAgICAgICdzbGlkZWVuZCcsXG4gICAgICAgICAgICAnc2xpZGVyaWdodCcsXG4gICAgICAgICAgICAnc2xpZGVsZWZ0J1xuICAgICAgICBdIDogW107XG4gICAgICAgIGlmICghdGhpcy5faGFtbWVyICYmIF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgSGFtbWVySlMuIENlcnRhaW4gQW5ndWxhciBNYXRlcmlhbCAnICtcbiAgICAgICAgICAgICAgICAnY29tcG9uZW50cyBtYXkgbm90IHdvcmsgY29ycmVjdGx5LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBIYW1tZXIgaW5zdGFuY2UgbWFudWFsbHkgdG8gYWRkIGN1c3RvbSByZWNvZ25pemVycyB0aGF0IG1hdGNoIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbiAgICAgKlxuICAgICAqIE91ciBnZXN0dXJlIG5hbWVzIGNvbWUgZnJvbSB0aGUgTWF0ZXJpYWwgRGVzaWduIGdlc3R1cmVzIHNwZWM6XG4gICAgICogaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9wYXR0ZXJucy9nZXN0dXJlcy5odG1sI2dlc3R1cmVzLXRvdWNoLW1lY2hhbmljc1xuICAgICAqXG4gICAgICogTW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZhdWx0IHJlY29nbml6ZXJzIGNhbiBiZSBmb3VuZCBpbiBIYW1tZXIgZG9jczpcbiAgICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItcGFuL1xuICAgICAqIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVjb2duaXplci1wcmVzcy9cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gd2hpY2ggdG8gYXNzaWduIHRoZSBuZXcgSGFtbWVySlMgZ2VzdHVyZXMuXG4gICAgICogQHJldHVybnMgTmV3bHktY3JlYXRlZCBIYW1tZXJKUyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5idWlsZEhhbW1lciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBtYyA9IG5ldyB0aGlzLl9oYW1tZXIoZWxlbWVudCk7XG4gICAgICAgIC8vIERlZmF1bHQgSGFtbWVyIFJlY29nbml6ZXJzLlxuICAgICAgICB2YXIgcGFuID0gbmV3IHRoaXMuX2hhbW1lci5QYW4oKTtcbiAgICAgICAgdmFyIHN3aXBlID0gbmV3IHRoaXMuX2hhbW1lci5Td2lwZSgpO1xuICAgICAgICB2YXIgcHJlc3MgPSBuZXcgdGhpcy5faGFtbWVyLlByZXNzKCk7XG4gICAgICAgIC8vIE5vdGljZSB0aGF0IGEgSGFtbWVySlMgcmVjb2duaXplciBjYW4gb25seSBkZXBlbmQgb24gb25lIG90aGVyIHJlY29nbml6ZXIgb25jZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBwcmV2aW91cyBgcmVjb2duaXplV2l0aGAgd2lsbCBiZSBkcm9wcGVkLlxuICAgICAgICAvLyBUT0RPOiBDb25maXJtIHRocmVzaG9sZCBudW1iZXJzIHdpdGggTWF0ZXJpYWwgRGVzaWduIFVYIFRlYW1cbiAgICAgICAgdmFyIHNsaWRlID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwYW4sIHsgZXZlbnQ6ICdzbGlkZScsIHRocmVzaG9sZDogMCB9LCBzd2lwZSk7XG4gICAgICAgIHZhciBsb25ncHJlc3MgPSB0aGlzLl9jcmVhdGVSZWNvZ25pemVyKHByZXNzLCB7IGV2ZW50OiAnbG9uZ3ByZXNzJywgdGltZTogNTAwIH0pO1xuICAgICAgICAvLyBPdmVyd3JpdGUgdGhlIGRlZmF1bHQgYHBhbmAgZXZlbnQgdG8gdXNlIHRoZSBzd2lwZSBldmVudC5cbiAgICAgICAgcGFuLnJlY29nbml6ZVdpdGgoc3dpcGUpO1xuICAgICAgICAvLyBBZGQgY3VzdG9taXplZCBnZXN0dXJlcyB0byBIYW1tZXIgbWFuYWdlclxuICAgICAgICBtYy5hZGQoW3N3aXBlLCBwcmVzcywgcGFuLCBzbGlkZSwgbG9uZ3ByZXNzXSk7XG4gICAgICAgIHJldHVybiBtYztcbiAgICB9O1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHJlY29nbml6ZXIsIHdpdGhvdXQgYWZmZWN0aW5nIHRoZSBkZWZhdWx0IHJlY29nbml6ZXJzIG9mIEhhbW1lckpTICovXG4gICAgR2VzdHVyZUNvbmZpZy5wcm90b3R5cGUuX2NyZWF0ZVJlY29nbml6ZXIgPSBmdW5jdGlvbiAoYmFzZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaW5oZXJpdGFuY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpbmhlcml0YW5jZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSBuZXcgYmFzZS5jb25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICAgICAgaW5oZXJpdGFuY2VzLnB1c2goYmFzZSk7XG4gICAgICAgIGluaGVyaXRhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbSk7IH0pO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9O1xuICAgIEdlc3R1cmVDb25maWcgPSBfX2RlY29yYXRlJDI2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDI2KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIEdlc3R1cmVDb25maWcpO1xuICAgIHJldHVybiBHZXN0dXJlQ29uZmlnO1xufShfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuSGFtbWVyR2VzdHVyZUNvbmZpZykpO1xuXG4vKipcbiAqIENsYXNzIHRvIGJlIHVzZWQgdG8gcG93ZXIgc2VsZWN0aW5nIG9uZSBvciBtb3JlIG9wdGlvbnMgZnJvbSBhIGxpc3QuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBTZWxlY3Rpb25Nb2RlbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uTW9kZWwoX2lzTXVsdGksIGluaXRpYWxseVNlbGVjdGVkVmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChfaXNNdWx0aSA9PT0gdm9pZCAwKSB7IF9pc011bHRpID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5faXNNdWx0aSA9IF9pc011bHRpO1xuICAgICAgICAvKiogQ3VycmVudGx5LXNlbGVjdGVkIHZhbHVlcy4gKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gbmV3IFNldCgpO1xuICAgICAgICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2VsZWN0ZWQgb3B0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkIGJ5IHRoZSBjaGFuZ2UgZXZlbnQuICovXG4gICAgICAgIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24gdGhhdCBoYXZlbid0IGJlZW4gZW1pdHRlZCBieSB0aGUgY2hhbmdlIGV2ZW50LiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZFRvRW1pdCA9IFtdO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC4gKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICBpZiAoaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChfaXNNdWx0aSkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxseVNlbGVjdGVkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5fbWFya1NlbGVjdGVkKHZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrU2VsZWN0ZWQoaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGFycmF5IGluIG9yZGVyIHRvIGF2b2lkIGZpcmluZyB0aGUgY2hhbmdlIGV2ZW50IGZvciBwcmVzZWxlY3RlZCB2YWx1ZXMuXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFRvRW1pdC5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKiogU2VsZWN0ZWQgdmFsdWUocykuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gQXJyYXkuZnJvbSh0aGlzLl9zZWxlY3Rpb24udmFsdWVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgdmFsdWUgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWFya1NlbGVjdGVkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmRlc2VsZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VubWFya1NlbGVjdGVkKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIG9mIHRoZSBzZWxlY3RlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bm1hcmtBbGwoKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmhhcyh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1vZGVsIGhhcyBhIHZhbHVlLlxuICAgICAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLnNpemUgPT09IDA7XG4gICAgfTtcbiAgICAvKiogRW1pdHMgYSBjaGFuZ2UgZXZlbnQgYW5kIGNsZWFycyB0aGUgcmVjb3JkcyBvZiBzZWxlY3RlZCBhbmQgZGVzZWxlY3RlZCB2YWx1ZXMuICovXG4gICAgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFRvRW1pdC5sZW5ndGggfHwgdGhpcy5fZGVzZWxlY3RlZFRvRW1pdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSBuZXcgU2VsZWN0aW9uQ2hhbmdlKHRoaXMuX3NlbGVjdGVkVG9FbWl0LCB0aGlzLl9kZXNlbGVjdGVkVG9FbWl0KTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UubmV4dChldmVudERhdGEpO1xuICAgICAgICAgICAgdGhpcy5fZGVzZWxlY3RlZFRvRW1pdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFNlbGVjdHMgYSB2YWx1ZS4gKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuX21hcmtTZWxlY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNNdWx0aSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFya0FsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFRvRW1pdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIERlc2VsZWN0cyBhIHZhbHVlLiAqL1xuICAgIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5fdW5tYXJrU2VsZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbi5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fZGVzZWxlY3RlZFRvRW1pdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENsZWFycyBvdXQgdGhlIHNlbGVjdGVkIHZhbHVlcy4gKi9cbiAgICBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuX3VubWFya0FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5fdW5tYXJrU2VsZWN0ZWQodmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdGlvbk1vZGVsO1xufSgpKTtcbi8qKlxuICogRGVzY3JpYmVzIGFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgb2YgYSBNZFNlbGVjdGlvbk1vZGVsIGhhcyBjaGFuZ2VkLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgU2VsZWN0aW9uQ2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25DaGFuZ2UoYWRkZWQsIHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5hZGRlZCA9IGFkZGVkO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0aW9uQ2hhbmdlO1xufSgpKTtcblxuLyoqXG4gKiBTY3JlZW5yZWFkZXJzIHdpbGwgb2Z0ZW4gZmlyZSBmYWtlIG1vdXNlZG93biBldmVudHMgd2hlbiBhIGZvY3VzYWJsZSBlbGVtZW50XG4gKiBpcyBhY3RpdmF0ZWQgdXNpbmcgdGhlIGtleWJvYXJkLiBXZSBjYW4gdHlwaWNhbGx5IGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlc2UgZmFrZWRcbiAqIG1vdXNlZG93biBldmVudHMgYW5kIHJlYWwgbW91c2Vkb3duIGV2ZW50cyB1c2luZyB0aGUgXCJidXR0b25zXCIgcHJvcGVydHkuIFdoaWxlXG4gKiByZWFsIG1vdXNlZG93bnMgd2lsbCBpbmRpY2F0ZSB0aGUgbW91c2UgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgKGUuZy4gXCIxXCIgZm9yXG4gKiB0aGUgbGVmdCBtb3VzZSBidXR0b24pLCBmYWtlZCBtb3VzZWRvd25zIHdpbGwgdXN1YWxseSBzZXQgdGhlIHByb3BlcnR5IHZhbHVlIHRvIDAuXG4gKi9cbmZ1bmN0aW9uIGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuYnV0dG9ucyA9PT0gMDtcbn1cblxudmFyIF9fZGVjb3JhdGUkMjcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQ2xhc3MgdG8gY29vcmRpbmF0ZSB1bmlxdWUgc2VsZWN0aW9uIGJhc2VkIG9uIG5hbWUuXG4gKiBJbnRlbmRlZCB0byBiZSBjb25zdW1lZCBhcyBhbiBBbmd1bGFyIHNlcnZpY2UuXG4gKiBUaGlzIHNlcnZpY2UgaXMgbmVlZGVkIGJlY2F1c2UgbmF0aXZlIHJhZGlvIGNoYW5nZSBldmVudHMgYXJlIG9ubHkgZmlyZWQgb24gdGhlIGl0ZW0gY3VycmVudGx5XG4gKiBiZWluZyBzZWxlY3RlZCwgYW5kIHdlIHN0aWxsIG5lZWQgdG8gdW5jaGVjayB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICpcbiAqIFRoaXMgc2VydmljZSBkb2VzIG5vdCAqc3RvcmUqIGFueSBJRHMgYW5kIG5hbWVzIGJlY2F1c2UgdGhleSBtYXkgY2hhbmdlIGF0IGFueSB0aW1lLCBzbyBpdCBpc1xuICogbGVzcyBlcnJvci1wcm9uZSBpZiB0aGV5IGFyZSBzaW1wbHkgcGFzc2VkIHRocm91Z2ggd2hlbiB0aGUgZXZlbnRzIG9jY3VyLlxuICovXG52YXIgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcigpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBvdGhlciBpdGVtcyB0aGF0IHNlbGVjdGlvbiBmb3IgdGhlIGdpdmVuIG5hbWUgaGFzIGJlZW4gc2V0LlxuICAgICAqIEBwYXJhbSBpZCBJRCBvZiB0aGUgaXRlbS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBpdGVtLlxuICAgICAqL1xuICAgIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fbGlzdGVuZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgbGlzdGVuZXIoaWQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogTGlzdGVuIGZvciBmdXR1cmUgY2hhbmdlcyB0byBpdGVtIHNlbGVjdGlvbi4gKi9cbiAgICBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG4gICAgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciA9IF9fZGVjb3JhdGUkMjcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcik7XG4gICAgcmV0dXJuIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXI7XG59KCkpO1xuZnVuY3Rpb24gVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSX0ZBQ1RPUlkocGFyZW50RGlzcGF0Y2hlcikge1xuICAgIHJldHVybiBwYXJlbnREaXNwYXRjaGVyIHx8IG5ldyBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyKCk7XG59XG52YXIgVU5JUVVFX1NFTEVDVElPTl9ESVNQQVRDSEVSX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBkaXNwYXRjaGVyIGF2YWlsYWJsZSwgdXNlIHRoYXQuIE90aGVyd2lzZSwgcHJvdmlkZSBhIG5ldyBvbmUuXG4gICAgcHJvdmlkZTogVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcixcbiAgICBkZXBzOiBbW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLlNraXBTZWxmKCksIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXJdXSxcbiAgICB1c2VGYWN0b3J5OiBVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVJfRkFDVE9SWVxufTtcblxudmFyIF9fZGVjb3JhdGUkMjkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8vIFRoaXMgaXMgdGhlIHZhbHVlIHVzZWQgYnkgQW5ndWxhckpTIE1hdGVyaWFsLiBUaHJvdWdoIHRyaWFsIGFuZCBlcnJvciAob24gaVBob25lIDZTKSB0aGV5IGZvdW5kXG4vLyB0aGF0IGEgdmFsdWUgb2YgYXJvdW5kIDY1MG1zIHNlZW1zIGFwcHJvcHJpYXRlLlxudmFyIFRPVUNIX0JVRkZFUl9NUyA9IDY1MDtcbi8qKiBNb25pdG9ycyBtb3VzZSBhbmQga2V5Ym9hcmQgZXZlbnRzIHRvIGRldGVybWluZSB0aGUgY2F1c2Ugb2YgZm9jdXMgZXZlbnRzLiAqL1xudmFyIEZvY3VzT3JpZ2luTW9uaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRm9jdXNPcmlnaW5Nb25pdG9yKCkge1xuICAgICAgICAvLyBOb3RlOiB3ZSBsaXN0ZW4gdG8gZXZlbnRzIGluIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHdlIGNhbiBkZXRlY3QgdGhlbSBldmVuIGlmIHRoZSB1c2VyIHN0b3BzXG4gICAgICAgIC8vIHByb3BhZ2F0aW9uLlxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogVGhlIGZvY3VzIG9yaWdpbiB0aGF0IHRoZSBuZXh0IGZvY3VzIGV2ZW50IGlzIGEgcmVzdWx0IG9mLiAqL1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSBudWxsO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgd2luZG93IGhhcyBqdXN0IGJlZW4gZm9jdXNlZC4gKi9cbiAgICAgICAgdGhpcy5fd2luZG93Rm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBPbiBrZXlkb3duIHJlY29yZCB0aGUgb3JpZ2luIGFuZCBjbGVhciBhbnkgdG91Y2ggZXZlbnQgdGhhdCBtYXkgYmUgaW4gcHJvZ3Jlc3MuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbGFzdFRvdWNoVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9zZXRPcmlnaW5Gb3JDdXJyZW50RXZlbnRRdWV1ZSgna2V5Ym9hcmQnKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIC8vIE9uIG1vdXNlZG93biByZWNvcmQgdGhlIG9yaWdpbiBvbmx5IGlmIHRoZXJlIGlzIG5vdCB0b3VjaCB0YXJnZXQsIHNpbmNlIGEgbW91c2Vkb3duIGNhblxuICAgICAgICAvLyBoYXBwZW4gYXMgYSByZXN1bHQgb2YgYSB0b3VjaCBldmVudC5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fbGFzdFRvdWNoVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldE9yaWdpbkZvckN1cnJlbnRFdmVudFF1ZXVlKCdtb3VzZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgdG91Y2hzdGFydCBldmVudCBmaXJlcyB0aGUgZm9jdXMgZXZlbnQgaXMgbm90IHlldCBpbiB0aGUgZXZlbnQgcXVldWUuIFRoaXMgbWVhbnMgd2VcbiAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiB0aGUgdHJpY2sgdXNlZCBhYm92ZSAoc2V0dGluZyB0aW1lb3V0IG9mIDBtcykuIEluc3RlYWQgd2Ugd2FpdCA2NTBtcyB0byBzZWUgaWZcbiAgICAgICAgLy8gYSBmb2N1cyBoYXBwZW5zLlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3RvdWNoVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl90b3VjaFRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2xhc3RUb3VjaFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIF90aGlzLl90b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9sYXN0VG91Y2hUYXJnZXQgPSBudWxsOyB9LCBUT1VDSF9CVUZGRVJfTVMpO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgLy8gTWFrZSBhIG5vdGUgb2Ygd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXMsIHNvIHdlIGNhbiByZXN0b3JlIHRoZSBvcmlnaW4gaW5mbyBmb3IgdGhlXG4gICAgICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3dpbmRvd0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fd2luZG93Rm9jdXNlZCA9IGZhbHNlOyB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhbiBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXMgY2xhc3Nlcy4gKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLnJlZ2lzdGVyRWxlbWVudEZvckZvY3VzQ2xhc3NlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCByZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICByZW5kZXJlci5saXN0ZW4oZWxlbWVudCwgJ2ZvY3VzJywgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5fb25Gb2N1cyhldmVudCwgZWxlbWVudCwgcmVuZGVyZXIsIHN1YmplY3QpOyB9KTtcbiAgICAgICAgcmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsICdibHVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uQmx1cihlbGVtZW50LCByZW5kZXJlciwgc3ViamVjdCk7IH0pO1xuICAgICAgICByZXR1cm4gc3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBlbGVtZW50IHZpYSB0aGUgc3BlY2lmaWVkIGZvY3VzIG9yaWdpbi4gKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLmZvY3VzVmlhID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJlbmRlcmVyLCBvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fc2V0T3JpZ2luRm9yQ3VycmVudEV2ZW50UXVldWUob3JpZ2luKTtcbiAgICAgICAgcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZChlbGVtZW50LCAnZm9jdXMnKTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSBvcmlnaW4gYW5kIHNjaGVkdWxlcyBhbiBhc3luYyBmdW5jdGlvbiB0byBjbGVhciBpdCBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBxdWV1ZS4gKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLl9zZXRPcmlnaW5Gb3JDdXJyZW50RXZlbnRRdWV1ZSA9IGZ1bmN0aW9uIChvcmlnaW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vcmlnaW4gPSBudWxsOyB9LCAwKTtcbiAgICB9O1xuICAgIC8qKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gZm9jdXMgZXZlbnQgd2FzIGNhdXNlZCBieSBhIHRvdWNoc3RhcnQgZXZlbnQuICovXG4gICAgRm9jdXNPcmlnaW5Nb25pdG9yLnByb3RvdHlwZS5fd2FzQ2F1c2VkQnlUb3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBOb3RlKG1tYWxlcmJhKTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgcXVpdGUgcGVyZmVjdCwgdGhlcmUgaXMgYSBzbWFsbCBlZGdlIGNhc2UuXG4gICAgICAgIC8vIENvbnNpZGVyIHRoZSBmb2xsb3dpbmcgZG9tIHN0cnVjdHVyZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPGRpdiAjcGFyZW50IHRhYmluZGV4PVwiMFwiIGNka0ZvY3VzQ2xhc3Nlcz5cbiAgICAgICAgLy8gICA8ZGl2ICNjaGlsZCAoY2xpY2spPVwiI3BhcmVudC5mb2N1cygpXCI+PC9kaXY+XG4gICAgICAgIC8vIDwvZGl2PlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgdXNlciB0b3VjaGVzIHRoZSAjY2hpbGQgZWxlbWVudCBhbmQgdGhlICNwYXJlbnQgaXMgcHJvZ3JhbW1hdGljYWxseSBmb2N1c2VkIGFzIGFcbiAgICAgICAgLy8gcmVzdWx0LCB0aGlzIGNvZGUgd2lsbCBzdGlsbCBjb25zaWRlciBpdCB0byBoYXZlIGJlZW4gY2F1c2VkIGJ5IHRoZSB0b3VjaCBldmVudCBhbmQgd2lsbFxuICAgICAgICAvLyBhcHBseSB0aGUgY2RrLXRvdWNoLWZvY3VzZWQgY2xhc3MgcmF0aGVyIHRoYW4gdGhlIGNkay1wcm9ncmFtLWZvY3VzZWQgY2xhc3MuIFRoaXMgaXMgYVxuICAgICAgICAvLyByZWxhdGl2ZWx5IHNtYWxsIGVkZ2UtY2FzZSB0aGF0IGNhbiBiZSB3b3JrZWQgYXJvdW5kIGJ5IHVzaW5nXG4gICAgICAgIC8vIGZvY3VzVmlhKHBhcmVudEVsLCByZW5kZXJlciwgICdwcm9ncmFtJykgdG8gZm9jdXMgdGhlIHBhcmVudCBlbGVtZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB3ZSBkZWNpZGUgdGhhdCB3ZSBhYnNvbHV0ZWx5IG11c3QgaGFuZGxlIHRoaXMgY2FzZSBjb3JyZWN0bHksIHdlIGNhbiBkbyBzbyBieSBsaXN0ZW5pbmdcbiAgICAgICAgLy8gZm9yIHRoZSBmaXJzdCBmb2N1cyBldmVudCBhZnRlciB0aGUgdG91Y2hzdGFydCwgYW5kIHRoZW4gdGhlIGZpcnN0IGJsdXIgZXZlbnQgYWZ0ZXIgdGhhdFxuICAgICAgICAvLyBmb2N1cyBldmVudC4gV2hlbiB0aGF0IGJsdXIgZXZlbnQgZmlyZXMgd2Uga25vdyB0aGF0IHdoYXRldmVyIGZvbGxvd3MgaXMgbm90IGEgcmVzdWx0IG9mIHRoZVxuICAgICAgICAvLyB0b3VjaHN0YXJ0LlxuICAgICAgICB2YXIgZm9jdXNUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0VG91Y2hUYXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIGZvY3VzVGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJlxuICAgICAgICAgICAgKGZvY3VzVGFyZ2V0ID09IHRoaXMuX2xhc3RUb3VjaFRhcmdldCB8fCBmb2N1c1RhcmdldC5jb250YWlucyh0aGlzLl9sYXN0VG91Y2hUYXJnZXQpKTtcbiAgICB9O1xuICAgIC8qKiBIYW5kbGVzIGZvY3VzIGV2ZW50cyBvbiBhIHJlZ2lzdGVyZWQgZWxlbWVudC4gKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLl9vbkZvY3VzID0gZnVuY3Rpb24gKGV2ZW50LCBlbGVtZW50LCByZW5kZXJlciwgc3ViamVjdCkge1xuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBkZXRlY3QgYSBjYXVzZSBmb3IgdGhlIGZvY3VzIGV2ZW50LCBpdCdzIGR1ZSB0byBvbmUgb2YgdHdvIHJlYXNvbnM6XG4gICAgICAgIC8vIDEpIFRoZSB3aW5kb3cgaGFzIGp1c3QgcmVnYWluZWQgZm9jdXMsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byByZXN0b3JlIHRoZSBmb2N1c2VkIHN0YXRlIG9mXG4gICAgICAgIC8vICAgIHRoZSBlbGVtZW50IGZyb20gYmVmb3JlIHRoZSB3aW5kb3cgYmx1cnJlZC5cbiAgICAgICAgLy8gMikgSXQgd2FzIGNhdXNlZCBieSBhIHRvdWNoIGV2ZW50LCBpbiB3aGljaCBjYXNlIHdlIG1hcmsgdGhlIG9yaWdpbiBhcyAndG91Y2gnLlxuICAgICAgICAvLyAzKSBUaGUgZWxlbWVudCB3YXMgcHJvZ3JhbW1hdGljYWxseSBmb2N1c2VkLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBtYXJrIHRoZSBvcmlnaW4gYXNcbiAgICAgICAgLy8gICAgJ3Byb2dyYW0nLlxuICAgICAgICBpZiAoIXRoaXMuX29yaWdpbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dpbmRvd0ZvY3VzZWQgJiYgdGhpcy5fbGFzdEZvY3VzT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luID0gdGhpcy5fbGFzdEZvY3VzT3JpZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fd2FzQ2F1c2VkQnlUb3VjaChldmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSAndG91Y2gnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luID0gJ3Byb2dyYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtZW50LCAnY2RrLWZvY3VzZWQnLCB0cnVlKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstdG91Y2gtZm9jdXNlZCcsIHRoaXMuX29yaWdpbiA9PSAndG91Y2gnKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGsta2V5Ym9hcmQtZm9jdXNlZCcsIHRoaXMuX29yaWdpbiA9PSAna2V5Ym9hcmQnKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstbW91c2UtZm9jdXNlZCcsIHRoaXMuX29yaWdpbiA9PSAnbW91c2UnKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstcHJvZ3JhbS1mb2N1c2VkJywgdGhpcy5fb3JpZ2luID09ICdwcm9ncmFtJyk7XG4gICAgICAgIHN1YmplY3QubmV4dCh0aGlzLl9vcmlnaW4pO1xuICAgICAgICB0aGlzLl9sYXN0Rm9jdXNPcmlnaW4gPSB0aGlzLl9vcmlnaW47XG4gICAgICAgIHRoaXMuX29yaWdpbiA9IG51bGw7XG4gICAgfTtcbiAgICAvKiogSGFuZGxlcyBibHVyIGV2ZW50cyBvbiBhIHJlZ2lzdGVyZWQgZWxlbWVudC4gKi9cbiAgICBGb2N1c09yaWdpbk1vbml0b3IucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyZXIsIHN1YmplY3QpIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstZm9jdXNlZCcsIGZhbHNlKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstdG91Y2gtZm9jdXNlZCcsIGZhbHNlKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGsta2V5Ym9hcmQtZm9jdXNlZCcsIGZhbHNlKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstbW91c2UtZm9jdXNlZCcsIGZhbHNlKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnQsICdjZGstcHJvZ3JhbS1mb2N1c2VkJywgZmFsc2UpO1xuICAgICAgICBzdWJqZWN0Lm5leHQobnVsbCk7XG4gICAgfTtcbiAgICBGb2N1c09yaWdpbk1vbml0b3IgPSBfX2RlY29yYXRlJDI5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDI5KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIEZvY3VzT3JpZ2luTW9uaXRvcik7XG4gICAgcmV0dXJuIEZvY3VzT3JpZ2luTW9uaXRvcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IGRldGVybWluZXMgaG93IGEgcGFydGljdWxhciBlbGVtZW50IHdhcyBmb2N1c2VkICh2aWEga2V5Ym9hcmQsIG1vdXNlLCBvclxuICogcHJvZ3JhbW1hdGljYWxseSkgYW5kIGFkZHMgY29ycmVzcG9uZGluZyBjbGFzc2VzIHRvIHRoZSBlbGVtZW50LlxuICovXG52YXIgQ2RrRm9jdXNDbGFzc2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZGtGb2N1c0NsYXNzZXMoZWxlbWVudFJlZiwgZm9jdXNPcmlnaW5Nb25pdG9yLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPVxuICAgICAgICAgICAgZm9jdXNPcmlnaW5Nb25pdG9yLnJlZ2lzdGVyRWxlbWVudEZvckZvY3VzQ2xhc3NlcyhlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgQ2RrRm9jdXNDbGFzc2VzID0gX19kZWNvcmF0ZSQyOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nka0ZvY3VzQ2xhc3Nlc10nLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgRm9jdXNPcmlnaW5Nb25pdG9yLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBDZGtGb2N1c0NsYXNzZXMpO1xuICAgIHJldHVybiBDZGtGb2N1c0NsYXNzZXM7XG59KCkpO1xuZnVuY3Rpb24gRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVJfRkFDVE9SWShwYXJlbnREaXNwYXRjaGVyKSB7XG4gICAgcmV0dXJuIHBhcmVudERpc3BhdGNoZXIgfHwgbmV3IEZvY3VzT3JpZ2luTW9uaXRvcigpO1xufVxudmFyIEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSID0ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBGb2N1c09yaWdpbk1vbml0b3IgYXZhaWxhYmxlLCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCBwcm92aWRlIGEgbmV3IG9uZS5cbiAgICBwcm92aWRlOiBGb2N1c09yaWdpbk1vbml0b3IsXG4gICAgZGVwczogW1tuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpLCBGb2N1c09yaWdpbk1vbml0b3JdXSxcbiAgICB1c2VGYWN0b3J5OiBGT0NVU19PUklHSU5fTU9OSVRPUl9QUk9WSURFUl9GQUNUT1JZXG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBDU1MgdHJhbnNmb3JtIHRvIGFuIGVsZW1lbnQsIGluY2x1ZGluZyBicm93c2VyLXByZWZpeGVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHBhcmFtIHRyYW5zZm9ybVZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q3NzVHJhbnNmb3JtKGVsZW1lbnQsIHRyYW5zZm9ybVZhbHVlKSB7XG4gICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdHJpbSB0aGUgcmVzdWx0LCBiZWNhdXNlIHRoZSBicm93c2VyIHdpbGwgaWdub3JlIHRoZSBzZXQgb3BlcmF0aW9uXG4gICAgLy8gaWYgdGhlIHN0cmluZyBjb250YWlucyBvbmx5IHdoaXRlc3BhY2UuXG4gICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtVmFsdWUudHJpbSgpO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdmFsdWU7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB2YWx1ZTtcbn1cblxudmFyIF9fZGVjb3JhdGUkMjggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBTdHlsZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIFN0eWxlTW9kdWxlID0gX19kZWNvcmF0ZSQyOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ2RrRm9jdXNDbGFzc2VzXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtDZGtGb2N1c0NsYXNzZXNdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgU3R5bGVNb2R1bGUpO1xuICAgIHJldHVybiBTdHlsZU1vZHVsZTtcbn0oKSk7XG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG52YXIgQW5pbWF0aW9uQ3VydmVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbmltYXRpb25DdXJ2ZXMoKSB7XG4gICAgfVxuICAgIEFuaW1hdGlvbkN1cnZlcy5TVEFOREFSRF9DVVJWRSA9ICdjdWJpYy1iZXppZXIoMC40LDAuMCwwLjIsMSknO1xuICAgIEFuaW1hdGlvbkN1cnZlcy5ERUNFTEVSQVRJT05fQ1VSVkUgPSAnY3ViaWMtYmV6aWVyKDAuMCwwLjAsMC4yLDEpJztcbiAgICBBbmltYXRpb25DdXJ2ZXMuQUNDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDEsMSknO1xuICAgIEFuaW1hdGlvbkN1cnZlcy5TSEFSUF9DVVJWRSA9ICdjdWJpYy1iZXppZXIoMC40LDAuMCwwLjYsMSknO1xuICAgIHJldHVybiBBbmltYXRpb25DdXJ2ZXM7XG59KCkpO1xuLyoqIEBkb2NzLXByaXZhdGUgKi9cbnZhciBBbmltYXRpb25EdXJhdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkR1cmF0aW9ucygpIHtcbiAgICB9XG4gICAgQW5pbWF0aW9uRHVyYXRpb25zLkNPTVBMRVggPSAnMzc1bXMnO1xuICAgIEFuaW1hdGlvbkR1cmF0aW9ucy5FTlRFUklORyA9ICcyMjVtcyc7XG4gICAgQW5pbWF0aW9uRHVyYXRpb25zLkVYSVRJTkcgPSAnMTk1bXMnO1xuICAgIHJldHVybiBBbmltYXRpb25EdXJhdGlvbnM7XG59KCkpO1xuXG4vKiogQ29lcmNlcyBhIGRhdGEtYm91bmQgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZykgdG8gYSBudW1iZXIuICovXG5mdW5jdGlvbiBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSwgZmFsbGJhY2tWYWx1ZSkge1xuICAgIGlmIChmYWxsYmFja1ZhbHVlID09PSB2b2lkIDApIHsgZmFsbGJhY2tWYWx1ZSA9IDA7IH1cbiAgICAvLyBwYXJzZUZsb2F0KHZhbHVlKSBoYW5kbGVzIG1vc3Qgb2YgdGhlIGNhc2VzIHdlJ3JlIGludGVyZXN0ZWQgaW4gKGl0IHRyZWF0cyBudWxsLCBlbXB0eSBzdHJpbmcsXG4gICAgLy8gYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzIGFzIE5hTiwgd2hlcmUgTnVtYmVyIGp1c3QgdXNlcyAwKSBidXQgaXQgY29uc2lkZXJzIHRoZSBzdHJpbmdcbiAgICAvLyAnMTIzaGVsbG8nIHRvIGJlIGEgdmFsaWQgbnVtYmVyLiBUaGVyZWZvcmUgd2UgYWxzbyBjaGVjayBpZiBOdW1iZXIodmFsdWUpIGlzIE5hTi5cbiAgICByZXR1cm4gaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpIHx8IGlzTmFOKE51bWJlcih2YWx1ZSkpID8gZmFsbGJhY2tWYWx1ZSA6IE51bWJlcih2YWx1ZSk7XG59XG5cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRDb3JlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENvcmVNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kQ29yZU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kQ29yZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZENvcmVNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTWRMaW5lTW9kdWxlLFxuICAgICAgICAgICAgICAgIFJ0bE1vZHVsZSxcbiAgICAgICAgICAgICAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICAgICAgICAgICAgICBPYnNlcnZlQ29udGVudE1vZHVsZSxcbiAgICAgICAgICAgICAgICBQb3J0YWxNb2R1bGUsXG4gICAgICAgICAgICAgICAgT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgICAgICBBMTF5TW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kT3B0aW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kU2VsZWN0aW9uTW9kdWxlLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBNZExpbmVNb2R1bGUsXG4gICAgICAgICAgICAgICAgUnRsTW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kUmlwcGxlTW9kdWxlLFxuICAgICAgICAgICAgICAgIE9ic2VydmVDb250ZW50TW9kdWxlLFxuICAgICAgICAgICAgICAgIFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgICAgICBPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgTWRPcHRpb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgTWRTZWxlY3Rpb25Nb2R1bGUsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDb3JlTW9kdWxlKTtcbiAgICByZXR1cm4gTWRDb3JlTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMzEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDQgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtYnV0dG9uLXRvZ2dsZS1ncm91cCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogVGhpcyBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1EX0JVVFRPTl9UT0dHTEVfR1JPVVBfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogX2FuZ3VsYXJfZm9ybXMuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZEJ1dHRvblRvZ2dsZUdyb3VwOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBfdW5pcXVlSWRDb3VudGVyJDEgPSAwO1xuLyoqIENoYW5nZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSBNZEJ1dHRvblRvZ2dsZS4gKi9cbnZhciBNZEJ1dHRvblRvZ2dsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZUNoYW5nZTtcbn0oKSk7XG4vKiogRXhjbHVzaXZlIHNlbGVjdGlvbiBidXR0b24gdG9nZ2xlIGdyb3VwIHRoYXQgYmVoYXZlcyBsaWtlIGEgcmFkaW8tYnV0dG9uIGdyb3VwLiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlR3JvdXAoKSB7XG4gICAgICAgIC8qKiBUaGUgdmFsdWUgZm9yIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwLiBTaG91bGQgbWF0Y2ggY3VycmVudGx5IHNlbGVjdGVkIGJ1dHRvbiB0b2dnbGUuICovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBIVE1MIG5hbWUgYXR0cmlidXRlIGFwcGxpZWQgdG8gdG9nZ2xlcyBpbiB0aGlzIGdyb3VwLiAqL1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJtZC1idXR0b24tdG9nZ2xlLWdyb3VwLVwiICsgX3VuaXF1ZUlkQ291bnRlciQxKys7XG4gICAgICAgIC8qKiBEaXNhYmxlcyBhbGwgdG9nZ2xlcyBpbiB0aGUgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJ1dHRvbiB0b2dnbGUgZ3JvdXAgc2hvdWxkIGJlIHZlcnRpY2FsLiAqL1xuICAgICAgICB0aGlzLl92ZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBidXR0b24gdG9nZ2xlLCBzaG91bGQgbWF0Y2ggdGhlIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwIGlzIGluaXRpYWxpemVkIG9yIG5vdC4gKi9cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1ldGhvZCB0byBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gdXBkYXRlIG5nTW9kZWwuXG4gICAgICAgICAqIE5vdyBgbmdNb2RlbGAgYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIG11bHRpcGxlIHNlbGVjdGlvbiBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgICAgICAvKiogb25Ub3VjaCBmdW5jdGlvbiByZWdpc3RlcmVkIHZpYSByZWdpc3Rlck9uVG91Y2ggKENvbnRyb2xWYWx1ZUFjY2Vzc29yKS4gKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGdyb3VwJ3MgdmFsdWUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5fY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBDaGlsZCBidXR0b24gdG9nZ2xlIGJ1dHRvbnMuICovXG4gICAgICAgIHRoaXMuX2J1dHRvblRvZ2dsZXMgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKiogYG5hbWVgIGF0dHJpYnV0ZSBmb3IgdGhlIHVuZGVybHlpbmcgYGlucHV0YCBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnV0dG9uVG9nZ2xlTmFtZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHRvZ2dsZSBncm91cCBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0b2dnbGUgZ3JvdXAgaXMgdmVydGljYWwuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmVydGljYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogVmFsdWUgb2YgdGhlIHRvZ2dsZSBncm91cC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkQnV0dG9uVG9nZ2xlRnJvbVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBlbWl0IGEgY2hhbmdlIGV2ZW50IGlmIHRoZSB2aWV3IGlzIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBlbWl0IGEgY2hhbmdlIGV2ZW50IGZvciB0aGUgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgdG9nZ2xlIGdyb3VwIGlzIHNlbGVjdGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gc2VsZWN0ZWQgPyBzZWxlY3RlZC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgIXNlbGVjdGVkLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUuX3VwZGF0ZUJ1dHRvblRvZ2dsZU5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fYnV0dG9uVG9nZ2xlcykge1xuICAgICAgICAgICAgdGhpcy5fYnV0dG9uVG9nZ2xlcy5mb3JFYWNoKGZ1bmN0aW9uICh0b2dnbGUpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGUubmFtZSA9IF90aGlzLl9uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIGludG8gc2hhcmVkIGNvZGUgd2l0aCByYWRpby5cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0ZWRCdXR0b25Ub2dnbGVGcm9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpc0FscmVhZHlTZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkICE9IG51bGwgJiYgdGhpcy5fc2VsZWN0ZWQudmFsdWUgPT0gdGhpcy5fdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9idXR0b25Ub2dnbGVzICE9IG51bGwgJiYgIWlzQWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdCdXR0b25Ub2dnbGUgPSB0aGlzLl9idXR0b25Ub2dnbGVzLmZpbHRlcihmdW5jdGlvbiAoYnV0dG9uVG9nZ2xlKSB7IHJldHVybiBidXR0b25Ub2dnbGUudmFsdWUgPT0gX3RoaXMuX3ZhbHVlOyB9KVswXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0J1dHRvblRvZ2dsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBtYXRjaGluZ0J1dHRvblRvZ2dsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvblRvZ2dsZXMuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uVG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblRvZ2dsZS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEaXNwYXRjaCBjaGFuZ2UgZXZlbnQgd2l0aCBjdXJyZW50IHNlbGVjdGlvbiBhbmQgZ3JvdXAgdmFsdWUuICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kQnV0dG9uVG9nZ2xlQ2hhbmdlKCk7XG4gICAgICAgIGV2ZW50LnNvdXJjZSA9IHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9kZWwgdmFsdWUuIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIHNldCB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIGZuIE9uIGNoYW5nZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY29udHJvbCBoYXMgYmVlbiB0b3VjaGVkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIGZuIE9uIHRvdWNoIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkIFdoZXRoZXIgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcImNoYW5nZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlOyB9KSksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcIl9idXR0b25Ub2dnbGVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcIm5hbWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwgbnVsbCk7XG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cCA9IF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWJ1dHRvbi10b2dnbGUtZ3JvdXA6bm90KFttdWx0aXBsZV0pLCBtYXQtYnV0dG9uLXRvZ2dsZS1ncm91cDpub3QoW211bHRpcGxlXSknLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfQlVUVE9OX1RPR0dMRV9HUk9VUF9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLXRvZ2dsZS1ncm91cF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAncmFkaW9ncm91cCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLXRvZ2dsZS12ZXJ0aWNhbF0nOiAndmVydGljYWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZEJ1dHRvblRvZ2dsZUdyb3VwJyxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXApO1xuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZUdyb3VwO1xufSgpKTtcbi8qKiBNdWx0aXBsZSBzZWxlY3Rpb24gYnV0dG9uLXRvZ2dsZSBncm91cC4gYG5nTW9kZWxgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBtb2RlLiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlKCkge1xuICAgICAgICAvKiogRGlzYWJsZXMgYWxsIHRvZ2dsZXMgaW4gdGhlIGdyb3VwLiAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwIHNob3VsZCBiZSB2ZXJ0aWNhbC4gKi9cbiAgICAgICAgdGhpcy5fdmVydGljYWwgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgdG9nZ2xlIGdyb3VwIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSA/IHRydWUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0b2dnbGUgZ3JvdXAgaXMgdmVydGljYWwuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmVydGljYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIG51bGwpO1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSA9IF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWJ1dHRvbi10b2dnbGUtZ3JvdXBbbXVsdGlwbGVdLCBtYXQtYnV0dG9uLXRvZ2dsZS1ncm91cFttdWx0aXBsZV0nLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZEJ1dHRvblRvZ2dsZUdyb3VwJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLWdyb3VwXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLXZlcnRpY2FsXSc6ICd2ZXJ0aWNhbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSk7XG4gICAgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZTtcbn0oKSk7XG4vKiogU2luZ2xlIGJ1dHRvbiBpbnNpZGUgb2YgYSB0b2dnbGUgZ3JvdXAuICovXG52YXIgTWRCdXR0b25Ub2dnbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlKHRvZ2dsZUdyb3VwLCB0b2dnbGVHcm91cE11bHRpcGxlLCBidXR0b25Ub2dnbGVEaXNwYXRjaGVyLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVEaXNwYXRjaGVyID0gYnV0dG9uVG9nZ2xlRGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGJ1dHRvbiB0b2dnbGUgaXMgY2hlY2tlZC4gKi9cbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyBidXR0b24gdG9nZ2xlIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIC8qKiBWYWx1ZSBhc3NpZ25lZCB0byB0aGlzIGJ1dHRvbiB0b2dnbGUuICovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBidXR0b24gdG9nZ2xlIGlzIGEgc2luZ2xlIHNlbGVjdGlvbi4gKi9cbiAgICAgICAgdGhpcy5faXNTaW5nbGVTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGdyb3VwIHZhbHVlIGNoYW5nZXMuICovXG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwID0gdG9nZ2xlR3JvdXA7XG4gICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSA9IHRvZ2dsZUdyb3VwTXVsdGlwbGU7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwKSB7XG4gICAgICAgICAgICBidXR0b25Ub2dnbGVEaXNwYXRjaGVyLmxpc3RlbihmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gX3RoaXMuaWQgJiYgbmFtZSA9PSBfdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAncmFkaW8nO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5idXR0b25Ub2dnbGVHcm91cC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5faXNTaW5nbGVTZWxlY3RvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZXJlIGlzIG5vIGdyb3VwIGF0IGFsbCwgdHJlYXQgdGhlIGJ1dHRvbiB0b2dnbGUgYXMgYSBjaGVja2JveCBzbyBpdCBjYW4gYmVcbiAgICAgICAgICAgIC8vIHRvZ2dsZWQgb24gb3Igb2ZmLlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgICAgICB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IFwibWQtYnV0dG9uLXRvZ2dsZS1cIiArIF91bmlxdWVJZENvdW50ZXIkMSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwICYmIHRoaXMuX3ZhbHVlID09IHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImlucHV0SWRcIiwge1xuICAgICAgICAvKiogVW5pcXVlIElEIGZvciB0aGUgdW5kZXJseWluZyBgaW5wdXRgIGVsZW1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyBcIi1pbnB1dFwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgYnV0dG9uIGlzIGNoZWNrZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgYnV0dG9uIHRvZ2dsZXMgd2l0aCB0aGUgc2FtZSBuYW1lIChpbiB0aGUgc2FtZSBncm91cCkgdG8gdW4tY2hlY2suXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlRGlzcGF0Y2hlci5ub3RpZnkodGhpcy5pZCwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gbmV3Q2hlY2tlZFN0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld0NoZWNrZWRTdGF0ZSAmJiB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yICYmIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAudmFsdWUgIT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAuc2VsZWN0ZWQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqIE1kQnV0dG9uVG9nZ2xlR3JvdXAgcmVhZHMgdGhpcyB0byBhc3NpZ24gaXRzIG93biB2YWx1ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idXR0b25Ub2dnbGVHcm91cCAhPSBudWxsICYmIHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBEaXNwYXRjaCBjaGFuZ2UgZXZlbnQgd2l0aCBjdXJyZW50IHZhbHVlLiAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTWRCdXR0b25Ub2dnbGVDaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5fY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkIHx8ICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwICE9IG51bGwgJiYgdGhpcy5idXR0b25Ub2dnbGVHcm91cC5kaXNhYmxlZCkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5idXR0b25Ub2dnbGVHcm91cE11bHRpcGxlICE9IG51bGwgJiYgdGhpcy5idXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLmRpc2FibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSA/IHRydWUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogVG9nZ2xlIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBidXR0b24gdG9nZ2xlLiAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5fdG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgIH07XG4gICAgLyoqIENoZWNrcyB0aGUgYnV0dG9uIHRvZ2dsZSBkdWUgdG8gYW4gaW50ZXJhY3Rpb24gd2l0aCB0aGUgdW5kZXJseWluZyBuYXRpdmUgaW5wdXQuICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLl9vbklucHV0Q2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAodGhpcy5faXNTaW5nbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gUHJvcGFnYXRlIHRoZSBjaGFuZ2Ugb25lLXdheSB2aWEgdGhlIGdyb3VwLCB3aGljaCB3aWxsIGluIHR1cm4gbWFyayB0aGlzXG4gICAgICAgICAgICAvLyBidXR0b24gdG9nZ2xlIGFzIGNoZWNrZWQuXG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cC5zZWxlY3RlZCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLm9uVG91Y2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCBhIGNoYW5nZSBldmVudCB3aGVuIHRoZSBuYXRpdmUgaW5wdXQgZG9lcy5cbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgfTtcbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gZm9yIGNsaWNrIGV2ZW50cyBvbiB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB3aGVuIGEgdXNlciBjbGlja3Mgb24gYSBsYWJlbCBlbGVtZW50LCBhIGdlbmVyYXRlZCBjbGljayBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGRpc3BhdGNoZWQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gU2luY2Ugd2UgYXJlIHVzaW5nIGEgbGFiZWwgZWxlbWVudCBhcyBvdXJcbiAgICAgICAgLy8gcm9vdCBjb250YWluZXIsIHRoZSBjbGljayBldmVudCBvbiB0aGUgYHNsaWRlLXRvZ2dsZWAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cbiAgICAgICAgLy8gVGhlIHJlYWwgY2xpY2sgZXZlbnQgd2lsbCBidWJibGUgdXAsIGFuZCB0aGUgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IGFsc28gdHJpZXMgdG8gYnViYmxlIHVwLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbGVhZCB0byBtdWx0aXBsZSBjbGljayBldmVudHMuXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBidXR0b24uICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZSlcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgnaW5wdXQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJfaW5wdXRFbGVtZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLWNoZWNrZWQnKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlLWRpc2FibGVkJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRCdXR0b25Ub2dnbGUgPSBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtYnV0dG9uLXRvZ2dsZSwgbWF0LWJ1dHRvbi10b2dnbGUnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIFthdHRyLmZvcl09XFxcImlucHV0SWRcXFwiIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbFxcXCI+PGlucHV0ICNpbnB1dCBjbGFzcz1cXFwibWF0LWJ1dHRvbi10b2dnbGUtaW5wdXQgY2RrLXZpc3VhbGx5LWhpZGRlblxcXCIgW3R5cGVdPVxcXCJfdHlwZVxcXCIgW2lkXT1cXFwiaW5wdXRJZFxcXCIgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiAoY2hhbmdlKT1cXFwiX29uSW5wdXRDaGFuZ2UoJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiX29uSW5wdXRDbGljaygkZXZlbnQpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50XFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PC9sYWJlbD5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1idXR0b24tdG9nZ2xlLWdyb3Vwe2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKTtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1mbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdztib3JkZXItcmFkaXVzOjJweDtjdXJzb3I6cG9pbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXB9Lm1hdC1idXR0b24tdG9nZ2xlLXZlcnRpY2Fse2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0ubWF0LWJ1dHRvbi10b2dnbGUtdmVydGljYWwgLm1hdC1idXR0b24tdG9nZ2xlLWxhYmVsLWNvbnRlbnR7ZGlzcGxheTpibG9ja30ubWF0LWJ1dHRvbi10b2dnbGUtZGlzYWJsZWQgLm1hdC1idXR0b24tdG9nZ2xlLWxhYmVsLWNvbnRlbnR7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1idXR0b24tdG9nZ2xle3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmfS5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50e2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xpbmUtaGVpZ2h0OjM2cHg7cGFkZGluZzowIDE2cHg7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5tYXQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50Pip7dmVydGljYWwtYWxpZ246bWlkZGxlfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1idXR0b24tdG9nZ2xlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ0KDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kNCgxLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbTWRCdXR0b25Ub2dnbGVHcm91cCwgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLCBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZSk7XG4gICAgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlO1xufSgpKTtcbnZhciBNZEJ1dHRvblRvZ2dsZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRCdXR0b25Ub2dnbGVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZEJ1dHRvblRvZ2dsZU1vZHVsZSA9IF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9mb3Jtcy5Gb3Jtc01vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgTWRCdXR0b25Ub2dnbGVHcm91cCxcbiAgICAgICAgICAgICAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsXG4gICAgICAgICAgICAgICAgTWRCdXR0b25Ub2dnbGUsXG4gICAgICAgICAgICAgICAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZEJ1dHRvblRvZ2dsZUdyb3VwLCBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIE1kQnV0dG9uVG9nZ2xlXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1VOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUl1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlTW9kdWxlKTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGVNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkMzIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8vIFRPRE8oamVsYm91cm4pOiBNYWtlIHRoZSBgaXNNb3VzZURvd25gIHN0dWZmIGRvbmUgd2l0aCBvbmUgZ2xvYmFsIGxpc3RlbmVyLlxuLy8gVE9ETyhrYXJhKTogQ29udmVydCBhdHRyaWJ1dGUgc2VsZWN0b3JzIHRvIGNsYXNzZXMgd2hlbiBhdHRyIG1hcHMgYmVjb21lIGF2YWlsYWJsZVxuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kQnV0dG9uQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvbkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRCdXR0b25Dc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtYnV0dG9uXSwgYnV0dG9uW21hdC1idXR0b25dLCBhW21kLWJ1dHRvbl0sIGFbbWF0LWJ1dHRvbl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJ1dHRvbl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQnV0dG9uQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRCdXR0b25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtcmFpc2VkLWJ1dHRvbl0sIGJ1dHRvblttYXQtcmFpc2VkLWJ1dHRvbl0sICcgK1xuICAgICAgICAgICAgICAgICdhW21kLXJhaXNlZC1idXR0b25dLCBhW21hdC1yYWlzZWQtYnV0dG9uXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcmFpc2VkLWJ1dHRvbl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbWQtaWNvbi1idXR0b25dLCBidXR0b25bbWF0LWljb24tYnV0dG9uXSwgYVttZC1pY29uLWJ1dHRvbl0sIGFbbWF0LWljb24tYnV0dG9uXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtaWNvbi1idXR0b25dJzogJ3RydWUnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyO1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZEZhYkNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRGYWJDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kRmFiQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQzMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uW21kLWZhYl0sIGJ1dHRvblttYXQtZmFiXSwgYVttZC1mYWJdLCBhW21hdC1mYWJdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1mYWJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEZhYkNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kRmFiQ3NzTWF0U3R5bGVyO1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZE1pbmlGYWJDc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWluaUZhYkNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRNaW5pRmFiQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQzMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uW21kLW1pbmktZmFiXSwgYnV0dG9uW21hdC1taW5pLWZhYl0sIGFbbWQtbWluaS1mYWJdLCBhW21hdC1taW5pLWZhYl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LW1pbmktZmFiXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRNaW5pRmFiQ3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWRNaW5pRmFiQ3NzTWF0U3R5bGVyO1xufSgpKTtcbi8qKlxuICogTWF0ZXJpYWwgZGVzaWduIGJ1dHRvbi5cbiAqL1xudmFyIE1kQnV0dG9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvbihfZWxlbWVudFJlZiwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBidXR0b24gaGFzIGZvY3VzIGZyb20gdGhlIGtleWJvYXJkIChub3QgdGhlIG1vdXNlKS4gVXNlZCBmb3IgY2xhc3MgYmluZGluZy4gKi9cbiAgICAgICAgdGhpcy5faXNLZXlib2FyZEZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgYSBtb3VzZWRvd24gaGFzIG9jY3VycmVkIG9uIHRoaXMgZWxlbWVudCBpbiB0aGUgbGFzdCAxMDBtcy4gKi9cbiAgICAgICAgdGhpcy5faXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHJpcHBsZSBlZmZlY3Qgb24gY2xpY2sgc2hvdWxkIGJlIGRpc2FibGVkLiAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHJpcHBsZSBlZmZlY3QgZm9yIHRoaXMgYnV0dG9uIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2KTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBidXR0b24gaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKSA/IHRydWUgOiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b24ucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgYnV0dG9uLiBDYW4gYmUgYHByaW1hcnlgLCBgYWNjZW50YCwgb3IgYHdhcm5gLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl91cGRhdGVDb2xvcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5fc2V0TW91c2Vkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXZSBvbmx5ICpzaG93KiB0aGUgZm9jdXMgc3R5bGUgd2hlbiBmb2N1cyBoYXMgY29tZSB0byB0aGUgYnV0dG9uIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAgICAgIC8vIFRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYyBpcyBzaWxlbnQgb24gdGhpcyB0b3BpYywgYW5kIHdpdGhvdXQgZG9pbmcgdGhpcywgdGhlXG4gICAgICAgIC8vIGJ1dHRvbiBjb250aW51ZXMgdG8gbG9vayA6YWN0aXZlIGFmdGVyIGNsaWNraW5nLlxuICAgICAgICAvLyBAc2VlIGh0dHA6Ly9tYXJjeXN1dHRvbi5jb20vYnV0dG9uLWZvY3VzLWhlbGwvXG4gICAgICAgIHRoaXMuX2lzTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IF90aGlzLl9pc01vdXNlRG93biA9IGZhbHNlOyB9LCAxMDApO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5fc2V0RWxlbWVudENvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBpc0FkZCkge1xuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBjb2xvciAhPSAnJykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuX2dldEhvc3RFbGVtZW50KCksIFwibWF0LVwiICsgY29sb3IsIGlzQWRkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9zZXRLZXlib2FyZEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0tleWJvYXJkRm9jdXNlZCA9ICF0aGlzLl9pc01vdXNlRG93bjtcbiAgICB9O1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5fcmVtb3ZlS2V5Ym9hcmRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNLZXlib2FyZEZvY3VzZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBidXR0b24uICovXG4gICAgTWRCdXR0b24ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2dldEhvc3RFbGVtZW50KCksICdmb2N1cycpO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9nZXRIb3N0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9O1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5faXNSb3VuZEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fZ2V0SG9zdEVsZW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnbWQtaWNvbi1idXR0b24nKSB8fFxuICAgICAgICAgICAgZWwuaGFzQXR0cmlidXRlKCdtZC1mYWInKSB8fFxuICAgICAgICAgICAgZWwuaGFzQXR0cmlidXRlKCdtZC1taW5pLWZhYicpO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9pc1JpcHBsZURpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlUmlwcGxlIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRCdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVSaXBwbGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRCdXR0b24ucHJvdG90eXBlLCBcImNvbG9yXCIsIG51bGwpO1xuICAgIE1kQnV0dG9uID0gX19kZWNvcmF0ZSQzMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ2J1dHRvblttZC1idXR0b25dLCBidXR0b25bbWQtcmFpc2VkLWJ1dHRvbl0sIGJ1dHRvblttZC1pY29uLWJ1dHRvbl0sJyArXG4gICAgICAgICAgICAgICAgJ2J1dHRvblttZC1mYWJdLCBidXR0b25bbWQtbWluaS1mYWJdLCcgK1xuICAgICAgICAgICAgICAgICdidXR0b25bbWF0LWJ1dHRvbl0sIGJ1dHRvblttYXQtcmFpc2VkLWJ1dHRvbl0sIGJ1dHRvblttYXQtaWNvbi1idXR0b25dLCcgK1xuICAgICAgICAgICAgICAgICdidXR0b25bbWF0LWZhYl0sIGJ1dHRvblttYXQtbWluaS1mYWJdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2Rpc2FibGVkXSc6ICdkaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtYnV0dG9uLWZvY3VzXSc6ICdfaXNLZXlib2FyZEZvY3VzZWQnLFxuICAgICAgICAgICAgICAgICcobW91c2Vkb3duKSc6ICdfc2V0TW91c2Vkb3duKCknLFxuICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ19zZXRLZXlib2FyZEZvY3VzKCknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX3JlbW92ZUtleWJvYXJkRm9jdXMoKScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHNwYW4gY2xhc3M9XFxcIm1hdC1idXR0b24td3JhcHBlclxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj48ZGl2IG1kLXJpcHBsZSAqbmdJZj1cXFwiIV9pc1JpcHBsZURpc2FibGVkKClcXFwiIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXJpcHBsZVxcXCIgW2NsYXNzLm1hdC1idXR0b24tcmlwcGxlLXJvdW5kXT1cXFwiX2lzUm91bmRCdXR0b24oKVxcXCIgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXlcXFwiICh0b3VjaHN0YXJ0KT1cXFwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcXFwiPjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWJ1dHRvbi1mb2N1cy5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LWZhYiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLWZvY3VzLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLWZvY3VzLm1hdC1taW5pLWZhYiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLWZvY3VzLm1hdC1yYWlzZWQtYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b246aG92ZXIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWljb24tYnV0dG9uOmhvdmVyIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7b3BhY2l0eToxfS5tYXQtYnV0dG9uLC5tYXQtZmFiLC5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtZGVjb3JhdGlvbjpub25lO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NTAwO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbjowO21pbi13aWR0aDo4OHB4O2xpbmUtaGVpZ2h0OjM2cHg7cGFkZGluZzowIDE2cHg7Ym9yZGVyLXJhZGl1czoycHh9W2Rpc2FibGVkXS5tYXQtYnV0dG9uLFtkaXNhYmxlZF0ubWF0LWZhYixbZGlzYWJsZWRdLm1hdC1pY29uLWJ1dHRvbixbZGlzYWJsZWRdLm1hdC1taW5pLWZhYixbZGlzYWJsZWRdLm1hdC1yYWlzZWQtYnV0dG9ue2N1cnNvcjpkZWZhdWx0fS5tYXQtZmFiLC5tYXQtbWluaS1mYWIsLm1hdC1yYWlzZWQtYnV0dG9ue2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zaXRpb246YmFja2dyb3VuZCAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm94LXNoYWRvdyAyODBtcyBjdWJpYy1iZXppZXIoLjQsMCwuMiwxKX0ubWF0LWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZlLC5tYXQtbWluaS1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZSwubWF0LXJhaXNlZC1idXR0b246bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgNXB4IDVweCAtM3B4IHJnYmEoMCwwLDAsLjIpLDAgOHB4IDEwcHggMXB4IHJnYmEoMCwwLDAsLjE0KSwwIDNweCAxNHB4IDJweCByZ2JhKDAsMCwwLC4xMil9W2Rpc2FibGVkXS5tYXQtZmFiLFtkaXNhYmxlZF0ubWF0LW1pbmktZmFiLFtkaXNhYmxlZF0ubWF0LXJhaXNlZC1idXR0b257Ym94LXNoYWRvdzpub25lfS5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3ZlciAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtYWNjZW50LC5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtcHJpbWFyeSwubWF0LWJ1dHRvbltkaXNhYmxlZF06aG92ZXIubWF0LXdhcm4sLm1hdC1pY29uLWJ1dHRvbltkaXNhYmxlZF06aG92ZXIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWljb24tYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtYWNjZW50LC5tYXQtaWNvbi1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1wcmltYXJ5LC5tYXQtaWNvbi1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC13YXJue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9Lm1hdC1mYWJ7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjA7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6NTZweDtoZWlnaHQ6NTZweDtwYWRkaW5nOjA7ZmxleC1zaHJpbms6MH0ubWF0LWljb24tYnV0dG9uLC5tYXQtbWluaS1mYWJ7bWluLXdpZHRoOjA7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtib3JkZXItcmFkaXVzOjUwJX0ubWF0LWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA3cHggOHB4IC00cHggcmdiYSgwLDAsMCwuMiksMCAxMnB4IDE3cHggMnB4IHJnYmEoMCwwLDAsLjE0KSwwIDVweCAyMnB4IDRweCByZ2JhKDAsMCwwLC4xMil9Lm1hdC1mYWIgLm1hdC1pY29uLC5tYXQtZmFiIGl7cGFkZGluZzoxNnB4IDA7bGluZS1oZWlnaHQ6MjRweH0ubWF0LW1pbmktZmFie2JveC1zaGFkb3c6MCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCA2cHggMTBweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAxOHB4IDAgcmdiYSgwLDAsMCwuMTIpO3BhZGRpbmc6MDtmbGV4LXNocmluazowfS5tYXQtbWluaS1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgN3B4IDhweCAtNHB4IHJnYmEoMCwwLDAsLjIpLDAgMTJweCAxN3B4IDJweCByZ2JhKDAsMCwwLC4xNCksMCA1cHggMjJweCA0cHggcmdiYSgwLDAsMCwuMTIpfS5tYXQtbWluaS1mYWIgLm1hdC1pY29uLC5tYXQtbWluaS1mYWIgaXtwYWRkaW5nOjhweCAwO2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1pY29uLWJ1dHRvbntwYWRkaW5nOjA7ZmxleC1zaHJpbms6MDtsaW5lLWhlaWdodDo0MHB4fS5tYXQtaWNvbi1idXR0b24gLm1hdC1pY29uLC5tYXQtaWNvbi1idXR0b24gaXtsaW5lLWhlaWdodDoyNHB4fS5tYXQtYnV0dG9uLC5tYXQtaWNvbi1idXR0b24sLm1hdC1yYWlzZWQtYnV0dG9ue2NvbG9yOmN1cnJlbnRDb2xvcn0ubWF0LWJ1dHRvbiAubWF0LWJ1dHRvbi13cmFwcGVyPiosLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi13cmFwcGVyPiosLm1hdC1yYWlzZWQtYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+Knt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWJ1dHRvbi1yaXBwbGV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjB9Lm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjEyKTtib3JkZXItcmFkaXVzOmluaGVyaXQ7cG9pbnRlci1ldmVudHM6bm9uZTtvcGFjaXR5OjB9Lm1hdC1idXR0b24tcmlwcGxlLXJvdW5ke2JvcmRlci1yYWRpdXM6NTAlO3otaW5kZXg6MX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuNSl9Lm1hdC1idXR0b24sLm1hdC1mYWIsLm1hdC1pY29uLWJ1dHRvbiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntvdXRsaW5lOnNvbGlkIDFweH19XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kQnV0dG9uKTtcbiAgICByZXR1cm4gTWRCdXR0b247XG59KCkpO1xuLyoqXG4gKiBSYWlzZWQgTWF0ZXJpYWwgZGVzaWduIGJ1dHRvbi5cbiAqL1xudmFyIE1kQW5jaG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkNyhNZEFuY2hvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEFuY2hvcihlbGVtZW50UmVmLCByZW5kZXJlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50UmVmLCByZW5kZXJlcik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEFuY2hvci5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwge1xuICAgICAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gLTEgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBbmNob3IucHJvdG90eXBlLCBcIl9pc0FyaWFEaXNhYmxlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZEFuY2hvci5wcm90b3R5cGUuX2hhbHREaXNhYmxlZEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBBIGRpc2FibGVkIGJ1dHRvbiBzaG91bGRuJ3QgYXBwbHkgYW55IGFjdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ3RhYkluZGV4JyksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZEFuY2hvci5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgbnVsbCk7XG4gICAgTWRBbmNob3IgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiBcImFbbWQtYnV0dG9uXSwgYVttZC1yYWlzZWQtYnV0dG9uXSwgYVttZC1pY29uLWJ1dHRvbl0sIGFbbWQtZmFiXSwgYVttZC1taW5pLWZhYl0sXFxuICAgICAgICAgICAgIGFbbWF0LWJ1dHRvbl0sIGFbbWF0LXJhaXNlZC1idXR0b25dLCBhW21hdC1pY29uLWJ1dHRvbl0sIGFbbWF0LWZhYl0sIGFbbWF0LW1pbmktZmFiXVwiLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbYXR0ci5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdfaXNBcmlhRGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWJ1dHRvbi1mb2N1c10nOiAnX2lzS2V5Ym9hcmRGb2N1c2VkJyxcbiAgICAgICAgICAgICAgICAnKG1vdXNlZG93biknOiAnX3NldE1vdXNlZG93bigpJyxcbiAgICAgICAgICAgICAgICAnKGZvY3VzKSc6ICdfc2V0S2V5Ym9hcmRGb2N1cygpJyxcbiAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19yZW1vdmVLZXlib2FyZEZvY3VzKCknLFxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19oYWx0RGlzYWJsZWRFdmVudHMoJGV2ZW50KScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHNwYW4gY2xhc3M9XFxcIm1hdC1idXR0b24td3JhcHBlclxcXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj48ZGl2IG1kLXJpcHBsZSAqbmdJZj1cXFwiIV9pc1JpcHBsZURpc2FibGVkKClcXFwiIGNsYXNzPVxcXCJtYXQtYnV0dG9uLXJpcHBsZVxcXCIgW2NsYXNzLm1hdC1idXR0b24tcmlwcGxlLXJvdW5kXT1cXFwiX2lzUm91bmRCdXR0b24oKVxcXCIgW21kUmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXlcXFwiICh0b3VjaHN0YXJ0KT1cXFwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcXFwiPjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWJ1dHRvbi1mb2N1cy5tYXQtYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b24tZm9jdXMubWF0LWZhYiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLWZvY3VzLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLWZvY3VzLm1hdC1taW5pLWZhYiAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uLWZvY3VzLm1hdC1yYWlzZWQtYnV0dG9uIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXksLm1hdC1idXR0b246aG92ZXIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWljb24tYnV0dG9uOmhvdmVyIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXl7b3BhY2l0eToxfS5tYXQtYnV0dG9uLC5tYXQtZmFiLC5tYXQtaWNvbi1idXR0b24sLm1hdC1taW5pLWZhYiwubWF0LXJhaXNlZC1idXR0b257Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtvdXRsaW5lOjA7Ym9yZGVyOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtZGVjb3JhdGlvbjpub25lO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NTAwO3RleHQtYWxpZ246Y2VudGVyO21hcmdpbjowO21pbi13aWR0aDo4OHB4O2xpbmUtaGVpZ2h0OjM2cHg7cGFkZGluZzowIDE2cHg7Ym9yZGVyLXJhZGl1czoycHh9W2Rpc2FibGVkXS5tYXQtYnV0dG9uLFtkaXNhYmxlZF0ubWF0LWZhYixbZGlzYWJsZWRdLm1hdC1pY29uLWJ1dHRvbixbZGlzYWJsZWRdLm1hdC1taW5pLWZhYixbZGlzYWJsZWRdLm1hdC1yYWlzZWQtYnV0dG9ue2N1cnNvcjpkZWZhdWx0fS5tYXQtZmFiLC5tYXQtbWluaS1mYWIsLm1hdC1yYWlzZWQtYnV0dG9ue2JveC1zaGFkb3c6MCAzcHggMXB4IC0ycHggcmdiYSgwLDAsMCwuMiksMCAycHggMnB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDVweCAwIHJnYmEoMCwwLDAsLjEyKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zaXRpb246YmFja2dyb3VuZCAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm94LXNoYWRvdyAyODBtcyBjdWJpYy1iZXppZXIoLjQsMCwuMiwxKX0ubWF0LWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZlLC5tYXQtbWluaS1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZSwubWF0LXJhaXNlZC1idXR0b246bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgNXB4IDVweCAtM3B4IHJnYmEoMCwwLDAsLjIpLDAgOHB4IDEwcHggMXB4IHJnYmEoMCwwLDAsLjE0KSwwIDNweCAxNHB4IDJweCByZ2JhKDAsMCwwLC4xMil9W2Rpc2FibGVkXS5tYXQtZmFiLFtkaXNhYmxlZF0ubWF0LW1pbmktZmFiLFtkaXNhYmxlZF0ubWF0LXJhaXNlZC1idXR0b257Ym94LXNoYWRvdzpub25lfS5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3ZlciAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5LC5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtYWNjZW50LC5tYXQtYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtcHJpbWFyeSwubWF0LWJ1dHRvbltkaXNhYmxlZF06aG92ZXIubWF0LXdhcm4sLm1hdC1pY29uLWJ1dHRvbltkaXNhYmxlZF06aG92ZXIgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWljb24tYnV0dG9uW2Rpc2FibGVkXTpob3Zlci5tYXQtYWNjZW50LC5tYXQtaWNvbi1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC1wcmltYXJ5LC5tYXQtaWNvbi1idXR0b25bZGlzYWJsZWRdOmhvdmVyLm1hdC13YXJue2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9Lm1hdC1mYWJ7Ym94LXNoYWRvdzowIDNweCA1cHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDZweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMXB4IDE4cHggMCByZ2JhKDAsMCwwLC4xMik7bWluLXdpZHRoOjA7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6NTZweDtoZWlnaHQ6NTZweDtwYWRkaW5nOjA7ZmxleC1zaHJpbms6MH0ubWF0LWljb24tYnV0dG9uLC5tYXQtbWluaS1mYWJ7bWluLXdpZHRoOjA7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtib3JkZXItcmFkaXVzOjUwJX0ubWF0LWZhYjpub3QoW2Rpc2FibGVkXSk6YWN0aXZle2JveC1zaGFkb3c6MCA3cHggOHB4IC00cHggcmdiYSgwLDAsMCwuMiksMCAxMnB4IDE3cHggMnB4IHJnYmEoMCwwLDAsLjE0KSwwIDVweCAyMnB4IDRweCByZ2JhKDAsMCwwLC4xMil9Lm1hdC1mYWIgLm1hdC1pY29uLC5tYXQtZmFiIGl7cGFkZGluZzoxNnB4IDA7bGluZS1oZWlnaHQ6MjRweH0ubWF0LW1pbmktZmFie2JveC1zaGFkb3c6MCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCA2cHggMTBweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAxOHB4IDAgcmdiYSgwLDAsMCwuMTIpO3BhZGRpbmc6MDtmbGV4LXNocmluazowfS5tYXQtbWluaS1mYWI6bm90KFtkaXNhYmxlZF0pOmFjdGl2ZXtib3gtc2hhZG93OjAgN3B4IDhweCAtNHB4IHJnYmEoMCwwLDAsLjIpLDAgMTJweCAxN3B4IDJweCByZ2JhKDAsMCwwLC4xNCksMCA1cHggMjJweCA0cHggcmdiYSgwLDAsMCwuMTIpfS5tYXQtbWluaS1mYWIgLm1hdC1pY29uLC5tYXQtbWluaS1mYWIgaXtwYWRkaW5nOjhweCAwO2xpbmUtaGVpZ2h0OjI0cHh9Lm1hdC1pY29uLWJ1dHRvbntwYWRkaW5nOjA7ZmxleC1zaHJpbms6MDtsaW5lLWhlaWdodDo0MHB4fS5tYXQtaWNvbi1idXR0b24gLm1hdC1pY29uLC5tYXQtaWNvbi1idXR0b24gaXtsaW5lLWhlaWdodDoyNHB4fS5tYXQtYnV0dG9uLC5tYXQtaWNvbi1idXR0b24sLm1hdC1yYWlzZWQtYnV0dG9ue2NvbG9yOmN1cnJlbnRDb2xvcn0ubWF0LWJ1dHRvbiAubWF0LWJ1dHRvbi13cmFwcGVyPiosLm1hdC1pY29uLWJ1dHRvbiAubWF0LWJ1dHRvbi13cmFwcGVyPiosLm1hdC1yYWlzZWQtYnV0dG9uIC5tYXQtYnV0dG9uLXdyYXBwZXI+Knt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSwubWF0LWJ1dHRvbi1yaXBwbGV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjB9Lm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjEyKTtib3JkZXItcmFkaXVzOmluaGVyaXQ7cG9pbnRlci1ldmVudHM6bm9uZTtvcGFjaXR5OjB9Lm1hdC1idXR0b24tcmlwcGxlLXJvdW5ke2JvcmRlci1yYWRpdXM6NTAlO3otaW5kZXg6MX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5e2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjU1LDI1NSwuNSl9Lm1hdC1idXR0b24sLm1hdC1mYWIsLm1hdC1pY29uLWJ1dHRvbiwubWF0LW1pbmktZmFiLC5tYXQtcmFpc2VkLWJ1dHRvbntvdXRsaW5lOnNvbGlkIDFweH19XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZEFuY2hvcik7XG4gICAgcmV0dXJuIE1kQW5jaG9yO1xufShNZEJ1dHRvbikpO1xudmFyIE1kQnV0dG9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRCdXR0b25Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kQnV0dG9uTW9kdWxlID0gX19kZWNvcmF0ZSQzMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIE1kUmlwcGxlTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBNZEJ1dHRvbiwgTWRBbmNob3IsXG4gICAgICAgICAgICAgICAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgICAgICAgICAgICAgICBNZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZFJhaXNlZEJ1dHRvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZEljb25CdXR0b25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRGYWJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRNaW5pRmFiQ3NzTWF0U3R5bGVyXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgTWRCdXR0b24sXG4gICAgICAgICAgICAgICAgTWRBbmNob3IsXG4gICAgICAgICAgICAgICAgTWRCdXR0b25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRJY29uQnV0dG9uQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kRmFiQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kTWluaUZhYkNzc01hdFN0eWxlclxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQnV0dG9uTW9kdWxlKTtcbiAgICByZXR1cm4gTWRCdXR0b25Nb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQzMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqIE1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBpbnRlZ2VyIHVzZWQgdG8gYXV0by1nZW5lcmF0ZSB1bmlxdWUgaWRzIGZvciBjaGVja2JveCBjb21wb25lbnRzLiAqL1xudmFyIG5leHRJZCA9IDA7XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtY2hlY2tib3ggdG8gcmVnaXN0ZXIgYXMgYSBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAqIFRoaXMgYWxsb3dzIGl0IHRvIHN1cHBvcnQgWyhuZ01vZGVsKV0uXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IF9hbmd1bGFyX2Zvcm1zLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRDaGVja2JveDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCBzdGF0ZXMgdGhhdCByZXF1aXJlIGN1c3RvbSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZW0uXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cblxuKGZ1bmN0aW9uIChUcmFuc2l0aW9uQ2hlY2tTdGF0ZSkge1xuICAgIC8qKiBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IGJlZm9yZSBhbnkgdXNlciBpbnRlcmFjdGlvbi4gKi9cbiAgICBUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtcIkluaXRcIl0gPSAwXSA9IFwiSW5pdFwiO1xuICAgIC8qKiBUaGUgc3RhdGUgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQgd2hlbiBpdCdzIGJlY29taW5nIGNoZWNrZWQuICovXG4gICAgVHJhbnNpdGlvbkNoZWNrU3RhdGVbVHJhbnNpdGlvbkNoZWNrU3RhdGVbXCJDaGVja2VkXCJdID0gMV0gPSBcIkNoZWNrZWRcIjtcbiAgICAvKiogVGhlIHN0YXRlIHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50IHdoZW4gaXQncyBiZWNvbWluZyB1bmNoZWNrZWQuICovXG4gICAgVHJhbnNpdGlvbkNoZWNrU3RhdGVbVHJhbnNpdGlvbkNoZWNrU3RhdGVbXCJVbmNoZWNrZWRcIl0gPSAyXSA9IFwiVW5jaGVja2VkXCI7XG4gICAgLyoqIFRoZSBzdGF0ZSByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudCB3aGVuIGl0J3MgYmVjb21pbmcgaW5kZXRlcm1pbmF0ZS4gKi9cbiAgICBUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtUcmFuc2l0aW9uQ2hlY2tTdGF0ZVtcIkluZGV0ZXJtaW5hdGVcIl0gPSAzXSA9IFwiSW5kZXRlcm1pbmF0ZVwiO1xufSkoZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZSB8fCAoZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZSA9IHt9KSk7XG4vKiogQ2hhbmdlIGV2ZW50IG9iamVjdCBlbWl0dGVkIGJ5IE1kQ2hlY2tib3guICovXG52YXIgTWRDaGVja2JveENoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGVja2JveENoYW5nZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kQ2hlY2tib3hDaGFuZ2U7XG59KCkpO1xuLyoqXG4gKiBBIG1hdGVyaWFsIGRlc2lnbiBjaGVja2JveCBjb21wb25lbnQuIFN1cHBvcnRzIGFsbCBvZiB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBIVE1MNSBjaGVja2JveCxcbiAqIGFuZCBleHBvc2VzIGEgc2ltaWxhciBBUEkuIEEgTWRDaGVja2JveCBjYW4gYmUgZWl0aGVyIGNoZWNrZWQsIHVuY2hlY2tlZCwgaW5kZXRlcm1pbmF0ZSwgb3JcbiAqIGRpc2FibGVkLiBOb3RlIHRoYXQgYWxsIGFkZGl0aW9uYWwgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzIGFyZSB0YWtlbiBjYXJlIG9mIGJ5IHRoZSBjb21wb25lbnQsXG4gKiBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHByb3ZpZGUgdGhlbSB5b3Vyc2VsZi4gSG93ZXZlciwgaWYgeW91IHdhbnQgdG8gb21pdCBhIGxhYmVsIGFuZCBzdGlsbFxuICogaGF2ZSB0aGUgY2hlY2tib3ggYmUgYWNjZXNzaWJsZSwgeW91IG1heSBzdXBwbHkgYW4gW2FyaWEtbGFiZWxdIGlucHV0LlxuICogU2VlOiBodHRwczovL3d3dy5nb29nbGUuY29tL2Rlc2lnbi9zcGVjL2NvbXBvbmVudHMvc2VsZWN0aW9uLWNvbnRyb2xzLmh0bWxcbiAqL1xudmFyIE1kQ2hlY2tib3ggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hlY2tib3goX3JlbmRlcmVyLCBfZWxlbWVudFJlZiwgX2NoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoZWQgdG8gdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9mIHRoZSBob3N0IGVsZW1lbnQuIEluIG1vc3QgY2FzZXMsIGFyaWFsLWxhYmVsbGVkYnkgd2lsbFxuICAgICAgICAgKiB0YWtlIHByZWNlZGVuY2Ugc28gdGhpcyBtYXkgYmUgb21pdHRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJpYUxhYmVsID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VycyBjYW4gc3BlY2lmeSB0aGUgYGFyaWEtbGFiZWxsZWRieWAgYXR0cmlidXRlIHdoaWNoIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBpbnB1dCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFyaWFMYWJlbGxlZGJ5ID0gbnVsbDtcbiAgICAgICAgLyoqIEEgdW5pcXVlIGlkIGZvciB0aGUgY2hlY2tib3guIElmIG9uZSBpcyBub3Qgc3VwcGxpZWQsIGl0IGlzIGF1dG8tZ2VuZXJhdGVkLiAqL1xuICAgICAgICB0aGlzLmlkID0gXCJtZC1jaGVja2JveC1cIiArICsrbmV4dElkO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGFwcGVhciBhZnRlciBvciBiZWZvcmUgdGhlIGNoZWNrYm94LiBEZWZhdWx0cyB0byAnYWZ0ZXInICovXG4gICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBUYWJpbmRleCB2YWx1ZSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgLyoqIE5hbWUgdmFsdWUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBpbnB1dCBlbGVtZW50IGlmIHByZXNlbnQgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2hlY2tib3gncyBgY2hlY2tlZGAgdmFsdWUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2hlY2tib3gncyBgaW5kZXRlcm1pbmF0ZWAgdmFsdWUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlQ2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgYmx1cnJlZC4gTmVlZGVkIHRvIHByb3Blcmx5IGltcGxlbWVudCBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcyA9ICcnO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hlY2tTdGF0ZSA9IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdDtcbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xvciA9ICdhY2NlbnQnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiZGlzYWJsZVJpcHBsZVwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGZvciB0aGlzIGNoZWNrYm94IGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIC8qKiBJRCBvZiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgaW5zaWRlIGA8bWQtY2hlY2tib3g+YCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcImlucHV0LVwiICsgdGhpcy5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIHJlcXVpcmVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9yZXF1aXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJhbGlnblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY2hlY2tib3ggc2hvdWxkIGFwcGVhciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGxhYmVsLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBhbGlnbiByZWZlcnMgdG8gdGhlIGNoZWNrYm94IHJlbGF0aXZlIHRvIHRoZSBsYWJlbCwgd2hpbGUgbGFiZWxQb3NpdGlvbiByZWZlcnMgdG8gdGhlXG4gICAgICAgICAgICAvLyBsYWJlbCByZWxhdGl2ZSB0byB0aGUgY2hlY2tib3guIEFzIHN1Y2gsIHRoZXkgYXJlIGludmVydGVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxQb3NpdGlvbiA9PSAnYWZ0ZXInID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsUG9zaXRpb24gPSAodiA9PSAnc3RhcnQnKSA/ICdhZnRlcicgOiAnYmVmb3JlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGNoZWNrZWQuIE5vdGUgdGhhdCBzZXR0aW5nIGBjaGVja2VkYCB3aWxsIGltbWVkaWF0ZWx5IHNldFxuICAgICAgICAgKiBgaW5kZXRlcm1pbmF0ZWAgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjaGVja2VkKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZCAhPSB0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KHRoaXMuX2luZGV0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSh0aGlzLl9jaGVja2VkID8gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkIDogZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiaW5kZXRlcm1pbmF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjaGVja2JveCBpcyBpbmRldGVybWluYXRlLiBUaGlzIGlzIGFsc28ga25vd24gYXMgXCJtaXhlZFwiIG1vZGUgYW5kIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgICAqIHJlcHJlc2VudCBhIGNoZWNrYm94IHdpdGggdGhyZWUgc3RhdGVzLCBlLmcuIGEgY2hlY2tib3ggdGhhdCByZXByZXNlbnRzIGEgbmVzdGVkIGxpc3Qgb2ZcbiAgICAgICAgICogY2hlY2thYmxlIGl0ZW1zLiBOb3RlIHRoYXQgd2hlbmV2ZXIgYGNoZWNrZWRgIGlzIHNldCwgaW5kZXRlcm1pbmF0ZSBpcyBpbW1lZGlhdGVseSBzZXQgdG9cbiAgICAgICAgICogZmFsc2UuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB3ZWIgcGxhdGZvcm0gaW4gdGhhdCBpbmRldGVybWluYXRlIHN0YXRlIG9uIG5hdGl2ZVxuICAgICAgICAgKiBjaGVja2JveGVzIGlzIG9ubHkgcmVtb3ZlIHdoZW4gdGhlIHVzZXIgbWFudWFsbHkgY2hlY2tzIHRoZSBjaGVja2JveCAocmF0aGVyIHRoYW4gc2V0dGluZyB0aGVcbiAgICAgICAgICogYGNoZWNrZWRgIHByb3BlcnR5IHByb2dyYW1tYXRpY2FsbHkpLiBIb3dldmVyLCB3ZSBmZWVsIHRoYXQgdGhpcyBiZWhhdmlvciBpcyBtb3JlIGFjY29tbW9kYXRpbmdcbiAgICAgICAgICogdG8gdGhlIHdheSBjb25zdW1lcnMgd291bGQgZW52aXNpb24gdXNpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGluZGV0ZXJtaW5hdGUgIT0gdGhpcy5faW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZShleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkluZGV0ZXJtaW5hdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkNoZWNrU3RhdGUodGhpcy5jaGVja2VkID8gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkIDogZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UuZW1pdCh0aGlzLl9pbmRldGVybWluYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgYnV0dG9uLiBDYW4gYmUgYHByaW1hcnlgLCBgYWNjZW50YCwgb3IgYHdhcm5gLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbG9yOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl91cGRhdGVDb2xvcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yLCBpc0FkZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9pc1JpcHBsZURpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlUmlwcGxlIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb2RlbCB2YWx1ZS4gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgc2V0IHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNoYW5nZS5cbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250cm9sIGhhcyBiZWVuIHRvdWNoZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNoZWNrYm94IGlzIHRvdWNoZWQuXG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNoZWNrYm94J3MgZGlzYWJsZWQgc3RhdGUuIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gaXNEaXNhYmxlZCBXaGV0aGVyIHRoZSBjaGVja2JveCBzaG91bGQgYmUgZGlzYWJsZWQuXG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX3RyYW5zaXRpb25DaGVja1N0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciBvbGRTdGF0ZSA9IHRoaXMuX2N1cnJlbnRDaGVja1N0YXRlO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICAgICAgdmFyIGVsZW1lbnRSZWYgPSB0aGlzLl9lbGVtZW50UmVmO1xuICAgICAgICBpZiAob2xkU3RhdGUgPT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MgPSB0aGlzLl9nZXRBbmltYXRpb25DbGFzc0ZvckNoZWNrU3RhdGVUcmFuc2l0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaGVja1N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fY3VycmVudEFuaW1hdGlvbkNsYXNzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kQ2hlY2tib3hDaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQuY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbih0aGlzLmNoZWNrZWQpO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKiBJbmZvcm1zIHRoZSBjb21wb25lbnQgd2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzIHNvIHRoYXQgd2UgY2FuIHN0eWxlIGFjY29yZGluZ2x5ICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX29uSW5wdXRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqIEluZm9ybXMgdGhlIGNvbXBvbmVudCB3aGVuIHdlIGxvc2UgZm9jdXMgaW4gb3JkZXIgdG8gc3R5bGUgYWNjb3JkaW5nbHkgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fb25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgfTtcbiAgICAvKiogVG9nZ2xlcyB0aGUgYGNoZWNrZWRgIHN0YXRlIG9mIHRoZSBjaGVja2JveC4gKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIGZvciBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxuICAgICAqIFRvZ2dsZXMgY2hlY2tlZCBzdGF0ZSBpZiBlbGVtZW50IGlzIG5vdCBkaXNhYmxlZC5cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fb25JbnRlcmFjdGlvbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGFsd2F5cyBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gb24gdGhlIGNoYW5nZSBldmVudC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBjaGFuZ2UgZXZlbnQsIGZyb20gdGhlIGlucHV0IGVsZW1lbnQsIHdpbGwgYnViYmxlIHVwIGFuZFxuICAgICAgICAvLyBlbWl0IGl0cyBldmVudCBvYmplY3QgdG8gdGhlIGBjaGFuZ2VgIG91dHB1dC5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb3VyIGN1c3RvbSBjaGFuZ2UgZXZlbnQgaWYgdGhlIG5hdGl2ZSBpbnB1dCBlbWl0dGVkIG9uZS5cbiAgICAgICAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBvbmx5IGVtaXQgaXQsIGlmIHRoZSBuYXRpdmUgaW5wdXQgdHJpZ2dlcmVkIG9uZSwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCB3aGVuIHRoZSBgY2hlY2tlZGAgdmFyaWFibGUgY2hhbmdlcyBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRm9jdXNlcyB0aGUgY2hlY2tib3guICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5faW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpO1xuICAgICAgICB0aGlzLl9vbklucHV0Rm9jdXMoKTtcbiAgICB9O1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBkaXNwYXRjaGVkIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuIFNpbmNlIHdlIGFyZSB1c2luZyBhIGxhYmVsIGVsZW1lbnQgYXMgb3VyXG4gICAgICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGBjaGVja2JveGAgd2lsbCBiZSBleGVjdXRlZCB0d2ljZS5cbiAgICAgICAgLy8gVGhlIHJlYWwgY2xpY2sgZXZlbnQgd2lsbCBidWJibGUgdXAsIGFuZCB0aGUgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IGFsc28gdHJpZXMgdG8gYnViYmxlIHVwLlxuICAgICAgICAvLyBUaGlzIHdpbGwgbGVhZCB0byBtdWx0aXBsZSBjbGljayBldmVudHMuXG4gICAgICAgIC8vIFByZXZlbnRpbmcgYnViYmxpbmcgZm9yIHRoZSBzZWNvbmQgZXZlbnQgd2lsbCBzb2x2ZSB0aGF0IGlzc3VlLlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9nZXRBbmltYXRpb25DbGFzc0ZvckNoZWNrU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICB2YXIgYW5pbVN1ZmZpeDtcbiAgICAgICAgc3dpdGNoIChvbGRTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkluaXQ6XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGVkZ2UgY2FzZSB3aGVyZSB1c2VyIGludGVyYWN0cyB3aXRoIGNoZWNrYm94IHRoYXQgZG9lcyBub3QgaGF2ZSBbKG5nTW9kZWwpXSBvclxuICAgICAgICAgICAgICAgIC8vIFtjaGVja2VkXSBib3VuZCB0byBpdC5cbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gJ3VuY2hlY2tlZC1jaGVja2VkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuVW5jaGVja2VkOlxuICAgICAgICAgICAgICAgIGFuaW1TdWZmaXggPSBuZXdTdGF0ZSA9PT0gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkID9cbiAgICAgICAgICAgICAgICAgICAgJ3VuY2hlY2tlZC1jaGVja2VkJyA6ICd1bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZDpcbiAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gbmV3U3RhdGUgPT09IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuVW5jaGVja2VkID9cbiAgICAgICAgICAgICAgICAgICAgJ2NoZWNrZWQtdW5jaGVja2VkJyA6ICdjaGVja2VkLWluZGV0ZXJtaW5hdGUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkluZGV0ZXJtaW5hdGU6XG4gICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9IG5ld1N0YXRlID09PSBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAnaW5kZXRlcm1pbmF0ZS1jaGVja2VkJyA6ICdpbmRldGVybWluYXRlLXVuY2hlY2tlZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibWF0LWNoZWNrYm94LWFuaW0tXCIgKyBhbmltU3VmZml4O1xuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2dldEhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtbGFiZWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImFyaWFMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLWxhYmVsbGVkYnknKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImFyaWFMYWJlbGxlZGJ5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImFsaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJsYWJlbFBvc2l0aW9uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcilcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiaW5kZXRlcm1pbmF0ZUNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgnaW5wdXQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcIl9pbnB1dEVsZW1lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiaW5kZXRlcm1pbmF0ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiY29sb3JcIiwgbnVsbCk7XG4gICAgTWRDaGVja2JveCA9IF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1jaGVja2JveCwgbWF0LWNoZWNrYm94JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxsYWJlbCBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWxheW91dFxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lclxcXCI+PGlucHV0ICNpbnB1dCBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWlucHV0IGNkay12aXN1YWxseS1oaWRkZW5cXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiBbaWRdPVxcXCJpbnB1dElkXFxcIiBbcmVxdWlyZWRdPVxcXCJyZXF1aXJlZFxcXCIgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiBbdGFiSW5kZXhdPVxcXCJ0YWJJbmRleFxcXCIgW2luZGV0ZXJtaW5hdGVdPVxcXCJpbmRldGVybWluYXRlXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiYXJpYUxhYmVsXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJhcmlhTGFiZWxsZWRieVxcXCIgKGZvY3VzKT1cXFwiX29uSW5wdXRGb2N1cygpXFxcIiAoYmx1cik9XFxcIl9vbklucHV0Qmx1cigpXFxcIiAoY2hhbmdlKT1cXFwiX29uSW50ZXJhY3Rpb25FdmVudCgkZXZlbnQpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPjxkaXYgbWQtcmlwcGxlICpuZ0lmPVxcXCIhX2lzUmlwcGxlRGlzYWJsZWQoKVxcXCIgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1yaXBwbGVcXFwiIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJfZ2V0SG9zdEVsZW1lbnQoKVxcXCIgW21kUmlwcGxlQ2VudGVyZWRdPVxcXCJ0cnVlXFxcIiBbbWRSaXBwbGVTcGVlZEZhY3Rvcl09XFxcIjAuM1xcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LWNoZWNrYm94LWZyYW1lXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtYmFja2dyb3VuZFxcXCI+PHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtY2hlY2ttYXJrXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCI+PHBhdGggY2xhc3M9XFxcIm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCJ3aGl0ZVxcXCIgZD1cXFwiTTQuMSwxMi43IDksMTcuNiAyMC4zLDYuM1xcXCIvPjwvc3ZnPjxkaXYgY2xhc3M9XFxcIm1hdC1jaGVja2JveC1taXhlZG1hcmtcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjxzcGFuIGNsYXNzPVxcXCJtYXQtY2hlY2tib3gtbGFiZWxcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+PC9sYWJlbD5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1jaGVja2JveC1mcmFtZSwubWF0LWNoZWNrYm94LXVuY2hlY2tlZCAubWF0LWNoZWNrYm94LWJhY2tncm91bmR7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmR7MCV7b3BhY2l0eTowfTUwJXtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgbWF0LWNoZWNrYm94LWZhZGUtb3V0LWJhY2tncm91bmR7MCUsNTAle29wYWNpdHk6MX0xMDAle29wYWNpdHk6MH19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWNoZWNrZWQtY2hlY2ttYXJrLXBhdGh7MCUsNTAle3N0cm9rZS1kYXNob2Zmc2V0OjIyLjkxMDI2fTUwJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLDAsLjIsLjEpfTEwMCV7c3Ryb2tlLWRhc2hvZmZzZXQ6MH19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJrezAlLDY4LjIle3RyYW5zZm9ybTpzY2FsZVgoMCl9NjguMiV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMCwwLDAsMSl9MTAwJXt0cmFuc2Zvcm06c2NhbGVYKDEpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1jaGVja2VkLXVuY2hlY2tlZC1jaGVja21hcmstcGF0aHtmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC40LDAsMSwxKTtzdHJva2UtZGFzaG9mZnNldDowfXRve3N0cm9rZS1kYXNob2Zmc2V0Oi0yMi45MTAyNn19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtY2hlY2tlZC1pbmRldGVybWluYXRlLWNoZWNrbWFya3tmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAsMCwuMiwuMSk7b3BhY2l0eToxO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97b3BhY2l0eTowO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtY2hlY2ttYXJre2Zyb217YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE0LDAsMCwxKTtvcGFjaXR5OjA7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9dG97b3BhY2l0eToxO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtY2hlY2tlZC1pbmRldGVybWluYXRlLW1peGVkbWFya3tmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAsMCwuMiwuMSk7b3BhY2l0eTowO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX10b3tvcGFjaXR5OjE7dHJhbnNmb3JtOnJvdGF0ZSgwKX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLW1peGVkbWFya3tmcm9te2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4xNCwwLDAsMSk7b3BhY2l0eToxO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97b3BhY2l0eTowO3RyYW5zZm9ybTpyb3RhdGUoMzE1ZGVnKX19QGtleWZyYW1lcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQtbWl4ZWRtYXJrezAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246bGluZWFyO29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGVYKDEpfTEwMCUsMzIuOCV7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZVgoMCl9fS5tYXQtY2hlY2tib3gtYmFja2dyb3VuZCwubWF0LWNoZWNrYm94LWNoZWNrbWFyaywubWF0LWNoZWNrYm94LWZyYW1le2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre3dpZHRoOmNhbGMoMTAwJSAtIDRweCl9Lm1hdC1jaGVja2JveC1iYWNrZ3JvdW5kLC5tYXQtY2hlY2tib3gtZnJhbWV7Ym9yZGVyLXJhZGl1czoycHg7Ym94LXNpemluZzpib3JkZXItYm94O3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1hdC1jaGVja2JveHtjdXJzb3I6cG9pbnRlcjtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO3RyYW5zaXRpb246YmFja2dyb3VuZCAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSksYm94LXNoYWRvdyAyODBtcyBjdWJpYy1iZXppZXIoLjQsMCwuMiwxKX0ubWF0LWNoZWNrYm94LWxheW91dHtjdXJzb3I6aW5oZXJpdDthbGlnbi1pdGVtczpiYXNlbGluZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7ZGlzcGxheTppbmxpbmUtZmxleH0ubWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lcntkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MjBweDtsaW5lLWhlaWdodDowO21hcmdpbjphdXRvIDhweCBhdXRvIGF1dG87b3JkZXI6MDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7d2hpdGUtc3BhY2U6bm93cmFwO3dpZHRoOjIwcHg7ZmxleC1zaHJpbms6MH1bZGlyPXJ0bF0gLm1hdC1jaGVja2JveC1pbm5lci1jb250YWluZXJ7bWFyZ2luLWxlZnQ6OHB4O21hcmdpbi1yaWdodDphdXRvfS5tYXQtY2hlY2tib3gtbGF5b3V0IC5tYXQtY2hlY2tib3gtbGFiZWx7bGluZS1oZWlnaHQ6MjRweH0ubWF0LWNoZWNrYm94LWZyYW1le3RyYW5zaXRpb246Ym9yZGVyLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsMCwuMiwuMSk7Ym9yZGVyLXdpZHRoOjJweDtib3JkZXItc3R5bGU6c29saWR9Lm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmlubGluZS1mbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsMCwuMiwuMSksb3BhY2l0eSA5MG1zIGN1YmljLWJlemllcigwLDAsLjIsLjEpfS5tYXQtY2hlY2tib3gtY2hlY2ttYXJre3dpZHRoOjEwMCV9Lm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHtzdHJva2UtZGFzaG9mZnNldDoyMi45MTAyNjtzdHJva2UtZGFzaGFycmF5OjIyLjkxMDI2O3N0cm9rZS13aWR0aDoyLjY3cHh9Lm1hdC1jaGVja2JveC1jaGVja2VkIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGgsLm1hdC1jaGVja2JveC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGh7c3Ryb2tlLWRhc2hvZmZzZXQ6MH0ubWF0LWNoZWNrYm94LW1peGVkbWFya3toZWlnaHQ6MnB4O29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGVYKDApIHJvdGF0ZSgwKX0ubWF0LWNoZWNrYm94LWxhYmVsLWJlZm9yZSAubWF0LWNoZWNrYm94LWlubmVyLWNvbnRhaW5lcntvcmRlcjoxO21hcmdpbi1sZWZ0OjhweDttYXJnaW4tcmlnaHQ6YXV0b31bZGlyPXJ0bF0gLm1hdC1jaGVja2JveC1sYWJlbC1iZWZvcmUgLm1hdC1jaGVja2JveC1pbm5lci1jb250YWluZXJ7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6OHB4fS5tYXQtY2hlY2tib3gtY2hlY2tlZCAubWF0LWNoZWNrYm94LWNoZWNrbWFya3tvcGFjaXR5OjF9Lm1hdC1jaGVja2JveC1jaGVja2VkIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre3RyYW5zZm9ybTpzY2FsZVgoMSkgcm90YXRlKC00NWRlZyl9Lm1hdC1jaGVja2JveC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJre29wYWNpdHk6MDt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0ubWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZVgoMSkgcm90YXRlKDApfS5tYXQtY2hlY2tib3gtZGlzYWJsZWR7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1jaGVja2VkIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmR9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1jaGVja2VkIC5tYXQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGh7YW5pbWF0aW9uOjE4MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWNoZWNrZWQtY2hlY2ttYXJrLXBhdGh9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZHthbmltYXRpb246MTgwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmR9Lm1hdC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1pbmRldGVybWluYXRlIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2FuaW1hdGlvbjo5MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLXVuY2hlY2tlZCAubWF0LWNoZWNrYm94LWJhY2tncm91bmR7YW5pbWF0aW9uOjE4MG1zIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtZmFkZS1vdXQtYmFja2dyb3VuZH0ubWF0LWNoZWNrYm94LWFuaW0tY2hlY2tlZC11bmNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aHthbmltYXRpb246OTBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWNoZWNrZWQtdW5jaGVja2VkLWNoZWNrbWFyay1wYXRofS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1jaGVja21hcmt7YW5pbWF0aW9uOjkwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtY2hlY2ttYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1hdC1jaGVja2JveC1taXhlZG1hcmt7YW5pbWF0aW9uOjkwbXMgbGluZWFyIDBzIG1hdC1jaGVja2JveC1jaGVja2VkLWluZGV0ZXJtaW5hdGUtbWl4ZWRtYXJrfS5tYXQtY2hlY2tib3gtYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQgLm1hdC1jaGVja2JveC1jaGVja21hcmt7YW5pbWF0aW9uOi41cyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWluZGV0ZXJtaW5hdGUtY2hlY2tlZC1jaGVja21hcmt9Lm1hdC1jaGVja2JveC1hbmltLWluZGV0ZXJtaW5hdGUtY2hlY2tlZCAubWF0LWNoZWNrYm94LW1peGVkbWFya3thbmltYXRpb246LjVzIGxpbmVhciAwcyBtYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLW1peGVkbWFya30ubWF0LWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQgLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5ke2FuaW1hdGlvbjoxODBtcyBsaW5lYXIgMHMgbWF0LWNoZWNrYm94LWZhZGUtb3V0LWJhY2tncm91bmR9Lm1hdC1jaGVja2JveC1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJre2FuaW1hdGlvbjouM3MgbGluZWFyIDBzIG1hdC1jaGVja2JveC1pbmRldGVybWluYXRlLXVuY2hlY2tlZC1taXhlZG1hcmt9Lm1hdC1jaGVja2JveC1pbnB1dHtib3R0b206MDtsZWZ0OjUwJX0ubWF0LWNoZWNrYm94LXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xNXB4O3RvcDotMTVweDtyaWdodDotMTVweDtib3R0b206LTE1cHg7Ym9yZGVyLXJhZGl1czo1MCU7ei1pbmRleDoxO3BvaW50ZXItZXZlbnRzOm5vbmV9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2JveC1pbmRldGVybWluYXRlXSc6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2JveC1jaGVja2VkXSc6ICdjaGVja2VkJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2JveC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNoZWNrYm94LWxhYmVsLWJlZm9yZV0nOiAnbGFiZWxQb3NpdGlvbiA9PSBcImJlZm9yZVwiJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGVja2JveC1mb2N1c2VkXSc6ICdfaGFzRm9jdXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01EX0NIRUNLQk9YX0NPTlRST0xfVkFMVUVfQUNDRVNTT1JdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZl0pXG4gICAgXSwgTWRDaGVja2JveCk7XG4gICAgcmV0dXJuIE1kQ2hlY2tib3g7XG59KCkpO1xudmFyIE1kQ2hlY2tib3hNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hlY2tib3hNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kQ2hlY2tib3hNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZENoZWNrYm94TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRDaGVja2JveE1vZHVsZSA9IF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRDaGVja2JveCwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZENoZWNrYm94XSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2hlY2tib3hNb2R1bGUpO1xuICAgIHJldHVybiBNZENoZWNrYm94TW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMzQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDUgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtcmFkaW8tZ3JvdXAgdG8gcmVnaXN0ZXIgYXMgYSBDb250cm9sVmFsdWVBY2Nlc3Nvci4gVGhpc1xuICogYWxsb3dzIGl0IHRvIHN1cHBvcnQgWyhuZ01vZGVsKV0gYW5kIG5nQ29udHJvbC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogX2FuZ3VsYXJfZm9ybXMuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZFJhZGlvR3JvdXA7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xudmFyIF91bmlxdWVJZENvdW50ZXIkMiA9IDA7XG4vKiogQ2hhbmdlIGV2ZW50IG9iamVjdCBlbWl0dGVkIGJ5IE1kUmFkaW8gYW5kIE1kUmFkaW9Hcm91cC4gKi9cbnZhciBNZFJhZGlvQ2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFJhZGlvQ2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRSYWRpb0NoYW5nZTtcbn0oKSk7XG4vKipcbiAqIEEgZ3JvdXAgb2YgcmFkaW8gYnV0dG9ucy4gTWF5IGNvbnRhaW4gb25lIG9yIG1vcmUgYDxtZC1yYWRpby1idXR0b24+YCBlbGVtZW50cy5cbiAqL1xudmFyIE1kUmFkaW9Hcm91cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSYWRpb0dyb3VwKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0ZWQgdmFsdWUgZm9yIGdyb3VwLiBTaG91bGQgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3RlZCByYWRpbyBidXR0b24gaWYgdGhlcmUgKmlzKlxuICAgICAgICAgKiBhIGNvcnJlc3BvbmRpbmcgcmFkaW8gYnV0dG9uIHdpdGggYSBtYXRjaGluZyB2YWx1ZS4gSWYgdGhlcmUgaXMgKm5vdCogc3VjaCBhIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICogcmFkaW8gYnV0dG9uLCB0aGlzIHZhbHVlIHBlcnNpc3RzIHRvIGJlIGFwcGxpZWQgaW4gY2FzZSBhIG5ldyByYWRpbyBidXR0b24gaXMgYWRkZWQgd2l0aCBhXG4gICAgICAgICAqIG1hdGNoaW5nIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKiogVGhlIEhUTUwgbmFtZSBhdHRyaWJ1dGUgYXBwbGllZCB0byByYWRpbyBidXR0b25zIGluIHRoaXMgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX25hbWUgPSBcIm1kLXJhZGlvLWdyb3VwLVwiICsgX3VuaXF1ZUlkQ291bnRlciQyKys7XG4gICAgICAgIC8qKiBEaXNhYmxlcyBhbGwgaW5kaXZpZHVhbCByYWRpbyBidXR0b25zIGFzc2lnbmVkIHRvIHRoaXMgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHJhZGlvIGJ1dHRvbi4gU2hvdWxkIG1hdGNoIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBgdmFsdWVgIGhhcyBiZWVuIHNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKiogVGhlIG1ldGhvZCB0byBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gdXBkYXRlIG5nTW9kZWwgKi9cbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogb25Ub3VjaCBmdW5jdGlvbiByZWdpc3RlcmVkIHZpYSByZWdpc3Rlck9uVG91Y2ggKENvbnRyb2xWYWx1ZUFjY2Vzc29yKS5cbiAgICAgICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGdyb3VwIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqIENoYW5nZSBldmVudHMgYXJlIG9ubHkgZW1pdHRlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uIHdpdGhcbiAgICAgICAgICogYSByYWRpbyBidXR0b24gKHRoZSBzYW1lIGJlaGF2aW9yIGFzIGA8aW5wdXQgdHlwZS1cInJhZGlvXCI+YCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogQ2hpbGQgcmFkaW8gYnV0dG9ucy4gKi9cbiAgICAgICAgdGhpcy5fcmFkaW9zID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGxhYmVscyBzaG91bGQgYXBwZWFyIGFmdGVyIG9yIGJlZm9yZSB0aGUgcmFkaW8tYnV0dG9ucy4gRGVmYXVsdHMgdG8gJ2FmdGVyJyAqL1xuICAgICAgICB0aGlzLmxhYmVsUG9zaXRpb24gPSAnYWZ0ZXInO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqIE5hbWUgb2YgdGhlIHJhZGlvIGJ1dHRvbiBncm91cC4gQWxsIHJhZGlvIGJ1dHRvbnMgaW5zaWRlIHRoaXMgZ3JvdXAgd2lsbCB1c2UgdGhpcyBuYW1lLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hbWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSYWRpb0J1dHRvbk5hbWVzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcImFsaWduXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWdubWVudCBvZiB0aGUgcmFkaW8tYnV0dG9ucyByZWxhdGl2ZSB0byB0aGVpciBsYWJlbHMuIENhbiBiZSAnYmVmb3JlJyBvciAnYWZ0ZXInLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBhbGlnbiByZWZlcnMgdG8gdGhlIGNoZWNrYm94IHJlbGF0aXZlIHRvIHRoZSBsYWJlbCwgd2hpbGUgbGFiZWxQb3NpdGlvbiByZWZlcnMgdG8gdGhlXG4gICAgICAgICAgICAvLyBsYWJlbCByZWxhdGl2ZSB0byB0aGUgY2hlY2tib3guIEFzIHN1Y2gsIHRoZXkgYXJlIGludmVydGVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxQb3NpdGlvbiA9PSAnYWZ0ZXInID8gJ3N0YXJ0JyA6ICdlbmQnO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsUG9zaXRpb24gPSAodiA9PSAnc3RhcnQnKSA/ICdhZnRlcicgOiAnYmVmb3JlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcmFkaW8gYnV0dG9uIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHByZXNlbmNlIG9mICphbnkqIGRpc2FibGVkIHZhbHVlIG1ha2VzIHRoZSBjb21wb25lbnQgZGlzYWJsZWQsICpleGNlcHQqIGZvciBmYWxzZS5cbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSA/IHRydWUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBWYWx1ZSBvZiB0aGUgcmFkaW8gYnV0dG9uLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoaXMgYmVmb3JlIHByb2NlZWRpbmcgdG8gZW5zdXJlIG5vIGNpcmN1bGFyIGxvb3Agb2NjdXJzIHdpdGggc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0ZWRSYWRpb0Zyb21WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrU2VsZWN0ZWRSYWRpb0J1dHRvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLl9jaGVja1NlbGVjdGVkUmFkaW9CdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkICYmICF0aGlzLl9zZWxlY3RlZC5jaGVja2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcmFkaW8gYnV0dG9uIGlzIHNlbGVjdGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBzZWxlY3RlZCA/IHNlbGVjdGVkLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2VsZWN0ZWRSYWRpb0J1dHRvbigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHByb3BlcnRpZXMgb25jZSBjb250ZW50IGNoaWxkcmVuIGFyZSBhdmFpbGFibGUuXG4gICAgICogVGhpcyBhbGxvd3MgdXMgdG8gcHJvcGFnYXRlIHJlbGV2YW50IGF0dHJpYnV0ZXMgdG8gYXNzb2NpYXRlZCBidXR0b25zLlxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNYXJrIHRoaXMgY29tcG9uZW50IGFzIGluaXRpYWxpemVkIGluIEFmdGVyQ29udGVudEluaXQgYmVjYXVzZSB0aGUgaW5pdGlhbCB2YWx1ZSBjYW5cbiAgICAgICAgLy8gcG9zc2libHkgYmUgc2V0IGJ5IE5nTW9kZWwgb24gTWRSYWRpb0dyb3VwLCBhbmQgaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgT25Jbml0IG9mIHRoZVxuICAgICAgICAvLyBOZ01vZGVsIG9jY3VycyAqYWZ0ZXIqIHRoZSBPbkluaXQgb2YgdGhlIE1kUmFkaW9Hcm91cC5cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXJrIHRoaXMgZ3JvdXAgYXMgYmVpbmcgXCJ0b3VjaGVkXCIgKGZvciBuZ01vZGVsKS4gTWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHRoZSBjb250YWluZWRcbiAgICAgKiByYWRpbyBidXR0b25zIHVwb24gdGhlaXIgYmx1ci5cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLl90b3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub25Ub3VjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLl91cGRhdGVSYWRpb0J1dHRvbk5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcmFkaW9zKSB7XG4gICAgICAgICAgICB0aGlzLl9yYWRpb3MuZm9yRWFjaChmdW5jdGlvbiAocmFkaW8pIHtcbiAgICAgICAgICAgICAgICByYWRpby5uYW1lID0gX3RoaXMubmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgYHNlbGVjdGVkYCByYWRpbyBidXR0b24gZnJvbSB0aGUgaW50ZXJuYWwgX3ZhbHVlIHN0YXRlLiAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVNlbGVjdGVkUmFkaW9Gcm9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBhbHJlYWR5IG1hdGNoZXMgdGhlIHNlbGVjdGVkIHJhZGlvLCBkbyBub3RoaW5nLlxuICAgICAgICB2YXIgaXNBbHJlYWR5U2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3RlZCAhPSBudWxsICYmIHRoaXMuX3NlbGVjdGVkLnZhbHVlID09IHRoaXMuX3ZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fcmFkaW9zICE9IG51bGwgJiYgIWlzQWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yYWRpb3MuZm9yRWFjaChmdW5jdGlvbiAocmFkaW8pIHtcbiAgICAgICAgICAgICAgICByYWRpby5jaGVja2VkID0gX3RoaXMudmFsdWUgPT0gcmFkaW8udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHJhZGlvLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlbGVjdGVkID0gcmFkaW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEaXNwYXRjaCBjaGFuZ2UgZXZlbnQgd2l0aCBjdXJyZW50IHNlbGVjdGlvbiBhbmQgZ3JvdXAgdmFsdWUuICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBuZXcgTWRSYWRpb0NoYW5nZSgpO1xuICAgICAgICAgICAgZXZlbnRfMS5zb3VyY2UgPSB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgICAgIGV2ZW50XzEudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnRfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vZGVsIHZhbHVlLiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgbW9kZWwgdmFsdWUgY2hhbmdlcy5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBmbiBDYWxsYmFjayB0byBiZSByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY29udHJvbCBpcyB0b3VjaGVkLlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIGNvbnRyb2wuIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gaXNEaXNhYmxlZCBXaGV0aGVyIHRoZSBjb250cm9sIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcilcbiAgICBdLCBNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcImNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRSYWRpb0J1dHRvbjsgfSkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcIl9yYWRpb3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJuYW1lXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcImFsaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFJhZGlvR3JvdXAucHJvdG90eXBlLCBcImxhYmVsUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwgbnVsbCk7XG4gICAgTWRSYWRpb0dyb3VwID0gX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtcmFkaW8tZ3JvdXAsIG1hdC1yYWRpby1ncm91cCcsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9SQURJT19HUk9VUF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdyYWRpb2dyb3VwJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yYWRpby1ncm91cF0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRSYWRpb0dyb3VwKTtcbiAgICByZXR1cm4gTWRSYWRpb0dyb3VwO1xufSgpKTtcbi8qKlxuICogQSByYWRpby1idXR0b24uIE1heSBiZSBpbnNpZGUgb2ZcbiAqL1xudmFyIE1kUmFkaW9CdXR0b24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmFkaW9CdXR0b24ocmFkaW9Hcm91cCwgX2VsZW1lbnRSZWYsIF9yZW5kZXJlciwgcmFkaW9EaXNwYXRjaGVyKSB7XG4gICAgICAgIC8vIEFzc2VydGlvbnMuIElkZWFsbHkgdGhlc2Ugc2hvdWxkIGJlIHN0cmlwcGVkIG91dCBieSB0aGUgY29tcGlsZXIuXG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiBBc3NlcnQgdGhhdCB0aGVyZSdzIG5vIG5hbWUgYmluZGluZyBBTkQgYSBwYXJlbnQgcmFkaW8gZ3JvdXAuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmFkaW9EaXNwYXRjaGVyID0gcmFkaW9EaXNwYXRjaGVyO1xuICAgICAgICAvKiogV2hldGhlciB0aGlzIHJhZGlvIGlzIGNoZWNrZWQuICovXG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRoZSB1bmlxdWUgSUQgZm9yIHRoZSByYWRpbyBidXR0b24uICovXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLXJhZGlvLVwiICsgX3VuaXF1ZUlkQ291bnRlciQyKys7XG4gICAgICAgIC8qKiBWYWx1ZSBhc3NpZ25lZCB0byB0aGlzIHJhZGlvLiovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBvZiB0aGlzIHJhZGlvIGJ1dHRvbiBjaGFuZ2VzLlxuICAgICAgICAgKiBDaGFuZ2UgZXZlbnRzIGFyZSBvbmx5IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyBkdWUgdG8gdXNlciBpbnRlcmFjdGlvbiB3aXRoXG4gICAgICAgICAqIHRoZSByYWRpbyBidXR0b24gKHRoZSBzYW1lIGJlaGF2aW9yIGFzIGA8aW5wdXQgdHlwZS1cInJhZGlvXCI+YCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnJhZGlvR3JvdXAgPSByYWRpb0dyb3VwO1xuICAgICAgICByYWRpb0Rpc3BhdGNoZXIubGlzdGVuKGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKGlkICE9IF90aGlzLmlkICYmIG5hbWUgPT0gX3RoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHJpcHBsZSBlZmZlY3QgZm9yIHRoaXMgcmFkaW8gYnV0dG9uIGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVSaXBwbGU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVSaXBwbGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIC8qKiBJRCBvZiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgaW5zaWRlIGA8bWQtcmFkaW8tYnV0dG9uPmAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZCArIFwiLWlucHV0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyByYWRpbyBidXR0b24gaXMgY2hlY2tlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tlZCAhPSBuZXdDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gbmV3Q2hlY2tlZFN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja2VkU3RhdGUgJiYgdGhpcy5yYWRpb0dyb3VwICYmIHRoaXMucmFkaW9Hcm91cC52YWx1ZSAhPSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmFkaW9Hcm91cC5zZWxlY3RlZCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFuZXdDaGVja2VkU3RhdGUgJiYgdGhpcy5yYWRpb0dyb3VwICYmIHRoaXMucmFkaW9Hcm91cC52YWx1ZSA9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW5jaGVja2luZyB0aGUgc2VsZWN0ZWQgcmFkaW8gYnV0dG9uLCB1cGRhdGUgdGhlIHNlbGVjdGVkIHJhZGlvXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IG9uIHRoZSBncm91cC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLnNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYWxsIHJhZGlvIGJ1dHRvbnMgd2l0aCB0aGUgc2FtZSBuYW1lIHRvIHVuLWNoZWNrLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGlvRGlzcGF0Y2hlci5ub3RpZnkodGhpcy5pZCwgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBUaGUgdmFsdWUgb2YgdGhpcyByYWRpbyBidXR0b24uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yYWRpb0dyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGVja2VkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZWQgdG8gbWF0Y2ggdGhlIHJhZGlvIGdyb3VwJ3MgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IHRoaXMucmFkaW9Hcm91cC52YWx1ZSA9PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuc2VsZWN0ZWQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiYWxpZ25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHJhZGlvLWJ1dHRvbiBzaG91bGQgYXBwZWFyIGJlZm9yZSBvciBhZnRlciB0aGUgbGFiZWwuXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGFsaWduIHJlZmVycyB0byB0aGUgY2hlY2tib3ggcmVsYXRpdmUgdG8gdGhlIGxhYmVsLCB3aGlsZSBsYWJlbFBvc2l0aW9uIHJlZmVycyB0byB0aGVcbiAgICAgICAgICAgIC8vIGxhYmVsIHJlbGF0aXZlIHRvIHRoZSBjaGVja2JveC4gQXMgc3VjaCwgdGhleSBhcmUgaW52ZXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09ICdhZnRlcicgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICh2ID09ICdzdGFydCcpID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwibGFiZWxQb3NpdGlvblwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYXBwZWFyIGFmdGVyIG9yIGJlZm9yZSB0aGUgcmFkaW8gYnV0dG9uLiBEZWZhdWx0cyB0byAnYWZ0ZXInICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsUG9zaXRpb24gfHwgKHRoaXMucmFkaW9Hcm91cCAmJiB0aGlzLnJhZGlvR3JvdXAubGFiZWxQb3NpdGlvbikgfHwgJ2FmdGVyJztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsUG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHJhZGlvIGJ1dHRvbiBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgfHwgKHRoaXMucmFkaW9Hcm91cCAhPSBudWxsICYmIHRoaXMucmFkaW9Hcm91cC5kaXNhYmxlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJlc2VuY2Ugb2YgKmFueSogZGlzYWJsZWQgdmFsdWUgbWFrZXMgdGhlIGNvbXBvbmVudCBkaXNhYmxlZCwgKmV4Y2VwdCogZm9yIGZhbHNlLlxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yYWRpb0dyb3VwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmFkaW8gaXMgaW5zaWRlIGEgcmFkaW8gZ3JvdXAsIGRldGVybWluZSBpZiBpdCBzaG91bGQgYmUgY2hlY2tlZFxuICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy5yYWRpb0dyb3VwLnZhbHVlID09PSB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgIC8vIENvcHkgbmFtZSBmcm9tIHBhcmVudCByYWRpbyBncm91cFxuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5yYWRpb0dyb3VwLm5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEaXNwYXRjaCBjaGFuZ2UgZXZlbnQgd2l0aCBjdXJyZW50IHZhbHVlLiAqL1xuICAgIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBNZFJhZGlvQ2hhbmdlKCk7XG4gICAgICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX2lzUmlwcGxlRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVSaXBwbGUgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdlIHVzZSBhIGhpZGRlbiBuYXRpdmUgaW5wdXQgZmllbGQgdG8gaGFuZGxlIGNoYW5nZXMgdG8gZm9jdXMgc3RhdGUgdmlhIGtleWJvYXJkIG5hdmlnYXRpb24sXG4gICAgICogd2l0aCB2aXN1YWwgcmVuZGVyaW5nIGRvbmUgc2VwYXJhdGVseS4gVGhlIG5hdGl2ZSBlbGVtZW50IGlzIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBvdmVyYWxsXG4gICAgICogc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIHJhZGlvIGJ1dHRvbi4gKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLl9pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgICAgIHRoaXMuX29uSW5wdXRGb2N1cygpO1xuICAgIH07XG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX29uSW5wdXRCbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLl90b3VjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZGlzcGF0Y2hlZCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBTaW5jZSB3ZSBhcmUgdXNpbmcgYSBsYWJlbCBlbGVtZW50IGFzIG91clxuICAgICAgICAvLyByb290IGNvbnRhaW5lciwgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBgcmFkaW8tYnV0dG9uYCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHJhZGlvIGJ1dHRvbiByZWNlaXZlZCBhIGNsaWNrIG9yIHRoZSBpbnB1dCByZWNvZ25pemVkIGFueSBjaGFuZ2UuXG4gICAgICogQ2xpY2tpbmcgb24gYSBsYWJlbCBlbGVtZW50LCB3aWxsIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQuXG4gICAgICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGNoYW5nZSBldmVudCwgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCwgd2lsbCBidWJibGUgdXAgYW5kXG4gICAgICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0LlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmFyIGdyb3VwVmFsdWVDaGFuZ2VkID0gdGhpcy5yYWRpb0dyb3VwICYmIHRoaXMudmFsdWUgIT0gdGhpcy5yYWRpb0dyb3VwLnZhbHVlO1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLl90b3VjaCgpO1xuICAgICAgICAgICAgaWYgKGdyb3VwVmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1yYWRpby1mb2N1c2VkJyksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiX2lzRm9jdXNlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdpZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtbGFiZWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImFyaWFMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLWxhYmVsbGVkYnknKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImFyaWFMYWJlbGxlZGJ5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcilcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoJ2lucHV0JyksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZilcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJfaW5wdXRFbGVtZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1yYWRpby1jaGVja2VkJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiYWxpZ25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImxhYmVsUG9zaXRpb25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1hdC1yYWRpby1kaXNhYmxlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRSYWRpb0J1dHRvbiA9IF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1yYWRpby1idXR0b24sIG1hdC1yYWRpby1idXR0b24nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIFthdHRyLmZvcl09XFxcImlucHV0SWRcXFwiIGNsYXNzPVxcXCJtYXQtcmFkaW8tbGFiZWxcXFwiICNsYWJlbD48ZGl2IGNsYXNzPVxcXCJtYXQtcmFkaW8tY29udGFpbmVyXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtcmFkaW8tb3V0ZXItY2lyY2xlXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtcmFkaW8taW5uZXItY2lyY2xlXFxcIj48L2Rpdj48ZGl2IG1kLXJpcHBsZSAqbmdJZj1cXFwiIV9pc1JpcHBsZURpc2FibGVkKClcXFwiIGNsYXNzPVxcXCJtYXQtcmFkaW8tcmlwcGxlXFxcIiBbbWRSaXBwbGVUcmlnZ2VyXT1cXFwibGFiZWxcXFwiIFttZFJpcHBsZUNlbnRlcmVkXT1cXFwidHJ1ZVxcXCIgW21kUmlwcGxlU3BlZWRGYWN0b3JdPVxcXCIwLjNcXFwiPjwvZGl2PjwvZGl2PjxpbnB1dCAjaW5wdXQgY2xhc3M9XFxcIm1hdC1yYWRpby1pbnB1dCBjZGstdmlzdWFsbHktaGlkZGVuXFxcIiB0eXBlPVxcXCJyYWRpb1xcXCIgW2lkXT1cXFwiaW5wdXRJZFxcXCIgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiYXJpYUxhYmVsXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJhcmlhTGFiZWxsZWRieVxcXCIgKGNoYW5nZSk9XFxcIl9vbklucHV0Q2hhbmdlKCRldmVudClcXFwiIChmb2N1cyk9XFxcIl9vbklucHV0Rm9jdXMoKVxcXCIgKGJsdXIpPVxcXCJfb25JbnB1dEJsdXIoKVxcXCIgKGNsaWNrKT1cXFwiX29uSW5wdXRDbGljaygkZXZlbnQpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtcmFkaW8tbGFiZWwtY29udGVudFxcXCIgW2NsYXNzLm1hdC1yYWRpby1sYWJlbC1iZWZvcmVdPVxcXCJsYWJlbFBvc2l0aW9uID09ICdiZWZvcmUnXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PC9sYWJlbD5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1yYWRpby1idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZn0ubWF0LXJhZGlvLWxhYmVse2N1cnNvcjpwb2ludGVyO2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6YmFzZWxpbmU7d2hpdGUtc3BhY2U6bm93cmFwfS5tYXQtcmFkaW8tY29udGFpbmVye2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MjBweDtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoyMHB4O3RvcDoycHh9Lm1hdC1yYWRpby1pbm5lci1jaXJjbGUsLm1hdC1yYWRpby1vdXRlci1jaXJjbGV7Ym94LXNpemluZzpib3JkZXItYm94O2hlaWdodDoyMHB4O2xlZnQ6MDt0b3A6MDt3aWR0aDoyMHB4O3Bvc2l0aW9uOmFic29sdXRlO2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtcmFkaW8tb3V0ZXItY2lyY2xle3RyYW5zaXRpb246Ym9yZGVyLWNvbG9yIGVhc2UgMjgwbXM7Ym9yZGVyLXdpZHRoOjJweDtib3JkZXItc3R5bGU6c29saWR9Lm1hdC1yYWRpby1pbm5lci1jaXJjbGV7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gZWFzZSAyODBtcyxiYWNrZ3JvdW5kLWNvbG9yIGVhc2UgMjgwbXM7dHJhbnNmb3JtOnNjYWxlKDApfS5tYXQtcmFkaW8tY2hlY2tlZCAubWF0LXJhZGlvLWlubmVyLWNpcmNsZXt0cmFuc2Zvcm06c2NhbGUoLjUpfS5tYXQtcmFkaW8tbGFiZWwtY29udGVudHtkaXNwbGF5OmlubGluZS1ibG9jaztvcmRlcjowO2xpbmUtaGVpZ2h0OmluaGVyaXQ7cGFkZGluZy1sZWZ0OjhweDtwYWRkaW5nLXJpZ2h0OjB9W2Rpcj1ydGxdIC5tYXQtcmFkaW8tbGFiZWwtY29udGVudHtwYWRkaW5nLXJpZ2h0OjhweDtwYWRkaW5nLWxlZnQ6MH0ubWF0LXJhZGlvLWxhYmVsLWNvbnRlbnQubWF0LXJhZGlvLWxhYmVsLWJlZm9yZXtvcmRlcjotMTtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjhweH1bZGlyPXJ0bF0gLm1hdC1yYWRpby1sYWJlbC1jb250ZW50Lm1hdC1yYWRpby1sYWJlbC1iZWZvcmV7cGFkZGluZy1yaWdodDowO3BhZGRpbmctbGVmdDo4cHh9Lm1hdC1yYWRpby1kaXNhYmxlZCwubWF0LXJhZGlvLWRpc2FibGVkIC5tYXQtcmFkaW8tbGFiZWx7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1yYWRpby1yaXBwbGV7cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTVweDt0b3A6LTE1cHg7cmlnaHQ6LTE1cHg7Ym90dG9tOi0xNXB4O2JvcmRlci1yYWRpdXM6NTAlO3otaW5kZXg6MTtwb2ludGVyLWV2ZW50czpub25lfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yYWRpby1idXR0b25dJzogJ3RydWUnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ1KDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDM0KCdkZXNpZ246cGFyYW10eXBlcycsIFtNZFJhZGlvR3JvdXAsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcl0pXG4gICAgXSwgTWRSYWRpb0J1dHRvbik7XG4gICAgcmV0dXJuIE1kUmFkaW9CdXR0b247XG59KCkpO1xudmFyIE1kUmFkaW9Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmFkaW9Nb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kUmFkaW9Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFJhZGlvTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kUmFkaW9Nb2R1bGUgPSBfX2RlY29yYXRlJDM0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZSwgTWRSaXBwbGVNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kUmFkaW9Hcm91cCwgTWRSYWRpb0J1dHRvbiwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtVTklRVUVfU0VMRUNUSU9OX0RJU1BBVENIRVJfUFJPVklERVIsIFZJRVdQT1JUX1JVTEVSX1BST1ZJREVSXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUmFkaW9Hcm91cCwgTWRSYWRpb0J1dHRvbl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFJhZGlvTW9kdWxlKTtcbiAgICByZXR1cm4gTWRSYWRpb01vZHVsZTtcbn0oKSk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIGtleWJvYXJkIGV2ZW50cyBmb3Igc2VsZWN0YWJsZSBsaXN0cy4gSWYgeW91IHBhc3MgaXQgYSBxdWVyeSBsaXN0XG4gKiBvZiBpdGVtcywgaXQgd2lsbCBzZXQgdGhlIGFjdGl2ZSBpdGVtIGNvcnJlY3RseSB3aGVuIGFycm93IGV2ZW50cyBvY2N1ci5cbiAqL1xudmFyIExpc3RLZXlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaXN0S2V5TWFuYWdlcihfaXRlbXMpIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBfaXRlbXM7XG4gICAgICAgIHRoaXMuX3RhYk91dCA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl93cmFwID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR1cm5zIG9uIHdyYXBwaW5nIG1vZGUsIHdoaWNoIGVuc3VyZXMgdGhhdCB0aGUgYWN0aXZlIGl0ZW0gd2lsbCB3cmFwIHRvXG4gICAgICogdGhlIG90aGVyIGVuZCBvZiBsaXN0IHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgaXRlbXMgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBMaXN0S2V5TWFuYWdlciB0aGF0IHRoZSBtZXRob2Qgd2FzIGNhbGxlZCBvbi5cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUud2l0aFdyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dyYXAgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBpdGVtIGF0IHRoZSBpbmRleCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpdGVtIHRvIGJlIHNldCBhcyBhY3RpdmUuXG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW0gPSB0aGlzLl9pdGVtcy50b0FycmF5KClbaW5kZXhdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gZGVwZW5kaW5nIG9uIHRoZSBrZXkgZXZlbnQgcGFzc2VkIGluLlxuICAgICAqIEBwYXJhbSBldmVudCBLZXlib2FyZCBldmVudCB0byBiZSB1c2VkIGZvciBkZXRlcm1pbmluZyB3aGljaCBlbGVtZW50IHNob3VsZCBiZSBhY3RpdmUuXG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLm9uS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5leHRJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJldmlvdXNJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhPTUU6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRU5EOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGFzdEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVEFCOlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBzaG91bGRuJ3QgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gb24gdGFiLlxuICAgICAgICAgICAgICAgIHRoaXMuX3RhYk91dC5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLCBcImFjdGl2ZUl0ZW1JbmRleFwiLCB7XG4gICAgICAgIC8qKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVJdGVtSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUsIFwiYWN0aXZlSXRlbVwiLCB7XG4gICAgICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUl0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgZmlyc3QgZW5hYmxlZCBpdGVtIGluIHRoZSBsaXN0LiAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5zZXRGaXJzdEl0ZW1BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KDAsIDEpO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHRvIHRoZSBsYXN0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuc2V0TGFzdEl0ZW1BY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEsIC0xKTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgbmV4dCBlbmFibGVkIGl0ZW0gaW4gdGhlIGxpc3QuICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLnNldE5leHRJdGVtQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtSW5kZXggPT09IG51bGwgPyB0aGlzLnNldEZpcnN0SXRlbUFjdGl2ZSgpIDogdGhpcy5fc2V0QWN0aXZlSXRlbUJ5RGVsdGEoMSk7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gYSBwcmV2aW91cyBlbmFibGVkIGl0ZW0gaW4gdGhlIGxpc3QuICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLnNldFByZXZpb3VzSXRlbUFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlSXRlbUluZGV4ID09PSBudWxsICYmIHRoaXMuX3dyYXAgPyB0aGlzLnNldExhc3RJdGVtQWN0aXZlKClcbiAgICAgICAgICAgIDogdGhpcy5fc2V0QWN0aXZlSXRlbUJ5RGVsdGEoLTEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNldHRpbmcgb2YgdGhlIGFjdGl2ZUl0ZW1JbmRleCB3aXRob3V0IGFueSBvdGhlciBlZmZlY3RzLlxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgbmV3IGFjdGl2ZUl0ZW1JbmRleC5cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUudXBkYXRlQWN0aXZlSXRlbUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZSwgXCJ0YWJPdXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFueSB0aW1lIHRoZSBUQUIga2V5IGlzIHByZXNzZWQsIHNvIGNvbXBvbmVudHMgY2FuIHJlYWN0XG4gICAgICAgICAqIHdoZW4gZm9jdXMgaXMgc2hpZnRlZCBvZmYgb2YgdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YWJPdXQuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGFjdGl2ZSBpdGVtLCBnaXZlbiBhIGxpc3Qgb2YgaXRlbXMgYW5kIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZVxuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgaXRlbSBhbmQgdGhlIG5ldyBhY3RpdmUgaXRlbS4gSXQgd2lsbCBjYWxjdWxhdGUgZGlmZmVyZW50bHlcbiAgICAgKiBkZXBlbmRpbmcgb24gd2hldGhlciB3cmFwIG1vZGUgaXMgdHVybmVkIG9uLlxuICAgICAqL1xuICAgIExpc3RLZXlNYW5hZ2VyLnByb3RvdHlwZS5fc2V0QWN0aXZlSXRlbUJ5RGVsdGEgPSBmdW5jdGlvbiAoZGVsdGEsIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcyA9PT0gdm9pZCAwKSB7IGl0ZW1zID0gdGhpcy5faXRlbXMudG9BcnJheSgpOyB9XG4gICAgICAgIHRoaXMuX3dyYXAgPyB0aGlzLl9zZXRBY3RpdmVJbldyYXBNb2RlKGRlbHRhLCBpdGVtcylcbiAgICAgICAgICAgIDogdGhpcy5fc2V0QWN0aXZlSW5EZWZhdWx0TW9kZShkZWx0YSwgaXRlbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gcHJvcGVybHkgZ2l2ZW4gXCJ3cmFwXCIgbW9kZS4gSW4gb3RoZXIgd29yZHMsIGl0IHdpbGwgY29udGludWUgdG8gbW92ZVxuICAgICAqIGRvd24gdGhlIGxpc3QgdW50aWwgaXQgZmluZHMgYW4gaXRlbSB0aGF0IGlzIG5vdCBkaXNhYmxlZCwgYW5kIGl0IHdpbGwgd3JhcCBpZiBpdFxuICAgICAqIGVuY291bnRlcnMgZWl0aGVyIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuX3NldEFjdGl2ZUluV3JhcE1vZGUgPSBmdW5jdGlvbiAoZGVsdGEsIGl0ZW1zKSB7XG4gICAgICAgIC8vIHdoZW4gYWN0aXZlIGl0ZW0gd291bGQgbGVhdmUgbWVudSwgd3JhcCB0byBiZWdpbm5pbmcgb3IgZW5kXG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9XG4gICAgICAgICAgICAodGhpcy5fYWN0aXZlSXRlbUluZGV4ICsgZGVsdGEgKyBpdGVtcy5sZW5ndGgpICUgaXRlbXMubGVuZ3RoO1xuICAgICAgICAvLyBza2lwIGFsbCBkaXNhYmxlZCBtZW51IGl0ZW1zIHJlY3Vyc2l2ZWx5IHVudGlsIGFuIGVuYWJsZWQgb25lIGlzIHJlYWNoZWRcbiAgICAgICAgaWYgKGl0ZW1zW3RoaXMuX2FjdGl2ZUl0ZW1JbmRleF0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbSh0aGlzLl9hY3RpdmVJdGVtSW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSBwcm9wZXJseSBnaXZlbiB0aGUgZGVmYXVsdCBtb2RlLiBJbiBvdGhlciB3b3JkcywgaXQgd2lsbFxuICAgICAqIGNvbnRpbnVlIHRvIG1vdmUgZG93biB0aGUgbGlzdCB1bnRpbCBpdCBmaW5kcyBhbiBpdGVtIHRoYXQgaXMgbm90IGRpc2FibGVkLiBJZlxuICAgICAqIGl0IGVuY291bnRlcnMgZWl0aGVyIGVuZCBvZiB0aGUgbGlzdCwgaXQgd2lsbCBzdG9wIGFuZCBub3Qgd3JhcC5cbiAgICAgKi9cbiAgICBMaXN0S2V5TWFuYWdlci5wcm90b3R5cGUuX3NldEFjdGl2ZUluRGVmYXVsdE1vZGUgPSBmdW5jdGlvbiAoZGVsdGEsIGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCArIGRlbHRhLCBkZWx0YSwgaXRlbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGZpcnN0IGVuYWJsZWQgaXRlbSBzdGFydGluZyBhdCB0aGUgaW5kZXggc3BlY2lmaWVkLiBJZiB0aGVcbiAgICAgKiBpdGVtIGlzIGRpc2FibGVkLCBpdCB3aWxsIG1vdmUgaW4gdGhlIGZhbGxiYWNrRGVsdGEgZGlyZWN0aW9uIHVudGlsIGl0IGVpdGhlclxuICAgICAqIGZpbmRzIGFuIGVuYWJsZWQgaXRlbSBvciBlbmNvdW50ZXJzIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICovXG4gICAgTGlzdEtleU1hbmFnZXIucHJvdG90eXBlLl9zZXRBY3RpdmVJdGVtQnlJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgZmFsbGJhY2tEZWx0YSwgaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSB0aGlzLl9pdGVtcy50b0FycmF5KCk7IH1cbiAgICAgICAgaWYgKCFpdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXRlbXNbaW5kZXhdLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpbmRleCArPSBmYWxsYmFja0RlbHRhO1xuICAgICAgICAgICAgaWYgKCFpdGVtc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXN0S2V5TWFuYWdlcjtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgRm9jdXNLZXlNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkOChGb2N1c0tleU1hbmFnZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRm9jdXNLZXlNYW5hZ2VyKGl0ZW1zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGl0ZW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBJdCBhbHNvIGFkZHMgZm9jdXNlcyB0aGUgbmV3bHkgYWN0aXZlIGl0ZW0uXG4gICAgICovXG4gICAgRm9jdXNLZXlNYW5hZ2VyLnByb3RvdHlwZS5zZXRBY3RpdmVJdGVtID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0QWN0aXZlSXRlbS5jYWxsKHRoaXMsIGluZGV4KTtcbiAgICAgICAgdGhpcy5hY3RpdmVJdGVtLmZvY3VzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9jdXNLZXlNYW5hZ2VyO1xufShMaXN0S2V5TWFuYWdlcikpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIGFsbCB0aGUgYW5pbWF0aW9ucyBmb3IgdGhlIG1kLXNlbGVjdCBjb21wb25lbnQsIHdpdGggZWFjaFxuICogY29uc3QgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgZm9yIG9uZSBhbmltYXRpb24uXG4gKlxuICogVGhlIHZhbHVlcyBiZWxvdyBtYXRjaCB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEFuZ3VsYXJKUyBNYXRlcmlhbCBtZC1zZWxlY3QgYW5pbWF0aW9uLlxuICovXG4vKipcbiAqIFRoaXMgYW5pbWF0aW9uIHNocmlua3MgdGhlIHBsYWNlaG9sZGVyIHRleHQgdG8gNzUlIG9mIGl0cyBub3JtYWwgc2l6ZSBhbmQgdHJhbnNsYXRlc1xuICogaXQgdG8gZWl0aGVyIHRoZSB0b3AgbGVmdCBjb3JuZXIgKGx0cikgb3IgdG9wIHJpZ2h0IGNvcm5lciAocnRsKSBvZiB0aGUgdHJpZ2dlcixcbiAqIGRlcGVuZGluZyBvbiB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGFwcGxpY2F0aW9uLlxuICovXG52YXIgdHJhbnNmb3JtUGxhY2Vob2xkZXIgPSBfYW5ndWxhcl9jb3JlLnRyaWdnZXIoJ3RyYW5zZm9ybVBsYWNlaG9sZGVyJywgW1xuICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ2Zsb2F0aW5nLWx0cicsIF9hbmd1bGFyX2NvcmUuc3R5bGUoe1xuICAgICAgICB0b3A6ICctMjJweCcsXG4gICAgICAgIGxlZnQ6ICctMnB4JyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDAuNzUpXCJcbiAgICB9KSksXG4gICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnZmxvYXRpbmctcnRsJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7XG4gICAgICAgIHRvcDogJy0yMnB4JyxcbiAgICAgICAgbGVmdDogJzJweCcsXG4gICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgwLjc1KVwiXG4gICAgfSkpLFxuICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbignKiA9PiAqJywgX2FuZ3VsYXJfY29yZS5hbmltYXRlKFwiNDAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSlcIikpXG5dKTtcbi8qKlxuICogVGhpcyBhbmltYXRpb24gdHJhbnNmb3JtcyB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbCBvbiBhbmQgb2ZmIHRoZSBwYWdlLlxuICpcbiAqIFdoZW4gdGhlIHBhbmVsIGlzIGF0dGFjaGVkIHRvIHRoZSBET00sIGl0IGV4cGFuZHMgaXRzIHdpZHRoIDMycHgsIHNjYWxlcyBpdCB1cCB0b1xuICogMTAwJSBvbiB0aGUgWSBheGlzLCBmYWRlcyBpbiBpdHMgYm9yZGVyLCBhbmQgdHJhbnNsYXRlcyBzbGlnaHRseSB1cCBhbmQgdG8gdGhlXG4gKiBzaWRlIHRvIGVuc3VyZSB0aGUgb3B0aW9uIHRleHQgY29ycmVjdGx5IG92ZXJsYXBzIHRoZSB0cmlnZ2VyIHRleHQuXG4gKlxuICogV2hlbiB0aGUgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIGl0IHNpbXBseSBmYWRlcyBvdXQgbGluZWFybHkuXG4gKi9cbnZhciB0cmFuc2Zvcm1QYW5lbCA9IF9hbmd1bGFyX2NvcmUudHJpZ2dlcigndHJhbnNmb3JtUGFuZWwnLCBbXG4gICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnc2hvd2luZycsIF9hbmd1bGFyX2NvcmUuc3R5bGUoe1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBtaW5XaWR0aDogJ2NhbGMoMTAwJSArIDMycHgpJyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZVkoMSlcIlxuICAgIH0pKSxcbiAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5zdHlsZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZCgwLCAwLCAwKSBzY2FsZVkoMClcIlxuICAgICAgICB9KSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5hbmltYXRlKFwiMTUwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSlcIilcbiAgICBdKSxcbiAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5hbmltYXRlKCcyNTBtcyAxMDBtcyBsaW5lYXInLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgb3BhY2l0eTogMCB9KSlcbiAgICBdKVxuXSk7XG4vKipcbiAqIFRoaXMgYW5pbWF0aW9uIGZhZGVzIGluIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGFuZCB0ZXh0IGNvbnRlbnQgb2YgdGhlXG4gKiBzZWxlY3QncyBvcHRpb25zLiBJdCBpcyB0aW1lIGRlbGF5ZWQgdG8gb2NjdXIgMTAwbXMgYWZ0ZXIgdGhlIG92ZXJsYXlcbiAqIHBhbmVsIGhhcyB0cmFuc2Zvcm1lZCBpbi5cbiAqL1xudmFyIGZhZGVJbkNvbnRlbnQgPSBfYW5ndWxhcl9jb3JlLnRyaWdnZXIoJ2ZhZGVJbkNvbnRlbnQnLCBbXG4gICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnc2hvd2luZycsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyBvcGFjaXR5OiAxIH0pKSxcbiAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJ3ZvaWQgPT4gc2hvd2luZycsIFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuYW5pbWF0ZShcIjE1MG1zIDEwMG1zIGN1YmljLWJlemllcigwLjU1LCAwLCAwLjU1LCAwLjIpXCIpXG4gICAgXSlcbl0pO1xuXG52YXIgX19kZWNvcmF0ZSQzNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzNiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNiA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogVGhlIGZvbGxvd2luZyBzdHlsZSBjb25zdGFudHMgYXJlIG5lY2Vzc2FyeSB0byBzYXZlIGhlcmUgaW4gb3JkZXJcbiAqIHRvIHByb3Blcmx5IGNhbGN1bGF0ZSB0aGUgYWxpZ25tZW50IG9mIHRoZSBzZWxlY3RlZCBvcHRpb24gb3ZlclxuICogdGhlIHRyaWdnZXIgZWxlbWVudC5cbiAqL1xuLyoqIFRoZSBmaXhlZCBoZWlnaHQgb2YgZXZlcnkgb3B0aW9uIGVsZW1lbnQuICovXG52YXIgU0VMRUNUX09QVElPTl9IRUlHSFQgPSA0ODtcbi8qKiBUaGUgbWF4IGhlaWdodCBvZiB0aGUgc2VsZWN0J3Mgb3ZlcmxheSBwYW5lbCAqL1xudmFyIFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUID0gMjU2O1xuLyoqIFRoZSBtYXggbnVtYmVyIG9mIG9wdGlvbnMgdmlzaWJsZSBhdCBvbmNlIGluIHRoZSBzZWxlY3QgcGFuZWwuICovXG52YXIgU0VMRUNUX01BWF9PUFRJT05TX0RJU1BMQVlFRCA9IDU7XG4vKiogVGhlIGZpeGVkIGhlaWdodCBvZiB0aGUgc2VsZWN0J3MgdHJpZ2dlciBlbGVtZW50LiAqL1xudmFyIFNFTEVDVF9UUklHR0VSX0hFSUdIVCA9IDMwO1xuLyoqXG4gKiBNdXN0IGFkanVzdCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gaGVpZ2h0IGJldHdlZW4gdGhlIG9wdGlvbiBhbmQgdGhlIHRyaWdnZXIsXG4gKiBzbyB0aGUgdGV4dCB3aWxsIGFsaWduIG9uIHRoZSB5IGF4aXMuXG4gKiAoU0VMRUNUX09QVElPTl9IRUlHSFQgKDQ4KSAtIFNFTEVDVF9UUklHR0VSX0hFSUdIVCAoMzApKSAvIDIgPSA5XG4gKi9cbnZhciBTRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UID0gOTtcbi8qKiBUaGUgcGFuZWwncyBwYWRkaW5nIG9uIHRoZSB4LWF4aXMgKi9cbnZhciBTRUxFQ1RfUEFORUxfUEFERElOR19YID0gMTY7XG4vKipcbiAqIFRoZSBwYW5lbCdzIHBhZGRpbmcgb24gdGhlIHktYXhpcy4gVGhpcyBwYWRkaW5nIGluZGljYXRlcyB0aGVyZSBhcmUgbW9yZVxuICogb3B0aW9ucyBhdmFpbGFibGUgaWYgeW91IHNjcm9sbC5cbiAqL1xudmFyIFNFTEVDVF9QQU5FTF9QQURESU5HX1kgPSAxNjtcbi8qKlxuICogVGhlIHNlbGVjdCBwYW5lbCB3aWxsIG9ubHkgXCJmaXRcIiBpbnNpZGUgdGhlIHZpZXdwb3J0IGlmIGl0IGlzIHBvc2l0aW9uZWQgYXRcbiAqIHRoaXMgdmFsdWUgb3IgbW9yZSBhd2F5IGZyb20gdGhlIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICovXG52YXIgU0VMRUNUX1BBTkVMX1ZJRVdQT1JUX1BBRERJTkcgPSA4O1xuLyoqIENoYW5nZSBldmVudCBvYmplY3QgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdCB2YWx1ZSBoYXMgY2hhbmdlZC4gKi9cbnZhciBNZFNlbGVjdENoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTZWxlY3RDaGFuZ2Uoc291cmNlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTWRTZWxlY3RDaGFuZ2U7XG59KCkpO1xudmFyIE1kU2VsZWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNlbGVjdChfZWxlbWVudCwgX3JlbmRlcmVyLCBfdmlld3BvcnRSdWxlciwgX2NoYW5nZURldGVjdG9yUmVmLCBfZGlyLCBfY29udHJvbCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyID0gX3ZpZXdwb3J0UnVsZXI7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9jb250cm9sID0gX2NvbnRyb2w7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgb3ZlcmxheSBwYW5lbCBpcyBvcGVuLiAqL1xuICAgICAgICB0aGlzLl9wYW5lbE9wZW4gPSBmYWxzZTtcbiAgICAgICAgLyoqIFN1YnNjcmlwdGlvbnMgdG8gb3B0aW9uIGV2ZW50cy4gKi9cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICAvKiogV2hldGhlciBmaWxsaW5nIG91dCB0aGUgc2VsZWN0IGlzIHJlcXVpcmVkIGluIHRoZSBmb3JtLiAgKi9cbiAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHNlbGVjdCBpcyBkaXNhYmxlZC4gICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IHBhbmVsLCBjYWxjdWxhdGVkIHRvIGNlbnRlciB0aGUgc2VsZWN0ZWQgb3B0aW9uLiAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSAwO1xuICAgICAgICAvKiogVGhlIGFuaW1hdGlvbiBzdGF0ZSBvZiB0aGUgcGxhY2Vob2xkZXIuICovXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSAnJztcbiAgICAgICAgLyoqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlcyAqL1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgICAgICAvKiogVmlldyAtPiBtb2RlbCBjYWxsYmFjayBjYWxsZWQgd2hlbiBzZWxlY3QgaGFzIGJlZW4gdG91Y2hlZCAqL1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKiBUaGUgSURzIG9mIGNoaWxkIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBhcmlhLW93bnMgYXR0cmlidXRlLiAqL1xuICAgICAgICB0aGlzLl9vcHRpb25JZHMgPSAnJztcbiAgICAgICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0IHBhbmVsJ3MgdHJhbnNmb3JtLW9yaWdpbiBwcm9wZXJ0eS4gKi9cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ3RvcCc7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBwYW5lbCdzIGFuaW1hdGlvbiBpcyBkb25lLiAqL1xuICAgICAgICB0aGlzLl9wYW5lbERvbmVBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB4LW9mZnNldCBvZiB0aGUgb3ZlcmxheSBwYW5lbCBpbiByZWxhdGlvbiB0byB0aGUgdHJpZ2dlcidzIHRvcCBzdGFydCBjb3JuZXIuXG4gICAgICAgICAqIFRoaXMgbXVzdCBiZSBhZGp1c3RlZCB0byBhbGlnbiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRleHQgb3ZlciB0aGUgdHJpZ2dlciB0ZXh0IHdoZW5cbiAgICAgICAgICogdGhlIHBhbmVsIG9wZW5zLiBXaWxsIGNoYW5nZSBiYXNlZCBvbiBMVFIgb3IgUlRMIHRleHQgZGlyZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgeS1vZmZzZXQgb2YgdGhlIG92ZXJsYXkgcGFuZWwgaW4gcmVsYXRpb24gdG8gdGhlIHRyaWdnZXIncyB0b3Agc3RhcnQgY29ybmVyLlxuICAgICAgICAgKiBUaGlzIG11c3QgYmUgYWRqdXN0ZWQgdG8gYWxpZ24gdGhlIHNlbGVjdGVkIG9wdGlvbiB0ZXh0IG92ZXIgdGhlIHRyaWdnZXIgdGV4dC5cbiAgICAgICAgICogd2hlbiB0aGUgcGFuZWwgb3BlbnMuIFdpbGwgY2hhbmdlIGJhc2VkIG9uIHRoZSB5LXBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcG9zaXRpb24gY29uZmlnIGVuc3VyZXMgdGhhdCB0aGUgdG9wIFwic3RhcnRcIiBjb3JuZXIgb2YgdGhlIG92ZXJsYXlcbiAgICAgICAgICogaXMgYWxpZ25lZCB3aXRoIHdpdGggdGhlIHRvcCBcInN0YXJ0XCIgb2YgdGhlIG9yaWdpbiBieSBkZWZhdWx0IChvdmVybGFwcGluZ1xuICAgICAgICAgKiB0aGUgdHJpZ2dlciBjb21wbGV0ZWx5KS4gSWYgdGhlIHBhbmVsIGNhbm5vdCBmaXQgYmVsb3cgdGhlIHRyaWdnZXIsIGl0XG4gICAgICAgICAqIHdpbGwgZmFsbCBiYWNrIHRvIGEgcG9zaXRpb24gYWJvdmUgdGhlIHRyaWdnZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wb3NpdGlvbnMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3JpZ2luWDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBvcmlnaW5ZOiAndG9wJyxcbiAgICAgICAgICAgICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IGhhcyBiZWVuIG9wZW5lZC4gKi9cbiAgICAgICAgdGhpcy5vbk9wZW4gPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0IGhhcyBiZWVuIGNsb3NlZC4gKi9cbiAgICAgICAgdGhpcy5vbkNsb3NlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdGVkIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQgYnkgdGhlIHVzZXIuICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9jb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sLnZhbHVlQWNjZXNzb3IgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwge1xuICAgICAgICAvKiogUGxhY2Vob2xkZXIgdG8gYmUgc2hvd24gaWYgbm8gdmFsdWUgaGFzIGJlZW4gc2VsZWN0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXI7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIE11c3Qgd2FpdCB0byByZWNvcmQgdGhlIHRyaWdnZXIgd2lkdGggdG8gZW5zdXJlIHBsYWNlaG9sZGVyIHdpZHRoIGlzIGluY2x1ZGVkLlxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RyaWdnZXJXaWR0aCA9IF90aGlzLl9nZXRXaWR0aCgpOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjb21wb25lbnQgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNlbGVjdC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIHJlcXVpcmVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9yZXF1aXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luaXRLZXlNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVN1YnNjcmlwdGlvbiA9IHRoaXMub3B0aW9ucy5jaGFuZ2VzLnN0YXJ0V2l0aChudWxsKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9jb250cm9sKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZXIgc2V0dGluZyB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgdGhlIFwiRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIC8vIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkXCIgZXJyb3JzIGZyb20gQW5ndWxhci5cbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fc2V0U2VsZWN0aW9uQnlWYWx1ZShfdGhpcy5fY29udHJvbC52YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RhYlN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdGFiU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBUb2dnbGVzIHRoZSBvdmVybGF5IHBhbmVsIG9wZW4gb3IgY2xvc2VkLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFuZWxPcGVuID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gICAgfTtcbiAgICAvKiogT3BlbnMgdGhlIG92ZXJsYXkgcGFuZWwuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlT3ZlcmxheVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyU3RhdGUgPSB0aGlzLl9pc1J0bCgpID8gJ2Zsb2F0aW5nLXJ0bCcgOiAnZmxvYXRpbmctbHRyJztcbiAgICAgICAgdGhpcy5fcGFuZWxPcGVuID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKiBDbG9zZXMgdGhlIG92ZXJsYXkgcGFuZWwgYW5kIGZvY3VzZXMgdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclN0YXRlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9jdXNIb3N0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZWxlY3QncyB2YWx1ZS4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSB0byBiZSB3cml0dGVuIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb25CeVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgc2VsZWN0J3MgdmFsdWVcbiAgICAgKiBjaGFuZ2VzIGZyb20gdXNlciBpbnB1dC4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYXZlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgc2VsZWN0IGlzIGJsdXJyZWRcbiAgICAgKiBieSB0aGUgdXNlci4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIHJlcXVpcmVkXG4gICAgICogdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgc2VsZWN0LiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgcmVxdWlyZWRcbiAgICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNEaXNhYmxlZCBTZXRzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2VsZWN0LnByb3RvdHlwZSwgXCJwYW5lbE9wZW5cIiwge1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIG92ZXJsYXkgcGFuZWwgaXMgb3Blbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuZWxPcGVuO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTZWxlY3QucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9pc1J0bCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgOiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBUaGUgd2lkdGggb2YgdGhlIHRyaWdnZXIgZWxlbWVudC4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gbWF0Y2hcbiAgICAgKiB0aGUgb3ZlcmxheSB3aWR0aCB0byB0aGUgdHJpZ2dlciB3aWR0aC5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJpZ2dlclJlY3QoKS53aWR0aDtcbiAgICB9O1xuICAgIC8qKiBFbnN1cmVzIHRoZSBwYW5lbCBvcGVucyBpZiBhY3RpdmF0ZWQgYnkgdGhlIGtleWJvYXJkLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5faGFuZGxlS2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRU5URVIgfHwgZXZlbnQua2V5Q29kZSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBwYW5lbCBlbGVtZW50IGlzIGZpbmlzaGVkIHRyYW5zZm9ybWluZyBpbiAodGhvdWdoIG5vdCBmYWRpbmcgaW4pLCBpdFxuICAgICAqIGVtaXRzIGFuIGV2ZW50IGFuZCBmb2N1c2VzIGFuIG9wdGlvbiBpZiB0aGUgcGFuZWwgaXMgb3Blbi5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uUGFuZWxEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbE9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzQ29ycmVjdE9wdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgcGFuZWwgY29udGVudCBpcyBkb25lIGZhZGluZyBpbiwgdGhlIF9wYW5lbERvbmVBbmltYXRpbmcgcHJvcGVydHkgaXNcbiAgICAgKiBzZXQgc28gdGhlIHByb3BlciBjbGFzcyBjYW4gYmUgYWRkZWQgdG8gdGhlIHBhbmVsLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fb25GYWRlSW5Eb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wYW5lbERvbmVBbmltYXRpbmcgPSB0aGlzLnBhbmVsT3BlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSB0b3VjaGVkIGNhbGxiYWNrIG9ubHkgaWYgdGhlIHBhbmVsIGlzIGNsb3NlZC4gT3RoZXJ3aXNlLCB0aGUgdHJpZ2dlciB3aWxsXG4gICAgICogXCJibHVyXCIgdG8gdGhlIHBhbmVsIHdoZW4gaXQgb3BlbnMsIGNhdXNpbmcgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhbmVsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBjb3JyZWN0IHRhYmluZGV4IGZvciB0aGUgc2VsZWN0IGRlcGVuZGluZyBvbiBkaXNhYmxlZCBzdGF0ZS4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldFRhYkluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICctMScgOiAnMCc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHNjcm9sbCBjb250YWluZXIuIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXJcbiAgICAgKiB0aGUgb3ZlcmxheSBwYW5lIGlzIGF0dGFjaGVkIG9yIHRoZSBzY3JvbGwgY29udGFpbmVyIGVsZW1lbnQgd2lsbCBub3QgeWV0IGJlXG4gICAgICogcHJlc2VudCBpbiB0aGUgRE9NLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5vdmVybGF5RGlyLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1zZWxlY3QtcGFuZWwnKTtcbiAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMuX3Njcm9sbFRvcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGVkIG9wdGlvbiBiYXNlZCBvbiBhIHZhbHVlLiBJZiBubyBvcHRpb24gY2FuIGJlXG4gICAgICogZm91bmQgd2l0aCB0aGUgZGVzaWduYXRlZCB2YWx1ZSwgdGhlIHNlbGVjdCB0cmlnZ2VyIGlzIGNsZWFyZWQuXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zZXRTZWxlY3Rpb25CeVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLnRvQXJyYXkoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHNlbGVjdGlvbiBpZiBubyBpdGVtIHdhcyBzZWxlY3RlZC5cbiAgICAgICAgdGhpcy5fY2xlYXJTZWxlY3Rpb24oKTtcbiAgICB9O1xuICAgIC8qKiBDbGVhcnMgdGhlIHNlbGVjdCB0cmlnZ2VyIGFuZCBkZXNlbGVjdHMgZXZlcnkgb3B0aW9uIGluIHRoZSBsaXN0LiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2xlYXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXBkYXRlT3B0aW9ucygpO1xuICAgIH07XG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9nZXRUcmlnZ2VyUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH07XG4gICAgLyoqIFNldHMgdXAgYSBrZXkgbWFuYWdlciB0byBsaXN0ZW4gdG8ga2V5Ym9hcmQgZXZlbnRzIG9uIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5faW5pdEtleU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIgPSBuZXcgRm9jdXNLZXlNYW5hZ2VyKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3RhYlN1YnNjcmlwdGlvbiA9IHRoaXMuX2tleU1hbmFnZXIudGFiT3V0LnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBEcm9wcyBjdXJyZW50IG9wdGlvbiBzdWJzY3JpcHRpb25zIGFuZCBJRHMgYW5kIHJlc2V0cyBmcm9tIHNjcmF0Y2guICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9yZXNldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2Ryb3BTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgIHRoaXMuX2xpc3RlblRvT3B0aW9ucygpO1xuICAgICAgICB0aGlzLl9zZXRPcHRpb25JZHMoKTtcbiAgICB9O1xuICAgIC8qKiBMaXN0ZW5zIHRvIHNlbGVjdGlvbiBldmVudHMgb24gZWFjaCBvcHRpb24uICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9saXN0ZW5Ub09wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBzdWIgPSBvcHRpb24ub25TZWxlY3Quc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5pc1VzZXJJbnB1dCAmJiBfdGhpcy5fc2VsZWN0ZWQgIT09IG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdENoYW5nZUV2ZW50KG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9vblNlbGVjdChvcHRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKHN1Yik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFVuc3Vic2NyaWJlcyBmcm9tIGFsbCBvcHRpb24gc3Vic2NyaXB0aW9ucy4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2Ryb3BTdWJzY3JpcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgfTtcbiAgICAvKiogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGFuIG9wdGlvbi4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2Uob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChuZXcgTWRTZWxlY3RDaGFuZ2UodGhpcywgb3B0aW9uLnZhbHVlKSk7XG4gICAgfTtcbiAgICAvKiogUmVjb3JkcyBvcHRpb24gSURzIHRvIHBhc3MgdG8gdGhlIGFyaWEtb3ducyBwcm9wZXJ0eS4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3NldE9wdGlvbklkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9uSWRzID0gdGhpcy5vcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24uaWQ7IH0pLmpvaW4oJyAnKTtcbiAgICB9O1xuICAgIC8qKiBXaGVuIGEgbmV3IG9wdGlvbiBpcyBzZWxlY3RlZCwgZGVzZWxlY3RzIHRoZSBvdGhlcnMgYW5kIGNsb3NlcyB0aGUgcGFuZWwuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9vblNlbGVjdCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBvcHRpb247XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5fc2V0VmFsdWVXaWR0aCgpO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclN0YXRlID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnBhbmVsT3Blbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRGVzZWxlY3QgZWFjaCBvcHRpb24gdGhhdCBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX3VwZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24gIT09IF90aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmRlc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTXVzdCBzZXQgdGhlIHdpZHRoIG9mIHRoZSBzZWxlY3RlZCBvcHRpb24ncyB2YWx1ZSBwcm9ncmFtbWF0aWNhbGx5XG4gICAgICogYmVjYXVzZSBpdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgYW5kIG90aGVyd2lzZSB3aWxsIG5vdCBjbGlwXG4gICAgICogb3ZlcmZsb3cuIFRoZSBzZWxlY3Rpb24gYXJyb3cgaXMgOXB4IHdpZGUsIGFkZCA0cHggb2YgcGFkZGluZyA9IDEzXG4gICAgICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9zZXRWYWx1ZVdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZFZhbHVlV2lkdGggPSB0aGlzLl90cmlnZ2VyV2lkdGggLSAxMztcbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBzZWxlY3RlZCBpdGVtLiBJZiBubyBvcHRpb24gaXMgc2VsZWN0ZWQsIGl0IHdpbGwgZm9jdXNcbiAgICAgKiB0aGUgZmlyc3QgaXRlbSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZm9jdXNDb3JyZWN0T3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKHRoaXMuX2dldE9wdGlvbkluZGV4KHRoaXMuc2VsZWN0ZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBob3N0IGVsZW1lbnQgd2hlbiB0aGUgcGFuZWwgY2xvc2VzLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fZm9jdXNIb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgfTtcbiAgICAvKiogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHByb3ZpZGVkIG9wdGlvbiBpbiB0aGUgb3B0aW9uIGxpc3QuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9nZXRPcHRpb25JbmRleCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgY3VycmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IChvcHRpb24gPT09IGN1cnJlbnQgPyBpbmRleCA6IHVuZGVmaW5lZCkgOiByZXN1bHQ7XG4gICAgICAgIH0sIHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICAvKiogQ2FsY3VsYXRlcyB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB4LSBhbmQgeS1vZmZzZXRzIG9mIHRoZSBvdmVybGF5IHBhbmVsLiAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gdGhpcy5faXNSdGwoKSA/IFNFTEVDVF9QQU5FTF9QQURESU5HX1ggOiAtU0VMRUNUX1BBTkVMX1BBRERJTkdfWDtcbiAgICAgICAgdmFyIHBhbmVsSGVpZ2h0ID0gTWF0aC5taW4odGhpcy5vcHRpb25zLmxlbmd0aCAqIFNFTEVDVF9PUFRJT05fSEVJR0hULCBTRUxFQ1RfUEFORUxfTUFYX0hFSUdIVCk7XG4gICAgICAgIHZhciBzY3JvbGxDb250YWluZXJIZWlnaHQgPSB0aGlzLm9wdGlvbnMubGVuZ3RoICogU0VMRUNUX09QVElPTl9IRUlHSFQ7XG4gICAgICAgIC8vIFRoZSBmYXJ0aGVzdCB0aGUgcGFuZWwgY2FuIGJlIHNjcm9sbGVkIGJlZm9yZSBpdCBoaXRzIHRoZSBib3R0b21cbiAgICAgICAgdmFyIG1heFNjcm9sbCA9IHNjcm9sbENvbnRhaW5lckhlaWdodCAtIHBhbmVsSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSB0aGlzLl9nZXRPcHRpb25JbmRleCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIC8vIFdlIG11c3QgbWFpbnRhaW4gYSBzY3JvbGwgYnVmZmVyIHNvIHRoZSBzZWxlY3RlZCBvcHRpb24gd2lsbCBiZSBzY3JvbGxlZCB0byB0aGVcbiAgICAgICAgICAgIC8vIGNlbnRlciBvZiB0aGUgb3ZlcmxheSBwYW5lbCByYXRoZXIgdGhhbiB0aGUgdG9wLlxuICAgICAgICAgICAgdmFyIHNjcm9sbEJ1ZmZlciA9IHBhbmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IHRoaXMuX2NhbGN1bGF0ZU92ZXJsYXlTY3JvbGwoc2VsZWN0ZWRJbmRleCwgc2Nyb2xsQnVmZmVyLCBtYXhTY3JvbGwpO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IHRoaXMuX2NhbGN1bGF0ZU92ZXJsYXlPZmZzZXQoc2VsZWN0ZWRJbmRleCwgc2Nyb2xsQnVmZmVyLCBtYXhTY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLCB0aGUgcGFuZWwgY2VudGVycyBvbiB0aGUgZmlyc3Qgb3B0aW9uLiBJbiB0aGlzIGNhc2UsXG4gICAgICAgICAgICAvLyB3ZSBtdXN0IG9ubHkgYWRqdXN0IGZvciB0aGUgaGVpZ2h0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgb3B0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgdHJpZ2dlciBlbGVtZW50LCB0aGVuIG11bHRpcGx5IGl0IGJ5IC0xIHRvIGVuc3VyZSB0aGUgcGFuZWwgbW92ZXNcbiAgICAgICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbiB1cCB0aGUgcGFnZS5cbiAgICAgICAgICAgIHRoaXMuX29mZnNldFkgPSAoU0VMRUNUX09QVElPTl9IRUlHSFQgLSBTRUxFQ1RfVFJJR0dFUl9IRUlHSFQpIC8gMiAqIC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoZWNrT3ZlcmxheVdpdGhpblZpZXdwb3J0KG1heFNjcm9sbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHNlbGVjdCdzIG92ZXJsYXkgcGFuZWwuXG4gICAgICpcbiAgICAgKiBBdHRlbXB0cyB0byBjZW50ZXIgdGhlIHNlbGVjdGVkIG9wdGlvbiBpbiB0aGUgcGFuZWwuIElmIHRoZSBvcHRpb24gaXNcbiAgICAgKiB0b28gaGlnaCBvciB0b28gbG93IGluIHRoZSBwYW5lbCB0byBiZSBzY3JvbGxlZCB0byB0aGUgY2VudGVyLCBpdCBjbGFtcHMgdGhlXG4gICAgICogc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBtaW4gb3IgbWF4IHNjcm9sbCBwb3NpdGlvbnMgcmVzcGVjdGl2ZWx5LlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2FsY3VsYXRlT3ZlcmxheVNjcm9sbCA9IGZ1bmN0aW9uIChzZWxlY3RlZEluZGV4LCBzY3JvbGxCdWZmZXIsIG1heFNjcm9sbCkge1xuICAgICAgICB2YXIgb3B0aW9uT2Zmc2V0RnJvbVNjcm9sbFRvcCA9IFNFTEVDVF9PUFRJT05fSEVJR0hUICogc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgdmFyIGhhbGZPcHRpb25IZWlnaHQgPSBTRUxFQ1RfT1BUSU9OX0hFSUdIVCAvIDI7XG4gICAgICAgIC8vIFN0YXJ0cyBhdCB0aGUgb3B0aW9uT2Zmc2V0RnJvbVNjcm9sbFRvcCwgd2hpY2ggc2Nyb2xscyB0aGUgb3B0aW9uIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBjb250YWluZXIsIHRoZW4gc3VidHJhY3RzIHRoZSBzY3JvbGwgYnVmZmVyIHRvIHNjcm9sbCB0aGUgb3B0aW9uIGRvd24gdG9cbiAgICAgICAgLy8gdGhlIGNlbnRlciBvZiB0aGUgb3ZlcmxheSBwYW5lbC4gSGFsZiB0aGUgb3B0aW9uIGhlaWdodCBtdXN0IGJlIHJlLWFkZGVkIHRvIHRoZVxuICAgICAgICAvLyBzY3JvbGxUb3Agc28gdGhlIG9wdGlvbiBpcyBjZW50ZXJlZCBiYXNlZCBvbiBpdHMgbWlkZGxlLCBub3QgaXRzIHRvcCBlZGdlLlxuICAgICAgICB2YXIgb3B0aW1hbFNjcm9sbFBvc2l0aW9uID0gb3B0aW9uT2Zmc2V0RnJvbVNjcm9sbFRvcCAtIHNjcm9sbEJ1ZmZlciArIGhhbGZPcHRpb25IZWlnaHQ7XG4gICAgICAgIHJldHVybiBjbGFtcFZhbHVlKDAsIG9wdGltYWxTY3JvbGxQb3NpdGlvbiwgbWF4U2Nyb2xsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHktb2Zmc2V0IG9mIHRoZSBzZWxlY3QncyBvdmVybGF5IHBhbmVsIGluIHJlbGF0aW9uIHRvIHRoZVxuICAgICAqIHRvcCBzdGFydCBjb3JuZXIgb2YgdGhlIHRyaWdnZXIuIEl0IGhhcyB0byBiZSBhZGp1c3RlZCBpbiBvcmRlciBmb3IgdGhlXG4gICAgICogc2VsZWN0ZWQgb3B0aW9uIHRvIGJlIGFsaWduZWQgb3ZlciB0aGUgdHJpZ2dlciB3aGVuIHRoZSBwYW5lbCBvcGVucy5cbiAgICAgKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2NhbGN1bGF0ZU92ZXJsYXlPZmZzZXQgPSBmdW5jdGlvbiAoc2VsZWN0ZWRJbmRleCwgc2Nyb2xsQnVmZmVyLCBtYXhTY3JvbGwpIHtcbiAgICAgICAgdmFyIG9wdGlvbk9mZnNldEZyb21QYW5lbFRvcDtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgICAgb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wID0gc2VsZWN0ZWRJbmRleCAqIFNFTEVDVF9PUFRJT05fSEVJR0hUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Njcm9sbFRvcCA9PT0gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3REaXNwbGF5ZWRJbmRleCA9IHRoaXMub3B0aW9ucy5sZW5ndGggLSBTRUxFQ1RfTUFYX09QVElPTlNfRElTUExBWUVEO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGlzcGxheUluZGV4ID0gc2VsZWN0ZWRJbmRleCAtIGZpcnN0RGlzcGxheWVkSW5kZXg7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBwYW5lbCBoZWlnaHQgaXMgbG9uZ2VyIHRoYW4gdGhlIGhlaWdodCBvZiB0aGUgb3B0aW9ucyBhbG9uZSxcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFsd2F5cyBleHRyYSBwYWRkaW5nIGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSBwYW5lbC4gV2hlblxuICAgICAgICAgICAgLy8gc2Nyb2xsZWQgdG8gdGhlIHZlcnkgYm90dG9tLCB0aGlzIHBhZGRpbmcgaXMgYXQgdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kXG4gICAgICAgICAgICAvLyBtdXN0IGJlIGFkZGVkIHRvIHRoZSBvZmZzZXQuXG4gICAgICAgICAgICBvcHRpb25PZmZzZXRGcm9tUGFuZWxUb3AgPVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGlzcGxheUluZGV4ICogU0VMRUNUX09QVElPTl9IRUlHSFQgKyBTRUxFQ1RfUEFORUxfUEFERElOR19ZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiB3YXMgc2Nyb2xsZWQgdG8gdGhlIG1pZGRsZSBvZiB0aGUgcGFuZWwgdXNpbmcgYSBzY3JvbGwgYnVmZmVyLFxuICAgICAgICAgICAgLy8gaXRzIG9mZnNldCB3aWxsIGJlIHRoZSBzY3JvbGwgYnVmZmVyIG1pbnVzIHRoZSBoYWxmIGhlaWdodCB0aGF0IHdhcyBhZGRlZCB0b1xuICAgICAgICAgICAgLy8gY2VudGVyIGl0LlxuICAgICAgICAgICAgb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wID0gc2Nyb2xsQnVmZmVyIC0gU0VMRUNUX09QVElPTl9IRUlHSFQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBmaW5hbCBvZmZzZXQgaXMgdGhlIG9wdGlvbidzIG9mZnNldCBmcm9tIHRoZSB0b3AsIGFkanVzdGVkIGZvciB0aGUgaGVpZ2h0XG4gICAgICAgIC8vIGRpZmZlcmVuY2UsIG11bHRpcGxpZWQgYnkgLTEgdG8gZW5zdXJlIHRoYXQgdGhlIG92ZXJsYXkgbW92ZXMgaW4gdGhlIGNvcnJlY3RcbiAgICAgICAgLy8gZGlyZWN0aW9uIHVwIHRoZSBwYWdlLlxuICAgICAgICByZXR1cm4gb3B0aW9uT2Zmc2V0RnJvbVBhbmVsVG9wICogLTEgLSBTRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlIGF0dGVtcHRlZCBvdmVybGF5IHBvc2l0aW9uIHdpbGwgZml0IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gICAgICogSWYgaXQgd2lsbCBub3QgZml0LCB0cmllcyB0byBhZGp1c3QgdGhlIHNjcm9sbCBwb3NpdGlvbiBhbmQgdGhlIGFzc29jaWF0ZWRcbiAgICAgKiB5LW9mZnNldCBzbyB0aGUgcGFuZWwgY2FuIG9wZW4gZnVsbHkgb24tc2NyZWVuLiBJZiBpdCBzdGlsbCB3b24ndCBmaXQsXG4gICAgICogc2V0cyB0aGUgb2Zmc2V0IGJhY2sgdG8gMCB0byBhbGxvdyB0aGUgZmFsbGJhY2sgcG9zaXRpb24gdG8gdGFrZSBvdmVyLlxuICAgICAqL1xuICAgIE1kU2VsZWN0LnByb3RvdHlwZS5fY2hlY2tPdmVybGF5V2l0aGluVmlld3BvcnQgPSBmdW5jdGlvbiAobWF4U2Nyb2xsKSB7XG4gICAgICAgIHZhciB2aWV3cG9ydFJlY3QgPSB0aGlzLl92aWV3cG9ydFJ1bGVyLmdldFZpZXdwb3J0UmVjdCgpO1xuICAgICAgICB2YXIgdHJpZ2dlclJlY3QgPSB0aGlzLl9nZXRUcmlnZ2VyUmVjdCgpO1xuICAgICAgICB2YXIgdG9wU3BhY2VBdmFpbGFibGUgPSB0cmlnZ2VyUmVjdC50b3AgLSBTRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORztcbiAgICAgICAgdmFyIGJvdHRvbVNwYWNlQXZhaWxhYmxlID0gdmlld3BvcnRSZWN0LmhlaWdodCAtIHRyaWdnZXJSZWN0LmJvdHRvbSAtIFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HO1xuICAgICAgICB2YXIgcGFuZWxIZWlnaHRUb3AgPSBNYXRoLmFicyh0aGlzLl9vZmZzZXRZKTtcbiAgICAgICAgdmFyIHRvdGFsUGFuZWxIZWlnaHQgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMubGVuZ3RoICogU0VMRUNUX09QVElPTl9IRUlHSFQsIFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUKTtcbiAgICAgICAgdmFyIHBhbmVsSGVpZ2h0Qm90dG9tID0gdG90YWxQYW5lbEhlaWdodCAtIHBhbmVsSGVpZ2h0VG9wIC0gdHJpZ2dlclJlY3QuaGVpZ2h0O1xuICAgICAgICBpZiAocGFuZWxIZWlnaHRCb3R0b20gPiBib3R0b21TcGFjZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0UGFuZWxVcChwYW5lbEhlaWdodEJvdHRvbSwgYm90dG9tU3BhY2VBdmFpbGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhbmVsSGVpZ2h0VG9wID4gdG9wU3BhY2VBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkanVzdFBhbmVsRG93bihwYW5lbEhlaWdodFRvcCwgdG9wU3BhY2VBdmFpbGFibGUsIG1heFNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5CYXNlZE9uT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBBZGp1c3RzIHRoZSBvdmVybGF5IHBhbmVsIHVwIHRvIGZpdCBpbiB0aGUgdmlld3BvcnQuICovXG4gICAgTWRTZWxlY3QucHJvdG90eXBlLl9hZGp1c3RQYW5lbFVwID0gZnVuY3Rpb24gKHBhbmVsSGVpZ2h0Qm90dG9tLCBib3R0b21TcGFjZUF2YWlsYWJsZSkge1xuICAgICAgICB2YXIgZGlzdGFuY2VCZWxvd1ZpZXdwb3J0ID0gcGFuZWxIZWlnaHRCb3R0b20gLSBib3R0b21TcGFjZUF2YWlsYWJsZTtcbiAgICAgICAgLy8gU2Nyb2xscyB0aGUgcGFuZWwgdXAgYnkgdGhlIGRpc3RhbmNlIGl0IHdhcyBleHRlbmRpbmcgcGFzdCB0aGUgYm91bmRhcnksIHRoZW5cbiAgICAgICAgLy8gYWRqdXN0cyB0aGUgb2Zmc2V0IGJ5IHRoYXQgYW1vdW50IHRvIG1vdmUgdGhlIHBhbmVsIHVwIGludG8gdGhlIHZpZXdwb3J0LlxuICAgICAgICB0aGlzLl9zY3JvbGxUb3AgLT0gZGlzdGFuY2VCZWxvd1ZpZXdwb3J0O1xuICAgICAgICB0aGlzLl9vZmZzZXRZIC09IGRpc3RhbmNlQmVsb3dWaWV3cG9ydDtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luQmFzZWRPbk9wdGlvbigpO1xuICAgICAgICAvLyBJZiB0aGUgcGFuZWwgaXMgc2Nyb2xsZWQgdG8gdGhlIHZlcnkgdG9wLCBpdCB3b24ndCBiZSBhYmxlIHRvIGZpdCB0aGUgcGFuZWxcbiAgICAgICAgLy8gYnkgc2Nyb2xsaW5nLCBzbyBzZXQgdGhlIG9mZnNldCB0byAwIHRvIGFsbG93IHRoZSBmYWxsYmFjayBwb3NpdGlvbiB0byB0YWtlXG4gICAgICAgIC8vIGVmZmVjdC5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbFRvcCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSBcIjUwJSBib3R0b20gMHB4XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBBZGp1c3RzIHRoZSBvdmVybGF5IHBhbmVsIGRvd24gdG8gZml0IGluIHRoZSB2aWV3cG9ydC4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2FkanVzdFBhbmVsRG93biA9IGZ1bmN0aW9uIChwYW5lbEhlaWdodFRvcCwgdG9wU3BhY2VBdmFpbGFibGUsIG1heFNjcm9sbCkge1xuICAgICAgICB2YXIgZGlzdGFuY2VBYm92ZVZpZXdwb3J0ID0gcGFuZWxIZWlnaHRUb3AgLSB0b3BTcGFjZUF2YWlsYWJsZTtcbiAgICAgICAgLy8gU2Nyb2xscyB0aGUgcGFuZWwgZG93biBieSB0aGUgZGlzdGFuY2UgaXQgd2FzIGV4dGVuZGluZyBwYXN0IHRoZSBib3VuZGFyeSwgdGhlblxuICAgICAgICAvLyBhZGp1c3RzIHRoZSBvZmZzZXQgYnkgdGhhdCBhbW91bnQgdG8gbW92ZSB0aGUgcGFuZWwgZG93biBpbnRvIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9wICs9IGRpc3RhbmNlQWJvdmVWaWV3cG9ydDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WSArPSBkaXN0YW5jZUFib3ZlVmlld3BvcnQ7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbkJhc2VkT25PcHRpb24oKTtcbiAgICAgICAgLy8gSWYgdGhlIHBhbmVsIGlzIHNjcm9sbGVkIHRvIHRoZSB2ZXJ5IGJvdHRvbSwgaXQgd29uJ3QgYmUgYWJsZSB0byBmaXQgdGhlXG4gICAgICAgIC8vIHBhbmVsIGJ5IHNjcm9sbGluZywgc28gc2V0IHRoZSBvZmZzZXQgdG8gMCB0byBhbGxvdyB0aGUgZmFsbGJhY2sgcG9zaXRpb25cbiAgICAgICAgLy8gdG8gdGFrZSBlZmZlY3QuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSBtYXhTY3JvbGw7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRZID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IFwiNTAlIHRvcCAwcHhcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIHRyYW5zZm9ybSBvcmlnaW4gcG9pbnQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIG9wdGlvbi4gKi9cbiAgICBNZFNlbGVjdC5wcm90b3R5cGUuX2dldE9yaWdpbkJhc2VkT25PcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmlnaW5ZID0gTWF0aC5hYnModGhpcy5fb2Zmc2V0WSkgLSBTRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UICsgU0VMRUNUX09QVElPTl9IRUlHSFQgLyAyO1xuICAgICAgICByZXR1cm4gXCI1MCUgXCIgKyBvcmlnaW5ZICsgXCJweCAwcHhcIjtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgndHJpZ2dlcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNignZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYpXG4gICAgXSwgTWRTZWxlY3QucHJvdG90eXBlLCBcInRyaWdnZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUpXG4gICAgXSwgTWRTZWxlY3QucHJvdG90eXBlLCBcIm92ZXJsYXlEaXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRPcHRpb24pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNignZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZFNlbGVjdC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNlbGVjdC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2VsZWN0LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTZWxlY3QucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNignZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcilcbiAgICBdLCBNZFNlbGVjdC5wcm90b3R5cGUsIFwib25PcGVuXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKVxuICAgIF0sIE1kU2VsZWN0LnByb3RvdHlwZSwgXCJvbkNsb3NlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKVxuICAgIF0sIE1kU2VsZWN0LnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBNZFNlbGVjdCA9IF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1zZWxlY3QsIG1hdC1zZWxlY3QnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXNlbGVjdC10cmlnZ2VyXFxcIiBjZGstb3ZlcmxheS1vcmlnaW4gKGNsaWNrKT1cXFwidG9nZ2xlKClcXFwiICNvcmlnaW49XFxcImNka092ZXJsYXlPcmlnaW5cXFwiICN0cmlnZ2VyPjxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LXBsYWNlaG9sZGVyXFxcIiBbY2xhc3MubWF0LWZsb2F0aW5nLXBsYWNlaG9sZGVyXT1cXFwidGhpcy5zZWxlY3RlZFxcXCIgW0B0cmFuc2Zvcm1QbGFjZWhvbGRlcl09XFxcIl9wbGFjZWhvbGRlclN0YXRlXFxcIiBbc3R5bGUud2lkdGgucHhdPVxcXCJfc2VsZWN0ZWRWYWx1ZVdpZHRoXFxcIj57eyBwbGFjZWhvbGRlciB9fSA8L3NwYW4+PHNwYW4gY2xhc3M9XFxcIm1hdC1zZWxlY3QtdmFsdWVcXFwiICpuZ0lmPVxcXCJzZWxlY3RlZFxcXCI+PHNwYW4gY2xhc3M9XFxcIm1hdC1zZWxlY3QtdmFsdWUtdGV4dFxcXCI+e3sgc2VsZWN0ZWQ/LnZpZXdWYWx1ZSB9fTwvc3Bhbj4gPC9zcGFuPjxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LWFycm93XFxcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVxcXCJtYXQtc2VsZWN0LXVuZGVybGluZVxcXCI+PC9zcGFuPjwvZGl2Pjx0ZW1wbGF0ZSBjZGstY29ubmVjdGVkLW92ZXJsYXkgW29yaWdpbl09XFxcIm9yaWdpblxcXCIgW29wZW5dPVxcXCJwYW5lbE9wZW5cXFwiIGhhc0JhY2tkcm9wIChiYWNrZHJvcENsaWNrKT1cXFwiY2xvc2UoKVxcXCIgYmFja2Ryb3BDbGFzcz1cXFwiY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3BcXFwiIFtwb3NpdGlvbnNdPVxcXCJfcG9zaXRpb25zXFxcIiBbbWluV2lkdGhdPVxcXCJfdHJpZ2dlcldpZHRoXFxcIiBbb2Zmc2V0WV09XFxcIl9vZmZzZXRZXFxcIiBbb2Zmc2V0WF09XFxcIl9vZmZzZXRYXFxcIiAoYXR0YWNoKT1cXFwiX3NldFNjcm9sbFRvcCgpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtc2VsZWN0LXBhbmVsXFxcIiBbQHRyYW5zZm9ybVBhbmVsXT1cXFwiJ3Nob3dpbmcnXFxcIiAoQHRyYW5zZm9ybVBhbmVsLmRvbmUpPVxcXCJfb25QYW5lbERvbmUoKVxcXCIgKGtleWRvd24pPVxcXCJfa2V5TWFuYWdlci5vbktleWRvd24oJGV2ZW50KVxcXCIgW3N0eWxlLnRyYW5zZm9ybU9yaWdpbl09XFxcIl90cmFuc2Zvcm1PcmlnaW5cXFwiIFtjbGFzcy5tYXQtc2VsZWN0LXBhbmVsLWRvbmUtYW5pbWF0aW5nXT1cXFwiX3BhbmVsRG9uZUFuaW1hdGluZ1xcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNlbGVjdC1jb250ZW50XFxcIiBbQGZhZGVJbkNvbnRlbnRdPVxcXCInc2hvd2luZydcXFwiIChAZmFkZUluQ29udGVudC5kb25lKT1cXFwiX29uRmFkZUluRG9uZSgpXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PC9kaXY+PC90ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1zZWxlY3R7ZGlzcGxheTppbmxpbmUtYmxvY2s7b3V0bGluZTowO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWZ9Lm1hdC1zZWxlY3QtdHJpZ2dlcntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2hlaWdodDozMHB4O21pbi13aWR0aDoxMTJweDtjdXJzb3I6cG9pbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7Zm9udC1zaXplOjE2cHh9W2FyaWEtZGlzYWJsZWQ9dHJ1ZV0gLm1hdC1zZWxlY3QtdHJpZ2dlcntjdXJzb3I6ZGVmYXVsdDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9Lm1hdC1zZWxlY3QtdW5kZXJsaW5le3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO2hlaWdodDoxcHh9W2FyaWEtZGlzYWJsZWQ9dHJ1ZV0gLm1hdC1zZWxlY3QtdW5kZXJsaW5le2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMCwwLDAsLjI2KSAwLHJnYmEoMCwwLDAsLjI2KSAzMyUsdHJhbnNwYXJlbnQgMCk7YmFja2dyb3VuZC1zaXplOjRweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgYm90dG9tfS5tYXQtc2VsZWN0LXBsYWNlaG9sZGVye3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6MCAycHg7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcDtmbGV4LWdyb3c6MX0ubWF0LXNlbGVjdC1wbGFjZWhvbGRlci5tYXQtZmxvYXRpbmctcGxhY2Vob2xkZXJ7dG9wOi0yMnB4O2xlZnQ6LTJweDt0ZXh0LWFsaWduOmxlZnQ7dHJhbnNmb3JtOnNjYWxlKC43NSl9W2Rpcj1ydGxdIC5tYXQtc2VsZWN0LXBsYWNlaG9sZGVye3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wfVtkaXI9cnRsXSAubWF0LXNlbGVjdC1wbGFjZWhvbGRlci5tYXQtZmxvYXRpbmctcGxhY2Vob2xkZXJ7bGVmdDoycHg7dGV4dC1hbGlnbjpyaWdodH1bYXJpYS1yZXF1aXJlZD10cnVlXSAubWF0LXNlbGVjdC1wbGFjZWhvbGRlcjo6YWZ0ZXJ7Y29udGVudDonKid9Lm1hdC1zZWxlY3QtdmFsdWV7cG9zaXRpb246YWJzb2x1dGU7bWF4LXdpZHRoOmNhbGMoMTAwJSAtIDE4cHgpO2ZsZXgtZ3JvdzoxO3RvcDowO2xlZnQ6MDtib3R0b206MDtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfVtkaXI9cnRsXSAubWF0LXNlbGVjdC12YWx1ZXtsZWZ0OmF1dG87cmlnaHQ6MH0ubWF0LXNlbGVjdC12YWx1ZS10ZXh0e3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdy14OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2xpbmUtaGVpZ2h0OjMwcHh9Lm1hdC1zZWxlY3QtYXJyb3d7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXItbGVmdDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItdG9wOjVweCBzb2xpZDttYXJnaW46MCA0cHh9Lm1hdC1zZWxlY3QtcGFuZWx7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDoxMTJweDttYXgtd2lkdGg6MjgwcHg7b3ZlcmZsb3c6YXV0bzstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7bWF4LWhlaWdodDoyNTZweH1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LXNlbGVjdC1wYW5lbHtvdXRsaW5lOnNvbGlkIDFweH19XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3Rib3gnLFxuICAgICAgICAgICAgICAgICdbYXR0ci50YWJpbmRleF0nOiAnX2dldFRhYkluZGV4KCknLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWxhYmVsXSc6ICdwbGFjZWhvbGRlcicsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtcmVxdWlyZWRdJzogJ3JlcXVpcmVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdkaXNhYmxlZC50b1N0cmluZygpJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1pbnZhbGlkXSc6ICdfY29udHJvbD8uaW52YWxpZCB8fCBcImZhbHNlXCInLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLW93bnNdJzogJ19vcHRpb25JZHMnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNlbGVjdC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNlbGVjdF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdfaGFuZGxlS2V5ZG93bigkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19vbkJsdXIoKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUGFuZWwsXG4gICAgICAgICAgICAgICAgZmFkZUluQ29udGVudFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRTZWxlY3QnLFxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ2KDQsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksXG4gICAgICAgIF9fcGFyYW0kNig1LCBfYW5ndWxhcl9jb3JlLlNlbGYoKSksXG4gICAgICAgIF9fcGFyYW0kNig1LCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBWaWV3cG9ydFJ1bGVyLCBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdG9yUmVmLCBEaXIsIF9hbmd1bGFyX2Zvcm1zLk5nQ29udHJvbF0pXG4gICAgXSwgTWRTZWxlY3QpO1xuICAgIHJldHVybiBNZFNlbGVjdDtcbn0oKSk7XG4vKiogQ2xhbXBzIGEgdmFsdWUgbiBiZXR3ZWVuIG1pbiBhbmQgbWF4IHZhbHVlcy4gKi9cbmZ1bmN0aW9uIGNsYW1wVmFsdWUobWluLCBuLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBuKSwgbWF4KTtcbn1cblxudmFyIF9fZGVjb3JhdGUkMzUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZFNlbGVjdE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTZWxlY3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kU2VsZWN0TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRTZWxlY3RNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFNlbGVjdE1vZHVsZSA9IF9fZGVjb3JhdGUkMzUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBPdmVybGF5TW9kdWxlLCBNZE9wdGlvbk1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRTZWxlY3QsIE1kT3B0aW9uTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2VsZWN0XSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM1KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2VsZWN0TW9kdWxlKTtcbiAgICByZXR1cm4gTWRTZWxlY3RNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQzNyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzNyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1EX1NMSURFX1RPR0dMRV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBfYW5ndWxhcl9mb3Jtcy5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kU2xpZGVUb2dnbGU7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLy8gQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgdGhlIE1kU2xpZGVUb2dnbGUgY29tcG9uZW50LlxudmFyIE1kU2xpZGVUb2dnbGVDaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVUb2dnbGVDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFNsaWRlVG9nZ2xlQ2hhbmdlO1xufSgpKTtcbi8vIEluY3JlYXNpbmcgaW50ZWdlciBmb3IgZ2VuZXJhdGluZyB1bmlxdWUgaWRzIGZvciBzbGlkZS10b2dnbGUgY29tcG9uZW50cy5cbnZhciBuZXh0SWQkMSA9IDA7XG4vKipcbiAqIFR3by1zdGF0ZSBjb250cm9sLCB3aGljaCBjYW4gYmUgYWxzbyBjYWxsZWQgYHN3aXRjaGAuXG4gKi9cbnZhciBNZFNsaWRlVG9nZ2xlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlVG9nZ2xlKF9lbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvLyBBIHVuaXF1ZSBpZCBmb3IgdGhlIHNsaWRlLXRvZ2dsZS4gQnkgZGVmYXVsdCB0aGUgaWQgaXMgYXV0by1nZW5lcmF0ZWQuXG4gICAgICAgIHRoaXMuX3VuaXF1ZUlkID0gXCJtZC1zbGlkZS10b2dnbGUtXCIgKyArK25leHRJZCQxO1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgICAvLyBOZWVkcyB0byBiZSBwdWJsaWMgdG8gc3VwcG9ydCBBT1QgY29tcGlsYXRpb24gKGFzIGhvc3QgYmluZGluZykuXG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIC8qKiBOYW1lIHZhbHVlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBwcmVzZW50ICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIC8qKiBBIHVuaXF1ZSBpZCBmb3IgdGhlIHNsaWRlLXRvZ2dsZSBpbnB1dC4gSWYgbm9uZSBpcyBzdXBwbGllZCwgaXQgd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC4gKi9cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3VuaXF1ZUlkO1xuICAgICAgICAvKiogVXNlZCB0byBzcGVjaWZ5IHRoZSB0YWJJbmRleCB2YWx1ZSBmb3IgdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cbiAgICAgICAgdGhpcy50YWJJbmRleCA9IDA7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYXBwZWFyIGFmdGVyIG9yIGJlZm9yZSB0aGUgc2xpZGUtdG9nZ2xlLiBEZWZhdWx0cyB0byAnYWZ0ZXInICovXG4gICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICdhZnRlcic7XG4gICAgICAgIC8qKiBVc2VkIHRvIHNldCB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSBudWxsO1xuICAgICAgICAvKiogVXNlZCB0byBzZXQgdGhlIGFyaWEtbGFiZWxsZWRieSBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cbiAgICAgICAgdGhpcy5hcmlhTGFiZWxsZWRieSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogQW4gZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIGVhY2ggdGltZSB0aGUgc2xpZGUtdG9nZ2xlIGNoYW5nZXMgaXRzIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlLXRvZ2dsZSBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgc2xpZGUtdG9nZ2xlIGlzIHJlcXVpcmVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9yZXF1aXJlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJpbnB1dElkXCIsIHtcbiAgICAgICAgLyoqIFJldHVybnMgdGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuaWQgfHwgdGhpcy5fdW5pcXVlSWQpICsgXCItaW5wdXRcIjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zbGlkZVJlbmRlcmVyID0gbmV3IFNsaWRlVG9nZ2xlUmVuZGVyZXIodGhpcy5fZWxlbWVudFJlZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgb25DaGFuZ2VFdmVudCBtZXRob2Qgd2lsbCBiZSBhbHNvIGNhbGxlZCBvbiBjbGljay5cbiAgICAgKiBUaGlzIGlzIGJlY2F1c2UgZXZlcnl0aGluZyBmb3IgdGhlIHNsaWRlLXRvZ2dsZSBpcyB3cmFwcGVkIGluc2lkZSBvZiBhIGxhYmVsLFxuICAgICAqIHdoaWNoIHRyaWdnZXJzIGEgb25DaGFuZ2UgZXZlbnQgb24gY2xpY2suXG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGNoYW5nZSBldmVudCwgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCwgd2lsbCBidWJibGUgdXAgYW5kXG4gICAgICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgY29tcG9uZW50J3MgYGNoYW5nZWAgb3V0cHV0LlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gT25jZSBhIGRyYWcgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLCB3ZSBkbyBub3Qgd2FudCB0byB0b2dnbGUgdGhlIHNsaWRlLXRvZ2dsZSBvbiBhIGNsaWNrLlxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMuX3NsaWRlUmVuZGVyZXIuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgLy8gRW1pdCBvdXIgY3VzdG9tIGNoYW5nZSBldmVudCBpZiB0aGUgbmF0aXZlIGlucHV0IGVtaXR0ZWQgb25lLlxuICAgICAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIG9ubHkgZW1pdCBpdCwgaWYgdGhlIG5hdGl2ZSBpbnB1dCB0cmlnZ2VyZWQgb25lLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIHdoZW4gdGhlIGBjaGVja2VkYCB2YXJpYWJsZSBjaGFuZ2VzIGZvciBleGFtcGxlLlxuICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBkaXNwYXRjaGVkIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuIFNpbmNlIHdlIGFyZSB1c2luZyBhIGxhYmVsIGVsZW1lbnQgYXMgb3VyXG4gICAgICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGBzbGlkZS10b2dnbGVgIHdpbGwgYmUgZXhlY3V0ZWQgdHdpY2UuXG4gICAgICAgIC8vIFRoZSByZWFsIGNsaWNrIGV2ZW50IHdpbGwgYnViYmxlIHVwLCBhbmQgdGhlIGdlbmVyYXRlZCBjbGljayBldmVudCBhbHNvIHRyaWVzIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGxlYWQgdG8gbXVsdGlwbGUgY2xpY2sgZXZlbnRzLlxuICAgICAgICAvLyBQcmV2ZW50aW5nIGJ1YmJsaW5nIGZvciB0aGUgc2Vjb25kIGV2ZW50IHdpbGwgc29sdmUgdGhhdCBpc3N1ZS5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fc2V0TW91c2Vkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXZSBvbmx5ICpzaG93KiB0aGUgZm9jdXMgc3R5bGUgd2hlbiBmb2N1cyBoYXMgY29tZSB0byB0aGUgYnV0dG9uIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAgICAgIC8vIFRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYyBpcyBzaWxlbnQgb24gdGhpcyB0b3BpYywgYW5kIHdpdGhvdXQgZG9pbmcgdGhpcywgdGhlXG4gICAgICAgIC8vIGJ1dHRvbiBjb250aW51ZXMgdG8gbG9vayA6YWN0aXZlIGFmdGVyIGNsaWNraW5nLlxuICAgICAgICAvLyBAc2VlIGh0dHA6Ly9tYXJjeXN1dHRvbi5jb20vYnV0dG9uLWZvY3VzLWhlbGwvXG4gICAgICAgIHRoaXMuX2lzTW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTsgfSwgMTAwKTtcbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgZm9jdXMgLyByaXBwbGUgaW5kaWNhdG9yIHdoZW4gdGhlIGZvY3VzIHdhcyBub3QgdHJpZ2dlcmVkIGJ5IGEgbW91c2VcbiAgICAgICAgLy8gaW50ZXJhY3Rpb24gb24gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKCF0aGlzLl9pc01vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5faGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgfTtcbiAgICAvKiogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci4gKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHZhbHVlO1xuICAgIH07XG4gICAgLyoqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfTtcbiAgICAvKiogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci4gKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgLyoqIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci4gKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfTtcbiAgICAvKiogRm9jdXNlcyB0aGUgc2xpZGUtdG9nZ2xlLiAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKTtcbiAgICAgICAgdGhpcy5fb25JbnB1dEZvY3VzKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgaXMgY2hlY2tlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuX2NoZWNrZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja2VkICE9PSAhIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UodGhpcy5fY2hlY2tlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlLXRvZ2dsZS4gQ2FuIGJlIHByaW1hcnksIGFjY2VudCwgb3Igd2Fybi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xvcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFRvZ2dsZXMgdGhlIGNoZWNrZWQgc3RhdGUgb2YgdGhlIHNsaWRlLXRvZ2dsZS4gKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fc2V0RWxlbWVudENvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBpc0FkZCkge1xuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBjb2xvciAhPSAnJykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyBjb2xvciwgaXNBZGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRW1pdHMgdGhlIGNoYW5nZSBldmVudCB0byB0aGUgYGNoYW5nZWAgb3V0cHV0IEV2ZW50RW1pdHRlciAqL1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBNZFNsaWRlVG9nZ2xlQ2hhbmdlKCk7XG4gICAgICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIGV2ZW50LmNoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG4gICAgICAgIHRoaXMuX2NoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9vbkRyYWdTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zbGlkZVJlbmRlcmVyLnN0YXJ0VGh1bWJEcmFnKHRoaXMuY2hlY2tlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9vbkRyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NsaWRlUmVuZGVyZXIuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLl9zbGlkZVJlbmRlcmVyLnVwZGF0ZVRodW1iUG9zaXRpb24oZXZlbnQuZGVsdGFYKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9zbGlkZVJlbmRlcmVyLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGljZSB0aGF0IHdlIGhhdmUgdG8gc3RvcCBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IGV2ZW50IGhhbmRsZXIsXG4gICAgICAgIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBjbGljayBldmVudCB3aWxsIGJlIGZpcmVkIGFuZCB3aWxsIHJlc2V0IHRoZSBuZXcgY2hlY2tlZCB2YXJpYWJsZS5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGVja2VkID0gX3RoaXMuX3NsaWRlUmVuZGVyZXIuc3RvcFRodW1iRHJhZygpO1xuICAgICAgICAgICAgX3RoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcInRhYkluZGV4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImxhYmVsUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiYXJpYUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiYXJpYUxhYmVsbGVkYnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgnaW5wdXQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcIl9pbnB1dEVsZW1lbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiY29sb3JcIiwgbnVsbCk7XG4gICAgTWRTbGlkZVRvZ2dsZSA9IF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1zbGlkZS10b2dnbGUsIG1hdC1zbGlkZS10b2dnbGUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlLXRvZ2dsZV0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hlY2tlZF0nOiAnY2hlY2tlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1hdC1zbGlkZS10b2dnbGUgcHJlZml4IHdpbGwgY2hhbmdlLCBvbmNlIHRoZSB0ZW1wb3JhcnkgcmlwcGxlIGlzIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGUtdG9nZ2xlLWZvY3VzZWRdJzogJ19oYXNGb2N1cycsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVsLWJlZm9yZV0nOiAnbGFiZWxQb3NpdGlvbiA9PSBcImJlZm9yZVwiJyxcbiAgICAgICAgICAgICAgICAnKG1vdXNlZG93biknOiAnX3NldE1vdXNlZG93bigpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxsYWJlbCBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1sYWJlbFxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1jb250YWluZXJcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtYmFyXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLXRodW1iLWNvbnRhaW5lclxcXCIgKHNsaWRlc3RhcnQpPVxcXCJfb25EcmFnU3RhcnQoKVxcXCIgKHNsaWRlKT1cXFwiX29uRHJhZygkZXZlbnQpXFxcIiAoc2xpZGVlbmQpPVxcXCJfb25EcmFnRW5kKClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZS10b2dnbGUtdGh1bWJcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1pbmstcmlwcGxlXFxcIj48L2Rpdj48L2Rpdj48L2Rpdj48aW5wdXQgI2lucHV0IGNsYXNzPVxcXCJtYXQtc2xpZGUtdG9nZ2xlLWlucHV0IGNkay12aXN1YWxseS1oaWRkZW5cXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiBbaWRdPVxcXCJpbnB1dElkXFxcIiBbcmVxdWlyZWRdPVxcXCJyZXF1aXJlZFxcXCIgW3RhYkluZGV4XT1cXFwidGFiSW5kZXhcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIiBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiYXJpYUxhYmVsXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJhcmlhTGFiZWxsZWRieVxcXCIgKGJsdXIpPVxcXCJfb25JbnB1dEJsdXIoKVxcXCIgKGZvY3VzKT1cXFwiX29uSW5wdXRGb2N1cygpXFxcIiAoY2hhbmdlKT1cXFwiX29uQ2hhbmdlRXZlbnQoJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiX29uSW5wdXRDbGljaygkZXZlbnQpXFxcIj48L2Rpdj48c3BhbiBjbGFzcz1cXFwibWF0LXNsaWRlLXRvZ2dsZS1jb250ZW50XFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPjwvbGFiZWw+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtc2xpZGUtdG9nZ2xle2Rpc3BsYXk6ZmxleDtoZWlnaHQ6MjRweDttYXJnaW46MTZweCAwO2xpbmUtaGVpZ2h0OjI0cHg7d2hpdGUtc3BhY2U6bm93cmFwOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtvdXRsaW5lOjB9Lm1hdC1zbGlkZS10b2dnbGUubWF0LWNoZWNrZWQgLm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVye3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgxMDAlLDAsMCl9Lm1hdC1zbGlkZS10b2dnbGUgLm1hdC1pbmstcmlwcGxle2JvcmRlci1yYWRpdXM6NTAlO29wYWNpdHk6MDtoZWlnaHQ6NDhweDtsZWZ0OjUwJTtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKTt0cmFuc2l0aW9uOm9wYWNpdHkgZWFzZSAyODBtcyxiYWNrZ3JvdW5kLWNvbG9yIGVhc2UgMjgwbXM7d2lkdGg6NDhweH0ubWF0LXNsaWRlLXRvZ2dsZS5tYXQtc2xpZGUtdG9nZ2xlLWZvY3VzZWQgLm1hdC1pbmstcmlwcGxle29wYWNpdHk6MX0ubWF0LXNsaWRlLXRvZ2dsZS5tYXQtc2xpZGUtdG9nZ2xlLWRpc2FibGVkIC5tYXQtaW5rLXJpcHBsZXtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9Lm1hdC1zbGlkZS10b2dnbGUubWF0LWRpc2FibGVkIC5tYXQtc2xpZGUtdG9nZ2xlLWNvbnRhaW5lciwubWF0LXNsaWRlLXRvZ2dsZS5tYXQtZGlzYWJsZWQgLm1hdC1zbGlkZS10b2dnbGUtbGFiZWx7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1zbGlkZS10b2dnbGUtY29udGVudHtmb250LXNpemU6MTRweDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjUwMH0ubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbHtkaXNwbGF5OmZsZXg7ZmxleDoxO2N1cnNvcjpwb2ludGVyfS5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVsLWJlZm9yZSAubWF0LXNsaWRlLXRvZ2dsZS1sYWJlbHtvcmRlcjoxfS5tYXQtc2xpZGUtdG9nZ2xlLWxhYmVsLWJlZm9yZSAubWF0LXNsaWRlLXRvZ2dsZS1jb250YWluZXJ7b3JkZXI6Mn0ubWF0LXNsaWRlLXRvZ2dsZS1jb250YWluZXJ7Y3Vyc29yOi13ZWJraXQtZ3JhYjtjdXJzb3I6Z3JhYjt3aWR0aDozNnB4O2hlaWdodDoyNHB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtc2xpZGUtdG9nZ2xlLWNvbnRhaW5lcixbZGlyPXJ0bF0gLm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWNvbnRhaW5lcnttYXJnaW4tcmlnaHQ6OHB4O21hcmdpbi1sZWZ0OjB9Lm1hdC1zbGlkZS10b2dnbGUtbGFiZWwtYmVmb3JlIC5tYXQtc2xpZGUtdG9nZ2xlLWNvbnRhaW5lcixbZGlyPXJ0bF0gLm1hdC1zbGlkZS10b2dnbGUtY29udGFpbmVye21hcmdpbi1sZWZ0OjhweDttYXJnaW4tcmlnaHQ6MH0ubWF0LXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjJweDtsZWZ0OjA7ei1pbmRleDoxO3dpZHRoOjE2cHg7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2l0aW9uOmFsbCA4MG1zIGxpbmVhcjt0cmFuc2l0aW9uLXByb3BlcnR5OnRyYW5zZm9ybX0ubWF0LXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXIubWF0LWRyYWdnaW5ne3RyYW5zaXRpb24tZHVyYXRpb246MHN9Lm1hdC1zbGlkZS10b2dnbGUtdGh1bWJ7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjA7bGVmdDowO3RvcDowO2hlaWdodDoyMHB4O3dpZHRoOjIwcHg7Ym9yZGVyLXJhZGl1czo1MCU7Ym94LXNoYWRvdzowIDJweCAxcHggLTFweCByZ2JhKDAsMCwwLC4yKSwwIDFweCAxcHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggM3B4IDAgcmdiYSgwLDAsMCwuMTIpfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtc2xpZGUtdG9nZ2xlLXRodW1ie2JhY2tncm91bmQ6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICMwMDB9Lm1hdC1zbGlkZS10b2dnbGUtYmFye2JhY2tncm91bmQ6I2ZmZn19Lm1hdC1zbGlkZS10b2dnbGUtYmFye3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MXB4O3RvcDo1cHg7d2lkdGg6MzRweDtoZWlnaHQ6MTRweDtib3JkZXItcmFkaXVzOjhweH0ubWF0LXNsaWRlLXRvZ2dsZS1pbnB1dHtib3R0b206MDtsZWZ0OjEwcHh9Lm1hdC1zbGlkZS10b2dnbGUtYmFyLC5tYXQtc2xpZGUtdG9nZ2xlLXRodW1ie3RyYW5zaXRpb246YWxsIDgwbXMgbGluZWFyO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZC1jb2xvcjt0cmFuc2l0aW9uLWRlbGF5OjUwbXN9XCJdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfU0xJREVfVE9HR0xFX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUpO1xuICAgIHJldHVybiBNZFNsaWRlVG9nZ2xlO1xufSgpKTtcbi8qKlxuICogUmVuZGVyZXIgZm9yIHRoZSBTbGlkZSBUb2dnbGUgY29tcG9uZW50LCB3aGljaCBzZXBhcmF0ZXMgRE9NIG1vZGlmaWNhdGlvbiBpbiBpdHMgb3duIGNsYXNzXG4gKi9cbnZhciBTbGlkZVRvZ2dsZVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGlkZVRvZ2dsZVJlbmRlcmVyKF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fdGh1bWJFbCA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyJyk7XG4gICAgICAgIHRoaXMuX3RodW1iQmFyRWwgPSBfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYXQtc2xpZGUtdG9nZ2xlLWJhcicpO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGUgc2xpZGUtdG9nZ2xlIGlzIGN1cnJlbnRseSBkcmFnZ2luZy4gKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS5pc0RyYWdnaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl90aHVtYkJhcldpZHRoO1xuICAgIH07XG4gICAgLyoqIEluaXRpYWxpemVzIHRoZSBkcmFnIG9mIHRoZSBzbGlkZS10b2dnbGUuICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUuc3RhcnRUaHVtYkRyYWcgPSBmdW5jdGlvbiAoY2hlY2tlZCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHVtYkJhcldpZHRoID0gdGhpcy5fdGh1bWJCYXJFbC5jbGllbnRXaWR0aCAtIHRoaXMuX3RodW1iRWwuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMuX3RodW1iRWwuY2xhc3NMaXN0LmFkZCgnbWF0LWRyYWdnaW5nJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBTdG9wcyB0aGUgY3VycmVudCBkcmFnIGFuZCByZXR1cm5zIHRoZSBuZXcgY2hlY2tlZCB2YWx1ZS4gKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS5zdG9wVGh1bWJEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RodW1iQmFyV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJFbC5jbGFzc0xpc3QucmVtb3ZlKCdtYXQtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIGFwcGx5Q3NzVHJhbnNmb3JtKHRoaXMuX3RodW1iRWwsICcnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZXJjZW50YWdlID4gNTA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBVcGRhdGVzIHRoZSB0aHVtYiBjb250YWluZXJzIHBvc2l0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBkaXN0YW5jZS4gKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVUaHVtYlBvc2l0aW9uID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX3BlcmNlbnRhZ2UgPSB0aGlzLl9nZXRUaHVtYlBlcmNlbnRhZ2UoZGlzdGFuY2UpO1xuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aGlzLl90aHVtYkVsLCBcInRyYW5zbGF0ZTNkKFwiICsgdGhpcy5fcGVyY2VudGFnZSArIFwiJSwgMCwgMClcIik7XG4gICAgfTtcbiAgICAvKiogUmV0cmlldmVzIHRoZSBwZXJjZW50YWdlIG9mIHRodW1iIGZyb20gdGhlIG1vdmVkIGRpc3RhbmNlLiAqL1xuICAgIFNsaWRlVG9nZ2xlUmVuZGVyZXIucHJvdG90eXBlLl9nZXRUaHVtYlBlcmNlbnRhZ2UgPSBmdW5jdGlvbiAoZGlzdGFuY2UpIHtcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSAoZGlzdGFuY2UgLyB0aGlzLl90aHVtYkJhcldpZHRoKSAqIDEwMDtcbiAgICAgICAgLy8gV2hlbiB0aGUgdG9nZ2xlIHdhcyBpbml0aWFsbHkgY2hlY2tlZCwgdGhlbiB3ZSBoYXZlIHRvIHN0YXJ0IHRoZSBkcmFnIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmICh0aGlzLl9jaGVja2VkKSB7XG4gICAgICAgICAgICBwZXJjZW50YWdlICs9IDEwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGVyY2VudGFnZSwgMTAwKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2xpZGVUb2dnbGVSZW5kZXJlcjtcbn0oKSk7XG52YXIgTWRTbGlkZVRvZ2dsZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRTbGlkZVRvZ2dsZU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kU2xpZGVUb2dnbGVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlTW9kdWxlID0gX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2Zvcm1zLkZvcm1zTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFNsaWRlVG9nZ2xlLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2xpZGVUb2dnbGVdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuSEFNTUVSX0dFU1RVUkVfQ09ORklHLCB1c2VDbGFzczogR2VzdHVyZUNvbmZpZyB9XSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2xpZGVUb2dnbGVNb2R1bGUpO1xuICAgIHJldHVybiBNZFNsaWRlVG9nZ2xlTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMzggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDcgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFZpc3VhbGx5LCBhIDMwcHggc2VwYXJhdGlvbiBiZXR3ZWVuIHRpY2sgbWFya3MgbG9va3MgYmVzdC4gVGhpcyBpcyB2ZXJ5IHN1YmplY3RpdmUgYnV0IGl0IGlzXG4gKiB0aGUgZGVmYXVsdCBzZXBhcmF0aW9uIHdlIGNob3NlLlxuICovXG52YXIgTUlOX0FVVE9fVElDS19TRVBBUkFUSU9OID0gMzA7XG4vKiogVGhlIHRodW1iIGdhcCBzaXplIGZvciBhIGRpc2FibGVkIHNsaWRlci4gKi9cbnZhciBESVNBQkxFRF9USFVNQl9HQVAgPSA3O1xuLyoqIFRoZSB0aHVtYiBnYXAgc2l6ZSBmb3IgYSBub24tYWN0aXZlIHNsaWRlciBhdCBpdHMgbWluaW11bSB2YWx1ZS4gKi9cbnZhciBNSU5fVkFMVUVfTk9OQUNUSVZFX1RIVU1CX0dBUCA9IDc7XG4vKiogVGhlIHRodW1iIGdhcCBzaXplIGZvciBhbiBhY3RpdmUgc2xpZGVyIGF0IGl0cyBtaW5pbXVtIHZhbHVlLiAqL1xudmFyIE1JTl9WQUxVRV9BQ1RJVkVfVEhVTUJfR0FQID0gMTA7XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtc2xpZGVyIHRvIHJlZ2lzdGVyIGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gKiBUaGlzIGFsbG93cyBpdCB0byBzdXBwb3J0IFsobmdNb2RlbCldIGFuZCBbZm9ybUNvbnRyb2xdLlxuICovXG52YXIgTURfU0xJREVSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IF9hbmd1bGFyX2Zvcm1zLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRTbGlkZXI7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqIEEgc2ltcGxlIGNoYW5nZSBldmVudCBlbWl0dGVkIGJ5IHRoZSBNZFNsaWRlciBjb21wb25lbnQuICovXG52YXIgTWRTbGlkZXJDaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVyQ2hhbmdlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTWRTbGlkZXJDaGFuZ2U7XG59KCkpO1xuLyoqXG4gKiBBbGxvd3MgdXNlcnMgdG8gc2VsZWN0IGZyb20gYSByYW5nZSBvZiB2YWx1ZXMgYnkgbW92aW5nIHRoZSBzbGlkZXIgdGh1bWIuIEl0IGlzIHNpbWlsYXIgaW5cbiAqIGJlaGF2aW9yIHRvIHRoZSBuYXRpdmUgYDxpbnB1dCB0eXBlPVwicmFuZ2VcIj5gIGVsZW1lbnQuXG4gKi9cbnZhciBNZFNsaWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZXIoX2RpciwgZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICAvKiogQSByZW5kZXJlciB0byBoYW5kbGUgdXBkYXRpbmcgdGhlIHNsaWRlcidzIHRodW1iIGFuZCBmaWxsIHRyYWNrLiAqL1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgZGltZW5zaW9ucyBvZiB0aGUgc2xpZGVyLiAqL1xuICAgICAgICB0aGlzLl9zbGlkZXJEaW1lbnNpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGh1bWJMYWJlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKiogVGhlIGxhc3QgdmFsdWVzIGZvciB3aGljaCBhIGNoYW5nZSBvciBpbnB1dCBldmVudCB3YXMgZW1pdHRlZC4gKi9cbiAgICAgICAgdGhpcy5fbGFzdENoYW5nZVZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdElucHV0VmFsdWUgPSBudWxsO1xuICAgICAgICAvKiogb25Ub3VjaCBmdW5jdGlvbiByZWdpc3RlcmVkIHZpYSByZWdpc3Rlck9uVG91Y2ggKENvbnRyb2xWYWx1ZUFjY2Vzc29yKS4gKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdGh1bWIgaXMgc2xpZGluZy5cbiAgICAgICAgICogVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlcmUgc2hvdWxkIGJlIGEgdHJhbnNpdGlvbiBmb3IgdGhlIHRodW1iIGFuZCBmaWxsIHRyYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc2xpZGVyIGlzIGFjdGl2ZSAoY2xpY2tlZCBvciBzbGlkaW5nKS5cbiAgICAgICAgICogVXNlZCB0byBzaHJpbmsgYW5kIGdyb3cgdGhlIHRodW1iIGFzIGFjY29yZGluZyB0byB0aGUgTWF0ZXJpYWwgRGVzaWduIHNwZWMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGVwID0gMTtcbiAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gMDtcbiAgICAgICAgdGhpcy5fdGlja0ludGVydmFsUGVyY2VudCA9IDA7XG4gICAgICAgIHRoaXMuX3BlcmNlbnQgPSAwO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX21pbiA9IDA7XG4gICAgICAgIHRoaXMuX21heCA9IDEwMDtcbiAgICAgICAgdGhpcy5faW52ZXJ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNsaWRlciB2YWx1ZSBoYXMgY2hhbmdlZC4gKi9cbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2xpZGVyIHRodW1iIG1vdmVzLiAqL1xuICAgICAgICB0aGlzLmlucHV0ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IFNsaWRlclJlbmRlcmVyKGVsZW1lbnRSZWYpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBzbGlkZXIgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2Rpc2FibGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ0aHVtYkxhYmVsXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIHRodW1iIGxhYmVsLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RodW1iTGFiZWw7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3RodW1iTGFiZWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aHVtYkxhYmVsRGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RodW1iTGFiZWw7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3RodW1iTGFiZWwgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJzdGVwXCIsIHtcbiAgICAgICAgLyoqIFRoZSB2YWx1ZXMgYXQgd2hpY2ggdGhlIHRodW1iIHdpbGwgc25hcC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGVwOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGVwID0gY29lcmNlTnVtYmVyUHJvcGVydHkodiwgdGhpcy5fc3RlcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3VuZExhYmVsVG8gPSB0aGlzLl9zdGVwLnRvU3RyaW5nKCkuc3BsaXQoJy4nKS5wb3AoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidGlja0ludGVydmFsXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBvZnRlbiB0byBzaG93IHRpY2tzLiBSZWxhdGl2ZSB0byB0aGUgc3RlcCBzbyB0aGF0IGEgdGljayBhbHdheXMgYXBwZWFycyBvbiBhIHN0ZXAuXG4gICAgICAgICAqIEV4OiBUaWNrIGludGVydmFsIG9mIDQgd2l0aCBhIHN0ZXAgb2YgMyB3aWxsIGRyYXcgYSB0aWNrIGV2ZXJ5IDQgc3RlcHMgKGV2ZXJ5IDEyIHZhbHVlcykuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RpY2tJbnRlcnZhbDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gKHYgPT0gJ2F1dG8nKSA/IHYgOiBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl90aWNrSW50ZXJ2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aWNrSW50ZXJ2YWxEZXByZWNhdGVkXCIsIHtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50aWNrSW50ZXJ2YWw7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy50aWNrSW50ZXJ2YWwgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRpY2tJbnRlcnZhbFBlcmNlbnRcIiwge1xuICAgICAgICAvKiogVGhlIHNpemUgb2YgYSB0aWNrIGludGVydmFsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgc2l6ZSBvZiB0aGUgdHJhY2suICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdGlja0ludGVydmFsUGVyY2VudDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJwZXJjZW50XCIsIHtcbiAgICAgICAgLyoqIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgdGhhdCBjb2luY2lkZXMgd2l0aCB0aGUgdmFsdWUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2xhbXAodGhpcy5fcGVyY2VudCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogVmFsdWUgb2YgdGhlIHNsaWRlci4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcmVhZCBhbmQgaXQgaXMgc3RpbGwgdW5pbml0aWFsaXplZCwgaW5pdGlhbGl6ZSBpdCB0byB0aGUgbWluLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX21pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9wZXJjZW50ID0gdGhpcy5fY2FsY3VsYXRlUGVyY2VudGFnZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwibWluXCIsIHtcbiAgICAgICAgLyoqIFRoZSBtaW5pbXVtIHZhbHVlIHRoYXQgdGhlIHNsaWRlciBjYW4gaGF2ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWluO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9taW4gPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl9taW4pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIHdhc24ndCBleHBsaWNpdGx5IHNldCBieSB0aGUgdXNlciwgc2V0IGl0IHRvIHRoZSBtaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fbWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGVyY2VudCA9IHRoaXMuX2NhbGN1bGF0ZVBlcmNlbnRhZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwibWF4XCIsIHtcbiAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIHNsaWRlciBjYW4gaGF2ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXggPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2LCB0aGlzLl9tYXgpO1xuICAgICAgICAgICAgdGhpcy5fcGVyY2VudCA9IHRoaXMuX2NhbGN1bGF0ZVBlcmNlbnRhZ2UodGhpcy52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiaW52ZXJ0XCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlciBpcyBpbnZlcnRlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbnZlcnQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2ludmVydCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidmVydGljYWxcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgc2xpZGVyIGlzIHZlcnRpY2FsLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl92ZXJ0aWNhbCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwiZGlzcGxheVZhbHVlXCIsIHtcbiAgICAgICAgLyoqIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGZvciBkaXNwbGF5IHB1cnBvc2VzLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNvdWxkIGJlIGltcHJvdmVkIGZ1cnRoZXIgYnkgcm91bmRpbmcgc29tZXRoaW5nIGxpa2UgMC45OTkgdG8gMSBvclxuICAgICAgICAgICAgLy8gMC44OTkgdG8gMC45LCBob3dldmVyIGl0IGlzIHZlcnkgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLCBiZWNhdXNlIGl0IGdldHMgY2FsbGVkIG9uXG4gICAgICAgICAgICAvLyBldmVyeSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3JvdW5kTGFiZWxUbyAmJiB0aGlzLnZhbHVlICUgMSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvRml4ZWQodGhpcy5fcm91bmRMYWJlbFRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcImludmVydEF4aXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYXhpcyBvZiB0aGUgc2xpZGVyIGlzIGludmVydGVkLlxuICAgICAgICAgKiAoaS5lLiB3aGV0aGVyIG1vdmluZyB0aGUgdGh1bWIgaW4gdGhlIHBvc2l0aXZlIHggb3IgeSBkaXJlY3Rpb24gZGVjcmVhc2VzIHRoZSBzbGlkZXIncyB2YWx1ZSkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFN0YW5kYXJkIG5vbi1pbnZlcnRlZCBtb2RlIGZvciBhIHZlcnRpY2FsIHNsaWRlciBzaG91bGQgYmUgZHJhZ2dpbmcgdGhlIHRodW1iIGZyb20gYm90dG9tIHRvXG4gICAgICAgICAgICAvLyB0b3AuIEhvd2V2ZXIgZnJvbSBhIHktYXhpcyBzdGFuZHBvaW50IHRoaXMgaXMgaW52ZXJ0ZWQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/ICF0aGlzLmludmVydCA6IHRoaXMuaW52ZXJ0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcImludmVydE1vdXNlQ29vcmRzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgbW91c2UgZXZlbnRzIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBzbGlkZXIgcG9zaXRpb24gYnkgY2FsY3VsYXRpbmcgdGhlaXIgZGlzdGFuY2VcbiAgICAgICAgICogZnJvbSB0aGUgcmlnaHQgb3IgYm90dG9tIGVkZ2Ugb2YgdGhlIHNsaWRlciBhcyBvcHBvc2VkIHRvIHRoZSB0b3Agb3IgbGVmdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRpcmVjdGlvbiA9PSAncnRsJyAmJiAhdGhpcy52ZXJ0aWNhbCkgPyAhdGhpcy5pbnZlcnRBeGlzIDogdGhpcy5pbnZlcnRBeGlzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl9pc01pblZhbHVlXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlciBpcyBhdCBpdHMgbWluaW11bSB2YWx1ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJjZW50ID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aHVtYkdhcFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHNwYWNlIHRvIGxlYXZlIGJldHdlZW4gdGhlIHNsaWRlciB0aHVtYiBhbmQgdGhlIHRyYWNrIGZpbGwgJiB0cmFjayBiYWNrZ3JvdW5kXG4gICAgICAgICAqIGVsZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBESVNBQkxFRF9USFVNQl9HQVA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNNaW5WYWx1ZSAmJiAhdGhpcy50aHVtYkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzQWN0aXZlID8gTUlOX1ZBTFVFX0FDVElWRV9USFVNQl9HQVAgOiBNSU5fVkFMVUVfTk9OQUNUSVZFX1RIVU1CX0dBUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRyYWNrQmFja2dyb3VuZFN0eWxlc1wiLCB7XG4gICAgICAgIC8qKiBDU1Mgc3R5bGVzIGZvciB0aGUgdHJhY2sgYmFja2dyb3VuZCBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy52ZXJ0aWNhbCA/ICdZJyA6ICdYJztcbiAgICAgICAgICAgIHZhciBzaWduID0gdGhpcy5pbnZlcnRNb3VzZUNvb3JkcyA/ICctJyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogXCJ0cmFuc2xhdGVcIiArIGF4aXMgKyBcIihcIiArIHNpZ24gKyB0aGlzLl90aHVtYkdhcCArIFwicHgpIHNjYWxlXCIgKyBheGlzICsgXCIoXCIgKyAoMSAtIHRoaXMucGVyY2VudCkgKyBcIilcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ0cmFja0ZpbGxTdHlsZXNcIiwge1xuICAgICAgICAvKiogQ1NTIHN0eWxlcyBmb3IgdGhlIHRyYWNrIGZpbGwgZWxlbWVudC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHRoaXMudmVydGljYWwgPyAnWScgOiAnWCc7XG4gICAgICAgICAgICB2YXIgc2lnbiA9IHRoaXMuaW52ZXJ0TW91c2VDb29yZHMgPyAnJyA6ICctJztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFwidHJhbnNsYXRlXCIgKyBheGlzICsgXCIoXCIgKyBzaWduICsgdGhpcy5fdGh1bWJHYXAgKyBcInB4KSBzY2FsZVwiICsgYXhpcyArIFwiKFwiICsgdGhpcy5wZXJjZW50ICsgXCIpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidGlja3NDb250YWluZXJTdHlsZXNcIiwge1xuICAgICAgICAvKiogQ1NTIHN0eWxlcyBmb3IgdGhlIHRpY2tzIGNvbnRhaW5lciBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy52ZXJ0aWNhbCA/ICdZJyA6ICdYJztcbiAgICAgICAgICAgIC8vIEZvciBhIGhvcml6b250YWwgc2xpZGVyIGluIFJUTCBsYW5ndWFnZXMgd2UgcHVzaCB0aGUgdGlja3MgY29udGFpbmVyIG9mZiB0aGUgbGVmdCBlZGdlXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSByaWdodCBlZGdlIHRvIGF2b2lkIGNhdXNpbmcgYSBob3Jpem9udGFsIHNjcm9sbGJhciB0byBhcHBlYXIuXG4gICAgICAgICAgICB2YXIgc2lnbiA9ICF0aGlzLnZlcnRpY2FsICYmIHRoaXMuZGlyZWN0aW9uID09ICdydGwnID8gJycgOiAnLSc7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy50aWNrSW50ZXJ2YWxQZXJjZW50IC8gMiAqIDEwMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFwidHJhbnNsYXRlXCIgKyBheGlzICsgXCIoXCIgKyBzaWduICsgb2Zmc2V0ICsgXCIlKVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRpY2tzU3R5bGVzXCIsIHtcbiAgICAgICAgLyoqIENTUyBzdHlsZXMgZm9yIHRoZSB0aWNrcyBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aWNrU2l6ZSA9IHRoaXMudGlja0ludGVydmFsUGVyY2VudCAqIDEwMDtcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kU2l6ZSA9IHRoaXMudmVydGljYWwgPyBcIjJweCBcIiArIHRpY2tTaXplICsgXCIlXCIgOiB0aWNrU2l6ZSArIFwiJSAycHhcIjtcbiAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy52ZXJ0aWNhbCA/ICdZJyA6ICdYJztcbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIHdlIHB1c2hlZCB0aGUgdGlja3MgY29udGFpbmVyLCBwdXNoIHRoZSB0aWNrcyB0aGUgb3Bwb3NpdGVcbiAgICAgICAgICAgIC8vIGRpcmVjdGlvbiB0byByZS1jZW50ZXIgdGhlbSBidXQgY2xpcCBvZmYgdGhlIGVuZCBlZGdlLiBJbiBSVEwgbGFuZ3VhZ2VzIHdlIG5lZWQgdG8gZmxpcCB0aGVcbiAgICAgICAgICAgIC8vIHRpY2tzIDE4MCBkZWdyZWVzIHNvIHdlJ3JlIHJlYWxseSBjdXR0aW5nIG9mZiB0aGUgZW5kIGVkZ2UgYWJkIG5vdCB0aGUgc3RhcnQuXG4gICAgICAgICAgICB2YXIgc2lnbiA9ICF0aGlzLnZlcnRpY2FsICYmIHRoaXMuZGlyZWN0aW9uID09ICdydGwnID8gJy0nIDogJyc7XG4gICAgICAgICAgICB2YXIgcm90YXRlID0gIXRoaXMudmVydGljYWwgJiYgdGhpcy5kaXJlY3Rpb24gPT0gJ3J0bCcgPyAnIHJvdGF0ZSgxODBkZWcpJyA6ICcnO1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZFNpemUnOiBiYWNrZ3JvdW5kU2l6ZSxcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRyYW5zbGF0ZVogdGlja3Mgc29tZXRpbWVzIGppdHRlciBhcyB0aGUgc2xpZGVyIG1vdmVzIG9uIENocm9tZSAmIEZpcmVmb3guXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFwidHJhbnNsYXRlWigwKSB0cmFuc2xhdGVcIiArIGF4aXMgKyBcIihcIiArIHNpZ24gKyB0aWNrU2l6ZSAvIDIgKyBcIiUpXCIgKyByb3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5faXNNaW5WYWx1ZSAmJiB0aGlzLl90aHVtYkdhcCkge1xuICAgICAgICAgICAgICAgIHZhciBzaWRlID0gdGhpcy52ZXJ0aWNhbCA/XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmludmVydEF4aXMgPyAnQm90dG9tJyA6ICdUb3AnKSA6XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmludmVydEF4aXMgPyAnUmlnaHQnIDogJ0xlZnQnKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNbKFwicGFkZGluZ1wiICsgc2lkZSldID0gdGhpcy5fdGh1bWJHYXAgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcInRodW1iQ29udGFpbmVyU3R5bGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHRoaXMudmVydGljYWwgPyAnWScgOiAnWCc7XG4gICAgICAgICAgICAvLyBGb3IgYSBob3Jpem9udGFsIHNsaWRlciBpbiBSVEwgbGFuZ3VhZ2VzIHdlIHB1c2ggdGhlIHRodW1iIGNvbnRhaW5lciBvZmYgdGhlIGxlZnQgZWRnZVxuICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgcmlnaHQgZWRnZSB0byBhdm9pZCBjYXVzaW5nIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIgdG8gYXBwZWFyLlxuICAgICAgICAgICAgdmFyIGludmVydE9mZnNldCA9ICh0aGlzLmRpcmVjdGlvbiA9PSAncnRsJyAmJiAhdGhpcy52ZXJ0aWNhbCkgPyAhdGhpcy5pbnZlcnRBeGlzIDogdGhpcy5pbnZlcnRBeGlzO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IChpbnZlcnRPZmZzZXQgPyB0aGlzLnBlcmNlbnQgOiAxIC0gdGhpcy5wZXJjZW50KSAqIDEwMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IFwidHJhbnNsYXRlXCIgKyBheGlzICsgXCIoLVwiICsgb2Zmc2V0ICsgXCIlKVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTbGlkZXIucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB7XG4gICAgICAgIC8qKiBUaGUgbGFuZ3VhZ2UgZGlyZWN0aW9uIGZvciB0aGlzIHNsaWRlciBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PSAncnRsJykgPyAncnRsJyA6ICdsdHInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uTW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBzYXZlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzbGlkZXIgaGVyZSBzbyB3ZSBjYW4gdXNlIHRoZW0gdG8gdXBkYXRlIHRoZSBzcGFjaW5nIG9mIHRoZVxuICAgICAgICAvLyB0aWNrcyBhbmQgZGV0ZXJtaW5lIHdoZXJlIG9uIHRoZSBzbGlkZXIgY2xpY2sgYW5kIHNsaWRlIGV2ZW50cyBoYXBwZW4uXG4gICAgICAgIHRoaXMuX3NsaWRlckRpbWVuc2lvbnMgPSB0aGlzLl9yZW5kZXJlci5nZXRTbGlkZXJEaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpY2tJbnRlcnZhbFBlcmNlbnQoKTtcbiAgICB9O1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZEZvY3VzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlRnJvbVBvc2l0aW9uKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgLyogRW1pdHMgYSBjaGFuZ2UgYW5kIGlucHV0IGV2ZW50IGlmIHRoZSB2YWx1ZSBjaGFuZ2VkLiAqL1xuICAgICAgICB0aGlzLl9lbWl0SW5wdXRFdmVudCgpO1xuICAgICAgICB0aGlzLl9lbWl0VmFsdWVJZkNoYW5nZWQoKTtcbiAgICB9O1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25TbGlkZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIHNsaWRlIGZyb20gc2VsZWN0aW5nIGFueXRoaW5nIGVsc2UuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlRnJvbVBvc2l0aW9uKHsgeDogZXZlbnQuY2VudGVyLngsIHk6IGV2ZW50LmNlbnRlci55IH0pO1xuICAgICAgICAvLyBOYXRpdmUgcmFuZ2UgZWxlbWVudHMgYWx3YXlzIGVtaXQgYGlucHV0YCBldmVudHMgd2hlbiB0aGUgdmFsdWUgY2hhbmdlZCB3aGlsZSBzbGlkaW5nLlxuICAgICAgICB0aGlzLl9lbWl0SW5wdXRFdmVudCgpO1xuICAgIH07XG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vblNsaWRlU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW11bGF0ZSBtb3VzZWVudGVyIGluIGNhc2UgdGhpcyBpcyBhIG1vYmlsZSBkZXZpY2UuXG4gICAgICAgIHRoaXMuX29uTW91c2VlbnRlcigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZEZvY3VzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlRnJvbVBvc2l0aW9uKHsgeDogZXZlbnQuY2VudGVyLngsIHk6IGV2ZW50LmNlbnRlci55IH0pO1xuICAgIH07XG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9vblNsaWRlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW1pdFZhbHVlSWZDaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICB9O1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25LZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFBBR0VfVVA6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KDEwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUEFHRV9ET1dOOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCgtMTApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubWF4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIT01FOlxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm1pbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBGb3IgYSBzaWdodGVkIHVzZXIgaXQgd291bGQgbWFrZSBtb3JlIHNlbnNlIHRoYXQgd2hlbiB0aGV5IHByZXNzIGFuIGFycm93IGtleSBvbiBhblxuICAgICAgICAgICAgICAgIC8vIGludmVydGVkIHNsaWRlciB0aGUgdGh1bWIgbW92ZXMgaW4gdGhhdCBkaXJlY3Rpb24uIEhvd2V2ZXIgZm9yIGEgYmxpbmQgdXNlciwgbm90aGluZ1xuICAgICAgICAgICAgICAgIC8vIGFib3V0IHRoZSBzbGlkZXIgaW5kaWNhdGVzIHRoYXQgaXQgaXMgaW52ZXJ0ZWQuIFRoZXkgd2lsbCBleHBlY3QgbGVmdCB0byBiZSBkZWNyZW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiBob3cgaXQgYXBwZWFycyBvbiB0aGUgc2NyZWVuLiBGb3Igc3BlYWtlcnMgb2ZSVEwgbGFuZ3VhZ2VzLCB0aGV5IHByb2JhYmx5XG4gICAgICAgICAgICAgICAgLy8gZXhwZWN0IGxlZnQgdG8gbWVhbiBpbmNyZW1lbnQuIFRoZXJlZm9yZSB3ZSBmbGlwIHRoZSBtZWFuaW5nIG9mIHRoZSBzaWRlIGFycm93IGtleXMgZm9yXG4gICAgICAgICAgICAgICAgLy8gUlRMLiBGb3IgaW52ZXJ0ZWQgc2xpZGVycyB3ZSBwcmVmZXIgYSBnb29kIGExMXkgZXhwZXJpZW5jZSB0byBoYXZpbmcgaXQgXCJsb29rIHJpZ2h0XCIgZm9yXG4gICAgICAgICAgICAgICAgLy8gc2lnaHRlZCB1c2VycywgdGhlcmVmb3JlIHdlIGRvIG5vdCBzd2FwIHRoZSBtZWFuaW5nLlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCh0aGlzLmRpcmVjdGlvbiA9PSAncnRsJyA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCgxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgb24gTEVGVF9BUlJPVyBhYm91dCB0aGUgY29uZGl0aW9ucyB1bmRlciB3aGljaCB3ZSBmbGlwIHRoZSBtZWFuaW5nLlxuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudCh0aGlzLmRpcmVjdGlvbiA9PSAncnRsJyA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5jcmVtZW50KC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGlmIHRoZSBrZXkgaXMgbm90IG9uZSB0aGF0IHdlIGV4cGxpY2l0bHkgaGFuZGxlIHRvIGF2b2lkIGNhbGxpbmcgcHJldmVudERlZmF1bHQgb25cbiAgICAgICAgICAgICAgICAvLyBpdC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fb25LZXl1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogSW5jcmVtZW50cyB0aGUgc2xpZGVyIGJ5IHRoZSBnaXZlbiBudW1iZXIgb2Ygc3RlcHMgKG5lZ2F0aXZlIG51bWJlciBkZWNyZW1lbnRzKS4gKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2luY3JlbWVudCA9IGZ1bmN0aW9uIChudW1TdGVwcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5fY2xhbXAodGhpcy52YWx1ZSArIHRoaXMuc3RlcCAqIG51bVN0ZXBzLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICB0aGlzLl9lbWl0SW5wdXRFdmVudCgpO1xuICAgICAgICB0aGlzLl9lbWl0VmFsdWVJZkNoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8qKiBDYWxjdWxhdGUgdGhlIG5ldyB2YWx1ZSBmcm9tIHRoZSBuZXcgcGh5c2ljYWwgbG9jYXRpb24uIFRoZSB2YWx1ZSB3aWxsIGFsd2F5cyBiZSBzbmFwcGVkLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVGcm9tUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2xpZGVyRGltZW5zaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnZlcnRpY2FsID8gdGhpcy5fc2xpZGVyRGltZW5zaW9ucy50b3AgOiB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLmxlZnQ7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuX3NsaWRlckRpbWVuc2lvbnMuaGVpZ2h0IDogdGhpcy5fc2xpZGVyRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgdmFyIHBvc0NvbXBvbmVudCA9IHRoaXMudmVydGljYWwgPyBwb3MueSA6IHBvcy54O1xuICAgICAgICAvLyBUaGUgZXhhY3QgdmFsdWUgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBldmVudCBhbmQgdXNlZCB0byBmaW5kIHRoZSBjbG9zZXN0IHNuYXAgdmFsdWUuXG4gICAgICAgIHZhciBwZXJjZW50ID0gdGhpcy5fY2xhbXAoKHBvc0NvbXBvbmVudCAtIG9mZnNldCkgLyBzaXplKTtcbiAgICAgICAgaWYgKHRoaXMuaW52ZXJ0TW91c2VDb29yZHMpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxIC0gcGVyY2VudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhhY3RWYWx1ZSA9IHRoaXMuX2NhbGN1bGF0ZVZhbHVlKHBlcmNlbnQpO1xuICAgICAgICAvLyBUaGlzIGNhbGN1bGF0aW9uIGZpbmRzIHRoZSBjbG9zZXN0IHN0ZXAgYnkgZmluZGluZyB0aGUgY2xvc2VzdCB3aG9sZSBudW1iZXIgZGl2aXNpYmxlIGJ5IHRoZVxuICAgICAgICAvLyBzdGVwIHJlbGF0aXZlIHRvIHRoZSBtaW4uXG4gICAgICAgIHZhciBjbG9zZXN0VmFsdWUgPSBNYXRoLnJvdW5kKChleGFjdFZhbHVlIC0gdGhpcy5taW4pIC8gdGhpcy5zdGVwKSAqIHRoaXMuc3RlcCArIHRoaXMubWluO1xuICAgICAgICAvLyBUaGUgdmFsdWUgbmVlZHMgdG8gc25hcCB0byB0aGUgbWluIGFuZCBtYXguXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9jbGFtcChjbG9zZXN0VmFsdWUsIHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgfTtcbiAgICAvKiogRW1pdHMgYSBjaGFuZ2UgZXZlbnQgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3QgZW1pdHRlZCB2YWx1ZS4gKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2VtaXRWYWx1ZUlmQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gdGhpcy5fbGFzdENoYW5nZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnRfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBFbWl0cyBhbiBpbnB1dCBldmVudCB3aGVuIHRoZSBjdXJyZW50IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBsYXN0IGVtaXR0ZWQgdmFsdWUuICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl9lbWl0SW5wdXRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gdGhpcy5fbGFzdElucHV0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8yID0gdGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RJbnB1dFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZW1pdChldmVudF8yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFVwZGF0ZXMgdGhlIGFtb3VudCBvZiBzcGFjZSBiZXR3ZWVuIHRpY2tzIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgd2lkdGggb2YgdGhlIHNsaWRlci4gKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX3VwZGF0ZVRpY2tJbnRlcnZhbFBlcmNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50aWNrSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aWNrSW50ZXJ2YWwgPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tTaXplID0gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuX3NsaWRlckRpbWVuc2lvbnMuaGVpZ2h0IDogdGhpcy5fc2xpZGVyRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgIHZhciBwaXhlbHNQZXJTdGVwID0gdHJhY2tTaXplICogdGhpcy5zdGVwIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgICAgICAgICAgdmFyIHN0ZXBzUGVyVGljayA9IE1hdGguY2VpbChNSU5fQVVUT19USUNLX1NFUEFSQVRJT04gLyBwaXhlbHNQZXJTdGVwKTtcbiAgICAgICAgICAgIHZhciBwaXhlbHNQZXJUaWNrID0gc3RlcHNQZXJUaWNrICogdGhpcy5zdGVwO1xuICAgICAgICAgICAgdGhpcy5fdGlja0ludGVydmFsUGVyY2VudCA9IHBpeGVsc1BlclRpY2sgLyB0cmFja1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aWNrSW50ZXJ2YWxQZXJjZW50ID0gdGhpcy50aWNrSW50ZXJ2YWwgKiB0aGlzLnN0ZXAgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBDcmVhdGVzIGEgc2xpZGVyIGNoYW5nZSBvYmplY3QgZnJvbSB0aGUgc3BlY2lmaWVkIHZhbHVlLiAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fY3JlYXRlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB0aGlzLnZhbHVlOyB9XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBNZFNsaWRlckNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcbiAgICAvKiogQ2FsY3VsYXRlcyB0aGUgcGVyY2VudGFnZSBvZiB0aGUgc2xpZGVyIHRoYXQgYSB2YWx1ZSBpcy4gKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZVBlcmNlbnRhZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICB9O1xuICAgIC8qKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZSBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciBjb3JyZXNwb25kcyB0by4gKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZVZhbHVlID0gZnVuY3Rpb24gKHBlcmNlbnRhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluICsgcGVyY2VudGFnZSAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm4gYSBudW1iZXIgYmV0d2VlbiB0d28gbnVtYmVycy4gKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuX2NsYW1wID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAobWluID09PSB2b2lkIDApIHsgbWluID0gMDsgfVxuICAgICAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gMTsgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtb2RlbCB2YWx1ZS4gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBlYiB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHRvdWNoZWQuXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkXG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCd0aHVtYkxhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcInRodW1iTGFiZWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ3RodW1iLWxhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcIl90aHVtYkxhYmVsRGVwcmVjYXRlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcInN0ZXBcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJ0aWNrSW50ZXJ2YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ3RpY2staW50ZXJ2YWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJfdGlja0ludGVydmFsRGVwcmVjYXRlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwibWluXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwibWF4XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwiaW52ZXJ0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwidmVydGljYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwiaW5wdXRcIiwgdm9pZCAwKTtcbiAgICBNZFNsaWRlciA9IF9fZGVjb3JhdGUkMzgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1zbGlkZXIsIG1hdC1zbGlkZXInLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTURfU0xJREVSX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX29uQmx1cigpJyxcbiAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfb25DbGljaygkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19vbktleWRvd24oJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgJyhrZXl1cCknOiAnX29uS2V5dXAoKScsXG4gICAgICAgICAgICAgICAgJyhtb3VzZWVudGVyKSc6ICdfb25Nb3VzZWVudGVyKCknLFxuICAgICAgICAgICAgICAgICcoc2xpZGUpJzogJ19vblNsaWRlKCRldmVudCknLFxuICAgICAgICAgICAgICAgICcoc2xpZGVlbmQpJzogJ19vblNsaWRlRW5kKCknLFxuICAgICAgICAgICAgICAgICcoc2xpZGVzdGFydCknOiAnX29uU2xpZGVTdGFydCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWF4XSc6ICdtYXgnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbWluXSc6ICdtaW4nLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXZhbHVlbm93XSc6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLWFjdGl2ZV0nOiAnX2lzQWN0aXZlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItaGFzLXRpY2tzXSc6ICd0aWNrSW50ZXJ2YWwnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1ob3Jpem9udGFsXSc6ICchdmVydGljYWwnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1heGlzLWludmVydGVkXSc6ICdpbnZlcnRBeGlzJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItc2xpZGluZ10nOiAnX2lzU2xpZGluZycsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXNob3dpbmddJzogJ3RodW1iTGFiZWwnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci12ZXJ0aWNhbF0nOiAndmVydGljYWwnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNsaWRlci1taW4tdmFsdWVdJzogJ19pc01pblZhbHVlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zbGlkZXItaGlkZS1sYXN0LXRpY2tdJzogJ19pc01pblZhbHVlICYmIF90aHVtYkdhcCAmJiBpbnZlcnRBeGlzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXdyYXBwZXJcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdHJhY2std3JhcHBlclxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5kXFxcIiBbbmdTdHlsZV09XFxcInRyYWNrQmFja2dyb3VuZFN0eWxlc1xcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10cmFjay1maWxsXFxcIiBbbmdTdHlsZV09XFxcInRyYWNrRmlsbFN0eWxlc1xcXCI+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LXNsaWRlci10aWNrcy1jb250YWluZXJcXFwiIFtuZ1N0eWxlXT1cXFwidGlja3NDb250YWluZXJTdHlsZXNcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdGlja3NcXFwiIFtuZ1N0eWxlXT1cXFwidGlja3NTdHlsZXNcXFwiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVyXFxcIiBbbmdTdHlsZV09XFxcInRodW1iQ29udGFpbmVyU3R5bGVzXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRodW1iXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtc2xpZGVyLXRodW1iLWxhYmVsXFxcIj48c3BhbiBjbGFzcz1cXFwibWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0XFxcIj57e2Rpc3BsYXlWYWx1ZX19PC9zcGFuPjwvZGl2PjwvZGl2PjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5kLC5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjhweDtvdXRsaW5lOjA7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tYXQtc2xpZGVyLXdyYXBwZXJ7cG9zaXRpb246YWJzb2x1dGV9Lm1hdC1zbGlkZXItdHJhY2std3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7cG9zaXRpb246YWJzb2x1dGU7dHJhbnNmb3JtLW9yaWdpbjowIDB9Lm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZHtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2Zvcm0tb3JpZ2luOjEwMCUgMTAwJX0ubWF0LXNsaWRlci10aWNrcy1jb250YWluZXJ7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO292ZXJmbG93OmhpZGRlbn0ubWF0LXNsaWRlci10aWNrc3tib3gtc2l6aW5nOmJvcmRlci1ib3g7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItZGlzYWJsZWQgLm1hdC1zbGlkZXItdGlja3N7b3BhY2l0eTowfS5tYXQtc2xpZGVyLXRodW1iLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLXRodW1ie3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0xMHB4O2JvdHRvbTotMTBweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtib3JkZXI6M3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6NTAlO3RyYW5zZm9ybTpzY2FsZSguNyk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJvcmRlci1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItdGh1bWItbGFiZWx7ZGlzcGxheTpub25lO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHg7Ym9yZGVyLXJhZGl1czo1MCU7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJvcmRlci1yYWRpdXMgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGJhY2tncm91bmQtY29sb3IgLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpfS5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHR7ei1pbmRleDoxO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjcwMDtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNsaWRlci1zbGlkaW5nIC5tYXQtc2xpZGVyLXRodW1iLWNvbnRhaW5lciwubWF0LXNsaWRlci1zbGlkaW5nIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmQsLm1hdC1zbGlkZXItc2xpZGluZyAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zaXRpb24tZHVyYXRpb246MHN9Lm1hdC1zbGlkZXItaGFzLXRpY2tzIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjAgc29saWQgcmdiYSgwLDAsMCwuNik7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1zbGlkZXItYWN0aXZlIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHQsLm1hdC1zbGlkZXItaGFzLXRpY2tzLm1hdC1zbGlkZXItYWN0aXZlIC5tYXQtc2xpZGVyLXRpY2tzLC5tYXQtc2xpZGVyLWhhcy10aWNrcy5tYXQtc2xpZGVyLWFjdGl2ZTpub3QoLm1hdC1zbGlkZXItaGlkZS1sYXN0LXRpY2spIC5tYXQtc2xpZGVyLXdyYXBwZXI6OmFmdGVyLC5tYXQtc2xpZGVyLWhhcy10aWNrczpob3ZlciAubWF0LXNsaWRlci10aWNrcywubWF0LXNsaWRlci1oYXMtdGlja3M6aG92ZXI6bm90KC5tYXQtc2xpZGVyLWhpZGUtbGFzdC10aWNrKSAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlcntvcGFjaXR5OjF9Lm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZyAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtkaXNwbGF5OmZsZXh9Lm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZCAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zZm9ybS1vcmlnaW46MTAwJSAxMDAlfS5tYXQtc2xpZGVyLWF4aXMtaW52ZXJ0ZWQgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZHt0cmFuc2Zvcm0tb3JpZ2luOjAgMH0ubWF0LXNsaWRlci1hY3RpdmUgLm1hdC1zbGlkZXItdGh1bWJ7Ym9yZGVyLXdpZHRoOjJweDt0cmFuc2Zvcm06c2NhbGUoMSl9Lm1hdC1zbGlkZXItYWN0aXZlLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZyAubWF0LXNsaWRlci10aHVtYnt0cmFuc2Zvcm06c2NhbGUoMCl9Lm1hdC1zbGlkZXItYWN0aXZlIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse2JvcmRlci1yYWRpdXM6NTAlIDUwJSAwfS5tYXQtc2xpZGVyLWRpc2FibGVkIC5tYXQtc2xpZGVyLXRodW1ie2JvcmRlci13aWR0aDo0cHg7dHJhbnNmb3JtOnNjYWxlKC41KX0ubWF0LXNsaWRlci1kaXNhYmxlZCAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtkaXNwbGF5Om5vbmV9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbHtoZWlnaHQ6NDhweDttaW4td2lkdGg6MTI4cHh9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci13cmFwcGVye2hlaWdodDoycHg7dG9wOjIzcHg7bGVmdDo4cHg7cmlnaHQ6OHB4fS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXJ7aGVpZ2h0OjJweDtib3JkZXItbGVmdC13aWR0aDoycHg7cmlnaHQ6MDt0b3A6MH0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRyYWNrLXdyYXBwZXJ7aGVpZ2h0OjJweDt3aWR0aDoxMDAlfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdHJhY2stZmlsbHtoZWlnaHQ6MnB4O3dpZHRoOjEwMCU7dHJhbnNmb3JtOnNjYWxlWCgwKX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmR7aGVpZ2h0OjJweDt3aWR0aDoxMDAlO3RyYW5zZm9ybTpzY2FsZVgoMSl9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10aWNrcy1jb250YWluZXJ7aGVpZ2h0OjJweDt3aWR0aDoxMDAlfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGlja3N7YmFja2dyb3VuZDpyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMCwwLDAsLjYpLHJnYmEoMCwwLDAsLjYpIDJweCx0cmFuc3BhcmVudCAwLHRyYW5zcGFyZW50KTtiYWNrZ3JvdW5kOi1tb3otcmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCguMDAwMWRlZyxyZ2JhKDAsMCwwLC42KSxyZ2JhKDAsMCwwLC42KSAycHgsdHJhbnNwYXJlbnQgMCx0cmFuc3BhcmVudCk7YmFja2dyb3VuZC1jbGlwOmNvbnRlbnQtYm94O2hlaWdodDoycHg7d2lkdGg6MTAwJX0ubWF0LXNsaWRlci1ob3Jpem9udGFsIC5tYXQtc2xpZGVyLXRodW1iLWNvbnRhaW5lcnt3aWR0aDoxMDAlO2hlaWdodDowO3RvcDo1MCV9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10aHVtYi1sYWJlbHtyaWdodDotMTRweDt0b3A6LTQwcHg7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMjZweCkgc2NhbGUoLjAxKSByb3RhdGUoNDVkZWcpfS5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtdGV4dHt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9Lm1hdC1zbGlkZXItaG9yaXpvbnRhbC5tYXQtc2xpZGVyLWFjdGl2ZSAubWF0LXNsaWRlci10aHVtYi1sYWJlbHt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0ubWF0LXNsaWRlci12ZXJ0aWNhbHt3aWR0aDo0OHB4O21pbi1oZWlnaHQ6MTI4cHh9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItd3JhcHBlcnt3aWR0aDoycHg7dG9wOjhweDtib3R0b206OHB4O2xlZnQ6MjNweH0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci13cmFwcGVyOjphZnRlcnt3aWR0aDoycHg7Ym9yZGVyLXRvcC13aWR0aDoycHg7Ym90dG9tOjA7bGVmdDowfS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRyYWNrLXdyYXBwZXJ7aGVpZ2h0OjEwMCU7d2lkdGg6MnB4fS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRyYWNrLWZpbGx7aGVpZ2h0OjEwMCU7d2lkdGg6MnB4O3RyYW5zZm9ybTpzY2FsZVkoMCl9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZHtoZWlnaHQ6MTAwJTt3aWR0aDoycHg7dHJhbnNmb3JtOnNjYWxlWSgxKX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aWNrcy1jb250YWluZXJ7d2lkdGg6MnB4O2hlaWdodDoxMDAlfS5tYXQtc2xpZGVyLXZlcnRpY2FsIC5tYXQtc2xpZGVyLXRpY2tze2JhY2tncm91bmQ6cmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCh0byBib3R0b20scmdiYSgwLDAsMCwuNikscmdiYSgwLDAsMCwuNikgMnB4LHRyYW5zcGFyZW50IDAsdHJhbnNwYXJlbnQpO2JhY2tncm91bmQtY2xpcDpjb250ZW50LWJveDt3aWR0aDoycHg7aGVpZ2h0OjEwMCV9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdGh1bWItY29udGFpbmVye2hlaWdodDoxMDAlO3dpZHRoOjA7bGVmdDo1MCV9Lm1hdC1zbGlkZXItdmVydGljYWwgLm1hdC1zbGlkZXItdGh1bWItbGFiZWx7Ym90dG9tOi0xNHB4O2xlZnQ6LTQwcHg7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjZweCkgc2NhbGUoLjAxKSByb3RhdGUoLTQ1ZGVnKX0ubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aHVtYi1sYWJlbC10ZXh0e3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtc2xpZGVyLXZlcnRpY2FsLm1hdC1zbGlkZXItYWN0aXZlIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVse3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX1bZGlyPXJ0bF0gLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXJ7bGVmdDowO3JpZ2h0OmF1dG99W2Rpcj1ydGxdIC5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdHJhY2stZmlsbHt0cmFuc2Zvcm0tb3JpZ2luOjEwMCUgMTAwJX1bZGlyPXJ0bF0gLm1hdC1zbGlkZXItaG9yaXpvbnRhbCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5kLFtkaXI9cnRsXSAubWF0LXNsaWRlci1ob3Jpem9udGFsLm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZCAubWF0LXNsaWRlci10cmFjay1maWxse3RyYW5zZm9ybS1vcmlnaW46MCAwfVtkaXI9cnRsXSAubWF0LXNsaWRlci1ob3Jpem9udGFsLm1hdC1zbGlkZXItYXhpcy1pbnZlcnRlZCAubWF0LXNsaWRlci10cmFjay1iYWNrZ3JvdW5ke3RyYW5zZm9ybS1vcmlnaW46MTAwJSAxMDAlfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kNygwLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbRGlyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kU2xpZGVyKTtcbiAgICByZXR1cm4gTWRTbGlkZXI7XG59KCkpO1xuLyoqXG4gKiBSZW5kZXJlciBjbGFzcyBpbiBvcmRlciB0byBrZWVwIGFsbCBkb20gbWFuaXB1bGF0aW9uIGluIG9uZSBwbGFjZSBhbmQgb3V0c2lkZSBvZiB0aGUgbWFpbiBjbGFzcy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFNsaWRlclJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGlkZXJSZW5kZXJlcihlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlckVsZW1lbnQgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgdGhlIHNsaWRlciB0cmFjayBlbGVtZW50LlxuICAgICAqIFRoZSB0cmFjayBpcyB1c2VkIHJhdGhlciB0aGFuIHRoZSBuYXRpdmUgZWxlbWVudCB0byBpZ25vcmUgdGhlIGV4dHJhIHNwYWNlIHRoYXQgdGhlIHRodW1iIGNhblxuICAgICAqIHRha2UgdXAuXG4gICAgICovXG4gICAgU2xpZGVyUmVuZGVyZXIucHJvdG90eXBlLmdldFNsaWRlckRpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyRWxlbWVudCA9IHRoaXMuX3NsaWRlckVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1hdC1zbGlkZXItd3JhcHBlcicpO1xuICAgICAgICByZXR1cm4gd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBuYXRpdmUgZWxlbWVudC5cbiAgICAgKiBDdXJyZW50bHkgb25seSB1c2VkIHRvIGFsbG93IGEgYmx1ciBldmVudCB0byBmaXJlIGJ1dCB3aWxsIGJlIHVzZWQgd2l0aCBrZXlib2FyZCBpbnB1dCBsYXRlci5cbiAgICAgKi9cbiAgICBTbGlkZXJSZW5kZXJlci5wcm90b3R5cGUuYWRkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlckVsZW1lbnQuZm9jdXMoKTtcbiAgICB9O1xuICAgIHJldHVybiBTbGlkZXJSZW5kZXJlcjtcbn0oKSk7XG52YXIgTWRTbGlkZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVyTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZFNsaWRlck1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kU2xpZGVyTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRTbGlkZXJNb2R1bGUgPSBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZSwgX2FuZ3VsYXJfZm9ybXMuRm9ybXNNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kU2xpZGVyLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2xpZGVyXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IEdlc3R1cmVDb25maWcgfV1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM4KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2xpZGVyTW9kdWxlKTtcbiAgICByZXR1cm4gTWRTbGlkZXJNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkMzkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDggPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIHR3byBNZFNpZGVuYXYgYXJlIG1hdGNoaW5nIHRoZSBzYW1lIHNpZGUuICovXG52YXIgTWREdXBsaWNhdGVkU2lkZW5hdkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkOShNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWREdXBsaWNhdGVkU2lkZW5hdkVycm9yKGFsaWduKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQSBzaWRlbmF2IHdhcyBhbHJlYWR5IGRlY2xhcmVkIGZvciAnYWxpZ249XFxcIlwiICsgYWxpZ24gKyBcIlxcXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWREdXBsaWNhdGVkU2lkZW5hdkVycm9yO1xufShNZEVycm9yKSk7XG4vKiogU2lkZW5hdiB0b2dnbGUgcHJvbWlzZSByZXN1bHQuICovXG52YXIgTWRTaWRlbmF2VG9nZ2xlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNpZGVuYXZUb2dnbGVSZXN1bHQodHlwZSwgYW5pbWF0aW9uRmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25GaW5pc2hlZCA9IGFuaW1hdGlvbkZpbmlzaGVkO1xuICAgIH1cbiAgICByZXR1cm4gTWRTaWRlbmF2VG9nZ2xlUmVzdWx0O1xufSgpKTtcbi8qKlxuICogPG1kLXNpZGVuYXY+IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBjb3JyZXNwb25kcyB0byB0aGUgZHJhd2VyIG9mIHRoZSBzaWRlbmF2LlxuICpcbiAqIFBsZWFzZSByZWZlciB0byBSRUFETUUubWQgZm9yIGV4YW1wbGVzIG9uIGhvdyB0byB1c2UgaXQuXG4gKi9cbnZhciBNZFNpZGVuYXYgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBfZWxlbWVudFJlZiBUaGUgRE9NIGVsZW1lbnQgcmVmZXJlbmNlLiBVc2VkIGZvciB0cmFuc2l0aW9uIGFuZCB3aWR0aCBjYWxjdWxhdGlvbi5cbiAgICAgKiAgICAgSWYgbm90IGF2YWlsYWJsZSB3ZSBkbyBub3QgaG9vayBvbiB0cmFuc2l0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZFNpZGVuYXYoX2VsZW1lbnRSZWYsIF9yZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBzaWRlbmF2IChkaXJlY3Rpb24gbmV1dHJhbCk7IHdoZXRoZXIgJ3N0YXJ0JyBvciAnZW5kJy4gKi9cbiAgICAgICAgdGhpcy5fYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICB0aGlzLl92YWxpZCA9IHRydWU7XG4gICAgICAgIC8qKiBNb2RlIG9mIHRoZSBzaWRlbmF2OyB3aGV0aGVyICdvdmVyJyBvciAnc2lkZScuICovXG4gICAgICAgIHRoaXMubW9kZSA9ICdvdmVyJztcbiAgICAgICAgdGhpcy5fZGlzYWJsZUNsb3NlID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGlzIG9wZW5lZC4gKi9cbiAgICAgICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgYmVpbmcgb3BlbmVkLiBVc2UgdGhpcyB0byBzeW5jaHJvbml6ZSBhbmltYXRpb25zLiAqL1xuICAgICAgICB0aGlzLm9uT3BlblN0YXJ0ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgZnVsbHkgb3BlbmVkLiAqL1xuICAgICAgICB0aGlzLm9uT3BlbiA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGlzIGJlaW5nIGNsb3NlZC4gVXNlIHRoaXMgdG8gc3luY2hyb25pemUgYW5pbWF0aW9ucy4gKi9cbiAgICAgICAgdGhpcy5vbkNsb3NlU3RhcnQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBmdWxseSBjbG9zZWQuICovXG4gICAgICAgIHRoaXMub25DbG9zZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGFsaWdubWVudCBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLm9uQWxpZ25DaGFuZ2VkID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCB0b2dnbGUgYW5pbWF0aW9uIHByb21pc2UuIGBudWxsYCBpZiBubyBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuICovXG4gICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgdG9nZ2xlIGFuaW1hdGlvbiBwcm9taXNlIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAgICAgICAqIGBudWxsYCBpZiBubyBhbmltYXRpb24gaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZCA9IG51bGw7XG4gICAgICAgIHRoaXMub25PcGVuLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVTaWRlbmF2V2FzT3BlbmVkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNGb2N1c1RyYXBEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9mb2N1c1RyYXAuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudFdoZW5SZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkNsb3NlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QoX3RoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZCwgJ2ZvY3VzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZChfdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnYmx1cicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlU2lkZW5hdldhc09wZW5lZCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoaXMgbWQtc2lkZW5hdiBpcyBwYXJ0IG9mIGEgdmFsaWQgbWQtc2lkZW5hdi1jb250YWluZXIgY29uZmlndXJhdGlvbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWxpZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGRyYXdlcnMgYXJlIG5vdCBpbiBhIHZhbGlkIGNvbmZpZ3VyYXRpb24gd2UgY2xvc2UgdGhlbSBhbGwgdW50aWwgdGhleSBhcmUgaW4gYSB2YWxpZFxuICAgICAgICAgICAgLy8gY29uZmlndXJhdGlvbiBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWxpZCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJhbGlnblwiLCB7XG4gICAgICAgIC8qKiBEaXJlY3Rpb24gd2hpY2ggdGhlIHNpZGVuYXYgaXMgYWxpZ25lZCBpbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hbGlnbjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgdmFsaWQgdmFsdWUuXG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA9PSAnZW5kJykgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gdGhpcy5fYWxpZ24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGlnbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMub25BbGlnbkNoYW5nZWQuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJkaXNhYmxlQ2xvc2VcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgc2lkZW5hdiBjYW4gYmUgY2xvc2VkIHdpdGggdGhlIGVzY2FwZSBrZXkgb3Igbm90LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVDbG9zZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZUNsb3NlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiaXNGb2N1c1RyYXBEaXNhYmxlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVGhlIGZvY3VzIHRyYXAgaXMgb25seSBlbmFibGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgb3BlbiBpbiBhbnkgbW9kZSBvdGhlciB0aGFuIHNpZGUuXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMub3BlbmVkIHx8IHRoaXMubW9kZSA9PSAnc2lkZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgc2lkZW5hdiBpcyBzZXQgdG8gb3BlbmVkIGluIHRoZSB0ZW1wbGF0ZSBhbmQgdGhlIHRyYW5zaXRpb25cbiAgICAgICAgLy8gaXNuJ3QgZW5kZWQuXG4gICAgICAgIGlmICh0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UgPSB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIm9wZW5lZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGlzIG9wZW5lZC4gV2Ugb3ZlcmxvYWQgdGhpcyBiZWNhdXNlIHdlIHRyaWdnZXIgYW4gZXZlbnQgd2hlbiBpdFxuICAgICAgICAgKiBzdGFydHMgb3IgZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vcGVuZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBPcGVuIHRoaXMgc2lkZW5hdiwgYW5kIHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiBpdCdzIGZ1bGx5IG9wZW5lZCAob3IgZ2V0XG4gICAgICogcmVqZWN0ZWQgaWYgaXQgZGlkbid0KS4gKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZSh0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlIHRoaXMgc2lkZW5hdiwgYW5kIHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiBpdCdzIGZ1bGx5IGNsb3NlZCAob3IgZ2V0XG4gICAgICogcmVqZWN0ZWQgaWYgaXQgZGlkbid0KS5cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2dnbGUoZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoaXMgc2lkZW5hdi4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgb3BlbigpIHdoZW4gaXQncyBhbHJlYWR5IG9wZW5lZCwgb3JcbiAgICAgKiBjbG9zZSgpIHdoZW4gaXQncyBjbG9zZWQuXG4gICAgICogQHBhcmFtIGlzT3BlbiBXaGV0aGVyIHRoZSBzaWRlbmF2IHNob3VsZCBiZSBvcGVuLlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB3aGV0aGVyIHRoZSBzaWRlbmF2IHdhcyBvcGVuZWQgb3IgY2xvc2VkLlxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGlzT3Blbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNPcGVuID09PSB2b2lkIDApIHsgaXNPcGVuID0gIXRoaXMub3BlbmVkOyB9XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgTWRTaWRlbmF2VG9nZ2xlUmVzdWx0KGlzT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG9ydGN1dCBpdCBpZiB3ZSdyZSBhbHJlYWR5IG9wZW5lZC5cbiAgICAgICAgaWYgKGlzT3BlbiA9PT0gdGhpcy5vcGVuZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlIHx8XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG5ldyBNZFNpZGVuYXZUb2dnbGVSZXN1bHQoaXNPcGVuID8gJ29wZW4nIDogJ2Nsb3NlJywgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5lZCA9IGlzT3BlbjtcbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW5TdGFydC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VTdGFydC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVUb2dnbGVBbmltYXRpb25Qcm9taXNlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSA9IGZ1bmN0aW9uIChhbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5ldyBNZFNpZGVuYXZUb2dnbGVSZXN1bHQoaXNPcGVuID8gJ29wZW4nIDogJ2Nsb3NlJywgYW5pbWF0aW9uRmluaXNoZWQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9nZ2xlQW5pbWF0aW9uUHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGtleWJvYXJkIGV2ZW50cy5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS5oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEUgJiYgIXRoaXMuZGlzYWJsZUNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0cmFuc2l0aW9uIGhhcyBmaW5pc2hlZCwgc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZSBmb3IgY2xhc3NlcyBhbmQgZW1pdCB0aGUgcHJvcGVyIGV2ZW50LlxuICAgICAqIFRoZSBldmVudCBwYXNzZWQgaXMgYWN0dWFsbHkgb2YgdHlwZSBUcmFuc2l0aW9uRXZlbnQsIGJ1dCB0aGF0IHR5cGUgaXMgbm90IGF2YWlsYWJsZSBpblxuICAgICAqIEFuZHJvaWQgc28gd2UgdXNlIGFueS5cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLl9vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uRXZlbnQudGFyZ2V0ID09IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgJiYgdHJhbnNpdGlvbkV2ZW50LnByb3BlcnR5TmFtZS5lbmRzV2l0aCgndHJhbnNmb3JtJykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlVG9nZ2xlQW5pbWF0aW9uUHJvbWlzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlID0gdGhpcy5fcmVzb2x2ZVRvZ2dsZUFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNDbG9zaW5nXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX29wZW5lZCAmJiAhIXRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc09wZW5pbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcGVuZWQgJiYgISF0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNDbG9zZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fb3BlbmVkICYmICF0aGlzLl90b2dnbGVBbmltYXRpb25Qcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNPcGVuZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcGVuZWQgJiYgIXRoaXMuX3RvZ2dsZUFuaW1hdGlvblByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc0VuZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ24gPT0gJ2VuZCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9tb2RlU2lkZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAnc2lkZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9tb2RlT3ZlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAnb3Zlcic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9tb2RlUHVzaFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAncHVzaCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl93aWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKEZvY3VzVHJhcCksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIEZvY3VzVHJhcClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9mb2N1c1RyYXBcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJhbGlnblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzkoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcImRpc2FibGVDbG9zZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ29wZW4tc3RhcnQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib25PcGVuU3RhcnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ29wZW4nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib25PcGVuXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCdjbG9zZS1zdGFydCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJvbkNsb3NlU3RhcnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ2Nsb3NlJyksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIm9uQ2xvc2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ2FsaWduLWNoYW5nZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib25BbGlnbkNoYW5nZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib3BlbmVkXCIsIG51bGwpO1xuICAgIE1kU2lkZW5hdiA9IF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1zaWRlbmF2LCBtYXQtc2lkZW5hdicsXG4gICAgICAgICAgICAvLyBUT0RPKG1tYWxlcmJhKTogbW92ZSB0ZW1wbGF0ZSB0byBzZXBhcmF0ZSBmaWxlLlxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGNkay1mb2N1cy10cmFwIGNsYXNzPVxcXCJtYXQtc2lkZW5hdi1mb2N1cy10cmFwXFxcIiBbZGlzYWJsZWRdPVxcXCJpc0ZvY3VzVHJhcERpc2FibGVkXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9jZGstZm9jdXMtdHJhcD5cIixcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2XSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnKHRyYW5zaXRpb25lbmQpJzogJ19vblRyYW5zaXRpb25FbmQoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgJyhrZXlkb3duKSc6ICdoYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgIC8vIG11c3QgcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGFsaWduaW5nIHRleHQgYmFzZWQgb24gdmFsdWVcbiAgICAgICAgICAgICAgICAnW2F0dHIuYWxpZ25dJzogJ251bGwnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtY2xvc2VkXSc6ICdfaXNDbG9zZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtY2xvc2luZ10nOiAnX2lzQ2xvc2luZycsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1lbmRdJzogJ19pc0VuZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1vcGVuZWRdJzogJ19pc09wZW5lZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1vcGVuaW5nXSc6ICdfaXNPcGVuaW5nJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LW92ZXJdJzogJ19tb2RlT3ZlcicsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtc2lkZW5hdi1wdXNoXSc6ICdfbW9kZVB1c2gnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtc2lkZV0nOiAnX21vZGVTaWRlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LWludmFsaWRdJzogJyF2YWxpZCcsXG4gICAgICAgICAgICAgICAgJ3RhYkluZGV4JzogJy0xJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFNpZGVuYXYpO1xuICAgIHJldHVybiBNZFNpZGVuYXY7XG59KCkpO1xuLyoqXG4gKiA8bWQtc2lkZW5hdi1jb250YWluZXI+IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBwYXJlbnQgY29tcG9uZW50IHRvIG9uZSBvciB0d28gPG1kLXNpZGVuYXY+cyB0aGF0IHZhbGlkYXRlcyB0aGUgc3RhdGUgaW50ZXJuYWxseVxuICogYW5kIGNvb3JkaW5hdGVzIHRoZSBiYWNrZHJvcCBhbmQgY29udGVudCBzdHlsaW5nLlxuICovXG52YXIgTWRTaWRlbmF2Q29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNpZGVuYXZDb250YWluZXIoX2RpciwgX2VsZW1lbnQsIF9yZW5kZXJlciwgX25nWm9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGJhY2tkcm9wIGlzIGNsaWNrZWQuICovXG4gICAgICAgIHRoaXMuYmFja2Ryb3BDbGljayA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogV2hldGhlciB0byBlbmFibGUgb3Blbi9jbG9zZSB0cmFudGlvbnMuICovXG4gICAgICAgIHRoaXMuX2VuYWJsZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIC8vIElmIGEgYERpcmAgZGlyZWN0aXZlIGV4aXN0cyB1cCB0aGUgdHJlZSwgbGlzdGVuIGRpcmVjdGlvbiBjaGFuZ2VzIGFuZCB1cGRhdGUgdGhlIGxlZnQvcmlnaHRcbiAgICAgICAgLy8gcHJvcGVydGllcyB0byBwb2ludCB0byB0aGUgcHJvcGVyIHN0YXJ0L2VuZC5cbiAgICAgICAgaWYgKF9kaXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgX2Rpci5kaXJDaGFuZ2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZURyYXdlcnMoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUsIFwic3RhcnRcIiwge1xuICAgICAgICAvKiogVGhlIHNpZGVuYXYgY2hpbGQgd2l0aCB0aGUgYHN0YXJ0YCBhbGlnbm1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLCBcImVuZFwiLCB7XG4gICAgICAgIC8qKiBUaGUgc2lkZW5hdiBjaGlsZCB3aXRoIHRoZSBgZW5kYCBhbGlnbm1lbnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZW5kOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gT24gY2hhbmdlcywgYXNzZXJ0IG9uIGNvbnNpc3RlbmN5LlxuICAgICAgICB0aGlzLl9zaWRlbmF2cy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmFsaWRhdGVEcmF3ZXJzKCk7IH0pO1xuICAgICAgICB0aGlzLl9zaWRlbmF2cy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlbmF2KSB7XG4gICAgICAgICAgICBfdGhpcy5fd2F0Y2hTaWRlbmF2VG9nZ2xlKHNpZGVuYXYpO1xuICAgICAgICAgICAgX3RoaXMuX3dhdGNoU2lkZW5hdkFsaWduKHNpZGVuYXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVEcmF3ZXJzKCk7XG4gICAgICAgIC8vIEdpdmUgdGhlIHZpZXcgYSBjaGFuY2UgdG8gcmVuZGVyIHRoZSBpbml0aWFsIHN0YXRlLCB0aGVuIGVuYWJsZSB0cmFuc2l0aW9ucy5cbiAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2VuYWJsZVRyYW5zaXRpb25zID0gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHNpZGVuYXYgZXZlbnRzIGluIG9yZGVyIHRvIHNldCBhIGNsYXNzIG9uIHRoZSBtYWluIGNvbnRhaW5lciBlbGVtZW50IHdoZW4gdGhlXG4gICAgICogc2lkZW5hdiBpcyBvcGVuIGFuZCB0aGUgYmFja2Ryb3AgaXMgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIGFueSBvdmVyZmxvdyBvbiB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBpcyBwcm9wZXJseSBoaWRkZW4uXG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fd2F0Y2hTaWRlbmF2VG9nZ2xlID0gZnVuY3Rpb24gKHNpZGVuYXYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFzaWRlbmF2IHx8IHNpZGVuYXYubW9kZSA9PT0gJ3NpZGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2lkZW5hdi5vbk9wZW4uc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zZXRDb250YWluZXJDbGFzcyhzaWRlbmF2LCB0cnVlKTsgfSk7XG4gICAgICAgIHNpZGVuYXYub25DbG9zZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldENvbnRhaW5lckNsYXNzKHNpZGVuYXYsIGZhbHNlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIHNpZGVuYXYgb25BbGlnbkNoYW5nZWQgZXZlbnQgaW4gb3JkZXIgdG8gcmUtdmFsaWRhdGUgZHJhd2VycyB3aGVuIHRoZSBhbGlnblxuICAgICAqIGNoYW5nZXMuXG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fd2F0Y2hTaWRlbmF2QWxpZ24gPSBmdW5jdGlvbiAoc2lkZW5hdikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXNpZGVuYXYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaWRlbmF2Lm9uQWxpZ25DaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmFsaWRhdGVEcmF3ZXJzKCk7IH0pO1xuICAgIH07XG4gICAgLyoqIFRvZ2dsZXMgdGhlICdtYXQtc2lkZW5hdi1vcGVuZWQnIGNsYXNzIG9uIHRoZSBtYWluICdtZC1zaWRlbmF2LWNvbnRhaW5lcicgZWxlbWVudC4gKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9zZXRDb250YWluZXJDbGFzcyA9IGZ1bmN0aW9uIChzaWRlbmF2LCBib29sKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtYXQtc2lkZW5hdi1vcGVuZWQnLCBib29sKTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSB2YWxpZCBzdGF0ZSBvZiB0aGUgZHJhd2Vycy4gKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9zZXREcmF3ZXJzVmFsaWQgPSBmdW5jdGlvbiAodmFsaWQpIHtcbiAgICAgICAgdGhpcy5fc2lkZW5hdnMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZW5hdikge1xuICAgICAgICAgICAgc2lkZW5hdi52YWxpZCA9IHZhbGlkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9lbmQgPSB0aGlzLl9sZWZ0ID0gdGhpcy5fcmlnaHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVmFsaWRhdGUgdGhlIHN0YXRlIG9mIHRoZSBzaWRlbmF2IGNoaWxkcmVuIGNvbXBvbmVudHMuICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fdmFsaWRhdGVEcmF3ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX2VuZCA9IG51bGw7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYXQgbW9zdCBvbmUgc3RhcnQgYW5kIG9uZSBlbmQgc2lkZW5hdi5cbiAgICAgICAgLy8gTk9URTogV2UgbXVzdCBjYWxsIHRvQXJyYXkgb24gX3NpZGVuYXZzIGV2ZW4gdGhvdWdoIGl0J3MgaXRlcmFibGVcbiAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxNjQpLlxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fc2lkZW5hdnMudG9BcnJheSgpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNpZGVuYXYgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoc2lkZW5hdi5hbGlnbiA9PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXREcmF3ZXJzVmFsaWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZCA9IHNpZGVuYXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXREcmF3ZXJzVmFsaWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gc2lkZW5hdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX2xlZnQgPSBudWxsO1xuICAgICAgICAvLyBEZXRlY3QgaWYgd2UncmUgTFRSIG9yIFJUTC5cbiAgICAgICAgaWYgKHRoaXMuX2RpciA9PSBudWxsIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJykge1xuICAgICAgICAgICAgdGhpcy5fbGVmdCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSB0aGlzLl9lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sZWZ0ID0gdGhpcy5fZW5kO1xuICAgICAgICAgICAgdGhpcy5fcmlnaHQgPSB0aGlzLl9zdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXREcmF3ZXJzVmFsaWQodHJ1ZSk7XG4gICAgfTtcbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9vbkJhY2tkcm9wQ2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iYWNrZHJvcENsaWNrLmVtaXQoKTtcbiAgICAgICAgdGhpcy5fY2xvc2VNb2RhbFNpZGVuYXYoKTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2Nsb3NlTW9kYWxTaWRlbmF2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDbG9zZSBhbGwgb3BlbiBzaWRlbmF2J3Mgd2hlcmUgY2xvc2luZyBpcyBub3QgZGlzYWJsZWQgYW5kIHRoZSBtb2RlIGlzIG5vdCBgc2lkZWAuXG4gICAgICAgIFt0aGlzLl9zdGFydCwgdGhpcy5fZW5kXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoc2lkZW5hdikgeyByZXR1cm4gc2lkZW5hdiAmJiAhc2lkZW5hdi5kaXNhYmxlQ2xvc2UgJiYgc2lkZW5hdi5tb2RlICE9PSAnc2lkZSc7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoc2lkZW5hdikgeyByZXR1cm4gc2lkZW5hdi5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2lzU2hvd2luZ0JhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lzU2lkZW5hdk9wZW4odGhpcy5fc3RhcnQpICYmIHRoaXMuX3N0YXJ0Lm1vZGUgIT0gJ3NpZGUnKVxuICAgICAgICAgICAgfHwgKHRoaXMuX2lzU2lkZW5hdk9wZW4odGhpcy5fZW5kKSAmJiB0aGlzLl9lbmQubW9kZSAhPSAnc2lkZScpO1xuICAgIH07XG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5faXNTaWRlbmF2T3BlbiA9IGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIHJldHVybiBzaWRlICE9IG51bGwgJiYgc2lkZS5vcGVuZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBzaWRlbmF2LCBpZiBpdCdzIGluIHRoZSBwcm9wZXIgbW9kZSBhbmQgb3BlbmVkLlxuICAgICAqIFRoaXMgbWF5IHJlbGF5b3V0IHRoZSB2aWV3LCBzbyBkbyBub3QgY2FsbCB0aGlzIG9mdGVuLlxuICAgICAqIEBwYXJhbSBzaWRlbmF2XG4gICAgICogQHBhcmFtIG1vZGVcbiAgICAgKi9cbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGggPSBmdW5jdGlvbiAoc2lkZW5hdiwgbW9kZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lzU2lkZW5hdk9wZW4oc2lkZW5hdikgJiYgc2lkZW5hdi5tb2RlID09IG1vZGUpID8gc2lkZW5hdi5fd2lkdGggOiAwO1xuICAgIH07XG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0TWFyZ2luTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCh0aGlzLl9sZWZ0LCAnc2lkZScpO1xuICAgIH07XG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0TWFyZ2luUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fcmlnaHQsICdzaWRlJyk7XG4gICAgfTtcbiAgICBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLl9nZXRQb3NpdGlvbkxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fbGVmdCwgJ3B1c2gnKTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldFBvc2l0aW9uUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fcmlnaHQsICdwdXNoJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBob3Jpem9udGFsIG9mZnNldCBmb3IgdGhlIGNvbnRlbnQgYXJlYS4gIFRoZXJlIHNob3VsZCBuZXZlciBiZSBhIHZhbHVlIGZvciBib3RoXG4gICAgICogbGVmdCBhbmQgcmlnaHQsIHNvIGJ5IHN1YnRyYWN0aW5nIHRoZSByaWdodCB2YWx1ZSBmcm9tIHRoZSBsZWZ0IHZhbHVlLCB3ZSBzaG91bGQgYWx3YXlzIGdldFxuICAgICAqIHRoZSBhcHByb3ByaWF0ZSBvZmZzZXQuXG4gICAgICovXG4gICAgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZS5fZ2V0UG9zaXRpb25PZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQb3NpdGlvbkxlZnQoKSAtIHRoaXMuX2dldFBvc2l0aW9uUmlnaHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNpbmcgW25nU3R5bGVdIHJhdGhlciB0aGFuIHNlcGFyYXRlIFtzdHlsZS4uLl0gcHJvcGVydGllcyBiZWNhdXNlIFtzdHlsZS50cmFuc2Zvcm1dXG4gICAgICogZG9lc24ndCBzZWVtIHRvIHdvcmsgcmlnaHQgbm93LlxuICAgICAqL1xuICAgIE1kU2lkZW5hdkNvbnRhaW5lci5wcm90b3R5cGUuX2dldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IHRoaXMuX2dldE1hcmdpbkxlZnQoKSArIFwicHhcIixcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiB0aGlzLl9nZXRNYXJnaW5SaWdodCgpICsgXCJweFwiLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKFwiICsgdGhpcy5fZ2V0UG9zaXRpb25PZmZzZXQoKSArIFwicHgsIDAsIDApXCJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZFNpZGVuYXYpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZFNpZGVuYXZDb250YWluZXIucHJvdG90eXBlLCBcIl9zaWRlbmF2c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2Q29udGFpbmVyLnByb3RvdHlwZSwgXCJiYWNrZHJvcENsaWNrXCIsIHZvaWQgMCk7XG4gICAgTWRTaWRlbmF2Q29udGFpbmVyID0gX19kZWNvcmF0ZSQzOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXNpZGVuYXYtY29udGFpbmVyLCBtYXQtc2lkZW5hdi1jb250YWluZXInLFxuICAgICAgICAgICAgLy8gRG8gbm90IHVzZSBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2guIEl0IGRvZXMgbm90IHdvcmsgZm9yIHRoaXMgY29tcG9uZW50IGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IGl0IGlzIGEgc2libGluZyBvZiBNZFNpZGVuYXYgKG9uIHRoZSBjb250ZW50IHRyZWUpIGFuZCBpc24ndCB1cGRhdGVkIHdoZW4gTWRTaWRlbmF2XG4gICAgICAgICAgICAvLyBjaGFuZ2VzIGl0cyBzdGF0ZS5cbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1zaWRlbmF2LWJhY2tkcm9wXFxcIiAoY2xpY2spPVxcXCJfb25CYWNrZHJvcENsaWNrZWQoKVxcXCIgW2NsYXNzLm1hdC1zaWRlbmF2LXNob3duXT1cXFwiX2lzU2hvd2luZ0JhY2tkcm9wKClcXFwiPjwvZGl2PjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtc2lkZW5hdiwgbWF0LXNpZGVuYXZcXFwiPjwvbmctY29udGVudD48ZGl2IGNsYXNzPVxcXCJtYXQtc2lkZW5hdi1jb250ZW50XFxcIiBbbmdTdHlsZV09XFxcIl9nZXRTdHlsZXMoKVxcXCIgY2RrLXNjcm9sbGFibGU+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXNpZGVuYXYtY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7Ym94LXNpemluZzpib3JkZXItYm94Oy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVufS5tYXQtc2lkZW5hdi1iYWNrZHJvcCwubWF0LXNpZGVuYXYtY29udGFpbmVyW2Z1bGxzY3JlZW5de3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO3JpZ2h0OjA7bGVmdDowfS5tYXQtc2lkZW5hdi1jb250YWluZXJbZnVsbHNjcmVlbl0ubWF0LXNpZGVuYXYtb3BlbmVke292ZXJmbG93OmhpZGRlbn0ubWF0LXNpZGVuYXYtYmFja2Ryb3B7ZGlzcGxheTpibG9jazt6LWluZGV4OjI7dmlzaWJpbGl0eTpoaWRkZW59Lm1hdC1zaWRlbmF2LWJhY2tkcm9wLm1hdC1zaWRlbmF2LXNob3due3Zpc2liaWxpdHk6dmlzaWJsZX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtY2xvc2VkLC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtY2xvc2VkLFtkaXI9cnRsXSAubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtY2xvc2VkLFtkaXI9cnRsXSAubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LWNsb3NlZHt2aXNpYmlsaXR5OmhpZGRlbn1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LXNpZGVuYXYtYmFja2Ryb3B7b3BhY2l0eTouNX19Lm1hdC1zaWRlbmF2LWNvbnRlbnR7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTtkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDAlO292ZXJmbG93OmF1dG99Lm1hdC1zaWRlbmF2e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Ym90dG9tOjA7ei1pbmRleDozO21pbi13aWR0aDo1JTtvdXRsaW5lOjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xMDAlLDAsMCl9Lm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5lZCwubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtb3BlbmluZ3t0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfS5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1zaWRle3otaW5kZXg6MX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5ke3JpZ2h0OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwMCUsMCwwKX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LW9wZW5lZCwubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LW9wZW5pbmd7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX1bZGlyPXJ0bF0gLm1hdC1zaWRlbmF2e3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgxMDAlLDAsMCl9W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuZWQsW2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1vcGVuaW5ne3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCl9W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmR7bGVmdDowO3JpZ2h0OmF1dG87dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xMDAlLDAsMCl9W2Rpcj1ydGxdIC5tYXQtc2lkZW5hdi5tYXQtc2lkZW5hdi1lbmQubWF0LXNpZGVuYXYtb3BlbmVkLFtkaXI9cnRsXSAubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtZW5kLm1hdC1zaWRlbmF2LW9wZW5pbmd7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX0ubWF0LXNpZGVuYXYubWF0LXNpZGVuYXYtb3BlbmVkOm5vdCgubWF0LXNpZGVuYXYtc2lkZSksLm1hdC1zaWRlbmF2Lm1hdC1zaWRlbmF2LW9wZW5pbmc6bm90KC5tYXQtc2lkZW5hdi1zaWRlKXtib3gtc2hhZG93OjAgOHB4IDEwcHggLTVweCByZ2JhKDAsMCwwLC4yKSwwIDE2cHggMjRweCAycHggcmdiYSgwLDAsMCwuMTQpLDAgNnB4IDMwcHggNXB4IHJnYmEoMCwwLDAsLjEyKX0ubWF0LXNpZGVuYXYtZm9jdXMtdHJhcHtoZWlnaHQ6MTAwJX0ubWF0LXNpZGVuYXYtZm9jdXMtdHJhcD4uY2RrLWZvY3VzLXRyYXAtY29udGVudHtib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTphdXRvO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfS5tYXQtc2lkZW5hdi1pbnZhbGlke2Rpc3BsYXk6bm9uZX1cIixcblwiLm1hdC1zaWRlbmF2LXRyYW5zaXRpb24gLm1hdC1zaWRlbmF2e3RyYW5zaXRpb246dHJhbnNmb3JtIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LXNpZGVuYXYtdHJhbnNpdGlvbiAubWF0LXNpZGVuYXYtY29udGVudHt0cmFuc2l0aW9uLWR1cmF0aW9uOi40czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKTt0cmFuc2l0aW9uLXByb3BlcnR5OnRyYW5zZm9ybSxtYXJnaW4tbGVmdCxtYXJnaW4tcmlnaHR9Lm1hdC1zaWRlbmF2LXRyYW5zaXRpb24gLm1hdC1zaWRlbmF2LWJhY2tkcm9wLm1hdC1zaWRlbmF2LXNob3due3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpZGVuYXYtY29udGFpbmVyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zaWRlbmF2LXRyYW5zaXRpb25dJzogJ19lbmFibGVUcmFuc2l0aW9ucycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ4KDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDM5KCdkZXNpZ246cGFyYW10eXBlcycsIFtEaXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5OZ1pvbmVdKVxuICAgIF0sIE1kU2lkZW5hdkNvbnRhaW5lcik7XG4gICAgcmV0dXJuIE1kU2lkZW5hdkNvbnRhaW5lcjtcbn0oKSk7XG52YXIgTWRTaWRlbmF2TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNpZGVuYXZNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kU2lkZW5hdk1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kU2lkZW5hdk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdk1vZHVsZSA9IF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBDb21wYXRpYmlsaXR5TW9kdWxlLCBBMTF5TW9kdWxlLCBPdmVybGF5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFNpZGVuYXZDb250YWluZXIsIE1kU2lkZW5hdiwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNpZGVuYXZDb250YWluZXIsIE1kU2lkZW5hdl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFNpZGVuYXZNb2R1bGUpO1xuICAgIHJldHVybiBNZFNpZGVuYXZNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ0MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0MCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kTGlzdERpdmlkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdERpdmlkZXIoKSB7XG4gICAgfVxuICAgIE1kTGlzdERpdmlkZXIgPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1kaXZpZGVyLCBtYXQtZGl2aWRlcidcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGlzdERpdmlkZXIpO1xuICAgIHJldHVybiBNZExpc3REaXZpZGVyO1xufSgpKTtcbnZhciBNZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdCgpIHtcbiAgICB9XG4gICAgTWRMaXN0ID0gX19kZWNvcmF0ZSQ0MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWxpc3QsIG1hdC1saXN0LCBtZC1uYXYtbGlzdCwgbWF0LW5hdi1saXN0JyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0JyB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1saXN0LC5tYXQtbmF2LWxpc3R7cGFkZGluZy10b3A6OHB4O2Rpc3BsYXk6YmxvY2t9Lm1hdC1saXN0IC5tYXQtc3ViaGVhZGVyLC5tYXQtbmF2LWxpc3QgLm1hdC1zdWJoZWFkZXJ7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7aGVpZ2h0OjQ4cHg7cGFkZGluZzoxNnB4O21hcmdpbjowO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjUwMH0ubWF0LWxpc3QgLm1hdC1zdWJoZWFkZXI6Zmlyc3QtY2hpbGQsLm1hdC1uYXYtbGlzdCAubWF0LXN1YmhlYWRlcjpmaXJzdC1jaGlsZHttYXJnaW4tdG9wOi04cHh9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW17ZGlzcGxheTpibG9ja30ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdzthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtib3gtc2l6aW5nOmJvcmRlci1ib3g7Zm9udC1zaXplOjE2cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDE2cHh9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC1saXN0LWl0ZW0tYXZhdGFyIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtbGlzdC1pdGVtLWF2YXRhciAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo1NnB4fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtMi1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS5tYXQtMi1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjcycHh9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6ODhweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0ubWF0LW11bHRpLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtLm1hdC1tdWx0aS1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjEwMCU7cGFkZGluZzo4cHggMTZweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQsLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3dpZHRoOjEwMCU7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjAgMTZweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ+KiwubWF0LW5hdi1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0Pip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ6ZW1wdHksLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0OmZpcnN0LWNoaWxkLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ6Zmlyc3QtY2hpbGR7cGFkZGluZzowfS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtYXZhdGFyLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWF2YXRhcntmbGV4LXNocmluazowO3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7Ym9yZGVyLXJhZGl1czo1MCV9Lm1hdC1saXN0IC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1pY29uLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWljb257d2lkdGg6MjRweDtoZWlnaHQ6MjRweDtib3JkZXItcmFkaXVzOjUwJTtwYWRkaW5nOjRweH0ubWF0LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5lLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5le3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdy14OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94fS5tYXQtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMiksLm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMil7Zm9udC1zaXplOjE0cHh9Lm1hdC1saXN0W2RlbnNlXSwubWF0LW5hdi1saXN0W2RlbnNlXXtwYWRkaW5nLXRvcDo0cHg7ZGlzcGxheTpibG9ja30ubWF0LWxpc3RbZGVuc2VdIC5tYXQtc3ViaGVhZGVyLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtc3ViaGVhZGVye2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O2hlaWdodDo0MHB4O3BhZGRpbmc6MTZweDttYXJnaW46MDtmb250LXNpemU6MTNweDtmb250LXdlaWdodDo1MDB9Lm1hdC1saXN0W2RlbnNlXSAubWF0LXN1YmhlYWRlcjpmaXJzdC1jaGlsZCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LXN1YmhlYWRlcjpmaXJzdC1jaGlsZHttYXJnaW4tdG9wOi00cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbXtkaXNwbGF5OmJsb2NrfS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtaXRlbS1jb250ZW50e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7YWxpZ24taXRlbXM6Y2VudGVyO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Ym94LXNpemluZzpib3JkZXItYm94O2ZvbnQtc2l6ZToxM3B4O2hlaWdodDo0MHB4O3BhZGRpbmc6MCAxNnB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LWxpc3QtaXRlbS1hdmF0YXIgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtbGlzdC1pdGVtLWF2YXRhciAubWF0LWxpc3QtaXRlbS1jb250ZW50e2hlaWdodDo0OHB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0ubWF0LTItbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC0yLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudHtoZWlnaHQ6NjBweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC0zLWxpbmUgLm1hdC1saXN0LWl0ZW0tY29udGVudCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtMy1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0Ojc2cHh9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbS5tYXQtbXVsdGktbGluZSAubWF0LWxpc3QtaXRlbS1jb250ZW50LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtLm1hdC1tdWx0aS1saW5lIC5tYXQtbGlzdC1pdGVtLWNvbnRlbnR7aGVpZ2h0OjEwMCU7cGFkZGluZzo4cHggMTZweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0LC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC10ZXh0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCAxNnB4fS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LXRleHQ+KiwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dD4qe21hcmdpbjowO3BhZGRpbmc6MDtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOmluaGVyaXR9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDpmaXJzdC1jaGlsZCwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtdGV4dDpmaXJzdC1jaGlsZHtwYWRkaW5nOjB9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpc3QtYXZhdGFyLC5tYXQtbmF2LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGlzdC1hdmF0YXJ7ZmxleC1zaHJpbms6MDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWljb24sLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saXN0LWljb257d2lkdGg6MjRweDtoZWlnaHQ6MjRweDtib3JkZXItcmFkaXVzOjUwJTtwYWRkaW5nOjRweH0ubWF0LWxpc3RbZGVuc2VdIC5tYXQtbGlzdC1pdGVtIC5tYXQtbGluZSwubWF0LW5hdi1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmV7d2hpdGUtc3BhY2U6bm93cmFwO292ZXJmbG93LXg6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9Lm1hdC1saXN0W2RlbnNlXSAubWF0LWxpc3QtaXRlbSAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMiksLm1hdC1uYXYtbGlzdFtkZW5zZV0gLm1hdC1saXN0LWl0ZW0gLm1hdC1saW5lOm50aC1jaGlsZChuKzIpe2ZvbnQtc2l6ZToxM3B4fS5tYXQtZGl2aWRlcntkaXNwbGF5OmJsb2NrO2JvcmRlci10b3Atc3R5bGU6c29saWQ7Ym9yZGVyLXRvcC13aWR0aDoxcHg7bWFyZ2luOjB9Lm1hdC1uYXYtbGlzdCBhe3RleHQtZGVjb3JhdGlvbjpub25lO2NvbG9yOmluaGVyaXR9Lm1hdC1uYXYtbGlzdCAubWF0LWxpc3QtaXRlbS1jb250ZW50e2N1cnNvcjpwb2ludGVyfS5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0tY29udGVudC5tYXQtbGlzdC1pdGVtLWZvY3VzLC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0tY29udGVudDpob3ZlcntvdXRsaW5lOjB9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZExpc3QpO1xuICAgIHJldHVybiBNZExpc3Q7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kTGlzdENzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0Q3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZExpc3RDc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1saXN0LCBtYXQtbGlzdCcsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbGlzdF0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGlzdENzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kTGlzdENzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWROYXZMaXN0Q3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE5hdkxpc3RDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kTmF2TGlzdENzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLW5hdi1saXN0LCBtYXQtbmF2LWxpc3QnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LW5hdi1saXN0XSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWROYXZMaXN0Q3NzTWF0U3R5bGVyKTtcbiAgICByZXR1cm4gTWROYXZMaXN0Q3NzTWF0U3R5bGVyO1xufSgpKTtcbi8qKlxuICogRGlyZWN0aXZlIHdob3NlIHB1cnBvc2UgaXMgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nIHRvIHRoaXMgc2VsZWN0b3IuXG4gKi9cbnZhciBNZERpdmlkZXJDc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGl2aWRlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWREaXZpZGVyQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQ0MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtZGl2aWRlciwgbWF0LWRpdmlkZXInLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpdmlkZXJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZERpdmlkZXJDc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZERpdmlkZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuLyogTmVlZCBkaXJlY3RpdmUgZm9yIGEgQ29udGVudENoaWxkIHF1ZXJ5IGluIGxpc3QtaXRlbSAqL1xudmFyIE1kTGlzdEF2YXRhckNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtbGlzdC1hdmF0YXJdLCBbbWF0LWxpc3QtYXZhdGFyXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbGlzdC1hdmF0YXJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuLyogTmVlZCBkaXJlY3RpdmUgdG8gYWRkIG1hdC0gQ1NTIHN0eWxpbmcgKi9cbnZhciBNZExpc3RJY29uQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3RJY29uQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZExpc3RJY29uQ3NzTWF0U3R5bGVyID0gX19kZWNvcmF0ZSQ0MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWxpc3QtaWNvbl0sIFttYXQtbGlzdC1pY29uXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtbGlzdC1pY29uXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaXN0SWNvbkNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kTGlzdEljb25Dc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtc3ViaGVhZGVyXSwgW21hdC1zdWJoZWFkZXJdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zdWJoZWFkZXJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xudmFyIE1kTGlzdEl0ZW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdEl0ZW0oX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9oYXNGb2N1cyA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRMaXN0SXRlbS5wcm90b3R5cGUsIFwiX2hhc0F2YXRhclwiLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKGF2YXRhcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21hdC1saXN0LWl0ZW0tYXZhdGFyJywgYXZhdGFyICE9IG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZExpc3RJdGVtLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVTZXR0ZXIgPSBuZXcgTWRMaW5lU2V0dGVyKHRoaXMuX2xpbmVzLCB0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudCk7XG4gICAgfTtcbiAgICBNZExpc3RJdGVtLnByb3RvdHlwZS5faGFuZGxlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gdHJ1ZTtcbiAgICB9O1xuICAgIE1kTGlzdEl0ZW0ucHJvdG90eXBlLl9oYW5kbGVCbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9oYXNGb2N1cyA9IGZhbHNlO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kTGluZSksIFxuICAgICAgICBfX21ldGFkYXRhJDQwKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kTGlzdEl0ZW0ucHJvdG90eXBlLCBcIl9saW5lc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZChNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnR5cGUnLCBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyXSlcbiAgICBdLCBNZExpc3RJdGVtLnByb3RvdHlwZSwgXCJfaGFzQXZhdGFyXCIsIG51bGwpO1xuICAgIE1kTGlzdEl0ZW0gPSBfX2RlY29yYXRlJDQwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtbGlzdC1pdGVtLCBtYXQtbGlzdC1pdGVtLCBhW21kLWxpc3QtaXRlbV0sIGFbbWF0LWxpc3QtaXRlbV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3RpdGVtJyxcbiAgICAgICAgICAgICAgICAnKGZvY3VzKSc6ICdfaGFuZGxlRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgJyhibHVyKSc6ICdfaGFuZGxlQmx1cigpJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1saXN0LWl0ZW1dJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1saXN0LWl0ZW0tY29udGVudFxcXCIgW2NsYXNzLm1hdC1saXN0LWl0ZW0tZm9jdXNdPVxcXCJfaGFzRm9jdXNcXFwiPjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWxpc3QtYXZhdGFyXSxbbWQtbGlzdC1pY29uXSwgW21hdC1saXN0LWF2YXRhcl0sIFttYXQtbGlzdC1pY29uXVxcXCI+PC9uZy1jb250ZW50PjxkaXYgY2xhc3M9XFxcIm1hdC1saXN0LXRleHRcXFwiPjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWxpbmVdLCBbbWF0LWxpbmVdXFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PlwiLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZExpc3RJdGVtKTtcbiAgICByZXR1cm4gTWRMaXN0SXRlbTtcbn0oKSk7XG52YXIgTWRMaXN0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kTGlzdE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kTGlzdE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kTGlzdE1vZHVsZSA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtNZExpbmVNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kTGlzdCxcbiAgICAgICAgICAgICAgICBNZExpc3RJdGVtLFxuICAgICAgICAgICAgICAgIE1kTGlzdERpdmlkZXIsXG4gICAgICAgICAgICAgICAgTWRMaXN0QXZhdGFyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kTGluZU1vZHVsZSxcbiAgICAgICAgICAgICAgICBDb21wYXRpYmlsaXR5TW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kTGlzdEljb25Dc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRMaXN0Q3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kTmF2TGlzdENzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZERpdmlkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRMaXN0U3ViaGVhZGVyQ3NzTWF0U3R5bGVyXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgTWRMaXN0LFxuICAgICAgICAgICAgICAgIE1kTGlzdEl0ZW0sXG4gICAgICAgICAgICAgICAgTWRMaXN0RGl2aWRlcixcbiAgICAgICAgICAgICAgICBNZExpc3RBdmF0YXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRMaXN0SWNvbkNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZExpc3RDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWROYXZMaXN0Q3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kRGl2aWRlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZExpc3RTdWJoZWFkZXJDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZExpc3RNb2R1bGUpO1xuICAgIHJldHVybiBNZExpc3RNb2R1bGU7XG59KCkpO1xuXG4vKipcbiAqIENvbnZlcnRzIHZhbHVlcyBpbnRvIHN0cmluZ3MuIEZhbHN5IHZhbHVlcyBiZWNvbWUgZW1wdHkgc3RyaW5ncy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29lcmNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gXCJcIiArICh2YWx1ZSB8fCAnJyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgdmFsdWUgdGhhdCBtaWdodCBiZSBhIHN0cmluZyBpbnRvIGEgbnVtYmVyLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb2VyY2VUb051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQodmFsdWUsIDEwKSA6IHZhbHVlO1xufVxuXG52YXIgX19kZWNvcmF0ZSQ0MiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0MiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kR3JpZFRpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZFRpbGUoX3JlbmRlcmVyLCBfZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yb3dzcGFuID0gMTtcbiAgICAgICAgdGhpcy5fY29sc3BhbiA9IDE7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJyb3dzcGFuXCIsIHtcbiAgICAgICAgLyoqIEFtb3VudCBvZiByb3dzIHRoYXQgdGhlIGdyaWQgdGlsZSB0YWtlcyB1cC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3dzcGFuOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9yb3dzcGFuID0gY29lcmNlVG9OdW1iZXIodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRHcmlkVGlsZS5wcm90b3R5cGUsIFwiY29sc3BhblwiLCB7XG4gICAgICAgIC8qKiBBbW91bnQgb2YgY29sdW1ucyB0aGF0IHRoZSBncmlkIHRpbGUgdGFrZXMgdXAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sc3BhbjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fY29sc3BhbiA9IGNvZXJjZVRvTnVtYmVyKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3R5bGUgb2YgdGhlIGdyaWQtdGlsZSBlbGVtZW50LiAgTmVlZHMgdG8gYmUgc2V0IG1hbnVhbGx5IHRvIGF2b2lkXG4gICAgICogXCJDaGFuZ2VkIGFmdGVyIGNoZWNrZWRcIiBlcnJvcnMgdGhhdCB3b3VsZCBvY2N1ciB3aXRoIEhvc3RCaW5kaW5nLlxuICAgICAqL1xuICAgIE1kR3JpZFRpbGUucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQyKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJyb3dzcGFuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQyKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJjb2xzcGFuXCIsIG51bGwpO1xuICAgIE1kR3JpZFRpbGUgPSBfX2RlY29yYXRlJDQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLCBtYXQtZ3JpZC10aWxlJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0aXRlbScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZ3JpZC10aWxlXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZmlndXJlIGNsYXNzPVxcXCJtYXQtZmlndXJlXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9maWd1cmU+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtZ3JpZC1saXN0e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1ncmlkLXRpbGV7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW59Lm1hdC1ncmlkLXRpbGUgLm1hdC1maWd1cmV7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOmFic29sdXRlO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2hlaWdodDoxMDAlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO3BhZGRpbmc6MDttYXJnaW46MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXIsLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjQ4cHg7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjM4KTtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowIDE2cHg7Zm9udC1zaXplOjE2cHg7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyIC5tYXQtbGluZSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXIgLm1hdC1saW5le3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdy14OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMiksLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyIC5tYXQtbGluZTpudGgtY2hpbGQobisyKXtmb250LXNpemU6MTJweH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0PiosLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyPiosLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyPip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXIubWF0LTItbGluZSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXIubWF0LTItbGluZXtoZWlnaHQ6NjhweH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVufS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1hdmF0YXI6ZW1wdHksLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVye3RvcDowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlcntib3R0b206MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MTZweH1bZGlyPXJ0bF0gLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcntwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjE2cHh9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRHcmlkVGlsZSk7XG4gICAgcmV0dXJuIE1kR3JpZFRpbGU7XG59KCkpO1xudmFyIE1kR3JpZFRpbGVUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEdyaWRUaWxlVGV4dChfcmVuZGVyZXIsIF9lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgfVxuICAgIE1kR3JpZFRpbGVUZXh0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xpbmVTZXR0ZXIgPSBuZXcgTWRMaW5lU2V0dGVyKHRoaXMuX2xpbmVzLCB0aGlzLl9yZW5kZXJlciwgdGhpcy5fZWxlbWVudCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRMaW5lKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRHcmlkVGlsZVRleHQucHJvdG90eXBlLCBcIl9saW5lc1wiLCB2b2lkIDApO1xuICAgIE1kR3JpZFRpbGVUZXh0ID0gX19kZWNvcmF0ZSQ0MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWdyaWQtdGlsZS1oZWFkZXIsIG1hdC1ncmlkLXRpbGUtaGVhZGVyLCBtZC1ncmlkLXRpbGUtZm9vdGVyLCBtYXQtZ3JpZC10aWxlLWZvb3RlcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudCBzZWxlY3Q9XFxcIlttZC1ncmlkLWF2YXRhcl0sIFttYXQtZ3JpZC1hdmF0YXJdXFxcIj48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LWdyaWQtbGlzdC10ZXh0XFxcIj48bmctY29udGVudCBzZWxlY3Q9XFxcIlttZC1saW5lXSwgW21hdC1saW5lXVxcXCI+PC9uZy1jb250ZW50PjwvZGl2PjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIlxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRHcmlkVGlsZVRleHQpO1xuICAgIHJldHVybiBNZEdyaWRUaWxlVGV4dDtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1ncmlkLWF2YXRhcl0sIFttYXQtZ3JpZC1hdmF0YXJdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1ncmlkLWF2YXRhcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kR3JpZEF2YXRhckNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWdyaWQtdGlsZS1oZWFkZXIsIG1hdC1ncmlkLXRpbGUtaGVhZGVyJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1ncmlkLXRpbGUtaGVhZGVyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRHcmlkVGlsZUhlYWRlckNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgd2hvc2UgcHVycG9zZSBpcyB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcgdG8gdGhpcyBzZWxlY3Rvci5cbiAqL1xudmFyIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIoKSB7XG4gICAgfVxuICAgIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIgPSBfX2RlY29yYXRlJDQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1ncmlkLXRpbGUtZm9vdGVyLCBtYXQtZ3JpZC10aWxlLWZvb3RlcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZ3JpZC10aWxlLWZvb3Rlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZEdyaWRUaWxlRm9vdGVyQ3NzTWF0U3R5bGVyO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBjb2xzIHByb3BlcnR5IGlzIG1pc3NpbmcgZnJvbSBncmlkLWxpc3RcbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kR3JpZExpc3RDb2xzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMChNZEdyaWRMaXN0Q29sc0Vycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kR3JpZExpc3RDb2xzRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwibWQtZ3JpZC1saXN0OiBtdXN0IHBhc3MgaW4gbnVtYmVyIG9mIGNvbHVtbnMuIEV4YW1wbGU6IDxtZC1ncmlkLWxpc3QgY29scz1cXFwiM1xcXCI+XCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRHcmlkTGlzdENvbHNFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYSB0aWxlJ3MgY29sc3BhbiBpcyBsb25nZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGNvbHMgaW4gbGlzdFxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRHcmlkVGlsZVRvb1dpZGVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEwKE1kR3JpZFRpbGVUb29XaWRlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZVRvb1dpZGVFcnJvcihjb2xzLCBsaXN0TGVuZ3RoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwibWQtZ3JpZC1saXN0OiB0aWxlIHdpdGggY29sc3BhbiBcIiArIGNvbHMgKyBcIiBpcyB3aWRlciB0aGFuIGdyaWQgd2l0aCBjb2xzPVxcXCJcIiArIGxpc3RMZW5ndGggKyBcIlxcXCIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRHcmlkVGlsZVRvb1dpZGVFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYW4gaW52YWxpZCByYXRpbyBpcyBwYXNzZWQgaW4gYXMgYSByb3dIZWlnaHRcbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kR3JpZExpc3RCYWRSYXRpb0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTAoTWRHcmlkTGlzdEJhZFJhdGlvRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdEJhZFJhdGlvRXJyb3IodmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJtZC1ncmlkLWxpc3Q6IGludmFsaWQgcmF0aW8gZ2l2ZW4gZm9yIHJvdy1oZWlnaHQ6IFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRHcmlkTGlzdEJhZFJhdGlvRXJyb3I7XG59KE1kRXJyb3IpKTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgZGV0ZXJtaW5pbmcsIGZyb20gYSBsaXN0IG9mIHRpbGVzLCB0aGUgKHJvdywgY29sKSBwb3NpdGlvbiBvZiBlYWNoIG9mIHRob3NlIHRpbGVzXG4gKiBpbiB0aGUgZ3JpZC4gVGhpcyBpcyBuZWNlc3NhcnkgKHJhdGhlciB0aGFuIGp1c3QgcmVuZGVyaW5nIHRoZSB0aWxlcyBpbiBub3JtYWwgZG9jdW1lbnQgZmxvdylcbiAqIGJlY2F1c2UgdGhlIHRpbGVzIGNhbiBoYXZlIGEgcm93c3Bhbi5cbiAqXG4gKiBUaGUgcG9zaXRpb25pbmcgYWxnb3JpdGhtIGdyZWVkaWx5IHBsYWNlcyBlYWNoIHRpbGUgYXMgc29vbiBhcyBpdCBlbmNvdW50ZXJzIGEgZ2FwIGluIHRoZSBncmlkXG4gKiBsYXJnZSBlbm91Z2ggdG8gYWNjb21tb2RhdGUgaXQgc28gdGhhdCB0aGUgdGlsZXMgc3RpbGwgcmVuZGVyIGluIHRoZSBzYW1lIG9yZGVyIGluIHdoaWNoIHRoZXlcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBUaGUgYmFzaXMgb2YgdGhlIGFsZ29yaXRobSBpcyB0aGUgdXNlIG9mIGFuIGFycmF5IHRvIHRyYWNrIHRoZSBhbHJlYWR5IHBsYWNlZCB0aWxlcy4gRWFjaFxuICogZWxlbWVudCBvZiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gYSBjb2x1bW4sIGFuZCB0aGUgdmFsdWUgaW5kaWNhdGVzIGhvdyBtYW55IGNlbGxzIGluIHRoYXRcbiAqIGNvbHVtbiBhcmUgYWxyZWFkeSBvY2N1cGllZDsgemVybyBpbmRpY2F0ZXMgYW4gZW1wdHkgY2VsbC4gTW92aW5nIFwiZG93blwiIHRvIHRoZSBuZXh0IHJvd1xuICogZGVjcmVtZW50cyBlYWNoIHZhbHVlIGluIHRoZSB0cmFja2luZyBhcnJheSAoaW5kaWNhdGluZyB0aGF0IHRoZSBjb2x1bW4gaXMgb25lIGNlbGwgY2xvc2VyIHRvXG4gKiBiZWluZyBmcmVlKS5cbiAqXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBUaWxlQ29vcmRpbmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVDb29yZGluYXRvcihudW1Db2x1bW5zLCB0aWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogSW5kZXggYXQgd2hpY2ggdGhlIHNlYXJjaCBmb3IgdGhlIG5leHQgZ2FwIHdpbGwgc3RhcnQuICovXG4gICAgICAgIHRoaXMuY29sdW1uSW5kZXggPSAwO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgcm93IGluZGV4LiAqL1xuICAgICAgICB0aGlzLnJvd0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy50cmFja2VyID0gbmV3IEFycmF5KG51bUNvbHVtbnMpO1xuICAgICAgICB0aGlzLnRyYWNrZXIuZmlsbCgwLCAwLCB0aGlzLnRyYWNrZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSB0aWxlcy5tYXAoZnVuY3Rpb24gKHRpbGUpIHsgcmV0dXJuIF90aGlzLl90cmFja1RpbGUodGlsZSk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZSwgXCJyb3dDb3VudFwiLCB7XG4gICAgICAgIC8qKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93cyBvY2N1cGllZCBieSB0aWxlcyAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm93SW5kZXggKyAxOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZSwgXCJyb3dzcGFuXCIsIHtcbiAgICAgICAgLyoqIEdldHMgdGhlIHRvdGFsIHNwYW4gb2Ygcm93cyBvY2N1cGllZCBieSB0aWxlcy5cbiAgICAgICAgICogRXg6IEEgbGlzdCB3aXRoIDEgcm93IHRoYXQgY29udGFpbnMgYSB0aWxlIHdpdGggcm93c3BhbiAyIHdpbGwgaGF2ZSBhIHRvdGFsIHJvd3NwYW4gb2YgMi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFJvd01heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHRoaXMudHJhY2tlcik7XG4gICAgICAgICAgICAvLyBpZiBhbnkgb2YgdGhlIHRpbGVzIGhhcyBhIHJvd3NwYW4gdGhhdCBwdXNoZXMgaXQgYmV5b25kIHRoZSB0b3RhbCByb3cgY291bnQsXG4gICAgICAgICAgICAvLyBhZGQgdGhlIGRpZmZlcmVuY2UgdG8gdGhlIHJvd2NvdW50XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJvd01heCA+IDEgPyB0aGlzLnJvd0NvdW50ICsgbGFzdFJvd01heCAtIDEgOiB0aGlzLnJvd0NvdW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQ2FsY3VsYXRlcyB0aGUgcm93IGFuZCBjb2wgcG9zaXRpb24gb2YgYSB0aWxlLiAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX3RyYWNrVGlsZSA9IGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgICAgIC8vIEZpbmQgYSBnYXAgbGFyZ2UgZW5vdWdoIGZvciB0aGlzIHRpbGUuXG4gICAgICAgIHZhciBnYXBTdGFydEluZGV4ID0gdGhpcy5fZmluZE1hdGNoaW5nR2FwKHRpbGUuY29sc3Bhbik7XG4gICAgICAgIC8vIFBsYWNlIHRpbGUgaW4gdGhlIHJlc3VsdGluZyBnYXAuXG4gICAgICAgIHRoaXMuX21hcmtUaWxlUG9zaXRpb24oZ2FwU3RhcnRJbmRleCwgdGlsZSk7XG4gICAgICAgIC8vIFRoZSBuZXh0IHRpbWUgd2UgbG9vayBmb3IgYSBnYXAsIHRoZSBzZWFyY2ggd2lsbCBzdGFydCBhdCBjb2x1bW5JbmRleCwgd2hpY2ggc2hvdWxkIGJlXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB0aWxlIHRoYXQgaGFzIGp1c3QgYmVlbiBwbGFjZWQuXG4gICAgICAgIHRoaXMuY29sdW1uSW5kZXggPSBnYXBTdGFydEluZGV4ICsgdGlsZS5jb2xzcGFuO1xuICAgICAgICByZXR1cm4gbmV3IFRpbGVQb3NpdGlvbih0aGlzLnJvd0luZGV4LCBnYXBTdGFydEluZGV4KTtcbiAgICB9O1xuICAgIC8qKiBGaW5kcyB0aGUgbmV4dCBhdmFpbGFibGUgc3BhY2UgbGFyZ2UgZW5vdWdoIHRvIGZpdCB0aGUgdGlsZS4gKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9maW5kTWF0Y2hpbmdHYXAgPSBmdW5jdGlvbiAodGlsZUNvbHMpIHtcbiAgICAgICAgaWYgKHRpbGVDb2xzID4gdGhpcy50cmFja2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kR3JpZFRpbGVUb29XaWRlRXJyb3IodGlsZUNvbHMsIHRoaXMudHJhY2tlci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0IGluZGV4IGlzIGluY2x1c2l2ZSwgZW5kIGluZGV4IGlzIGV4Y2x1c2l2ZS5cbiAgICAgICAgdmFyIGdhcFN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGdhcEVuZEluZGV4ID0gLTE7XG4gICAgICAgIC8vIExvb2sgZm9yIGEgZ2FwIGxhcmdlIGVub3VnaCB0byBmaXQgdGhlIGdpdmVuIHRpbGUuIEVtcHR5IHNwYWNlcyBhcmUgbWFya2VkIHdpdGggYSB6ZXJvLlxuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHJvdywgZ28gdG8gdGhlIG5leHQgcm93LlxuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uSW5kZXggKyB0aWxlQ29scyA+IHRoaXMudHJhY2tlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0Um93KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBTdGFydEluZGV4ID0gdGhpcy50cmFja2VyLmluZGV4T2YoMCwgdGhpcy5jb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbW9yZSBlbXB0eSBzcGFjZXMgaW4gdGhpcyByb3cgYXQgYWxsLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IHJvdy5cbiAgICAgICAgICAgIGlmIChnYXBTdGFydEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dFJvdygpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2FwRW5kSW5kZXggPSB0aGlzLl9maW5kR2FwRW5kSW5kZXgoZ2FwU3RhcnRJbmRleCk7XG4gICAgICAgICAgICAvLyBJZiBhIGdhcCBsYXJnZSBlbm91Z2ggaXNuJ3QgZm91bmQsIHdlIHdhbnQgdG8gc3RhcnQgbG9va2luZyBpbW1lZGlhdGVseSBhZnRlciB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8gZ2FwIG9uIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuY29sdW1uSW5kZXggPSBnYXBTdGFydEluZGV4ICsgMTtcbiAgICAgICAgfSB3aGlsZSAoZ2FwRW5kSW5kZXggLSBnYXBTdGFydEluZGV4IDwgdGlsZUNvbHMpO1xuICAgICAgICByZXR1cm4gZ2FwU3RhcnRJbmRleDtcbiAgICB9O1xuICAgIC8qKiBNb3ZlIFwiZG93blwiIHRvIHRoZSBuZXh0IHJvdy4gKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9uZXh0Um93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbHVtbkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5yb3dJbmRleCsrO1xuICAgICAgICAvLyBEZWNyZW1lbnQgYWxsIHNwYWNlcyBieSBvbmUgdG8gcmVmbGVjdCBtb3ZpbmcgZG93biBvbmUgcm93LlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy50cmFja2VyW2ldID0gTWF0aC5tYXgoMCwgdGhpcy50cmFja2VyW2ldIC0gMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBlbmQgaW5kZXggKGV4Y2x1c2l2ZSkgb2YgYSBnYXAgZ2l2ZW4gdGhlIGluZGV4IGZyb20gd2hpY2ggdG8gc3RhcnQgbG9va2luZy5cbiAgICAgKiBUaGUgZ2FwIGVuZHMgd2hlbiBhIG5vbi16ZXJvIHZhbHVlIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX2ZpbmRHYXBFbmRJbmRleCA9IGZ1bmN0aW9uIChnYXBTdGFydEluZGV4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBnYXBTdGFydEluZGV4ICsgMTsgaSA8IHRoaXMudHJhY2tlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tlcltpXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGdhcCBlbmRzIHdpdGggdGhlIGVuZCBvZiB0aGUgcm93LlxuICAgICAgICByZXR1cm4gdGhpcy50cmFja2VyLmxlbmd0aDtcbiAgICB9O1xuICAgIC8qKiBVcGRhdGUgdGhlIHRpbGUgdHJhY2tlciB0byBhY2NvdW50IGZvciB0aGUgZ2l2ZW4gdGlsZSBpbiB0aGUgZ2l2ZW4gc3BhY2UuICovXG4gICAgVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZS5fbWFya1RpbGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgdGlsZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGUuY29sc3BhbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXJbc3RhcnQgKyBpXSA9IHRpbGUucm93c3BhbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpbGVDb29yZGluYXRvcjtcbn0oKSk7XG4vKipcbiAqIFNpbXBsZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGlsZSBwb3NpdGlvbiAocm93LCBjb2wpLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgVGlsZVBvc2l0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWxlUG9zaXRpb24ocm93LCBjb2wpIHtcbiAgICAgICAgdGhpcy5yb3cgPSByb3c7XG4gICAgICAgIHRoaXMuY29sID0gY29sO1xuICAgIH1cbiAgICByZXR1cm4gVGlsZVBvc2l0aW9uO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIFNldHMgdGhlIHN0eWxlIHByb3BlcnRpZXMgZm9yIGFuIGluZGl2aWR1YWwgdGlsZSwgZ2l2ZW4gdGhlIHBvc2l0aW9uIGNhbGN1bGF0ZWQgYnkgdGhlXG4gKiBUaWxlIENvb3JkaW5hdG9yLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgVGlsZVN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGlsZVN0eWxlcigpIHtcbiAgICAgICAgdGhpcy5fcm93cyA9IDA7XG4gICAgICAgIHRoaXMuX3Jvd3NwYW4gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGdyaWQtbGlzdCBsYXlvdXQgaW5mbyBvbmNlIGl0IGlzIGF2YWlsYWJsZS4gQ2Fubm90IGJlIHByb2Nlc3NlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgKiBiZWNhdXNlIHRoZXNlIHByb3BlcnRpZXMgaGF2ZW4ndCBiZWVuIGNhbGN1bGF0ZWQgYnkgdGhhdCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBndXR0ZXJTaXplIFNpemUgb2YgdGhlIGdyaWQncyBndXR0ZXIuXG4gICAgICogQHBhcmFtIHRyYWNrZXIgSW5zdGFuY2Ugb2YgdGhlIFRpbGVDb29yZGluYXRvci5cbiAgICAgKiBAcGFyYW0gY29scyBBbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZ3JpZC5cbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIExheW91dCBkaXJlY3Rpb24gb2YgdGhlIGdyaWQuXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChndXR0ZXJTaXplLCB0cmFja2VyLCBjb2xzLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fZ3V0dGVyU2l6ZSA9IG5vcm1hbGl6ZVVuaXRzKGd1dHRlclNpemUpO1xuICAgICAgICB0aGlzLl9yb3dzID0gdHJhY2tlci5yb3dDb3VudDtcbiAgICAgICAgdGhpcy5fcm93c3BhbiA9IHRyYWNrZXIucm93c3BhbjtcbiAgICAgICAgdGhpcy5fY29scyA9IGNvbHM7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBhbW91bnQgb2Ygc3BhY2UgYSBzaW5nbGUgMXgxIHRpbGUgd291bGQgdGFrZSB1cCAod2lkdGggb3IgaGVpZ2h0KS5cbiAgICAgKiBVc2VkIGFzIGEgYmFzaXMgZm9yIG90aGVyIGNhbGN1bGF0aW9ucy5cbiAgICAgKiBAcGFyYW0gc2l6ZVBlcmNlbnQgUGVyY2VudCBvZiB0aGUgdG90YWwgZ3JpZC1saXN0IHNwYWNlIHRoYXQgb25lIDF4MSB0aWxlIHdvdWxkIHRha2UgdXAuXG4gICAgICogQHBhcmFtIGd1dHRlckZyYWN0aW9uIEZyYWN0aW9uIG9mIHRoZSBndXR0ZXIgc2l6ZSB0YWtlbiB1cCBieSBvbmUgMXgxIHRpbGUuXG4gICAgICogQHJldHVybiBUaGUgc2l6ZSBvZiBhIDF4MSB0aWxlIGFzIGFuIGV4cHJlc3Npb24gdGhhdCBjYW4gYmUgZXZhbHVhdGVkIHZpYSBDU1MgY2FsYygpLlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmdldEJhc2VUaWxlU2l6ZSA9IGZ1bmN0aW9uIChzaXplUGVyY2VudCwgZ3V0dGVyRnJhY3Rpb24pIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgYmFzZSBzaXplIHBlcmNlbnQgKGFzIHdvdWxkIGJlIGlmIGV2ZW5seSBkaXZpZGluZyB0aGUgc2l6ZSBiZXR3ZWVuIGNlbGxzKSxcbiAgICAgICAgLy8gYW5kIHRoZW4gc3VidHJhY3RpbmcgdGhlIHNpemUgb2Ygb25lIGd1dHRlci4gSG93ZXZlciwgc2luY2UgdGhlcmUgYXJlIG5vIGd1dHRlcnMgb24gdGhlXG4gICAgICAgIC8vIGVkZ2VzLCBlYWNoIHRpbGUgb25seSB1c2VzIGEgZnJhY3Rpb24gKGd1dHRlclNoYXJlID0gbnVtR3V0dGVycyAvIG51bUNlbGxzKSBvZiB0aGUgZ3V0dGVyXG4gICAgICAgIC8vIHNpemUuIChJbWFnaW5lIGhhdmluZyBvbmUgZ3V0dGVyIHBlciB0aWxlLCBhbmQgdGhlbiBicmVha2luZyB1cCB0aGUgZXh0cmEgZ3V0dGVyIG9uIHRoZVxuICAgICAgICAvLyBlZGdlIGV2ZW5seSBhbW9uZyB0aGUgY2VsbHMpLlxuICAgICAgICByZXR1cm4gXCIoXCIgKyBzaXplUGVyY2VudCArIFwiJSAtICggXCIgKyB0aGlzLl9ndXR0ZXJTaXplICsgXCIgKiBcIiArIGd1dHRlckZyYWN0aW9uICsgXCIgKSlcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgVGhlIGhvcml6b250YWwgb3IgdmVydGljYWwgcG9zaXRpb24gb2YgYSB0aWxlLCBlLmcuLCB0aGUgJ3RvcCcgb3IgJ2xlZnQnIHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgTnVtYmVyIG9mIHRpbGVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVuZGVyZWQgaW4gdGhlIHJvdy9jb2x1bW4uXG4gICAgICogQHBhcmFtIGJhc2VTaXplIEJhc2Ugc2l6ZSBvZiBhIDF4MSB0aWxlIChhcyBjb21wdXRlZCBpbiBnZXRCYXNlVGlsZVNpemUpLlxuICAgICAqIEByZXR1cm4gUG9zaXRpb24gb2YgdGhlIHRpbGUgYXMgYSBDU1MgY2FsYygpIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0VGlsZVBvc2l0aW9uID0gZnVuY3Rpb24gKGJhc2VTaXplLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIGNvbWVzIHRoZSBzaXplIG9mIGEgMXgxIHRpbGUgcGx1cyBndXR0ZXIgZm9yIGVhY2ggcHJldmlvdXMgdGlsZSBpbiB0aGVcbiAgICAgICAgLy8gcm93L2NvbHVtbiAob2Zmc2V0KS5cbiAgICAgICAgcmV0dXJuIGNhbGMoXCIoXCIgKyBiYXNlU2l6ZSArIFwiICsgXCIgKyB0aGlzLl9ndXR0ZXJTaXplICsgXCIpICogXCIgKyBvZmZzZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWN0dWFsIHNpemUgb2YgYSB0aWxlLCBlLmcuLCB3aWR0aCBvciBoZWlnaHQsIHRha2luZyByb3dzcGFuIG9yIGNvbHNwYW4gaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBiYXNlU2l6ZSBCYXNlIHNpemUgb2YgYSAxeDEgdGlsZSAoYXMgY29tcHV0ZWQgaW4gZ2V0QmFzZVRpbGVTaXplKS5cbiAgICAgKiBAcGFyYW0gc3BhbiBUaGUgdGlsZSdzIHJvd3NwYW4gb3IgY29sc3Bhbi5cbiAgICAgKiBAcmV0dXJuIFNpemUgb2YgdGhlIHRpbGUgYXMgYSBDU1MgY2FsYygpIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0VGlsZVNpemUgPSBmdW5jdGlvbiAoYmFzZVNpemUsIHNwYW4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgYmFzZVNpemUgKyBcIiAqIFwiICsgc3BhbiArIFwiKSArIChcIiArIChzcGFuIC0gMSkgKyBcIiAqIFwiICsgdGhpcy5fZ3V0dGVyU2l6ZSArIFwiKVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3R5bGUgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkIHRvIGEgdGlsZSBmb3IgdGhlIGdpdmVuIHJvdyBhbmQgY29sdW1uIGluZGV4LlxuICAgICAqIEBwYXJhbSB0aWxlIFRpbGUgdG8gd2hpY2ggdG8gYXBwbHkgdGhlIHN0eWxpbmcuXG4gICAgICogQHBhcmFtIHJvd0luZGV4IEluZGV4IG9mIHRoZSB0aWxlJ3Mgcm93LlxuICAgICAqIEBwYXJhbSBjb2xJbmRleCBJbmRleCBvZiB0aGUgdGlsZSdzIGNvbHVtbi5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgY29sSW5kZXgpIHtcbiAgICAgICAgLy8gUGVyY2VudCBvZiB0aGUgYXZhaWxhYmxlIGhvcml6b250YWwgc3BhY2UgdGhhdCBvbmUgY29sdW1uIHRha2VzIHVwLlxuICAgICAgICB2YXIgcGVyY2VudFdpZHRoUGVyVGlsZSA9IDEwMCAvIHRoaXMuX2NvbHM7XG4gICAgICAgIC8vIEZyYWN0aW9uIG9mIHRoZSB2ZXJ0aWNhbCBndXR0ZXIgc2l6ZSB0aGF0IGVhY2ggY29sdW1uIHRha2VzIHVwLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaWYgdGhlcmUgYXJlIDUgY29sdW1ucywgZWFjaCBjb2x1bW4gdXNlcyA0LzUgPSAwLjggdGltZXMgdGhlIGd1dHRlciB3aWR0aC5cbiAgICAgICAgdmFyIGd1dHRlcldpZHRoRnJhY3Rpb25QZXJUaWxlID0gKHRoaXMuX2NvbHMgLSAxKSAvIHRoaXMuX2NvbHM7XG4gICAgICAgIHRoaXMuc2V0Q29sU3R5bGVzKHRpbGUsIGNvbEluZGV4LCBwZXJjZW50V2lkdGhQZXJUaWxlLCBndXR0ZXJXaWR0aEZyYWN0aW9uUGVyVGlsZSk7XG4gICAgICAgIHRoaXMuc2V0Um93U3R5bGVzKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGhQZXJUaWxlLCBndXR0ZXJXaWR0aEZyYWN0aW9uUGVyVGlsZSk7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgaG9yaXpvbnRhbCBwbGFjZW1lbnQgb2YgdGhlIHRpbGUgaW4gdGhlIGxpc3QuICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Q29sU3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIGNvbEluZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIC8vIEJhc2UgaG9yaXpvbnRhbCBzaXplIG9mIGEgY29sdW1uLlxuICAgICAgICB2YXIgYmFzZVRpbGVXaWR0aCA9IHRoaXMuZ2V0QmFzZVRpbGVTaXplKHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpO1xuICAgICAgICAvLyBUaGUgd2lkdGggYW5kIGhvcml6b250YWwgcG9zaXRpb24gb2YgZWFjaCB0aWxlIGlzIGFsd2F5cyBjYWxjdWxhdGVkIHRoZSBzYW1lIHdheSwgYnV0IHRoZVxuICAgICAgICAvLyBoZWlnaHQgYW5kIHZlcnRpY2FsIHBvc2l0aW9uIGRlcGVuZHMgb24gdGhlIHJvd01vZGUuXG4gICAgICAgIHZhciBzaWRlID0gdGhpcy5fZGlyZWN0aW9uID09PSAnbHRyJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKHNpZGUsIHRoaXMuZ2V0VGlsZVBvc2l0aW9uKGJhc2VUaWxlV2lkdGgsIGNvbEluZGV4KSk7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCd3aWR0aCcsIGNhbGModGhpcy5nZXRUaWxlU2l6ZShiYXNlVGlsZVdpZHRoLCB0aWxlLmNvbHNwYW4pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB0b3RhbCBzaXplIHRha2VuIHVwIGJ5IGd1dHRlcnMgYWNyb3NzIG9uZSBheGlzIG9mIGEgbGlzdC5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRHdXR0ZXJTcGFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3V0dGVyU2l6ZSArIFwiICogKFwiICsgdGhpcy5fcm93c3BhbiArIFwiIC0gMSlcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHRvdGFsIHNpemUgdGFrZW4gdXAgYnkgdGlsZXMgYWNyb3NzIG9uZSBheGlzIG9mIGEgbGlzdC5cbiAgICAgKiBAcGFyYW0gdGlsZUhlaWdodCBIZWlnaHQgb2YgdGhlIHRpbGUuXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0VGlsZVNwYW4gPSBmdW5jdGlvbiAodGlsZUhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93c3BhbiArIFwiICogXCIgKyB0aGlzLmdldFRpbGVTaXplKHRpbGVIZWlnaHQsIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmVydGljYWwgcGxhY2VtZW50IG9mIHRoZSB0aWxlIGluIHRoZSBsaXN0LlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCB0eXBlIG9mIFRpbGVTdHlsZXIuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkgeyB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNvbXB1dGVkIGhlaWdodCBhbmQgcmV0dXJucyB0aGUgY29ycmVjdCBzdHlsZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIHR5cGUgb2YgVGlsZVN0eWxlci5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBUaWxlU3R5bGVyO1xufSgpKTtcbi8qKlxuICogVGhpcyB0eXBlIG9mIHN0eWxlciBpcyBpbnN0YW50aWF0ZWQgd2hlbiB0aGUgdXNlciBwYXNzZXMgaW4gYSBmaXhlZCByb3cgaGVpZ2h0LlxuICogRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiMTAwcHhcIj5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIEZpeGVkVGlsZVN0eWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDExKEZpeGVkVGlsZVN0eWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaXhlZFRpbGVTdHlsZXIoZml4ZWRSb3dIZWlnaHQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZml4ZWRSb3dIZWlnaHQgPSBmaXhlZFJvd0hlaWdodDtcbiAgICB9XG4gICAgRml4ZWRUaWxlU3R5bGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGd1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbikge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBndXR0ZXJTaXplLCB0cmFja2VyLCBjb2xzLCBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmZpeGVkUm93SGVpZ2h0ID0gbm9ybWFsaXplVW5pdHModGhpcy5maXhlZFJvd0hlaWdodCk7XG4gICAgfTtcbiAgICBGaXhlZFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkge1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgndG9wJywgdGhpcy5nZXRUaWxlUG9zaXRpb24odGhpcy5maXhlZFJvd0hlaWdodCwgcm93SW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ2hlaWdodCcsIGNhbGModGhpcy5nZXRUaWxlU2l6ZSh0aGlzLmZpeGVkUm93SGVpZ2h0LCB0aWxlLnJvd3NwYW4pKSk7XG4gICAgfTtcbiAgICBGaXhlZFRpbGVTdHlsZXIucHJvdG90eXBlLmdldENvbXB1dGVkSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2hlaWdodCcsIGNhbGModGhpcy5nZXRUaWxlU3Bhbih0aGlzLmZpeGVkUm93SGVpZ2h0KSArIFwiICsgXCIgKyB0aGlzLmdldEd1dHRlclNwYW4oKSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHJldHVybiBGaXhlZFRpbGVTdHlsZXI7XG59KFRpbGVTdHlsZXIpKTtcbi8qKlxuICogVGhpcyB0eXBlIG9mIHN0eWxlciBpcyBpbnN0YW50aWF0ZWQgd2hlbiB0aGUgdXNlciBwYXNzZXMgaW4gYSB3aWR0aDpoZWlnaHQgcmF0aW9cbiAqIGZvciB0aGUgcm93IGhlaWdodC4gIEV4YW1wbGUgPG1kLWdyaWQtbGlzdCBjb2xzPVwiM1wiIHJvd0hlaWdodD1cIjM6MVwiPlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgUmF0aW9UaWxlU3R5bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTEoUmF0aW9UaWxlU3R5bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhdGlvVGlsZVN0eWxlcih2YWx1ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyc2VSYXRpbyh2YWx1ZSk7XG4gICAgfVxuICAgIFJhdGlvVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Um93U3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIHZhciBwZXJjZW50SGVpZ2h0UGVyVGlsZSA9IHBlcmNlbnRXaWR0aCAvIHRoaXMucm93SGVpZ2h0UmF0aW87XG4gICAgICAgIHRoaXMuYmFzZVRpbGVIZWlnaHQgPSB0aGlzLmdldEJhc2VUaWxlU2l6ZShwZXJjZW50SGVpZ2h0UGVyVGlsZSwgZ3V0dGVyV2lkdGgpO1xuICAgICAgICAvLyBVc2UgcGFkZGluZ1RvcCBhbmQgbWFyZ2luVG9wIHRvIG1haW50YWluIHRoZSBnaXZlbiBhc3BlY3QgcmF0aW8sIGFzXG4gICAgICAgIC8vIGEgcGVyY2VudGFnZS1iYXNlZCB2YWx1ZSBmb3IgdGhlc2UgcHJvcGVydGllcyBpcyBhcHBsaWVkIHZlcnN1cyB0aGUgKndpZHRoKiBvZiB0aGVcbiAgICAgICAgLy8gY29udGFpbmluZyBibG9jay4gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvYm94Lmh0bWwjbWFyZ2luLXByb3BlcnRpZXNcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ21hcmdpblRvcCcsIHRoaXMuZ2V0VGlsZVBvc2l0aW9uKHRoaXMuYmFzZVRpbGVIZWlnaHQsIHJvd0luZGV4KSk7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCdwYWRkaW5nVG9wJywgY2FsYyh0aGlzLmdldFRpbGVTaXplKHRoaXMuYmFzZVRpbGVIZWlnaHQsIHRpbGUucm93c3BhbikpKTtcbiAgICB9O1xuICAgIFJhdGlvVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAncGFkZGluZ0JvdHRvbScsIGNhbGModGhpcy5nZXRUaWxlU3Bhbih0aGlzLmJhc2VUaWxlSGVpZ2h0KSArIFwiICsgXCIgKyB0aGlzLmdldEd1dHRlclNwYW4oKSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJhdGlvVGlsZVN0eWxlci5wcm90b3R5cGUuX3BhcnNlUmF0aW8gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJhdGlvUGFydHMgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICBpZiAocmF0aW9QYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZEdyaWRMaXN0QmFkUmF0aW9FcnJvcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dIZWlnaHRSYXRpbyA9IHBhcnNlRmxvYXQocmF0aW9QYXJ0c1swXSkgLyBwYXJzZUZsb2F0KHJhdGlvUGFydHNbMV0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJhdGlvVGlsZVN0eWxlcjtcbn0oVGlsZVN0eWxlcikpO1xuLyoqXG4gKiBUaGlzIHR5cGUgb2Ygc3R5bGVyIGlzIGluc3RhbnRpYXRlZCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBcImZpdFwiIHJvdyBoZWlnaHQgbW9kZS5cbiAqIEluIG90aGVyIHdvcmRzLCB0aGUgcm93IGhlaWdodCB3aWxsIHJlZmxlY3QgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgY29udGFpbmVyIGRpdmlkZWRcbiAqIGJ5IHRoZSBudW1iZXIgb2Ygcm93cy4gIEV4YW1wbGUgPG1kLWdyaWQtbGlzdCBjb2xzPVwiM1wiIHJvd0hlaWdodD1cImZpdFwiPlxuICpcbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIEZpdFRpbGVTdHlsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMShGaXRUaWxlU3R5bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpdFRpbGVTdHlsZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBGaXRUaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRSb3dTdHlsZXMgPSBmdW5jdGlvbiAodGlsZSwgcm93SW5kZXgsIHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpIHtcbiAgICAgICAgLy8gUGVyY2VudCBvZiB0aGUgYXZhaWxhYmxlIHZlcnRpY2FsIHNwYWNlIHRoYXQgb25lIHJvdyB0YWtlcyB1cC5cbiAgICAgICAgdmFyIHBlcmNlbnRIZWlnaHRQZXJUaWxlID0gMTAwIC8gdGhpcy5fcm93c3BhbjtcbiAgICAgICAgLy8gRnJhY3Rpb24gb2YgdGhlIGhvcml6b250YWwgZ3V0dGVyIHNpemUgdGhhdCBlYWNoIGNvbHVtbiB0YWtlcyB1cC5cbiAgICAgICAgdmFyIGd1dHRlckhlaWdodFBlclRpbGUgPSAodGhpcy5fcm93cyAtIDEpIC8gdGhpcy5fcm93cztcbiAgICAgICAgLy8gQmFzZSB2ZXJ0aWNhbCBzaXplIG9mIGEgY29sdW1uLlxuICAgICAgICB2YXIgYmFzZVRpbGVIZWlnaHQgPSB0aGlzLmdldEJhc2VUaWxlU2l6ZShwZXJjZW50SGVpZ2h0UGVyVGlsZSwgZ3V0dGVySGVpZ2h0UGVyVGlsZSk7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCd0b3AnLCB0aGlzLmdldFRpbGVQb3NpdGlvbihiYXNlVGlsZUhlaWdodCwgcm93SW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ2hlaWdodCcsIGNhbGModGhpcy5nZXRUaWxlU2l6ZShiYXNlVGlsZUhlaWdodCwgdGlsZS5yb3dzcGFuKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpdFRpbGVTdHlsZXI7XG59KFRpbGVTdHlsZXIpKTtcbi8qKiBXcmFwcyBhIENTUyBzdHJpbmcgaW4gYSBjYWxjIGZ1bmN0aW9uICovXG5mdW5jdGlvbiBjYWxjKGV4cCkgeyByZXR1cm4gXCJjYWxjKFwiICsgZXhwICsgXCIpXCI7IH1cbi8qKiBBcHBlbmRzIHBpeGVscyB0byBhIENTUyBzdHJpbmcgaWYgbm8gdW5pdHMgYXJlIGdpdmVuLiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlLm1hdGNoKC9weHxlbXxyZW0vKSkgPyB2YWx1ZSA6IHZhbHVlICsgJ3B4Jztcbn1cblxudmFyIF9fZGVjb3JhdGUkNDEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDkgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vLyBUT0RPKGthcmEpOiBDb25kaXRpb25hbCAocmVzcG9uc2l2ZSkgY29sdW1uIGNvdW50IC8gcm93IHNpemUuXG4vLyBUT0RPKGthcmEpOiBSZS1sYXlvdXQgb24gd2luZG93IHJlc2l6ZSAvIG1lZGlhIGNoYW5nZSAoZGVib3VuY2VkKS5cbi8vIFRPRE8oa2FyYSk6IGdyaWRUaWxlSGVhZGVyIGFuZCBncmlkVGlsZUZvb3Rlci5cbnZhciBNRF9GSVRfTU9ERSA9ICdmaXQnO1xudmFyIE1kR3JpZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZExpc3QoX3JlbmRlcmVyLCBfZWxlbWVudCwgX2Rpcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICAvKiogVGhlIGFtb3VudCBvZiBzcGFjZSBiZXR3ZWVuIHRpbGVzLiBUaGlzIHdpbGwgYmUgc29tZXRoaW5nIGxpa2UgJzVweCcgb3IgJzJlbScuICovXG4gICAgICAgIHRoaXMuX2d1dHRlciA9ICcxcHgnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRHcmlkTGlzdC5wcm90b3R5cGUsIFwiY29sc1wiLCB7XG4gICAgICAgIC8qKiBBbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZ3JpZCBsaXN0LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbHM7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2NvbHMgPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJndXR0ZXJTaXplXCIsIHtcbiAgICAgICAgLyoqIFNpemUgb2YgdGhlIGdyaWQgbGlzdCdzIGd1dHRlciBpbiBwaXhlbHMuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZ3V0dGVyOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9ndXR0ZXIgPSBjb2VyY2VUb1N0cmluZyh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJyb3dIZWlnaHRcIiwge1xuICAgICAgICAvKiogU2V0IGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHJvdyBoZWlnaHQgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB2YWx1ZS4gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0hlaWdodCA9IGNvZXJjZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRpbGVTdHlsZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29scygpO1xuICAgICAgICB0aGlzLl9jaGVja1Jvd0hlaWdodCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGxheW91dCBjYWxjdWxhdGlvbiBpcyBmYWlybHkgY2hlYXAgaWYgbm90aGluZyBjaGFuZ2VzLCBzbyB0aGVyZSdzIGxpdHRsZSBjb3N0XG4gICAgICogdG8gcnVuIGl0IGZyZXF1ZW50bHkuXG4gICAgICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYXlvdXRUaWxlcygpO1xuICAgIH07XG4gICAgLyoqIFRocm93IGEgZnJpZW5kbHkgZXJyb3IgaWYgY29scyBwcm9wZXJ0eSBpcyBtaXNzaW5nICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX2NoZWNrQ29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZEdyaWRMaXN0Q29sc0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEZWZhdWx0IHRvIGVxdWFsIHdpZHRoOmhlaWdodCBpZiByb3dIZWlnaHQgcHJvcGVydHkgaXMgbWlzc2luZyAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9jaGVja1Jvd0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgUmF0aW9UaWxlU3R5bGVyKCcxOjEnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENyZWF0ZXMgY29ycmVjdCBUaWxlIFN0eWxlciBzdWJ0eXBlIGJhc2VkIG9uIHJvd0hlaWdodCBwYXNzZWQgaW4gYnkgdXNlciAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9zZXRUaWxlU3R5bGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcm93SGVpZ2h0ID09PSBNRF9GSVRfTU9ERSkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBGaXRUaWxlU3R5bGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcm93SGVpZ2h0ICYmIHRoaXMuX3Jvd0hlaWdodC5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBSYXRpb1RpbGVTdHlsZXIodGhpcy5fcm93SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgRml4ZWRUaWxlU3R5bGVyKHRoaXMuX3Jvd0hlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBDb21wdXRlcyBhbmQgYXBwbGllcyB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gZm9yIGFsbCBjaGlsZHJlbiBncmlkIHRpbGVzLiAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9sYXlvdXRUaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyYWNrZXIgPSBuZXcgVGlsZUNvb3JkaW5hdG9yKHRoaXMuY29scywgdGhpcy5fdGlsZXMpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyID8gdGhpcy5fZGlyLnZhbHVlIDogJ2x0cic7XG4gICAgICAgIHRoaXMuX3RpbGVTdHlsZXIuaW5pdCh0aGlzLmd1dHRlclNpemUsIHRyYWNrZXIsIHRoaXMuY29scywgZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5fdGlsZXMuZm9yRWFjaChmdW5jdGlvbiAodGlsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0cmFja2VyLnBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBfdGhpcy5fdGlsZVN0eWxlci5zZXRTdHlsZSh0aWxlLCBwb3Mucm93LCBwb3MuY29sKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NldExpc3RTdHlsZSh0aGlzLl90aWxlU3R5bGVyLmdldENvbXB1dGVkSGVpZ2h0KCkpO1xuICAgIH07XG4gICAgLyoqIFNldHMgc3R5bGUgb24gdGhlIG1haW4gZ3JpZC1saXN0IGVsZW1lbnQsIGdpdmVuIHRoZSBzdHlsZSBuYW1lIGFuZCB2YWx1ZS4gKi9cbiAgICBNZEdyaWRMaXN0LnByb3RvdHlwZS5fc2V0TGlzdFN0eWxlID0gZnVuY3Rpb24gKHN0eWxlJCQxKSB7XG4gICAgICAgIGlmIChzdHlsZSQkMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgc3R5bGUkJDFbMF0sIHN0eWxlJCQxWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kR3JpZFRpbGUpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MSgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJfdGlsZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRHcmlkTGlzdC5wcm90b3R5cGUsIFwiY29sc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRHcmlkTGlzdC5wcm90b3R5cGUsIFwiZ3V0dGVyU2l6ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT2JqZWN0XSlcbiAgICBdLCBNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJyb3dIZWlnaHRcIiwgbnVsbCk7XG4gICAgTWRHcmlkTGlzdCA9IF9fZGVjb3JhdGUkNDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1ncmlkLWxpc3QsIG1hdC1ncmlkLWxpc3QnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtZ3JpZC1saXN0e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC1ncmlkLXRpbGV7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW59Lm1hdC1ncmlkLXRpbGUgLm1hdC1maWd1cmV7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOmFic29sdXRlO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2hlaWdodDoxMDAlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO3BhZGRpbmc6MDttYXJnaW46MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXIsLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjQ4cHg7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjM4KTtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowIDE2cHg7Zm9udC1zaXplOjE2cHg7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjB9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyIC5tYXQtbGluZSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXIgLm1hdC1saW5le3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdy14OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94fS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3RlciAubWF0LWxpbmU6bnRoLWNoaWxkKG4rMiksLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyIC5tYXQtbGluZTpudGgtY2hpbGQobisyKXtmb250LXNpemU6MTJweH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0PiosLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtZm9vdGVyPiosLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVyPip7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6aW5oZXJpdH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1mb290ZXIubWF0LTItbGluZSwubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtdGlsZS1oZWFkZXIubWF0LTItbGluZXtoZWlnaHQ6NjhweH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtbGlzdC10ZXh0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVufS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC1hdmF0YXI6ZW1wdHksLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWxpc3QtdGV4dDplbXB0eXtkaXNwbGF5Om5vbmV9Lm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLXRpbGUtaGVhZGVye3RvcDowfS5tYXQtZ3JpZC10aWxlIC5tYXQtZ3JpZC10aWxlLWZvb3Rlcntib3R0b206MH0ubWF0LWdyaWQtdGlsZSAubWF0LWdyaWQtYXZhdGFye3BhZGRpbmctcmlnaHQ6MTZweH1bZGlyPXJ0bF0gLm1hdC1ncmlkLXRpbGUgLm1hdC1ncmlkLWF2YXRhcntwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjE2cHh9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ2xpc3QnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWdyaWQtbGlzdF0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ5KDIsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDQxKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIERpcl0pXG4gICAgXSwgTWRHcmlkTGlzdCk7XG4gICAgcmV0dXJuIE1kR3JpZExpc3Q7XG59KCkpO1xudmFyIE1kR3JpZExpc3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZExpc3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kR3JpZExpc3RNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZEdyaWRMaXN0TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRHcmlkTGlzdE1vZHVsZSA9IF9fZGVjb3JhdGUkNDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtNZExpbmVNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kR3JpZExpc3QsXG4gICAgICAgICAgICAgICAgTWRHcmlkVGlsZSxcbiAgICAgICAgICAgICAgICBNZEdyaWRUaWxlVGV4dCxcbiAgICAgICAgICAgICAgICBNZExpbmVNb2R1bGUsXG4gICAgICAgICAgICAgICAgQ29tcGF0aWJpbGl0eU1vZHVsZSxcbiAgICAgICAgICAgICAgICBNZEdyaWRUaWxlSGVhZGVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVGb290ZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRHcmlkQXZhdGFyQ3NzTWF0U3R5bGVyXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgTWRHcmlkTGlzdCxcbiAgICAgICAgICAgICAgICBNZEdyaWRUaWxlLFxuICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVUZXh0LFxuICAgICAgICAgICAgICAgIE1kR3JpZFRpbGVIZWFkZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRHcmlkVGlsZUZvb3RlckNzc01hdFN0eWxlcixcbiAgICAgICAgICAgICAgICBNZEdyaWRBdmF0YXJDc3NNYXRTdHlsZXJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRHcmlkTGlzdE1vZHVsZSk7XG4gICAgcmV0dXJuIE1kR3JpZExpc3RNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ0MyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0MyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDb250ZW50IG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKi9cbnZhciBNZENhcmRDb250ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRDb250ZW50KCkge1xuICAgIH1cbiAgICBNZENhcmRDb250ZW50ID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC1jb250ZW50LCBtYXQtY2FyZC1jb250ZW50JyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLWNvbnRlbnRdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRDb250ZW50KTtcbiAgICByZXR1cm4gTWRDYXJkQ29udGVudDtcbn0oKSk7XG4vKipcbiAqIFRpdGxlIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKi9cbnZhciBNZENhcmRUaXRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkVGl0bGUoKSB7XG4gICAgfVxuICAgIE1kQ2FyZFRpdGxlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC10aXRsZSwgbWF0LWNhcmQtdGl0bGUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtdGl0bGVdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRUaXRsZSk7XG4gICAgcmV0dXJuIE1kQ2FyZFRpdGxlO1xufSgpKTtcbi8qKlxuICogU3ViLXRpdGxlIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKi9cbnZhciBNZENhcmRTdWJ0aXRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkU3VidGl0bGUoKSB7XG4gICAgfVxuICAgIE1kQ2FyZFN1YnRpdGxlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC1zdWJ0aXRsZSwgbWF0LWNhcmQtc3VidGl0bGUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtc3VidGl0bGVdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRTdWJ0aXRsZSk7XG4gICAgcmV0dXJuIE1kQ2FyZFN1YnRpdGxlO1xufSgpKTtcbi8qKlxuICogQWN0aW9uIHNlY3Rpb24gb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZEFjdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZEFjdGlvbnMoKSB7XG4gICAgfVxuICAgIE1kQ2FyZEFjdGlvbnMgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWFjdGlvbnMsIG1hdC1jYXJkLWFjdGlvbnMnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtYWN0aW9uc10nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZEFjdGlvbnMpO1xuICAgIHJldHVybiBNZENhcmRBY3Rpb25zO1xufSgpKTtcbi8qKlxuICogRm9vdGVyIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKi9cbnZhciBNZENhcmRGb290ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZEZvb3RlcigpIHtcbiAgICB9XG4gICAgTWRDYXJkRm9vdGVyID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC1mb290ZXIsIG1hdC1jYXJkLWZvb3RlcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1mb290ZXJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRGb290ZXIpO1xuICAgIHJldHVybiBNZENhcmRGb290ZXI7XG59KCkpO1xuLyoqXG4gKiBJbWFnZSB1c2VkIGluIGEgY2FyZCwgbmVlZGVkIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZy5cbiAqL1xudmFyIE1kQ2FyZFNtSW1hZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZFNtSW1hZ2UoKSB7XG4gICAgfVxuICAgIE1kQ2FyZFNtSW1hZ2UgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtY2FyZC1zbS1pbWFnZV0sIFttYXQtY2FyZC1zbS1pbWFnZV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWNhcmQtc20taW1hZ2VdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRTbUltYWdlKTtcbiAgICByZXR1cm4gTWRDYXJkU21JbWFnZTtcbn0oKSk7XG4vKipcbiAqIEltYWdlIHVzZWQgaW4gYSBjYXJkLCBuZWVkZWQgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nLlxuICovXG52YXIgTWRDYXJkTWRJbWFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkTWRJbWFnZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkTWRJbWFnZSA9IF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC1jYXJkLW1kLWltYWdlXSwgW21hdC1jYXJkLW1kLWltYWdlXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1tZC1pbWFnZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZE1kSW1hZ2UpO1xuICAgIHJldHVybiBNZENhcmRNZEltYWdlO1xufSgpKTtcbi8qKlxuICogSW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKi9cbnZhciBNZENhcmRMZ0ltYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRMZ0ltYWdlKCkge1xuICAgIH1cbiAgICBNZENhcmRMZ0ltYWdlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWNhcmQtbGctaW1hZ2VdLCBbbWF0LWNhcmQtbGctaW1hZ2VdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnY2xhc3MubWF0LWNhcmQtbGctaW1hZ2UnOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZExnSW1hZ2UpO1xuICAgIHJldHVybiBNZENhcmRMZ0ltYWdlO1xufSgpKTtcbi8qKlxuICogSW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKi9cbnZhciBNZENhcmRJbWFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkSW1hZ2UoKSB7XG4gICAgfVxuICAgIE1kQ2FyZEltYWdlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWNhcmQtaW1hZ2VdLCBbbWF0LWNhcmQtaW1hZ2VdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLWltYWdlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkSW1hZ2UpO1xuICAgIHJldHVybiBNZENhcmRJbWFnZTtcbn0oKSk7XG4vKipcbiAqIExhcmdlIGltYWdlIHVzZWQgaW4gYSBjYXJkLCBuZWVkZWQgdG8gYWRkIHRoZSBtYXQtIENTUyBzdHlsaW5nLlxuICovXG52YXIgTWRDYXJkWGxJbWFnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkWGxJbWFnZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkWGxJbWFnZSA9IF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWNhcmQteGwtaW1hZ2UsIG1hdC1jYXJkLXhsLWltYWdlJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLXhsLWltYWdlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkWGxJbWFnZSk7XG4gICAgcmV0dXJuIE1kQ2FyZFhsSW1hZ2U7XG59KCkpO1xuLyoqXG4gKiBBdmF0YXIgaW1hZ2UgdXNlZCBpbiBhIGNhcmQsIG5lZWRlZCB0byBhZGQgdGhlIG1hdC0gQ1NTIHN0eWxpbmcuXG4gKi9cbnZhciBNZENhcmRBdmF0YXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZEF2YXRhcigpIHtcbiAgICB9XG4gICAgTWRDYXJkQXZhdGFyID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC1hdmF0YXIsIG1hdC1jYXJkLWF2YXRhcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC1hdmF0YXJdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRBdmF0YXIpO1xuICAgIHJldHVybiBNZENhcmRBdmF0YXI7XG59KCkpO1xuLyoqXG4gKiBBIGJhc2ljIGNvbnRlbnQgY29udGFpbmVyIGNvbXBvbmVudCB0aGF0IGFkZHMgdGhlIHN0eWxlcyBvZiBhIE1hdGVyaWFsIGRlc2lnbiBjYXJkLlxuICpcbiAqIFdoaWxlIHRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIGFsb25lLCBpdCBhbHNvIHByb3ZpZGVzIGEgbnVtYmVyXG4gKiBvZiBwcmVzZXQgc3R5bGVzIGZvciBjb21tb24gY2FyZCBzZWN0aW9ucywgaW5jbHVkaW5nOlxuICogLSBtZC1jYXJkLXRpdGxlXG4gKiAtIG1kLWNhcmQtc3VidGl0bGVcbiAqIC0gbWQtY2FyZC1jb250ZW50XG4gKiAtIG1kLWNhcmQtYWN0aW9uc1xuICogLSBtZC1jYXJkLWZvb3RlclxuICovXG52YXIgTWRDYXJkID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmQoKSB7XG4gICAgfVxuICAgIE1kQ2FyZCA9IF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1jYXJkLCBtYXQtY2FyZCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtY2FyZHtib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwwLDAsLjIpLDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCA1cHggMCByZ2JhKDAsMCwwLC4xMik7dHJhbnNpdGlvbjpib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllciguNCwwLC4yLDEpO3dpbGwtY2hhbmdlOmJveC1zaGFkb3c7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjI0cHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZn1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LWNhcmR7b3V0bGluZTpzb2xpZCAxcHh9fS5tYXQtY2FyZC1mbGF0e2JveC1zaGFkb3c6bm9uZX0ubWF0LWNhcmQtYWN0aW9ucywubWF0LWNhcmQtY29udGVudCwubWF0LWNhcmQtc3VidGl0bGUsLm1hdC1jYXJkLXRpdGxle2Rpc3BsYXk6YmxvY2s7bWFyZ2luLWJvdHRvbToxNnB4fS5tYXQtY2FyZC10aXRsZXtmb250LXNpemU6MjRweDtmb250LXdlaWdodDo0MDB9Lm1hdC1jYXJkLWNvbnRlbnQsLm1hdC1jYXJkLWhlYWRlciAubWF0LWNhcmQtdGl0bGUsLm1hdC1jYXJkLXN1YnRpdGxle2ZvbnQtc2l6ZToxNHB4fS5tYXQtY2FyZC1hY3Rpb25ze21hcmdpbi1sZWZ0Oi0xNnB4O21hcmdpbi1yaWdodDotMTZweDtwYWRkaW5nOjhweCAwfS5tYXQtY2FyZC1hY3Rpb25zW2FsaWduPWVuZF17ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZH0ubWF0LWNhcmQtaW1hZ2V7d2lkdGg6Y2FsYygxMDAlICsgNDhweCk7bWFyZ2luOjAgLTI0cHggMTZweH0ubWF0LWNhcmQteGwtaW1hZ2V7d2lkdGg6MjQwcHg7aGVpZ2h0OjI0MHB4O21hcmdpbjotOHB4fS5tYXQtY2FyZC1mb290ZXJ7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTttaW4taGVpZ2h0OjVweDtib3R0b206MDtsZWZ0OjB9Lm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1idXR0b24sLm1hdC1jYXJkLWFjdGlvbnMgLm1hdC1yYWlzZWQtYnV0dG9ue21hcmdpbjowIDRweH0ubWF0LWNhcmQtaGVhZGVye2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7aGVpZ2h0OjQwcHg7bWFyZ2luOi04cHggMCAxNnB4fS5tYXQtY2FyZC1oZWFkZXItdGV4dHtoZWlnaHQ6NDBweDttYXJnaW46MCA4cHh9Lm1hdC1jYXJkLWF2YXRhcntoZWlnaHQ6NDBweDt3aWR0aDo0MHB4O2JvcmRlci1yYWRpdXM6NTAlfS5tYXQtY2FyZC1sZy1pbWFnZSwubWF0LWNhcmQtbWQtaW1hZ2UsLm1hdC1jYXJkLXNtLWltYWdle21hcmdpbjotOHB4IDB9Lm1hdC1jYXJkLXRpdGxlLWdyb3Vwe2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjttYXJnaW46MCAtOHB4fS5tYXQtY2FyZC1zbS1pbWFnZXt3aWR0aDo4MHB4O2hlaWdodDo4MHB4fS5tYXQtY2FyZC1tZC1pbWFnZXt3aWR0aDoxMTJweDtoZWlnaHQ6MTEycHh9Lm1hdC1jYXJkLWxnLWltYWdle3dpZHRoOjE1MnB4O2hlaWdodDoxNTJweH1AbWVkaWEgKG1heC13aWR0aDo2MDBweCl7Lm1hdC1jYXJke3BhZGRpbmc6MjRweCAxNnB4fS5tYXQtY2FyZC1hY3Rpb25ze21hcmdpbi1sZWZ0Oi04cHg7bWFyZ2luLXJpZ2h0Oi04cHh9Lm1hdC1jYXJkLWltYWdle3dpZHRoOmNhbGMoMTAwJSArIDMycHgpO21hcmdpbjoxNnB4IC0xNnB4fS5tYXQtY2FyZC10aXRsZS1ncm91cHttYXJnaW46MH0ubWF0LWNhcmQteGwtaW1hZ2V7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0ubWF0LWNhcmQtaGVhZGVye21hcmdpbjotOHB4IDAgMH19Lm1hdC1jYXJkLWNvbnRlbnQ+OmZpcnN0LWNoaWxkLC5tYXQtY2FyZD46Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowfS5tYXQtY2FyZC1jb250ZW50PjpsYXN0LWNoaWxkLC5tYXQtY2FyZD46bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9Lm1hdC1jYXJkLWltYWdlOmZpcnN0LWNoaWxke21hcmdpbi10b3A6LTI0cHh9Lm1hdC1jYXJkPi5tYXQtY2FyZC1hY3Rpb25zOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTotMTZweDtwYWRkaW5nLWJvdHRvbTowfS5tYXQtY2FyZC1hY3Rpb25zIC5tYXQtYnV0dG9uOmZpcnN0LWNoaWxkLC5tYXQtY2FyZC1hY3Rpb25zIC5tYXQtcmFpc2VkLWJ1dHRvbjpmaXJzdC1jaGlsZHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5tYXQtY2FyZC1zdWJ0aXRsZTpub3QoOmZpcnN0LWNoaWxkKSwubWF0LWNhcmQtdGl0bGU6bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXRvcDotNHB4fS5tYXQtY2FyZC1oZWFkZXIgLm1hdC1jYXJkLXN1YnRpdGxlOm5vdCg6Zmlyc3QtY2hpbGQpLC5tYXQtY2FyZD4ubWF0LWNhcmQteGwtaW1hZ2U6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDotOHB4fS5tYXQtY2FyZD4ubWF0LWNhcmQteGwtaW1hZ2U6bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOi04cHh9XCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkKTtcbiAgICByZXR1cm4gTWRDYXJkO1xufSgpKTtcbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIHRoZSBgPG1kLWNhcmQ+YCBjb21wb25lbnQuIEl0IGFkZHMgc3R5bGVzIGZvciBhXG4gKiBwcmVzZXQgaGVhZGVyIHNlY3Rpb24gKGkuZS4gYSB0aXRsZSwgc3VidGl0bGUsIGFuZCBhdmF0YXIgbGF5b3V0KS5cbiAqL1xudmFyIE1kQ2FyZEhlYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkSGVhZGVyKCkge1xuICAgIH1cbiAgICBNZENhcmRIZWFkZXIgPSBfX2RlY29yYXRlJDQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtY2FyZC1oZWFkZXIsIG1hdC1jYXJkLWhlYWRlcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudCBzZWxlY3Q9XFxcIlttZC1jYXJkLWF2YXRhcl0sIFttYXQtY2FyZC1hdmF0YXJdXFxcIj48L25nLWNvbnRlbnQ+PGRpdiBjbGFzcz1cXFwibWF0LWNhcmQtaGVhZGVyLXRleHRcXFwiPjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWQtY2FyZC10aXRsZSwgbWF0LWNhcmQtdGl0bGUsIG1kLWNhcmQtc3VidGl0bGUsIG1hdC1jYXJkLXN1YnRpdGxlXFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jYXJkLWhlYWRlcl0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZEhlYWRlcik7XG4gICAgcmV0dXJuIE1kQ2FyZEhlYWRlcjtcbn0oKSk7XG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiB0aGUgPG1kLWNhcmQ+IGNvbXBvbmVudC4gSXQgYWRkcyBzdHlsZXMgZm9yIGEgcHJlc2V0XG4gKiBsYXlvdXQgdGhhdCBncm91cHMgYW4gaW1hZ2Ugd2l0aCBhIHRpdGxlIHNlY3Rpb24uXG4gKi9cbnZhciBNZENhcmRUaXRsZUdyb3VwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRUaXRsZUdyb3VwKCkge1xuICAgIH1cbiAgICBNZENhcmRUaXRsZUdyb3VwID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWNhcmQtdGl0bGUtZ3JvdXAsIG1hdC1jYXJkLXRpdGxlLWdyb3VwJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXY+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1jYXJkLXRpdGxlLCBtYXQtY2FyZC10aXRsZSwgbWQtY2FyZC1zdWJ0aXRsZSwgbWF0LWNhcmQtc3VidGl0bGVcXFwiPjwvbmctY29udGVudD48L2Rpdj48bmctY29udGVudCBzZWxlY3Q9XFxcImltZ1xcXCI+PC9uZy1jb250ZW50PjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2FyZC10aXRsZS1ncm91cF0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZFRpdGxlR3JvdXApO1xuICAgIHJldHVybiBNZENhcmRUaXRsZUdyb3VwO1xufSgpKTtcbnZhciBNZENhcmRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRDYXJkTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRDYXJkTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRDYXJkTW9kdWxlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW0NvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kQ2FyZCxcbiAgICAgICAgICAgICAgICBNZENhcmRIZWFkZXIsXG4gICAgICAgICAgICAgICAgTWRDYXJkVGl0bGVHcm91cCxcbiAgICAgICAgICAgICAgICBNZENhcmRDb250ZW50LFxuICAgICAgICAgICAgICAgIE1kQ2FyZFRpdGxlLFxuICAgICAgICAgICAgICAgIE1kQ2FyZFN1YnRpdGxlLFxuICAgICAgICAgICAgICAgIE1kQ2FyZEFjdGlvbnMsXG4gICAgICAgICAgICAgICAgTWRDYXJkRm9vdGVyLFxuICAgICAgICAgICAgICAgIE1kQ2FyZFNtSW1hZ2UsXG4gICAgICAgICAgICAgICAgTWRDYXJkTWRJbWFnZSxcbiAgICAgICAgICAgICAgICBNZENhcmRMZ0ltYWdlLFxuICAgICAgICAgICAgICAgIE1kQ2FyZEltYWdlLFxuICAgICAgICAgICAgICAgIE1kQ2FyZFhsSW1hZ2UsXG4gICAgICAgICAgICAgICAgTWRDYXJkQXZhdGFyLFxuICAgICAgICAgICAgICAgIENvbXBhdGliaWxpdHlNb2R1bGUsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgTWRDYXJkLCBNZENhcmRIZWFkZXIsIE1kQ2FyZFRpdGxlR3JvdXAsIE1kQ2FyZENvbnRlbnQsIE1kQ2FyZFRpdGxlLCBNZENhcmRTdWJ0aXRsZSxcbiAgICAgICAgICAgICAgICBNZENhcmRBY3Rpb25zLCBNZENhcmRGb290ZXIsIE1kQ2FyZFNtSW1hZ2UsIE1kQ2FyZE1kSW1hZ2UsIE1kQ2FyZExnSW1hZ2UsIE1kQ2FyZEltYWdlLFxuICAgICAgICAgICAgICAgIE1kQ2FyZFhsSW1hZ2UsIE1kQ2FyZEF2YXRhcixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRNb2R1bGUpO1xuICAgIHJldHVybiBNZENhcmRNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ0NSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0NSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBNYXRlcmlhbCBkZXNpZ24gc3R5bGVkIENoaXAgY29tcG9uZW50LiBVc2VkIGluc2lkZSB0aGUgTWRDaGlwTGlzdCBjb21wb25lbnQuXG4gKi9cbnZhciBNZENoaXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hpcChfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgY2hpcCBpcyBkaXNhYmxlZC4gRGlzYWJsZWQgY2hpcHMgY2Fubm90IGJlIGZvY3VzZWQuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBjaGlwIGlzIHNlbGVjdGVkLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAvKiogVGhlIHBhbGV0dGUgY29sb3Igb2Ygc2VsZWN0ZWQgY2hpcHMuICovXG4gICAgICAgIHRoaXMuX2NvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBjaGlwIGlzIGZvY3VzZWQuICovXG4gICAgICAgIHRoaXMub25Gb2N1cyA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBjaGlwIGlzIHNlbGVjdGVkLiAqL1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSBjaGlwIGlzIGRlc2VsZWN0ZWQuICovXG4gICAgICAgIHRoaXMuZGVzZWxlY3QgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEVtaXR0ZWQgd2hlbiB0aGUgY2hpcCBpcyBkZXN0cm95ZWQuICovXG4gICAgICAgIHRoaXMuZGVzdHJveSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBNZENoaXAucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0Q1NTQ2xhc3MoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3IodGhpcy5fY29sb3IpO1xuICAgIH07XG4gICAgTWRDaGlwLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95LmVtaXQoeyBjaGlwOiB0aGlzIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hpcC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIGNoaXAgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICAvKiogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgb2YgdGhlIGNoaXAuICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSkgPyB0cnVlIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hpcC5wcm90b3R5cGUsIFwiX2lzQXJpYURpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIEEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IGRpc2FibGVkIHN0YXRlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoY29lcmNlQm9vbGVhblByb3BlcnR5KHRoaXMuZGlzYWJsZWQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hpcC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyBjaGlwIGlzIHNlbGVjdGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoeyBjaGlwOiB0aGlzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdC5lbWl0KHsgY2hpcDogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY3VycmVudCBzZWxlY3RlZCBzdGF0ZSBvZiB0aGlzIGNoaXAuXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBjaGlwIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIE1kQ2hpcC5wcm90b3R5cGUudG9nZ2xlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGlwLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIGNoaXAuIENhbiBiZSBgcHJpbWFyeWAsIGBhY2NlbnRgLCBvciBgd2FybmAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQWxsb3dzIGZvciBwcm9ncmFtbWF0aWMgZm9jdXNpbmcgb2YgdGhlIGNoaXAuICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpO1xuICAgICAgICB0aGlzLm9uRm9jdXMuZW1pdCh7IGNoaXA6IHRoaXMgfSk7XG4gICAgfTtcbiAgICAvKiogRW5zdXJlcyBldmVudHMgZmlyZSBwcm9wZXJseSB1cG9uIGNsaWNrLiAqL1xuICAgIE1kQ2hpcC5wcm90b3R5cGUuX2hhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGRpc2FibGVkXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBJbml0aWFsaXplcyB0aGUgYXBwcm9wcmlhdGUgQ1NTIGNsYXNzZXMgYmFzZWQgb24gdGhlIGNoaXAgdHlwZSAoYmFzaWMgb3Igc3RhbmRhcmQpLiAqL1xuICAgIE1kQ2hpcC5wcm90b3R5cGUuX2FkZERlZmF1bHRDU1NDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBBbHdheXMgYWRkIHRoZSBgbWF0LWNoaXBgIGNsYXNzXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ21hdC1jaGlwJyk7XG4gICAgICAgIC8vIElmIHdlIGFyZSBhIGJhc2ljIGNoaXAsIGFsc28gYWRkIHRoZSBgbWF0LWJhc2ljLWNoaXBgIGNsYXNzIGZvciA6bm90KCkgdGFyZ2V0aW5nXG4gICAgICAgIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdtYXQtYmFzaWMtY2hpcCcgfHwgZWwuaGFzQXR0cmlidXRlKCdtYXQtYmFzaWMtY2hpcCcpIHx8XG4gICAgICAgICAgICBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09ICdtZC1iYXNpYy1jaGlwJyB8fCBlbC5oYXNBdHRyaWJ1dGUoJ21kLWJhc2ljLWNoaXAnKSkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbWF0LWJhc2ljLWNoaXAnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFVwZGF0ZXMgdGhlIHByaXZhdGUgX2NvbG9yIHZhcmlhYmxlIGFuZCB0aGUgbmF0aXZlIGVsZW1lbnQuICovXG4gICAgTWRDaGlwLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgbWF0LWNvbG9yIG9uIHRoZSBuYXRpdmUgZWxlbWVudC4gKi9cbiAgICBNZENoaXAucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yLCBpc0FkZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRDaGlwLnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQ2hpcC5wcm90b3R5cGUsIFwiZGVzZWxlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDUoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQ2hpcC5wcm90b3R5cGUsIFwiZGVzdHJveVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ1KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRDaGlwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQ2hpcC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ0NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDUoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQ2hpcC5wcm90b3R5cGUsIFwiY29sb3JcIiwgbnVsbCk7XG4gICAgTWRDaGlwID0gX19kZWNvcmF0ZSQ0NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBcIm1kLWJhc2ljLWNoaXAsIFttZC1iYXNpYy1jaGlwXSwgbWQtY2hpcCwgW21kLWNoaXBdLFxcbiAgICAgICAgICAgICBtYXQtYmFzaWMtY2hpcCwgW21hdC1iYXNpYy1jaGlwXSwgbWF0LWNoaXAsIFttYXQtY2hpcF1cIixcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGlwXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnLFxuICAgICAgICAgICAgICAgICdyb2xlJzogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtY2hpcC1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLWRpc2FibGVkXSc6ICdfaXNBcmlhRGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ19oYW5kbGVDbGljaygkZXZlbnQpJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRDaGlwKTtcbiAgICByZXR1cm4gTWRDaGlwO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNDQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQSBtYXRlcmlhbCBkZXNpZ24gY2hpcHMgY29tcG9uZW50IChuYW1lZCBDaGlwTGlzdCBmb3IgaXQncyBzaW1pbGFyaXR5IHRvIHRoZSBMaXN0IGNvbXBvbmVudCkuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgPG1kLWNoaXAtbGlzdD5cbiAqICAgICAgIDxtZC1jaGlwPkNoaXAgMTxtZC1jaGlwPlxuICogICAgICAgPG1kLWNoaXA+Q2hpcCAyPG1kLWNoaXA+XG4gKiAgICAgPC9tZC1jaGlwLWxpc3Q+XG4gKi9cbnZhciBNZENoaXBMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoaXBMaXN0KF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqIFRyYWNrIHdoaWNoIGNoaXBzIHdlJ3JlIGxpc3RlbmluZyB0byBmb3IgZm9jdXMvZGVzdHJ1Y3Rpb24uICovXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZWQgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIGNoaXAgaXMgc2VsZWN0YWJsZS4gKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIE1kQ2hpcExpc3QucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIodGhpcy5jaGlwcykud2l0aFdyYXAoKTtcbiAgICAgICAgLy8gR28gYWhlYWQgYW5kIHN1YnNjcmliZSBhbGwgb2YgdGhlIGluaXRpYWwgY2hpcHNcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlQ2hpcHModGhpcy5jaGlwcyk7XG4gICAgICAgIC8vIFdoZW4gdGhlIGxpc3QgY2hhbmdlcywgcmUtc3Vic2NyaWJlXG4gICAgICAgIHRoaXMuY2hpcHMuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoaXBzKSB7XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaWJlQ2hpcHMoY2hpcHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoaXBMaXN0LnByb3RvdHlwZSwgXCJzZWxlY3RhYmxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY2hpcCBpcyBzZWxlY3RhYmxlLiBXaGVuIGEgY2hpcCBpcyBub3Qgc2VsZWN0YWJsZSxcbiAgICAgICAgICogaXQncyBzZWxlY3RlZCBzdGF0ZSBpcyBhbHdheXMgaWdub3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGFibGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RhYmxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbW1hdGljYWxseSBmb2N1cyB0aGUgY2hpcCBsaXN0LiBUaGlzIGluIHR1cm4gZm9jdXNlcyB0aGUgZmlyc3RcbiAgICAgKiBub24tZGlzYWJsZWQgY2hpcCBpbiB0aGlzIGNoaXAgbGlzdC5cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogQVJJQSBzYXlzIHRoaXMgc2hvdWxkIGZvY3VzIHRoZSBmaXJzdCBgc2VsZWN0ZWRgIGNoaXAuXG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgfTtcbiAgICAvKiogUGFzc2VzIHJlbGV2YW50IGtleSBwcmVzc2VzIHRvIG91ciBrZXkgbWFuYWdlci4gKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5fa2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAvLyBJZiB0aGV5IGFyZSBvbiBhIGNoaXAsIGNoZWNrIGZvciBzcGFjZS9sZWZ0L3JpZ2h0LCBvdGhlcndpc2UgcGFzcyB0byBvdXIga2V5IG1hbmFnZXJcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtYXQtY2hpcCcpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2VsZWN0YWJsZSwgdG9nZ2xlIHRoZSBmb2N1c2VkIGNoaXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlU2VsZWN0T25Gb2N1c2VkQ2hpcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBwcmV2ZW50IHNwYWNlIGZyb20gc2Nyb2xsaW5nIHRoZSBwYWdlIHNpbmNlIHRoZSBsaXN0IGhhcyBmb2N1c1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0UHJldmlvdXNJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0TmV4dEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGNoaXAuICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX3RvZ2dsZVNlbGVjdE9uRm9jdXNlZENoaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFsbG93IGRpc2FibGluZyBvZiBjaGlwIHNlbGVjdGlvblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb2N1c2VkSW5kZXggPSB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleDtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmFsaWRJbmRleChmb2N1c2VkSW5kZXgpKSB7XG4gICAgICAgICAgICB2YXIgZm9jdXNlZENoaXAgPSB0aGlzLmNoaXBzLnRvQXJyYXkoKVtmb2N1c2VkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWRDaGlwKSB7XG4gICAgICAgICAgICAgICAgZm9jdXNlZENoaXAudG9nZ2xlU2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIGNoaXBzIGFuZCBhZGQgdGhlbSB0byBvdXIgbGlzdCBvZlxuICAgICAqIHN1YnNjcmliZWQgY2hpcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hpcHMgVGhlIGxpc3Qgb2YgY2hpcHMgdG8gYmUgc3Vic2NyaWJlZC5cbiAgICAgKi9cbiAgICBNZENoaXBMaXN0LnByb3RvdHlwZS5fc3Vic2NyaWJlQ2hpcHMgPSBmdW5jdGlvbiAoY2hpcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2hpcHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpcCkgeyByZXR1cm4gX3RoaXMuX2FkZENoaXAoY2hpcCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgc3BlY2lmaWMgY2hpcCB0byBvdXIgc3Vic2NyaWJlZCBsaXN0LiBJZiB0aGUgY2hpcCBoYXNcbiAgICAgKiBhbHJlYWR5IGJlZW4gc3Vic2NyaWJlZCwgdGhpcyBlbnN1cmVzIGl0IGlzIG9ubHkgc3Vic2NyaWJlZFxuICAgICAqIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hpcCBUaGUgY2hpcCB0byBiZSBzdWJzY3JpYmVkIChvciBjaGVja2VkIGZvciBleGlzdGluZ1xuICAgICAqIHN1YnNjcmlwdGlvbikuXG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX2FkZENoaXAgPSBmdW5jdGlvbiAoY2hpcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGJlZW4gc3Vic2NyaWJlZCB0byBhIHBhcmVudCwgZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaWJlZC5oYXMoY2hpcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYXRjaCBmb3IgZm9jdXMgZXZlbnRzIG91dHNpZGUgb2YgdGhlIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAgICAgY2hpcC5vbkZvY3VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2hpcEluZGV4ID0gX3RoaXMuY2hpcHMudG9BcnJheSgpLmluZGV4T2YoY2hpcCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzVmFsaWRJbmRleChjaGlwSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2tleU1hbmFnZXIudXBkYXRlQWN0aXZlSXRlbUluZGV4KGNoaXBJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBPbiBkZXN0cm95LCByZW1vdmUgdGhlIGl0ZW0gZnJvbSBvdXIgbGlzdCwgYW5kIGNoZWNrIGZvY3VzXG4gICAgICAgIGNoaXAuZGVzdHJveS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoaXBJbmRleCA9IF90aGlzLmNoaXBzLnRvQXJyYXkoKS5pbmRleE9mKGNoaXApO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9pc1ZhbGlkSW5kZXgoY2hpcEluZGV4KSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGNoaXAgaXMgdGhlIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIGlmIChjaGlwSW5kZXggPCBfdGhpcy5jaGlwcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0oY2hpcEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpcEluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0oY2hpcEluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmliZWQuZGVsZXRlKGNoaXApO1xuICAgICAgICAgICAgY2hpcC5kZXN0cm95LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVkLnNldChjaGlwLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZW5zdXJlIGFsbCBpbmRleGVzIGFyZSB2YWxpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbmRleCBpcyB2YWxpZCBmb3Igb3VyIGxpc3Qgb2YgY2hpcHMuXG4gICAgICovXG4gICAgTWRDaGlwTGlzdC5wcm90b3R5cGUuX2lzVmFsaWRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuY2hpcHMubGVuZ3RoO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDQoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZENoaXBMaXN0LnByb3RvdHlwZSwgXCJzZWxlY3RhYmxlXCIsIG51bGwpO1xuICAgIE1kQ2hpcExpc3QgPSBfX2RlY29yYXRlJDQ0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtY2hpcC1saXN0LCBtYXQtY2hpcC1saXN0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1kLWNoaXAtbGlzdC13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydGllc1xuICAgICAgICAgICAgICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0Ym94JyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1jaGlwLWxpc3RdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgIC8vIEV2ZW50c1xuICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ2ZvY3VzKCknLFxuICAgICAgICAgICAgICAgICcoa2V5ZG93biknOiAnX2tleWRvd24oJGV2ZW50KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxdWVyaWVzOiB7XG4gICAgICAgICAgICAgICAgY2hpcHM6IG5ldyBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZENoaXApXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LWNoaXAtbGlzdC13cmFwcGVye2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC13cmFwOndyYXA7YWxpZ24taXRlbXM6ZmxleC1zdGFydH0ubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKXttYXJnaW46MCAzcHh9Lm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCk6Zmlyc3QtY2hpbGR7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6M3B4fS5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApOmxhc3QtY2hpbGQsW2Rpcj1ydGxdIC5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApOmZpcnN0LWNoaWxke21hcmdpbi1sZWZ0OjNweDttYXJnaW4tcmlnaHQ6MH1bZGlyPXJ0bF0gLm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCk6bGFzdC1jaGlsZHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDozcHh9Lm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6OHB4IDEycHg7Ym9yZGVyLXJhZGl1czoyNHB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE2cHh9Lm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVye2Rpc3BsYXk6YmxvY2t9Lm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKXtkaXNwbGF5OmJsb2NrO21hcmdpbjowIDAgOHB4fVtkaXI9cnRsXSAubWF0LWNoaXAtbGlzdC1zdGFja2VkIC5tYXQtY2hpcC1saXN0LXdyYXBwZXIgLm1hdC1jaGlwOm5vdCgubWF0LWJhc2ljLWNoaXApe21hcmdpbjowIDAgOHB4fS5tYXQtY2hpcC1saXN0LXN0YWNrZWQgLm1hdC1jaGlwLWxpc3Qtd3JhcHBlciAubWF0LWNoaXA6bm90KC5tYXQtYmFzaWMtY2hpcCk6bGFzdC1jaGlsZCxbZGlyPXJ0bF0gLm1hdC1jaGlwLWxpc3Qtc3RhY2tlZCAubWF0LWNoaXAtbGlzdC13cmFwcGVyIC5tYXQtY2hpcDpub3QoLm1hdC1iYXNpYy1jaGlwKTpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZENoaXBMaXN0KTtcbiAgICByZXR1cm4gTWRDaGlwTGlzdDtcbn0oKSk7XG52YXIgTWRDaGlwc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGlwc01vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRDaGlwc01vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kQ2hpcHNNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZENoaXBzTW9kdWxlID0gX19kZWNvcmF0ZSQ0NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW10sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRDaGlwTGlzdCwgTWRDaGlwXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kQ2hpcExpc3QsIE1kQ2hpcF1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2hpcHNNb2R1bGUpO1xuICAgIHJldHVybiBNZENoaXBzTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ0NyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0NyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBsb2FkIGFuIGljb24gd2l0aCBhIG5hbWUgdGhhdCBjYW5ub3QgYmUgZm91bmQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEljb25OYW1lTm90Rm91bmRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEzKE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yKGljb25OYW1lKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiVW5hYmxlIHRvIGZpbmQgaWNvbiB3aXRoIHRoZSBuYW1lIFxcXCJcIiArIGljb25OYW1lICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRJY29uTmFtZU5vdEZvdW5kRXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gbG9hZCBTVkcgY29udGVudCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIGV4cGVjdGVkXG4gKiA8c3ZnPiB0YWcuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZEljb25TdmdUYWdOb3RGb3VuZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTMoTWRJY29uU3ZnVGFnTm90Rm91bmRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEljb25TdmdUYWdOb3RGb3VuZEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnPHN2Zz4gdGFnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gTWRJY29uU3ZnVGFnTm90Rm91bmRFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBhbiBpY29uLCBpbmNsdWRpbmcgdGhlIFVSTCBhbmQgcG9zc2libHkgdGhlIGNhY2hlZCBTVkcgZWxlbWVudC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIFN2Z0ljb25Db25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN2Z0ljb25Db25maWcodXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gU3ZnSWNvbkNvbmZpZztcbn0oKSk7XG4vKiogUmV0dXJucyB0aGUgY2FjaGUga2V5IHRvIHVzZSBmb3IgYW4gaWNvbiBuYW1lc3BhY2UgYW5kIG5hbWUuICovXG52YXIgaWNvbktleSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG5hbWUpIHsgcmV0dXJuIG5hbWVzcGFjZSArICc6JyArIG5hbWU7IH07XG4vKipcbiAqIFNlcnZpY2UgdG8gcmVnaXN0ZXIgYW5kIGRpc3BsYXkgaWNvbnMgdXNlZCBieSB0aGUgPG1kLWljb24+IGNvbXBvbmVudC5cbiAqIC0gUmVnaXN0ZXJzIGljb24gVVJMcyBieSBuYW1lc3BhY2UgYW5kIG5hbWUuXG4gKiAtIFJlZ2lzdGVycyBpY29uIHNldCBVUkxzIGJ5IG5hbWVzcGFjZS5cbiAqIC0gUmVnaXN0ZXJzIGFsaWFzZXMgZm9yIENTUyBjbGFzc2VzLCBmb3IgdXNlIHdpdGggaWNvbiBmb250cy5cbiAqIC0gTG9hZHMgaWNvbnMgZnJvbSBVUkxzIGFuZCBleHRyYWN0cyBpbmRpdmlkdWFsIGljb25zIGZyb20gaWNvbiBzZXRzLlxuICovXG52YXIgTWRJY29uUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSWNvblJlZ2lzdHJ5KF9odHRwLCBfc2FuaXRpemVyKSB7XG4gICAgICAgIHRoaXMuX2h0dHAgPSBfaHR0cDtcbiAgICAgICAgdGhpcy5fc2FuaXRpemVyID0gX3Nhbml0aXplcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVSTHMgYW5kIGNhY2hlZCBTVkcgZWxlbWVudHMgZm9yIGluZGl2aWR1YWwgaWNvbnMuIEtleXMgYXJlIG9mIHRoZSBmb3JtYXQgXCJbbmFtZXNwYWNlXTpbaWNvbl1cIi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N2Z0ljb25Db25maWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3ZnSWNvbkNvbmZpZyBvYmplY3RzIGFuZCBjYWNoZWQgU1ZHIGVsZW1lbnRzIGZvciBpY29uIHNldHMsIGtleWVkIGJ5IG5hbWVzcGFjZS5cbiAgICAgICAgICogTXVsdGlwbGUgaWNvbiBzZXRzIGNhbiBiZSByZWdpc3RlcmVkIHVuZGVyIHRoZSBzYW1lIG5hbWVzcGFjZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ljb25TZXRDb25maWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogQ2FjaGUgZm9yIGljb25zIGxvYWRlZCBieSBkaXJlY3QgVVJMcy4gKi9cbiAgICAgICAgdGhpcy5fY2FjaGVkSWNvbnNCeVVybCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIEluLXByb2dyZXNzIGljb24gZmV0Y2hlcy4gVXNlZCB0byBjb2FsZXNjZSBtdWx0aXBsZSByZXF1ZXN0cyB0byB0aGUgc2FtZSBVUkwuICovXG4gICAgICAgIHRoaXMuX2luUHJvZ3Jlc3NVcmxGZXRjaGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogTWFwIGZyb20gZm9udCBpZGVudGlmaWVycyB0byB0aGVpciBDU1MgY2xhc3MgbmFtZXMuIFVzZWQgZm9yIGljb24gZm9udHMuICovXG4gICAgICAgIHRoaXMuX2ZvbnRDc3NDbGFzc2VzQnlBbGlhcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBDU1MgY2xhc3MgdG8gYXBwbHkgd2hlbiBhbiA8bWQtaWNvbj4gY29tcG9uZW50IGhhcyBubyBpY29uIG5hbWUsIHVybCwgb3IgZm9udCBzcGVjaWZpZWQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0ICdtYXRlcmlhbC1pY29ucycgdmFsdWUgYXNzdW1lcyB0aGF0IHRoZSBtYXRlcmlhbCBpY29uIGZvbnQgaGFzIGJlZW4gbG9hZGVkIGFzXG4gICAgICAgICAqIGRlc2NyaWJlZCBhdCBodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbnMvI2ljb24tZm9udC1mb3ItdGhlLXdlYlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGVmYXVsdEZvbnRTZXRDbGFzcyA9ICdtYXRlcmlhbC1pY29ucyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpY29uIGJ5IFVSTCBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gICAgICogQHBhcmFtIGljb25OYW1lIE5hbWUgdW5kZXIgd2hpY2ggdGhlIGljb24gc2hvdWxkIGJlIHJlZ2lzdGVyZWQuXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRTdmdJY29uID0gZnVuY3Rpb24gKGljb25OYW1lLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3ZnSWNvbkluTmFtZXNwYWNlKCcnLCBpY29uTmFtZSwgdXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpY29uIGJ5IFVSTCBpbiB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZS5cbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIE5hbWVzcGFjZSBpbiB3aGljaCB0aGUgaWNvbiBzaG91bGQgYmUgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcGFyYW0gaWNvbk5hbWUgTmFtZSB1bmRlciB3aGljaCB0aGUgaWNvbiBzaG91bGQgYmUgcmVnaXN0ZXJlZC5cbiAgICAgKiBAcGFyYW0gdXJsXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmFkZFN2Z0ljb25Jbk5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIGljb25OYW1lLCB1cmwpIHtcbiAgICAgICAgdmFyIGtleSA9IGljb25LZXkobmFtZXNwYWNlLCBpY29uTmFtZSk7XG4gICAgICAgIHRoaXMuX3N2Z0ljb25Db25maWdzLnNldChrZXksIG5ldyBTdmdJY29uQ29uZmlnKHVybCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBpY29uIHNldCBieSBVUkwgaW4gdGhlIGRlZmF1bHQgbmFtZXNwYWNlLlxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuYWRkU3ZnSWNvblNldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3ZnSWNvblNldEluTmFtZXNwYWNlKCcnLCB1cmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gc2V0IGJ5IFVSTCBpbiB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZS5cbiAgICAgKiBAcGFyYW0gbmFtZXNwYWNlIE5hbWVzcGFjZSBpbiB3aGljaCB0byByZWdpc3RlciB0aGUgaWNvbiBzZXQuXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCB1cmwpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IG5ldyBTdmdJY29uQ29uZmlnKHVybCk7XG4gICAgICAgIGlmICh0aGlzLl9pY29uU2V0Q29uZmlncy5oYXMobmFtZXNwYWNlKSkge1xuICAgICAgICAgICAgdGhpcy5faWNvblNldENvbmZpZ3MuZ2V0KG5hbWVzcGFjZSkucHVzaChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faWNvblNldENvbmZpZ3Muc2V0KG5hbWVzcGFjZSwgW2NvbmZpZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhbiBhbGlhcyBmb3IgYSBDU1MgY2xhc3MgbmFtZSB0byBiZSB1c2VkIGZvciBpY29uIGZvbnRzLiBDcmVhdGluZyBhbiBtZEljb25cbiAgICAgKiBjb21wb25lbnQgd2l0aCB0aGUgYWxpYXMgYXMgdGhlIGZvbnRTZXQgaW5wdXQgd2lsbCBjYXVzZSB0aGUgY2xhc3MgbmFtZSB0byBiZSBhcHBsaWVkXG4gICAgICogdG8gdGhlIDxtZC1pY29uPiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFsaWFzIEFsaWFzIGZvciB0aGUgZm9udC5cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lIENsYXNzIG5hbWUgb3ZlcnJpZGUgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhbGlhcy5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJGb250Q2xhc3NBbGlhcyA9IGZ1bmN0aW9uIChhbGlhcywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IHZvaWQgMCkgeyBjbGFzc05hbWUgPSBhbGlhczsgfVxuICAgICAgICB0aGlzLl9mb250Q3NzQ2xhc3Nlc0J5QWxpYXMuc2V0KGFsaWFzLCBjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIENTUyBjbGFzcyBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWxpYXMgYnkgYSBwcmV2aW91cyBjYWxsIHRvXG4gICAgICogcmVnaXN0ZXJGb250Q2xhc3NBbGlhcy4gSWYgbm8gQ1NTIGNsYXNzIGhhcyBiZWVuIGFzc29jaWF0ZWQsIHJldHVybnMgdGhlIGFsaWFzIHVubW9kaWZpZWQuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmNsYXNzTmFtZUZvckZvbnRBbGlhcyA9IGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udENzc0NsYXNzZXNCeUFsaWFzLmdldChhbGlhcykgfHwgYWxpYXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBDU1MgY2xhc3MgbmFtZSB0byBiZSB1c2VkIGZvciBpY29uIGZvbnRzIHdoZW4gYW4gPG1kLWljb24+IGNvbXBvbmVudCBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmb250U2V0IGlucHV0IHZhbHVlLCBhbmQgaXMgbm90IGxvYWRpbmcgYW4gaWNvbiBieSBuYW1lIG9yIFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuc2V0RGVmYXVsdEZvbnRTZXRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEZvbnRTZXRDbGFzcyA9IGNsYXNzTmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDU1MgY2xhc3MgbmFtZSB0byBiZSB1c2VkIGZvciBpY29uIGZvbnRzIHdoZW4gYW4gPG1kLWljb24+IGNvbXBvbmVudCBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmb250U2V0IGlucHV0IHZhbHVlLCBhbmQgaXMgbm90IGxvYWRpbmcgYW4gaWNvbiBieSBuYW1lIG9yIFVSTC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvbnRTZXRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRGb250U2V0Q2xhc3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBwcm9kdWNlcyB0aGUgaWNvbiAoYXMgYW4gPHN2Zz4gRE9NIGVsZW1lbnQpIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAgICAgKiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgVVJMIG1heSBiZSBjYWNoZWQgc28gdGhpcyB3aWxsIG5vdCBhbHdheXMgY2F1c2UgYW4gSFRUUCByZXF1ZXN0LCBidXRcbiAgICAgKiB0aGUgcHJvZHVjZWQgZWxlbWVudCB3aWxsIGFsd2F5cyBiZSBhIG5ldyBjb3B5IG9mIHRoZSBvcmlnaW5hbGx5IGZldGNoZWQgaWNvbi4gKFRoYXQgaXMsXG4gICAgICogaXQgd2lsbCBub3QgY29udGFpbiBhbnkgbW9kaWZpY2F0aW9ucyBtYWRlIHRvIGVsZW1lbnRzIHByZXZpb3VzbHkgcmV0dXJuZWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNhZmVVcmwgVVJMIGZyb20gd2hpY2ggdG8gZmV0Y2ggdGhlIFNWRyBpY29uLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRTdmdJY29uRnJvbVVybCA9IGZ1bmN0aW9uIChzYWZlVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLl9zYW5pdGl6ZXIuc2FuaXRpemUoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBzYWZlVXJsKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZEljb25zQnlVcmwuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5vZihjbG9uZVN2Zyh0aGlzLl9jYWNoZWRJY29uc0J5VXJsLmdldCh1cmwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRTdmdJY29uRnJvbUNvbmZpZyhuZXcgU3ZnSWNvbkNvbmZpZyh1cmwpKVxuICAgICAgICAgICAgLmRvKGZ1bmN0aW9uIChzdmcpIHsgcmV0dXJuIF90aGlzLl9jYWNoZWRJY29uc0J5VXJsLnNldCh1cmwsIHN2Zyk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdmcpIHsgcmV0dXJuIGNsb25lU3ZnKHN2Zyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcHJvZHVjZXMgdGhlIGljb24gKGFzIGFuIDxzdmc+IERPTSBlbGVtZW50KSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAgICogYW5kIG5hbWVzcGFjZS4gVGhlIGljb24gbXVzdCBoYXZlIGJlZW4gcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkSWNvbiBvciBhZGRJY29uU2V0O1xuICAgICAqIGlmIG5vdCwgdGhlIE9ic2VydmFibGUgd2lsbCB0aHJvdyBhbiBNZEljb25OYW1lTm90Rm91bmRFcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGljb24gdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgTmFtZXNwYWNlIGluIHdoaWNoIHRvIGxvb2sgZm9yIHRoZSBpY29uLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXROYW1lZFN2Z0ljb24gPSBmdW5jdGlvbiAobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHZvaWQgMCkgeyBuYW1lc3BhY2UgPSAnJzsgfVxuICAgICAgICAvLyBSZXR1cm4gKGNvcHkgb2YpIGNhY2hlZCBpY29uIGlmIHBvc3NpYmxlLlxuICAgICAgICB2YXIga2V5ID0gaWNvbktleShuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgICBpZiAodGhpcy5fc3ZnSWNvbkNvbmZpZ3MuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTdmdGcm9tQ29uZmlnKHRoaXMuX3N2Z0ljb25Db25maWdzLmdldChrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgaWYgd2UgaGF2ZSBhbnkgaWNvbiBzZXRzIHJlZ2lzdGVyZWQgZm9yIHRoZSBuYW1lc3BhY2UuXG4gICAgICAgIHZhciBpY29uU2V0Q29uZmlncyA9IHRoaXMuX2ljb25TZXRDb25maWdzLmdldChuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoaWNvblNldENvbmZpZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTdmdGcm9tSWNvblNldENvbmZpZ3MobmFtZSwgaWNvblNldENvbmZpZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS50aHJvdyhuZXcgTWRJY29uTmFtZU5vdEZvdW5kRXJyb3Ioa2V5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWNoZWQgaWNvbiBmb3IgYSBTdmdJY29uQ29uZmlnIGlmIGF2YWlsYWJsZSwgb3IgZmV0Y2hlcyBpdCBmcm9tIGl0cyBVUkwgaWYgbm90LlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2V0U3ZnRnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIFNWRyBlbGVtZW50IGZvciB0aGlzIGljb24sIHJldHVybiBhIGNvcHkuXG4gICAgICAgICAgICByZXR1cm4gcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUub2YoY2xvbmVTdmcoY29uZmlnLnN2Z0VsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBpY29uIGZyb20gdGhlIGNvbmZpZydzIFVSTCwgY2FjaGUgaXQsIGFuZCByZXR1cm4gYSBjb3B5LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRTdmdJY29uRnJvbUNvbmZpZyhjb25maWcpXG4gICAgICAgICAgICAgICAgLmRvKGZ1bmN0aW9uIChzdmcpIHsgcmV0dXJuIGNvbmZpZy5zdmdFbGVtZW50ID0gc3ZnOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gY2xvbmVTdmcoc3ZnKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGZpbmQgYW4gaWNvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBpbiBhbnkgb2YgdGhlIFNWRyBpY29uIHNldHMuXG4gICAgICogRmlyc3Qgc2VhcmNoZXMgdGhlIGF2YWlsYWJsZSBjYWNoZWQgaWNvbnMgZm9yIGEgbmVzdGVkIGVsZW1lbnQgd2l0aCBhIG1hdGNoaW5nIG5hbWUsIGFuZFxuICAgICAqIGlmIGZvdW5kIGNvcGllcyB0aGUgZWxlbWVudCB0byBhIG5ldyA8c3ZnPiBlbGVtZW50LiBJZiBub3QgZm91bmQsIGZldGNoZXMgYWxsIGljb24gc2V0c1xuICAgICAqIHRoYXQgaGF2ZSBub3QgYmVlbiBjYWNoZWQsIGFuZCBzZWFyY2hlcyBhZ2FpbiBhZnRlciBhbGwgZmV0Y2hlcyBhcmUgY29tcGxldGVkLlxuICAgICAqIFRoZSByZXR1cm5lZCBPYnNlcnZhYmxlIHByb2R1Y2VzIHRoZSBTVkcgZWxlbWVudCBpZiBwb3NzaWJsZSwgYW5kIHRocm93c1xuICAgICAqIE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yIGlmIG5vIGljb24gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgY2FuIGJlIGZvdW5kLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2V0U3ZnRnJvbUljb25TZXRDb25maWdzID0gZnVuY3Rpb24gKG5hbWUsIGljb25TZXRDb25maWdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEZvciBhbGwgdGhlIGljb24gc2V0IFNWRyBlbGVtZW50cyB3ZSd2ZSBmZXRjaGVkLCBzZWUgaWYgYW55IGNvbnRhaW4gYW4gaWNvbiB3aXRoIHRoZVxuICAgICAgICAvLyByZXF1ZXN0ZWQgbmFtZS5cbiAgICAgICAgdmFyIG5hbWVkSWNvbiA9IHRoaXMuX2V4dHJhY3RJY29uV2l0aE5hbWVGcm9tQW55U2V0KG5hbWUsIGljb25TZXRDb25maWdzKTtcbiAgICAgICAgaWYgKG5hbWVkSWNvbikge1xuICAgICAgICAgICAgLy8gV2UgY291bGQgY2FjaGUgbmFtZWRJY29uIGluIF9zdmdJY29uQ29uZmlncywgYnV0IHNpbmNlIHdlIGhhdmUgdG8gbWFrZSBhIGNvcHkgZXZlcnlcbiAgICAgICAgICAgIC8vIHRpbWUgYW55d2F5LCB0aGVyZSdzIHByb2JhYmx5IG5vdCBtdWNoIGFkdmFudGFnZSBjb21wYXJlZCB0byBqdXN0IGFsd2F5cyBleHRyYWN0aW5nXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBpY29uIHNldC5cbiAgICAgICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5vZihuYW1lZEljb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBmb3VuZCBpbiBhbnkgY2FjaGVkIGljb24gc2V0cy4gSWYgdGhlcmUgYXJlIGljb24gc2V0cyB3aXRoIFVSTHMgdGhhdCB3ZSBoYXZlbid0XG4gICAgICAgIC8vIGZldGNoZWQsIGZldGNoIHRoZW0gbm93IGFuZCBsb29rIGZvciBpY29uTmFtZSBpbiB0aGUgcmVzdWx0cy5cbiAgICAgICAgdmFyIGljb25TZXRGZXRjaFJlcXVlc3RzID0gaWNvblNldENvbmZpZ3NcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGljb25TZXRDb25maWcpIHsgcmV0dXJuICFpY29uU2V0Q29uZmlnLnN2Z0VsZW1lbnQ7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpY29uU2V0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2xvYWRTdmdJY29uU2V0RnJvbUNvbmZpZyhpY29uU2V0Q29uZmlnKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyLCBjYXVnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gX3RoaXMuX3Nhbml0aXplci5zYW5pdGl6ZShfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIGljb25TZXRDb25maWcudXJsKTtcbiAgICAgICAgICAgICAgICAvLyBTd2FsbG93IGVycm9ycyBmZXRjaGluZyBpbmRpdmlkdWFsIFVSTHMgc28gdGhlIGNvbWJpbmVkIE9ic2VydmFibGUgd29uJ3RcbiAgICAgICAgICAgICAgICAvLyBuZWNlc3NhcmlseSBmYWlsLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBpY29uIHNldCBVUkw6IFwiICsgdXJsICsgXCIgZmFpbGVkOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLm9mKG51bGwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZG8oZnVuY3Rpb24gKHN2Zykge1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIFNWRyBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvblNldENvbmZpZy5zdmdFbGVtZW50ID0gc3ZnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHRoZSBpY29uIHNldCBVUkxzLiBXaGVuIHRoZSByZXF1ZXN0cyBjb21wbGV0ZSwgZXZlcnkgSWNvblNldCBzaG91bGQgaGF2ZSBhXG4gICAgICAgIC8vIGNhY2hlZCBTVkcgZWxlbWVudCAodW5sZXNzIHRoZSByZXF1ZXN0IGZhaWxlZCksIGFuZCB3ZSBjYW4gY2hlY2sgYWdhaW4gZm9yIHRoZSBpY29uLlxuICAgICAgICByZXR1cm4gcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUuZm9ya0pvaW4oaWNvblNldEZldGNoUmVxdWVzdHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpZ25vcmVkUmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIGZvdW5kSWNvbiA9IF90aGlzLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldChuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kSWNvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZEljb25OYW1lTm90Rm91bmRFcnJvcihuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3VuZEljb247XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIGNhY2hlZCBTVkcgZWxlbWVudHMgZm9yIHRoZSBnaXZlbiBpY29uIHNldHMgZm9yIGEgbmVzdGVkIGljb24gZWxlbWVudCB3aG9zZSBcImlkXCJcbiAgICAgKiB0YWcgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIG5hbWUuIElmIGZvdW5kLCBjb3BpZXMgdGhlIG5lc3RlZCBlbGVtZW50IHRvIGEgbmV3IFNWRyBlbGVtZW50IGFuZFxuICAgICAqIHJldHVybnMgaXQuIFJldHVybnMgbnVsbCBpZiBubyBtYXRjaGluZyBlbGVtZW50IGlzIGZvdW5kLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fZXh0cmFjdEljb25XaXRoTmFtZUZyb21BbnlTZXQgPSBmdW5jdGlvbiAoaWNvbk5hbWUsIGljb25TZXRDb25maWdzKSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgYmFja3dhcmRzLCBzbyBpY29uIHNldHMgYWRkZWQgbGF0ZXIgaGF2ZSBwcmVjZWRlbmNlLlxuICAgICAgICBmb3IgKHZhciBpID0gaWNvblNldENvbmZpZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBpY29uU2V0Q29uZmlnc1tpXTtcbiAgICAgICAgICAgIGlmIChjb25maWcuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZEljb24gPSB0aGlzLl9leHRyYWN0U3ZnSWNvbkZyb21TZXQoY29uZmlnLnN2Z0VsZW1lbnQsIGljb25OYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZEljb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGNvbnRlbnQgb2YgdGhlIGljb24gVVJMIHNwZWNpZmllZCBpbiB0aGUgU3ZnSWNvbkNvbmZpZyBhbmQgY3JlYXRlcyBhbiBTVkcgZWxlbWVudFxuICAgICAqIGZyb20gaXQuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9sb2FkU3ZnSWNvbkZyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFVybChjb25maWcudXJsKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3ZnVGV4dCkgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZVN2Z0VsZW1lbnRGb3JTaW5nbGVJY29uKHN2Z1RleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBjb250ZW50IG9mIHRoZSBpY29uIHNldCBVUkwgc3BlY2lmaWVkIGluIHRoZSBTdmdJY29uQ29uZmlnIGFuZCBjcmVhdGVzIGFuIFNWRyBlbGVtZW50XG4gICAgICogZnJvbSBpdC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2xvYWRTdmdJY29uU2V0RnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVE9ETzogRG9jdW1lbnQgdGhhdCBpY29ucyBzaG91bGQgb25seSBiZSBsb2FkZWQgZnJvbSB0cnVzdGVkIHNvdXJjZXMuXG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaFVybChjb25maWcudXJsKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3ZnVGV4dCkgeyByZXR1cm4gX3RoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKHN2Z1RleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBET00gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBTVkcgc3RyaW5nLCBhbmQgYWRkcyBkZWZhdWx0IGF0dHJpYnV0ZXMuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9jcmVhdGVTdmdFbGVtZW50Rm9yU2luZ2xlSWNvbiA9IGZ1bmN0aW9uIChyZXNwb25zZVRleHQpIHtcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHRoaXMuX3NldFN2Z0F0dHJpYnV0ZXMoc3ZnKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIHRoZSBjYWNoZWQgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gU3ZnSWNvbkNvbmZpZyBmb3IgYSBuZXN0ZWQgaWNvbiBlbGVtZW50IHdob3NlIFwiaWRcIlxuICAgICAqIHRhZyBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgbmFtZS4gSWYgZm91bmQsIGNvcGllcyB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYSBuZXcgU1ZHIGVsZW1lbnQgYW5kXG4gICAgICogcmV0dXJucyBpdC4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9leHRyYWN0U3ZnSWNvbkZyb21TZXQgPSBmdW5jdGlvbiAoaWNvblNldCwgaWNvbk5hbWUpIHtcbiAgICAgICAgdmFyIGljb25Ob2RlID0gaWNvblNldC5xdWVyeVNlbGVjdG9yKCcjJyArIGljb25OYW1lKTtcbiAgICAgICAgaWYgKCFpY29uTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGljb24gbm9kZSBpcyBpdHNlbGYgYW4gPHN2Zz4gbm9kZSwgY2xvbmUgYW5kIHJldHVybiBpdCBkaXJlY3RseS4gSWYgbm90LCBzZXQgaXQgYXNcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgb2YgYSBuZXcgPHN2Zz4gbm9kZS5cbiAgICAgICAgaWYgKGljb25Ob2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFN2Z0F0dHJpYnV0ZXMoaWNvbk5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGVFbGVtZW50KCdTVkcnKSBkb2Vzbid0IHdvcmsgYXMgZXhwZWN0ZWQ7IHRoZSBET00gZW5kcyB1cCB3aXRoXG4gICAgICAgIC8vIHRoZSBjb3JyZWN0IG5vZGVzLCBidXQgdGhlIFNWRyBjb250ZW50IGRvZXNuJ3QgcmVuZGVyLiBJbnN0ZWFkIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gY3JlYXRlIGFuIGVtcHR5IFNWRyBub2RlIHVzaW5nIGlubmVySFRNTCBhbmQgYXBwZW5kIGl0cyBjb250ZW50LlxuICAgICAgICAvLyBFbGVtZW50cyBjcmVhdGVkIHVzaW5nIERPTVBhcnNlci5wYXJzZUZyb21TdHJpbmcgaGF2ZSB0aGUgc2FtZSBwcm9ibGVtLlxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIzMDAzMjc4L3N2Zy1pbm5lcmh0bWwtaW4tZmlyZWZveC1jYW4tbm90LWRpc3BsYXlcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKCc8c3ZnPjwvc3ZnPicpO1xuICAgICAgICAvLyBDbG9uZSB0aGUgbm9kZSBzbyB3ZSBkb24ndCByZW1vdmUgaXQgZnJvbSB0aGUgcGFyZW50IGljb24gc2V0IGVsZW1lbnQuXG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChpY29uTm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0U3ZnQXR0cmlidXRlcyhzdmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIERPTSBlbGVtZW50IGZyb20gdGhlIGdpdmVuIFNWRyBzdHJpbmcuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9zdmdFbGVtZW50RnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRoYW4gaW5uZXJIVE1MPyBSZW5kZXJlciBkb2Vzbid0IGFwcGVhciB0byBoYXZlIGEgbWV0aG9kIGZvclxuICAgICAgICAvLyBjcmVhdGluZyBhbiBlbGVtZW50IGZyb20gYW4gSFRNTCBzdHJpbmcuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IHN0cjtcbiAgICAgICAgdmFyIHN2ZyA9IGRpdi5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZEljb25TdmdUYWdOb3RGb3VuZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgYW4gU1ZHIGVsZW1lbnQgdG8gYmUgdXNlZCBhcyBhbiBpY29uLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fc2V0U3ZnQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgICAgICAgaWYgKCFzdmcuZ2V0QXR0cmlidXRlKCd4bWxucycpKSB7XG4gICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuICAgICAgICB9XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2ZpdCcsICcnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgJ3hNaWRZTWlkIG1lZXQnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJywgJ2ZhbHNlJyk7IC8vIERpc2FibGUgSUUxMSBkZWZhdWx0IGJlaGF2aW9yIHRvIG1ha2UgU1ZHcyBmb2N1c2FibGUuXG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgd2hpY2ggcHJvZHVjZXMgdGhlIHN0cmluZyBjb250ZW50cyBvZiB0aGUgZ2l2ZW4gVVJMLiBSZXN1bHRzIG1heSBiZVxuICAgICAqIGNhY2hlZCwgc28gZnV0dXJlIGNhbGxzIHdpdGggdGhlIHNhbWUgVVJMIG1heSBub3QgY2F1c2UgYW5vdGhlciBIVFRQIHJlcXVlc3QuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9mZXRjaFVybCA9IGZ1bmN0aW9uIChzYWZlVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLl9zYW5pdGl6ZXIuc2FuaXRpemUoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBzYWZlVXJsKTtcbiAgICAgICAgLy8gU3RvcmUgaW4tcHJvZ3Jlc3MgZmV0Y2hlcyB0byBhdm9pZCBzZW5kaW5nIGEgZHVwbGljYXRlIHJlcXVlc3QgZm9yIGEgVVJMIHdoZW4gdGhlcmUgaXNcbiAgICAgICAgLy8gYWxyZWFkeSBhIHJlcXVlc3QgaW4gcHJvZ3Jlc3MgZm9yIHRoYXQgVVJMLiBJdCdzIG5lY2Vzc2FyeSB0byBjYWxsIHNoYXJlKCkgb24gdGhlXG4gICAgICAgIC8vIE9ic2VydmFibGUgcmV0dXJuZWQgYnkgaHR0cC5nZXQoKSBzbyB0aGF0IG11bHRpcGxlIHN1YnNjcmliZXJzIGRvbid0IGNhdXNlIG11bHRpcGxlIFhIUnMuXG4gICAgICAgIGlmICh0aGlzLl9pblByb2dyZXNzVXJsRmV0Y2hlcy5oYXModXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luUHJvZ3Jlc3NVcmxGZXRjaGVzLmdldCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiBmb3Igc29tZSByZWFzb24sIHRoZSBgZmluYWxseWAgb3BlcmF0b3IgXCJsb3Nlc1wiIHRoZSBnZW5lcmljIHR5cGUgb24gdGhlXG4gICAgICAgIC8vIE9ic2VydmFibGUuIEZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuXG4gICAgICAgIHZhciByZXEgPSB0aGlzLl9odHRwLmdldCh1cmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UudGV4dCgpOyB9KVxuICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2luUHJvZ3Jlc3NVcmxGZXRjaGVzLmRlbGV0ZSh1cmwpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNoYXJlKCk7XG4gICAgICAgIHRoaXMuX2luUHJvZ3Jlc3NVcmxGZXRjaGVzLnNldCh1cmwsIHJlcSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfTtcbiAgICBNZEljb25SZWdpc3RyeSA9IF9fZGVjb3JhdGUkNDcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2h0dHAuSHR0cCwgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRvbVNhbml0aXplcl0pXG4gICAgXSwgTWRJY29uUmVnaXN0cnkpO1xuICAgIHJldHVybiBNZEljb25SZWdpc3RyeTtcbn0oKSk7XG4vKiogQ2xvbmVzIGFuIFNWR0VsZW1lbnQgd2hpbGUgcHJlc2VydmluZyB0eXBlIGluZm9ybWF0aW9uLiAqL1xuZnVuY3Rpb24gY2xvbmVTdmcoc3ZnKSB7XG4gICAgcmV0dXJuIHN2Zy5jbG9uZU5vZGUodHJ1ZSk7XG59XG5cbnZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkNDYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYW4gaW52YWxpZCBpY29uIG5hbWUgaXMgcGFzc2VkIHRvIGFuIG1kLWljb24gY29tcG9uZW50LiAqL1xudmFyIE1kSWNvbkludmFsaWROYW1lRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMihNZEljb25JbnZhbGlkTmFtZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSWNvbkludmFsaWROYW1lRXJyb3IoaWNvbk5hbWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbnZhbGlkIGljb24gbmFtZTogXFxcIlwiICsgaWNvbk5hbWUgKyBcIlxcXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25JbnZhbGlkTmFtZUVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIENvbXBvbmVudCB0byBkaXNwbGF5IGFuIGljb24uIEl0IGNhbiBiZSB1c2VkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gU3BlY2lmeSB0aGUgc3ZnU3JjIGlucHV0IHRvIGxvYWQgYW4gU1ZHIGljb24gZnJvbSBhIFVSTC4gVGhlIFNWRyBjb250ZW50IGlzIGRpcmVjdGx5IGlubGluZWRcbiAqICAgYXMgYSBjaGlsZCBvZiB0aGUgPG1kLWljb24+IGNvbXBvbmVudCwgc28gdGhhdCBDU1Mgc3R5bGVzIGNhbiBlYXNpbHkgYmUgYXBwbGllZCB0byBpdC5cbiAqICAgVGhlIFVSTCBpcyBsb2FkZWQgdmlhIGFuIFhNTEh0dHBSZXF1ZXN0LCBzbyBpdCBtdXN0IGJlIG9uIHRoZSBzYW1lIGRvbWFpbiBhcyB0aGUgcGFnZSBvciBpdHNcbiAqICAgc2VydmVyIG11c3QgYmUgY29uZmlndXJlZCB0byBhbGxvdyBjcm9zcy1kb21haW4gcmVxdWVzdHMuXG4gKiAgIEV4YW1wbGU6XG4gKiAgICAgPG1kLWljb24gc3ZnU3JjPVwiYXNzZXRzL2Fycm93LnN2Z1wiPjwvbWQtaWNvbj5cbiAqXG4gKiAtIFNwZWNpZnkgdGhlIHN2Z0ljb24gaW5wdXQgdG8gbG9hZCBhbiBTVkcgaWNvbiBmcm9tIGEgVVJMIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIHRoZVxuICogICBhZGRTdmdJY29uLCBhZGRTdmdJY29uSW5OYW1lc3BhY2UsIGFkZFN2Z0ljb25TZXQsIG9yIGFkZFN2Z0ljb25TZXRJbk5hbWVzcGFjZSBtZXRob2RzIG9mXG4gKiAgIE1kSWNvblJlZ2lzdHJ5LiBJZiB0aGUgc3ZnSWNvbiB2YWx1ZSBjb250YWlucyBhIGNvbG9uIGl0IGlzIGFzc3VtZWQgdG8gYmUgaW4gdGhlIGZvcm1hdFxuICogICBcIltuYW1lc3BhY2VdOltuYW1lXVwiLCBpZiBub3QgdGhlIHZhbHVlIHdpbGwgYmUgdGhlIG5hbWUgb2YgYW4gaWNvbiBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuXG4gKiAgIEV4YW1wbGVzOlxuICogICAgIDxtZC1pY29uIHN2Z0ljb249XCJsZWZ0LWFycm93XCI+PC9tZC1pY29uPlxuICogICAgIDxtZC1pY29uIHN2Z0ljb249XCJhbmltYWxzOmNhdFwiPjwvbWQtaWNvbj5cbiAqXG4gKiAtIFVzZSBhIGZvbnQgbGlnYXR1cmUgYXMgYW4gaWNvbiBieSBwdXR0aW5nIHRoZSBsaWdhdHVyZSB0ZXh0IGluIHRoZSBjb250ZW50IG9mIHRoZSA8bWQtaWNvbj5cbiAqICAgY29tcG9uZW50LiBCeSBkZWZhdWx0IHRoZSBNYXRlcmlhbCBpY29ucyBmb250IGlzIHVzZWQgYXMgZGVzY3JpYmVkIGF0XG4gKiAgIGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29ucy8jaWNvbi1mb250LWZvci10aGUtd2ViLiBZb3UgY2FuIHNwZWNpZnkgYW5cbiAqICAgYWx0ZXJuYXRlIGZvbnQgYnkgc2V0dGluZyB0aGUgZm9udFNldCBpbnB1dCB0byBlaXRoZXIgdGhlIENTUyBjbGFzcyB0byBhcHBseSB0byB1c2UgdGhlXG4gKiAgIGRlc2lyZWQgZm9udCwgb3IgdG8gYW4gYWxpYXMgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggTWRJY29uUmVnaXN0cnkucmVnaXN0ZXJGb250Q2xhc3NBbGlhcy5cbiAqICAgRXhhbXBsZXM6XG4gKiAgICAgPG1kLWljb24+aG9tZTwvbWQtaWNvbj5cbiAqICAgICA8bWQtaWNvbiBmb250U2V0PVwibXlmb250XCI+c3VuPC9tZC1pY29uPlxuICpcbiAqIC0gU3BlY2lmeSBhIGZvbnQgZ2x5cGggdG8gYmUgaW5jbHVkZWQgdmlhIENTUyBydWxlcyBieSBzZXR0aW5nIHRoZSBmb250U2V0IGlucHV0IHRvIHNwZWNpZnkgdGhlXG4gKiAgIGZvbnQsIGFuZCB0aGUgZm9udEljb24gaW5wdXQgdG8gc3BlY2lmeSB0aGUgaWNvbi4gVHlwaWNhbGx5IHRoZSBmb250SWNvbiB3aWxsIHNwZWNpZnkgYVxuICogICBDU1MgY2xhc3Mgd2hpY2ggY2F1c2VzIHRoZSBnbHlwaCB0byBiZSBkaXNwbGF5ZWQgdmlhIGEgOmJlZm9yZSBzZWxlY3RvciwgYXMgaW5cbiAqICAgaHR0cHM6Ly9mb3J0YXdlc29tZS5naXRodWIuaW8vRm9udC1Bd2Vzb21lL2V4YW1wbGVzL1xuICogICBFeGFtcGxlOlxuICogICAgIDxtZC1pY29uIGZvbnRTZXQ9XCJmYVwiIGZvbnRJY29uPVwiYWxhcm1cIj48L21kLWljb24+XG4gKi9cbnZhciBNZEljb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSWNvbihfZWxlbWVudFJlZiwgX3JlbmRlcmVyLCBfbWRJY29uUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fbWRJY29uUmVnaXN0cnkgPSBfbWRJY29uUmVnaXN0cnk7XG4gICAgICAgIC8qKiBTY3JlZW5yZWFkZXIgbGFiZWwgZm9yIHRoZSBpY29uLiAqL1xuICAgICAgICB0aGlzLmhvc3RBcmlhTGFiZWwgPSAnJztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSWNvbi5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKiogQ29sb3Igb2YgdGhlIGljb24uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sb3I7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRJY29uLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICBNZEljb24ucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1hdC1cIiArIGNvbG9yLCBpc0FkZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhbiBzdmdJY29uIGJpbmRpbmcgdmFsdWUgaW50byBpdHMgaWNvbiBzZXQgYW5kIGljb24gbmFtZSBjb21wb25lbnRzLlxuICAgICAqIFJldHVybnMgYSAyLWVsZW1lbnQgYXJyYXkgb2YgWyhpY29uIHNldCksIChpY29uIG5hbWUpXS5cbiAgICAgKiBUaGUgc2VwYXJhdG9yIGZvciB0aGUgdHdvIGZpZWxkcyBpcyAnOicuIElmIHRoZXJlIGlzIG5vIHNlcGFyYXRvciwgYW4gZW1wdHlcbiAgICAgKiBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIHRoZSBpY29uIHNldCBhbmQgdGhlIGVudGlyZSB2YWx1ZSBpcyByZXR1cm5lZCBmb3JcbiAgICAgKiB0aGUgaWNvbiBuYW1lLiBJZiB0aGUgYXJndW1lbnQgaXMgZmFsc3ksIHJldHVybnMgYW4gYXJyYXkgb2YgdHdvIGVtcHR5IHN0cmluZ3MuXG4gICAgICogVGhyb3dzIGEgTWRJY29uSW52YWxpZE5hbWVFcnJvciBpZiB0aGUgbmFtZSBjb250YWlucyB0d28gb3IgbW9yZSAnOicgc2VwYXJhdG9ycy5cbiAgICAgKiBFeGFtcGxlczpcbiAgICAgKiAgICdzb2NpYWw6Y2FrZScgLT4gWydzb2NpYWwnLCAnY2FrZSddXG4gICAgICogICAncGVuZ3VpbicgLT4gWycnLCAncGVuZ3VpbiddXG4gICAgICogICBudWxsIC0+IFsnJywgJyddXG4gICAgICogICAnYTpiOmMnIC0+ICh0aHJvd3MgTWRJY29uSW52YWxpZE5hbWVFcnJvcilcbiAgICAgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLl9zcGxpdEljb25OYW1lID0gZnVuY3Rpb24gKGljb25OYW1lKSB7XG4gICAgICAgIGlmICghaWNvbk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbJycsICcnXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFydHMgPSBpY29uTmFtZS5zcGxpdCgnOicpO1xuICAgICAgICBzd2l0Y2ggKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIFVzZSBkZWZhdWx0IG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gWycnLCBwYXJ0c1swXV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWRJY29uSW52YWxpZE5hbWVFcnJvcihpY29uTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hhbmdlZElucHV0cyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpO1xuICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgaW5saW5lIFNWRyBpY29uIGlmIHRoZSBpbnB1dHMgY2hhbmdlZCwgdG8gYXZvaWQgdW5uZWNlc3NhcnkgRE9NIG9wZXJhdGlvbnMuXG4gICAgICAgIGlmIChjaGFuZ2VkSW5wdXRzLmluZGV4T2YoJ3N2Z0ljb24nKSAhPSAtMSB8fCBjaGFuZ2VkSW5wdXRzLmluZGV4T2YoJ3N2Z1NyYycpICE9IC0xKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdmdJY29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5fc3BsaXRJY29uTmFtZSh0aGlzLnN2Z0ljb24pLCBuYW1lc3BhY2UgPSBfYVswXSwgaWNvbk5hbWUgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZEljb25SZWdpc3RyeS5nZXROYW1lZFN2Z0ljb24oaWNvbk5hbWUsIG5hbWVzcGFjZSkuZmlyc3QoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gX3RoaXMuX3NldFN2Z0VsZW1lbnQoc3ZnKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY29uc29sZS5sb2coXCJFcnJvciByZXRyaWV2aW5nIGljb246IFwiICsgZXJyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9udEljb25DbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQXJpYUxhYmVsKCk7XG4gICAgfTtcbiAgICBNZEljb24ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVcGRhdGUgZm9udCBjbGFzc2VzIGJlY2F1c2UgbmdPbkNoYW5nZXMgd29uJ3QgYmUgY2FsbGVkIGlmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgcHJlc2VudCxcbiAgICAgICAgLy8gZS5nLiA8bWQtaWNvbj5hcnJvdzwvbWQtaWNvbj4uIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGFkZCBhIENTUyBjbGFzcyBmb3IgdGhlIGRlZmF1bHQgZm9udC5cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9udEljb25DbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVcGRhdGUgYXJpYSBsYWJlbCBoZXJlIGJlY2F1c2UgaXQgbWF5IGRlcGVuZCBvbiB0aGUgcHJvamVjdGVkIHRleHQgY29udGVudC5cbiAgICAgICAgLy8gKGUuZy4gPG1kLWljb24+aG9tZTwvbWQtaWNvbj4gc2hvdWxkIHVzZSAnaG9tZScpLlxuICAgICAgICB0aGlzLl91cGRhdGVBcmlhTGFiZWwoKTtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3VwZGF0ZUFyaWFMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyaWFMYWJlbCA9IHRoaXMuX2dldEFyaWFMYWJlbCgpO1xuICAgICAgICBpZiAoYXJpYUxhYmVsICYmIGFyaWFMYWJlbCAhPT0gdGhpcy5fcHJldmlvdXNBcmlhTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzQXJpYUxhYmVsID0gYXJpYUxhYmVsO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWxhYmVsJywgYXJpYUxhYmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRJY29uLnByb3RvdHlwZS5fZ2V0QXJpYUxhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IHByb3ZpZGVkIGFuIGFyaWEtbGFiZWwgYXR0cmlidXRlIHZhbHVlLCB1c2UgaXQgYXMtaXMuIE90aGVyd2lzZSBsb29rIGZvciBhXG4gICAgICAgIC8vIHJlYXNvbmFibGUgdmFsdWUgZnJvbSB0aGUgYWx0IGF0dHJpYnV0ZSwgZm9udCBpY29uIG5hbWUsIFNWRyBpY29uIG5hbWUsIG9yIChmb3IgbGlnYXR1cmVzKVxuICAgICAgICAvLyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBkaXJlY3RpdmUuXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuaG9zdEFyaWFMYWJlbCB8fFxuICAgICAgICAgICAgdGhpcy5hbHQgfHxcbiAgICAgICAgICAgIHRoaXMuZm9udEljb24gfHxcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0SWNvbk5hbWUodGhpcy5zdmdJY29uKVsxXTtcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIFwiY29udGVudFwiIG9mIGFuIFNWRyBpY29uIGlzIG5vdCBhIHVzZWZ1bCBsYWJlbC5cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFdhcm4gaGVyZSBpbiBkZXYgbW9kZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBNZEljb24ucHJvdG90eXBlLl91c2luZ0ZvbnRJY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc3ZnSWNvbjtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3NldFN2Z0VsZW1lbnQgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgICAgIHZhciBsYXlvdXRFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgY2hpbGQgbm9kZXMgYW5kIGFkZCB0aGUgbmV3IFNWRyBlbGVtZW50LlxuICAgICAgICAvLyBXZSB3b3VsZCB1c2UgcmVuZGVyZXIuZGV0YWNoVmlldyhBcnJheS5mcm9tKGxheW91dEVsZW1lbnQuY2hpbGROb2RlcykpIGhlcmUsXG4gICAgICAgIC8vIGJ1dCBpdCBmYWlscyBpbiBJRTExOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82MzI3XG4gICAgICAgIGxheW91dEVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnByb2plY3ROb2RlcyhsYXlvdXRFbGVtZW50LCBbc3ZnXSk7XG4gICAgfTtcbiAgICBNZEljb24ucHJvdG90eXBlLl91cGRhdGVGb250SWNvbkNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHZhciBmb250U2V0Q2xhc3MgPSB0aGlzLmZvbnRTZXQgP1xuICAgICAgICAgICAgdGhpcy5fbWRJY29uUmVnaXN0cnkuY2xhc3NOYW1lRm9yRm9udEFsaWFzKHRoaXMuZm9udFNldCkgOlxuICAgICAgICAgICAgdGhpcy5fbWRJY29uUmVnaXN0cnkuZ2V0RGVmYXVsdEZvbnRTZXRDbGFzcygpO1xuICAgICAgICBpZiAoZm9udFNldENsYXNzICE9IHRoaXMuX3ByZXZpb3VzRm9udFNldENsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNGb250U2V0Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbSwgdGhpcy5fcHJldmlvdXNGb250U2V0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb250U2V0Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbSwgZm9udFNldENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRm9udFNldENsYXNzID0gZm9udFNldENsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvbnRJY29uICE9IHRoaXMuX3ByZXZpb3VzRm9udEljb25DbGFzcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzRm9udEljb25DbGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtLCB0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZvbnRJY29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW0sIHRoaXMuZm9udEljb24sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNGb250SWNvbkNsYXNzID0gdGhpcy5mb250SWNvbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSWNvbi5wcm90b3R5cGUsIFwic3ZnSWNvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEljb24ucHJvdG90eXBlLCBcImZvbnRTZXRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJY29uLnByb3RvdHlwZSwgXCJmb250SWNvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEljb24ucHJvdG90eXBlLCBcImFsdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLWxhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEljb24ucHJvdG90eXBlLCBcImhvc3RBcmlhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJY29uLnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBNZEljb24gPSBfX2RlY29yYXRlJDQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3RlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWljb24sIG1hdC1pY29uJyxcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1pY29ue2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtkaXNwbGF5OmlubGluZS1ibG9jaztmaWxsOmN1cnJlbnRDb2xvcjtoZWlnaHQ6MjRweDt3aWR0aDoyNHB4fVwiXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdpbWcnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWljb25dJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBNZEljb25SZWdpc3RyeV0pXG4gICAgXSwgTWRJY29uKTtcbiAgICByZXR1cm4gTWRJY29uO1xufSgpKTtcbmZ1bmN0aW9uIElDT05fUkVHSVNUUllfUFJPVklERVJfRkFDVE9SWShwYXJlbnRSZWdpc3RyeSwgaHR0cCwgc2FuaXRpemVyKSB7XG4gICAgcmV0dXJuIHBhcmVudFJlZ2lzdHJ5IHx8IG5ldyBNZEljb25SZWdpc3RyeShodHRwLCBzYW5pdGl6ZXIpO1xufVxuXG52YXIgSUNPTl9SRUdJU1RSWV9QUk9WSURFUiA9IHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIE1kSWNvblJlZ2lzdHJ5IGF2YWlsYWJsZSwgdXNlIHRoYXQuIE90aGVyd2lzZSwgcHJvdmlkZSBhIG5ldyBvbmUuXG4gICAgcHJvdmlkZTogTWRJY29uUmVnaXN0cnksXG4gICAgZGVwczogW1tuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZigpLCBNZEljb25SZWdpc3RyeV0sIF9hbmd1bGFyX2h0dHAuSHR0cCwgX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkRvbVNhbml0aXplcl0sXG4gICAgdXNlRmFjdG9yeTogSUNPTl9SRUdJU1RSWV9QUk9WSURFUl9GQUNUT1JZLFxufTtcbnZhciBNZEljb25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSWNvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRJY29uTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRJY29uTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kSWNvbk1vZHVsZSA9IF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9odHRwLkh0dHBNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kSWNvbiwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZEljb25dLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbSUNPTl9SRUdJU1RSWV9QUk9WSURFUl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEljb25Nb2R1bGUpO1xuICAgIHJldHVybiBNZEljb25Nb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDE0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDQ4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBCZW5jaHByZXNzIHRlc3RzLlxuLyoqIEEgc2luZ2xlIGRlZ3JlZSBpbiByYWRpYW5zLiAqL1xudmFyIERFR1JFRV9JTl9SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcbi8qKiBEdXJhdGlvbiBvZiB0aGUgaW5kZXRlcm1pbmF0ZSBhbmltYXRpb24uICovXG52YXIgRFVSQVRJT05fSU5ERVRFUk1JTkFURSA9IDY2Nztcbi8qKiBEdXJhdGlvbiBvZiB0aGUgaW5kZXRlcm1pbmF0ZSBhbmltYXRpb24uICovXG52YXIgRFVSQVRJT05fREVURVJNSU5BVEUgPSAyMjU7XG4vKiogU3RhcnQgYW5pbWF0aW9uIHZhbHVlIG9mIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbiAqL1xudmFyIHN0YXJ0SW5kZXRlcm1pbmF0ZSA9IDM7XG4vKiogRW5kIGFuaW1hdGlvbiB2YWx1ZSBvZiB0aGUgaW5kZXRlcm1pbmF0ZSBhbmltYXRpb24gKi9cbnZhciBlbmRJbmRldGVybWluYXRlID0gODA7XG4vKiBNYXhpbXVtIGFuZ2xlIGZvciB0aGUgYXJjLiBUaGUgYW5nbGUgY2FuJ3QgYmUgZXhhY3RseSAzNjAsIGJlY2F1c2UgdGhlIGFyYyBiZWNvbWVzIGhpZGRlbi4gKi9cbnZhciBNQVhfQU5HTEUgPSAzNTkuOTkgLyAxMDA7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyKCkge1xuICAgIH1cbiAgICBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLXByb2dyZXNzLXNwaW5uZXIsIG1hdC1wcm9ncmVzcy1zcGlubmVyJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wcm9ncmVzcy1zcGlubmVyXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIpO1xuICAgIHJldHVybiBNZFByb2dyZXNzU3Bpbm5lckNzc01hdFN0eWxlcjtcbn0oKSk7XG4vKipcbiAqIERpcmVjdGl2ZSB3aG9zZSBwdXJwb3NlIGlzIHRvIGFkZCB0aGUgbWF0LSBDU1Mgc3R5bGluZyB0byB0aGlzIHNlbGVjdG9yLlxuICovXG52YXIgTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlcigpIHtcbiAgICB9XG4gICAgTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlciA9IF9fZGVjb3JhdGUkNDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLXByb2dyZXNzLWNpcmNsZSwgbWF0LXByb2dyZXNzLWNpcmNsZScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHJvZ3Jlc3MtY2lyY2xlXSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlcik7XG4gICAgcmV0dXJuIE1kUHJvZ3Jlc3NDaXJjbGVDc3NNYXRTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiA8bWQtcHJvZ3Jlc3Mtc3Bpbm5lcj4gY29tcG9uZW50LlxuICovXG52YXIgTWRQcm9ncmVzc1NwaW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUHJvZ3Jlc3NTcGlubmVyKF9uZ1pvbmUsIF9lbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgLyoqIFRoZSBpZCBvZiB0aGUgbGFzdCByZXF1ZXN0ZWQgYW5pbWF0aW9uLiAqL1xuICAgICAgICB0aGlzLl9sYXN0QW5pbWF0aW9uSWQgPSAwO1xuICAgICAgICB0aGlzLl9tb2RlID0gJ2RldGVybWluYXRlJztcbiAgICAgICAgdGhpcy5fY29sb3IgPSAncHJpbWFyeSc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUsIFwiX2FyaWFWYWx1ZU1pblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZXMgZm9yIGFyaWEgbWF4IGFuZCBtaW4gYXJlIG9ubHkgZGVmaW5lZCBhcyBudW1iZXJzIHdoZW4gaW4gYSBkZXRlcm1pbmF0ZSBtb2RlLiAgV2UgZG8gdGhpc1xuICAgICAgICAgKiBiZWNhdXNlIHZvaWNlb3ZlciBkb2VzIG5vdCByZXBvcnQgdGhlIHByb2dyZXNzIGluZGljYXRvciBhcyBpbmRldGVybWluYXRlIGlmIHRoZSBhcmlhIG1pblxuICAgICAgICAgKiBhbmQvb3IgbWF4IHZhbHVlIGFyZSBudW1iZXIgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScgPyAwIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJfYXJpYVZhbHVlTWF4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScgPyAxMDAgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcImludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbFwiLCB7XG4gICAgICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJkZXRlcm1pbmF0ZUludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBhbnkgYW5pbWF0aW9ucyB0aGF0IHdlcmUgcnVubmluZy5cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXBJbmRldGVybWluYXRlQW5pbWF0aW9uKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgcHJvZ3Jlc3Mtc3Bpbm5lci4gQ2FuIGJlIHByaW1hcnksIGFjY2VudCwgb3Igd2Fybi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xvcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBWYWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlLiBJdCBpcyBib3VuZCB0byB0aGUgaG9zdCBhcyB0aGUgYXR0cmlidXRlIGFyaWEtdmFsdWVub3cuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodiAhPSBudWxsICYmIHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY2xhbXAodik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUNpcmNsZSgodGhpcy52YWx1ZSB8fCAwKSwgbmV3VmFsdWUsIGxpbmVhckVhc2UsIERVUkFUSU9OX0RFVEVSTUlOQVRFLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLCBcIm1vZGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlXG4gICAgICAgICAqXG4gICAgICAgICAqIElucHV0IG11c3QgYmUgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSBQcm9ncmVzc01vZGUsIGRlZmF1bHRzIHRvICdkZXRlcm1pbmF0ZScuXG4gICAgICAgICAqIG1vZGUgaXMgYm91bmQgdG8gdGhlIGhvc3QgYXMgdGhlIGF0dHJpYnV0ZSBob3N0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgaWYgKG0gPT0gJ2luZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRJbmRldGVybWluYXRlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwSW5kZXRlcm1pbmF0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBjaXJjbGUgZnJvbSBvbmUgcGVyY2VudGFnZSB2YWx1ZSB0byBhbm90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFuaW1hdGVGcm9tIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaXJjbGUgZmlsbGVkIHN0YXJ0aW5nIHRoZSBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIGFuaW1hdGVUbyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2lyY2xlIGZpbGxlZCBlbmRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gZWFzZSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIG1hbmFnZSB0aGUgcGFjZSBvZiBjaGFuZ2UgaW4gdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGxlbmd0aCBvZiB0aW1lIHRvIHNob3cgdGhlIGFuaW1hdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSByb3RhdGlvbiBUaGUgc3RhcnRpbmcgYW5nbGUgb2YgdGhlIGNpcmNsZSBmaWxsLCB3aXRoIDDCsCByZXByZXNlbnRlZCBhdCB0aGUgdG9wIGNlbnRlclxuICAgICAqICAgIG9mIHRoZSBjaXJjbGUuXG4gICAgICovXG4gICAgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9hbmltYXRlQ2lyY2xlID0gZnVuY3Rpb24gKGFuaW1hdGVGcm9tLCBhbmltYXRlVG8sIGVhc2UsIGR1cmF0aW9uLCByb3RhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWQgPSArK3RoaXMuX2xhc3RBbmltYXRpb25JZDtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBjaGFuZ2VJblZhbHVlID0gYW5pbWF0ZVRvIC0gYW5pbWF0ZUZyb207XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gYW5pbWF0ZSBpdCBpZiB0aGUgdmFsdWVzIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAoYW5pbWF0ZVRvID09PSBhbmltYXRlRnJvbSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQXJjKGFuaW1hdGVUbywgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGFwc2VkVGltZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKERhdGUubm93KCkgLSBzdGFydFRpbWUsIGR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlckFyYyhlYXNlKGVsYXBzZWRUaW1lLCBhbmltYXRlRnJvbSwgY2hhbmdlSW5WYWx1ZSwgZHVyYXRpb24pLCByb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBhbmltYXRpb25zIGJ5IGNoZWNraW5nIGlmIGEgbmV3IGFuaW1hdGlvbiBoYXMgYmVlbiBjYWxsZWQgZm9yIGFuZFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGxhc3RlZCBsb25nZXIgdGhhbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gX3RoaXMuX2xhc3RBbmltYXRpb25JZCAmJiBlbGFwc2VkVGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25fMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgYW5pbWF0aW9uIG91dHNpZGUgb2YgQW5ndWxhcidzIHpvbmUsIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBoaXR0aW5nIFpvbmVKUyBhbmQgY2hhbmdlIGRldGVjdGlvbiBvbiBlYWNoIGZyYW1lLlxuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGFuaW1hdGlvbl8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBpbmRldGVybWluYXRlIGFuaW1hdGlvbiBpbnRlcnZhbCwgaWYgaXQgaXMgbm90IGFscmVhZHkgcnVubmluZy5cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX3N0YXJ0SW5kZXRlcm1pbmF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJvdGF0aW9uU3RhcnRQb2ludCA9IDA7XG4gICAgICAgIHZhciBzdGFydCA9IHN0YXJ0SW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgdmFyIGVuZCA9IGVuZEluZGV0ZXJtaW5hdGU7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IERVUkFUSU9OX0lOREVURVJNSU5BVEU7XG4gICAgICAgIHZhciBhbmltYXRlJCQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGVDaXJjbGUoc3RhcnQsIGVuZCwgbWF0ZXJpYWxFYXNlLCBkdXJhdGlvbiwgcm90YXRpb25TdGFydFBvaW50KTtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgcm90YXRpb24gZnJvbSByZWFjaGluZyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUi5cbiAgICAgICAgICAgIHJvdGF0aW9uU3RhcnRQb2ludCA9IChyb3RhdGlvblN0YXJ0UG9pbnQgKyBlbmQpICUgMTAwO1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ID0gLWVuZDtcbiAgICAgICAgICAgIGVuZCA9IC10ZW1wO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCA9IHNldEludGVydmFsKGFuaW1hdGUkJDEsIGR1cmF0aW9uICsgNTAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhbmltYXRlJCQxKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBpbnRlcnZhbCwgZW5kaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICovXG4gICAgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl9jbGVhbnVwSW5kZXRlcm1pbmF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwgPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgYXJjIG9udG8gdGhlIFNWRyBlbGVtZW50LiBQcm94aWVzIGBnZXRBcmNgIHdoaWxlIHNldHRpbmcgdGhlIHByb3BlclxuICAgICAqIERPTSBhdHRyaWJ1dGUgb24gdGhlIGA8cGF0aD5gLlxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZS5fcmVuZGVyQXJjID0gZnVuY3Rpb24gKGN1cnJlbnRWYWx1ZSwgcm90YXRpb24pIHtcbiAgICAgICAgLy8gQ2FjaGVzIHRoZSBwYXRoIHJlZmVyZW5jZSBzbyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUgbG9va2VkIHVwIGV2ZXJ5IHRpbWUuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aCA9IHRoaXMuX3BhdGggfHwgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3BhdGgnKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHBhdGggd2FzIGZvdW5kLiBUaGlzIG1heSBub3QgYmUgdGhlIGNhc2UgaWYgdGhlXG4gICAgICAgIC8vIGFuaW1hdGlvbiBmdW5jdGlvbiBmaXJlcyB0b28gZWFybHkuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIGdldFN2Z0FyYyhjdXJyZW50VmFsdWUsIHJvdGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbG9yIG9mIHRoZSBwcm9ncmVzcy1zcGlubmVyIGJ5IGFkZGluZyB0aGUgbmV3IHBhbGV0dGUgY2xhc3MgdG8gdGhlIGVsZW1lbnRcbiAgICAgKiBhbmQgcmVtb3ZpbmcgdGhlIG9sZCBvbmUuXG4gICAgICovXG4gICAgTWRQcm9ncmVzc1NwaW5uZXIucHJvdG90eXBlLl91cGRhdGVDb2xvciA9IGZ1bmN0aW9uIChuZXdDb2xvcikge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IodGhpcy5fY29sb3IsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKG5ld0NvbG9yLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdDb2xvcjtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHRoZSBnaXZlbiBwYWxldHRlIGNsYXNzIG9uIHRoZSBjb21wb25lbnQgZWxlbWVudC4gKi9cbiAgICBNZFByb2dyZXNzU3Bpbm5lci5wcm90b3R5cGUuX3NldEVsZW1lbnRDb2xvciA9IGZ1bmN0aW9uIChjb2xvciwgaXNBZGQpIHtcbiAgICAgICAgaWYgKGNvbG9yICE9IG51bGwgJiYgY29sb3IgIT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWF0LVwiICsgY29sb3IsIGlzQWRkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVub3cnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5tb2RlJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUHJvZ3Jlc3NTcGlubmVyLnByb3RvdHlwZSwgXCJtb2RlXCIsIG51bGwpO1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyID0gX19kZWNvcmF0ZSQ0OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXByb2dyZXNzLXNwaW5uZXIsIG1hdC1wcm9ncmVzcy1zcGlubmVyLCBtZC1wcm9ncmVzcy1jaXJjbGUsIG1hdC1wcm9ncmVzcy1jaXJjbGUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnX2FyaWFWYWx1ZU1pbicsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ19hcmlhVmFsdWVNYXgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+PHBhdGg+PC9wYXRoPjwvc3ZnPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrO2hlaWdodDoxMDBweDt3aWR0aDoxMDBweDtvdmVyZmxvdzpoaWRkZW59Omhvc3Qgc3Zne2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXJ9Omhvc3QgcGF0aHtmaWxsOnRyYW5zcGFyZW50O3N0cm9rZS13aWR0aDoxMHB4fTpob3N0W21vZGU9aW5kZXRlcm1pbmF0ZV0gc3Zne2FuaW1hdGlvbi1kdXJhdGlvbjo1LjI1cywyLjg4N3M7YW5pbWF0aW9uLW5hbWU6bWF0LXByb2dyZXNzLXNwaW5uZXItc3BvcmFkaWMtcm90YXRlLG1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGU7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpLGxpbmVhcjthbmltYXRpb24taXRlcmF0aW9uLWNvdW50OmluZmluaXRlO3RyYW5zaXRpb246bm9uZX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLWxpbmVhci1yb3RhdGV7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zcG9yYWRpYy1yb3RhdGV7MTIuNSV7dHJhbnNmb3JtOnJvdGF0ZSgxMzVkZWcpfTI1JXt0cmFuc2Zvcm06cm90YXRlKDI3MGRlZyl9MzcuNSV7dHJhbnNmb3JtOnJvdGF0ZSg0MDVkZWcpfTUwJXt0cmFuc2Zvcm06cm90YXRlKDU0MGRlZyl9NjIuNSV7dHJhbnNmb3JtOnJvdGF0ZSg2NzVkZWcpfTc1JXt0cmFuc2Zvcm06cm90YXRlKDgxMGRlZyl9ODcuNSV7dHJhbnNmb3JtOnJvdGF0ZSg5NDVkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgxMDgwZGVnKX19XCJdLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ4KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLk5nWm9uZSwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFByb2dyZXNzU3Bpbm5lcik7XG4gICAgcmV0dXJuIE1kUHJvZ3Jlc3NTcGlubmVyO1xufSgpKTtcbi8qKlxuICogPG1kLXNwaW5uZXI+IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIGEgY29tcG9uZW50IGRlZmluaXRpb24gdG8gYmUgdXNlZCBhcyBhIGNvbnZlbmllbmNlIHJlZmVyZW5jZSB0byBjcmVhdGUgYW5cbiAqIGluZGV0ZXJtaW5hdGUgPG1kLXByb2dyZXNzLXNwaW5uZXI+IGluc3RhbmNlLlxuICovXG52YXIgTWRTcGlubmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTQoTWRTcGlubmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kU3Bpbm5lcihlbGVtZW50UmVmLCBuZ1pvbmUsIHJlbmRlcmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG5nWm9uZSwgZWxlbWVudFJlZiwgcmVuZGVyZXIpO1xuICAgICAgICB0aGlzLm1vZGUgPSAnaW5kZXRlcm1pbmF0ZSc7XG4gICAgfVxuICAgIE1kU3Bpbm5lci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZSBgbmdPbkRlc3Ryb3lgIGZyb20gYE1kUHJvZ3Jlc3NTcGlubmVyYCBzaG91bGQgYmUgY2FsbGVkIGV4cGxpY2l0bHksIGJlY2F1c2VcbiAgICAgICAgLy8gaW4gY2VydGFpbiBjYXNlcyBBbmd1bGFyIHdvbid0IGNhbGwgaXQgKGUuZy4gd2hlbiB1c2luZyBBb1QgYW5kIGluIHVuaXQgdGVzdHMpLlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25EZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBNZFNwaW5uZXIgPSBfX2RlY29yYXRlJDQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtc3Bpbm5lciwgbWF0LXNwaW5uZXInLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAnbW9kZSc6ICdpbmRldGVybWluYXRlJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1zcGlubmVyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3ZnIHZpZXdCb3g9XFxcIjAgMCAxMDAgMTAwXFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWlkWU1pZCBtZWV0XFxcIj48cGF0aD48L3BhdGg+PC9zdmc+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjEwMHB4O3dpZHRoOjEwMHB4O292ZXJmbG93OmhpZGRlbn06aG9zdCBzdmd7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlcn06aG9zdCBwYXRoe2ZpbGw6dHJhbnNwYXJlbnQ7c3Ryb2tlLXdpZHRoOjEwcHh9Omhvc3RbbW9kZT1pbmRldGVybWluYXRlXSBzdmd7YW5pbWF0aW9uLWR1cmF0aW9uOjUuMjVzLDIuODg3czthbmltYXRpb24tbmFtZTptYXQtcHJvZ3Jlc3Mtc3Bpbm5lci1zcG9yYWRpYy1yb3RhdGUsbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMzUsMCwuMjUsMSksbGluZWFyO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6aW5maW5pdGU7dHJhbnNpdGlvbjpub25lfUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLXNwaW5uZXItbGluZWFyLXJvdGF0ZXswJXt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1zcGlubmVyLXNwb3JhZGljLXJvdGF0ZXsxMi41JXt0cmFuc2Zvcm06cm90YXRlKDEzNWRlZyl9MjUle3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX0zNy41JXt0cmFuc2Zvcm06cm90YXRlKDQwNWRlZyl9NTAle3RyYW5zZm9ybTpyb3RhdGUoNTQwZGVnKX02Mi41JXt0cmFuc2Zvcm06cm90YXRlKDY3NWRlZyl9NzUle3RyYW5zZm9ybTpyb3RhdGUoODEwZGVnKX04Ny41JXt0cmFuc2Zvcm06cm90YXRlKDk0NWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDEwODBkZWcpfX1cIl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLk5nWm9uZSwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlcl0pXG4gICAgXSwgTWRTcGlubmVyKTtcbiAgICByZXR1cm4gTWRTcGlubmVyO1xufShNZFByb2dyZXNzU3Bpbm5lcikpO1xuLyoqXG4gKiBNb2R1bGUgZnVuY3Rpb25zLlxuICovXG4vKiogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiAwIGFuZCAxMDAuICovXG5mdW5jdGlvbiBjbGFtcCh2KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgdikpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBQb2xhciBjb29yZGluYXRlcyB0byBDYXJ0ZXNpYW4uXG4gKi9cbmZ1bmN0aW9uIHBvbGFyVG9DYXJ0ZXNpYW4ocmFkaXVzLCBwYXRoUmFkaXVzLCBhbmdsZUluRGVncmVlcykge1xuICAgIHZhciBhbmdsZUluUmFkaWFucyA9IChhbmdsZUluRGVncmVlcyAtIDkwKSAqIERFR1JFRV9JTl9SQURJQU5TO1xuICAgIHJldHVybiAocmFkaXVzICsgKHBhdGhSYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucykpKSArXG4gICAgICAgICcsJyArIChyYWRpdXMgKyAocGF0aFJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSkpO1xufVxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb24gZm9yIGxpbmVhciBhbmltYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGxpbmVhckVhc2UoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGNoYW5nZUluVmFsdWUgKiBjdXJyZW50VGltZSAvIGR1cmF0aW9uICsgc3RhcnRWYWx1ZTtcbn1cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9uIHRvIG1hdGNoIG1hdGVyaWFsIGRlc2lnbiBpbmRldGVybWluYXRlIGFuaW1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0ZXJpYWxFYXNlKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBjaGFuZ2VJblZhbHVlLCBkdXJhdGlvbikge1xuICAgIHZhciB0aW1lID0gY3VycmVudFRpbWUgLyBkdXJhdGlvbjtcbiAgICB2YXIgdGltZUN1YmVkID0gTWF0aC5wb3codGltZSwgMyk7XG4gICAgdmFyIHRpbWVRdWFkID0gTWF0aC5wb3codGltZSwgNCk7XG4gICAgdmFyIHRpbWVRdWludCA9IE1hdGgucG93KHRpbWUsIDUpO1xuICAgIHJldHVybiBzdGFydFZhbHVlICsgY2hhbmdlSW5WYWx1ZSAqICgoNiAqIHRpbWVRdWludCkgKyAoLTE1ICogdGltZVF1YWQpICsgKDEwICogdGltZUN1YmVkKSk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHBhdGggdmFsdWUgdG8gZGVmaW5lIHRoZSBhcmMuICBDb252ZXJ0aW5nIHBlcmNlbnRhZ2UgdmFsdWVzIHRvIHRvIHBvbGFyXG4gKiBjb29yZGluYXRlcyBvbiB0aGUgY2lyY2xlLCBhbmQgdGhlbiB0byBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgaW4gdGhlIHZpZXdwb3J0LlxuICpcbiAqIEBwYXJhbSBjdXJyZW50VmFsdWUgVGhlIGN1cnJlbnQgcGVyY2VudGFnZSB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgY2lyY2xlLCB0aGUgcGVyY2VudGFnZSBvZiB0aGVcbiAqICAgIGNpcmNsZSB0byBmaWxsLlxuICogQHBhcmFtIHJvdGF0aW9uIFRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgY2lyY2xlIHdpdGggMCBiZWluZyB0aGUgMCBkZWdyZWUgcG9pbnQuXG4gKiBAcmV0dXJuIEEgc3RyaW5nIGZvciBhbiBTVkcgcGF0aCByZXByZXNlbnRpbmcgYSBjaXJjbGUgZmlsbGVkIGZyb20gdGhlIHN0YXJ0aW5nIHBvaW50IHRvIHRoZVxuICogICAgcGVyY2VudGFnZSB2YWx1ZSBwcm92aWRlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0U3ZnQXJjKGN1cnJlbnRWYWx1ZSwgcm90YXRpb24pIHtcbiAgICB2YXIgc3RhcnRQb2ludCA9IHJvdGF0aW9uIHx8IDA7XG4gICAgdmFyIHJhZGl1cyA9IDUwO1xuICAgIHZhciBwYXRoUmFkaXVzID0gNDA7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBzdGFydFBvaW50ICogTUFYX0FOR0xFO1xuICAgIHZhciBlbmRBbmdsZSA9IGN1cnJlbnRWYWx1ZSAqIE1BWF9BTkdMRTtcbiAgICB2YXIgc3RhcnQgPSBwb2xhclRvQ2FydGVzaWFuKHJhZGl1cywgcGF0aFJhZGl1cywgc3RhcnRBbmdsZSk7XG4gICAgdmFyIGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4ocmFkaXVzLCBwYXRoUmFkaXVzLCBlbmRBbmdsZSArIHN0YXJ0QW5nbGUpO1xuICAgIHZhciBhcmNTd2VlcCA9IGVuZEFuZ2xlIDwgMCA/IDAgOiAxO1xuICAgIHZhciBsYXJnZUFyY0ZsYWc7XG4gICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgICBsYXJnZUFyY0ZsYWcgPSBlbmRBbmdsZSA+PSAtMTgwID8gMCA6IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsYXJnZUFyY0ZsYWcgPSBlbmRBbmdsZSA8PSAxODAgPyAwIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIFwiTVwiICsgc3RhcnQgKyBcIkFcIiArIHBhdGhSYWRpdXMgKyBcIixcIiArIHBhdGhSYWRpdXMgKyBcIiAwIFwiICsgbGFyZ2VBcmNGbGFnICsgXCIsXCIgKyBhcmNTd2VlcCArIFwiIFwiICsgZW5kO1xufVxudmFyIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlID0gX19kZWNvcmF0ZSQ0OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW0NvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kUHJvZ3Jlc3NTcGlubmVyLFxuICAgICAgICAgICAgICAgIE1kU3Bpbm5lcixcbiAgICAgICAgICAgICAgICBDb21wYXRpYmlsaXR5TW9kdWxlLFxuICAgICAgICAgICAgICAgIE1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyLFxuICAgICAgICAgICAgICAgIE1kUHJvZ3Jlc3NDaXJjbGVDc3NNYXRTdHlsZXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBNZFByb2dyZXNzU3Bpbm5lcixcbiAgICAgICAgICAgICAgICBNZFNwaW5uZXIsXG4gICAgICAgICAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXIsXG4gICAgICAgICAgICAgICAgTWRQcm9ncmVzc0NpcmNsZUNzc01hdFN0eWxlclxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ4KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlKTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGU7XG59KCkpO1xuXG4vKiogQGRlcHJlY2F0ZWQgKi9cblxudmFyIF9fZGVjb3JhdGUkNDkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8vIFRPRE8oam9zZXBocGVycm90dCk6IEJlbmNocHJlc3MgdGVzdHMuXG4vLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBBZGQgQVJJQSBhdHRyaWJ1dGVzIGZvciBwcm9ncmVzc2JhciBcImZvclwiLlxuLyoqXG4gKiA8bWQtcHJvZ3Jlc3MtYmFyPiBjb21wb25lbnQuXG4gKi9cbnZhciBNZFByb2dyZXNzQmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzQmFyKCkge1xuICAgICAgICAvKiogQ29sb3Igb2YgdGhlIHByb2dyZXNzIGJhci4gKi9cbiAgICAgICAgdGhpcy5jb2xvciA9ICdwcmltYXJ5JztcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9idWZmZXJWYWx1ZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIElucHV0IG11c3QgYmUgb25lIG9mIHRoZXNlIHZhbHVlczogZGV0ZXJtaW5hdGUsIGluZGV0ZXJtaW5hdGUsIGJ1ZmZlciwgcXVlcnksIGRlZmF1bHRzIHRvXG4gICAgICAgICAqICdkZXRlcm1pbmF0ZScuXG4gICAgICAgICAqIE1pcnJvcmVkIHRvIG1vZGUgYXR0cmlidXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb2RlID0gJ2RldGVybWluYXRlJztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqIFZhbHVlIG9mIHRoZSBwcm9ncmVzc2Jhci4gRGVmYXVsdHMgdG8gemVyby4gTWlycm9yZWQgdG8gYXJpYS12YWx1ZW5vdy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLl92YWx1ZSA9IGNsYW1wJDEodiB8fCAwKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcImJ1ZmZlclZhbHVlXCIsIHtcbiAgICAgICAgLyoqIEJ1ZmZlciB2YWx1ZSBvZiB0aGUgcHJvZ3Jlc3MgYmFyLiBEZWZhdWx0cyB0byB6ZXJvLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2J1ZmZlclZhbHVlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMuX2J1ZmZlclZhbHVlID0gY2xhbXAkMSh2IHx8IDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogR2V0cyB0aGUgY3VycmVudCB0cmFuc2Zvcm0gdmFsdWUgZm9yIHRoZSBwcm9ncmVzcyBiYXIncyBwcmltYXJ5IGluZGljYXRvci4gKi9cbiAgICBNZFByb2dyZXNzQmFyLnByb3RvdHlwZS5fcHJpbWFyeVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy52YWx1ZSAvIDEwMDtcbiAgICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiBcInNjYWxlWChcIiArIHNjYWxlICsgXCIpXCIgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIHZhbHVlIGZvciB0aGUgcHJvZ3Jlc3MgYmFyJ3MgYnVmZmVyIGluZGljYXRvci4gIE9ubHkgdXNlZCBpZiB0aGVcbiAgICAgKiBwcm9ncmVzcyBtb2RlIGlzIHNldCB0byBidWZmZXIsIG90aGVyd2lzZSByZXR1cm5zIGFuIHVuZGVmaW5lZCwgY2F1c2luZyBubyB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzQmFyLnByb3RvdHlwZS5fYnVmZmVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09ICdidWZmZXInKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmJ1ZmZlclZhbHVlIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiBcInNjYWxlWChcIiArIHNjYWxlICsgXCIpXCIgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ0OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbm93JyksIFxuICAgICAgICBfX21ldGFkYXRhJDQ5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwiYnVmZmVyVmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ0OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5tb2RlJyksIFxuICAgICAgICBfX21ldGFkYXRhJDQ5KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgTWRQcm9ncmVzc0JhciA9IF9fZGVjb3JhdGUkNDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1wcm9ncmVzcy1iYXIsIG1hdC1wcm9ncmVzcy1iYXInLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6ICcwJyxcbiAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1heCc6ICcxMDAnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXByaW1hcnldJzogJ2NvbG9yID09IFwicHJpbWFyeVwiJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1hY2NlbnRdJzogJ2NvbG9yID09IFwiYWNjZW50XCInLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXdhcm5dJzogJ2NvbG9yID09IFwid2FyblwiJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wcm9ncmVzcy1iYXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1wcm9ncmVzcy1iYXItYnVmZmVyIG1hdC1wcm9ncmVzcy1iYXItZWxlbWVudFxcXCIgW25nU3R5bGVdPVxcXCJfYnVmZmVyVHJhbnNmb3JtKClcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeSBtYXQtcHJvZ3Jlc3MtYmFyLWZpbGwgbWF0LXByb2dyZXNzLWJhci1lbGVtZW50XFxcIiBbbmdTdHlsZV09XFxcIl9wcmltYXJ5VHJhbnNmb3JtKClcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5IG1hdC1wcm9ncmVzcy1iYXItZmlsbCBtYXQtcHJvZ3Jlc3MtYmFyLWVsZW1lbnRcXFwiPjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrO2hlaWdodDo1cHg7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApO3RyYW5zaXRpb246b3BhY2l0eSAyNTBtcyBsaW5lYXI7d2lkdGg6MTAwJX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1lbGVtZW50LDpob3N0IC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVye2hlaWdodDoxMDAlO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCV9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZHtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtiYWNrZ3JvdW5kLXNpemU6MTBweCA0cHg7ZGlzcGxheTpub25lfTpob3N0IC5tYXQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlcnt0cmFuc2Zvcm0tb3JpZ2luOnRvcCBsZWZ0O3RyYW5zaXRpb246dHJhbnNmb3JtIDI1MG1zIGVhc2V9Omhvc3QgLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5e2Rpc3BsYXk6bm9uZX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1maWxse2FuaW1hdGlvbjpub25lO3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMjUwbXMgZWFzZX06aG9zdCAubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlcnthbmltYXRpb246bm9uZTtjb250ZW50OicnO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xlZnQ6MH06aG9zdFttb2RlPXF1ZXJ5XXt0cmFuc2Zvcm06cm90YXRlWigxODBkZWcpfTpob3N0W21vZGU9cXVlcnldIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGwsOmhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1maWxse3RyYW5zaXRpb246bm9uZX06aG9zdFttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LDpob3N0W21vZGU9aW5kZXRlcm1pbmF0ZV0gLm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeXthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtdHJhbnNsYXRlIDJzIGluZmluaXRlIGxpbmVhcjtsZWZ0Oi0xNDUuMTY2NjExJX06aG9zdFttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIsOmhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1wcmltYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXJ7YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS1pbmRldGVybWluYXRlLXNjYWxlIDJzIGluZmluaXRlIGxpbmVhcn06aG9zdFttb2RlPXF1ZXJ5XSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnksOmhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnl7YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5LWluZGV0ZXJtaW5hdGUtdHJhbnNsYXRlIDJzIGluZmluaXRlIGxpbmVhcjtsZWZ0Oi01NC44ODg4OTElO2Rpc3BsYXk6YmxvY2t9Omhvc3RbbW9kZT1xdWVyeV0gLm1hdC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5Lm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIsOmhvc3RbbW9kZT1pbmRldGVybWluYXRlXSAubWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnkubWF0LXByb2dyZXNzLWJhci1maWxsOjphZnRlcnthbmltYXRpb246bWF0LXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS1zY2FsZSAycyBpbmZpbml0ZSBsaW5lYXJ9Omhvc3RbbW9kZT1idWZmZXJdIC5tYXQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmR7YW5pbWF0aW9uOm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZC1zY3JvbGwgMjUwbXMgaW5maW5pdGUgbGluZWFyO2Rpc3BsYXk6YmxvY2t9Omhvc3QtY29udGV4dChbZGlyPXJ0bF0pe3RyYW5zZm9ybTpyb3RhdGVZKDE4MGRlZyl9QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGV7MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9MjAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC41LDAsLjcwMTczLC40OTU4Mik7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9NTkuMTUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4zMDI0NCwuMzgxMzUsLjU1LC45NTYzNSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoODMuNjcxNDIlKX0xMDAle3RyYW5zZm9ybTp0cmFuc2xhdGVYKDIwMC42MTEwNiUpfX1Aa2V5ZnJhbWVzIG1hdC1wcm9ncmVzcy1iYXItcHJpbWFyeS1pbmRldGVybWluYXRlLXNjYWxlezAle3RyYW5zZm9ybTpzY2FsZVgoLjA4KX0zNi42NSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjMzNDczLC4xMjQ4MiwuNzg1ODQsMSk7dHJhbnNmb3JtOnNjYWxlWCguMDgpfTY5LjE1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMDYsLjExLC42LDEpO3RyYW5zZm9ybTpzY2FsZVgoLjY2MTQ4KX0xMDAle3RyYW5zZm9ybTpzY2FsZVgoLjA4KX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXRyYW5zbGF0ZXswJXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMTUsMCwuNTE1MDYsLjQwOTY5KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKX0yNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjMxMDMzLC4yODQwNiwuOCwuNzMzNzEpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDM3LjY1MTkxJSl9NDguMzUle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC40LC42MjcwNCwuNiwuOTAyMDMpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDg0LjM4NjE3JSl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxNjAuMjc3NzglKX19QGtleWZyYW1lcyBtYXQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXNjYWxlezAle2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4xNSwwLC41MTUwNiwuNDA5NjkpO3RyYW5zZm9ybTpzY2FsZVgoLjA4KX0xOS4xNSV7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjMxMDMzLC4yODQwNiwuOCwuNzMzNzEpO3RyYW5zZm9ybTpzY2FsZVgoLjQ1NzEpfTQ0LjE1JXthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNCwuNjI3MDQsLjYsLjkwMjAzKTt0cmFuc2Zvcm06c2NhbGVYKC43Mjc5Nil9MTAwJXt0cmFuc2Zvcm06c2NhbGVYKC4wOCl9fUBrZXlmcmFtZXMgbWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kLXNjcm9sbHt0b3t0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCl9fVwiXSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFByb2dyZXNzQmFyKTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc0Jhcjtcbn0oKSk7XG4vKiogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiB0d28gbnVtYmVycywgYnkgZGVmYXVsdCAwIGFuZCAxMDAuICovXG5mdW5jdGlvbiBjbGFtcCQxKHYsIG1pbiwgbWF4KSB7XG4gICAgaWYgKG1pbiA9PT0gdm9pZCAwKSB7IG1pbiA9IDA7IH1cbiAgICBpZiAobWF4ID09PSB2b2lkIDApIHsgbWF4ID0gMTAwOyB9XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2KSk7XG59XG52YXIgTWRQcm9ncmVzc0Jhck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcm9ncmVzc0Jhck1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRQcm9ncmVzc0Jhck1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kUHJvZ3Jlc3NCYXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFByb2dyZXNzQmFyTW9kdWxlID0gX19kZWNvcmF0ZSQ0OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kUHJvZ3Jlc3NCYXIsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRQcm9ncmVzc0Jhcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFByb2dyZXNzQmFyTW9kdWxlKTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc0Jhck1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMTUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqIEBkb2NzLXByaXZhdGUgKi9cbnZhciBNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTUoTWRJbnB1dENvbnRhaW5lclBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnUGxhY2Vob2xkZXIgYXR0cmlidXRlIGFuZCBjaGlsZCBlbGVtZW50IHdlcmUgYm90aCBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yO1xufShNZEVycm9yKSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDE1KE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZElucHV0Q29udGFpbmVyVW5zdXBwb3J0ZWRUeXBlRXJyb3IodHlwZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIklucHV0IHR5cGUgXFxcIlwiICsgdHlwZSArIFwiXFxcIiBpc24ndCBzdXBwb3J0ZWQgYnkgbWQtaW5wdXQtY29udGFpbmVyLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqIEBkb2NzLXByaXZhdGUgKi9cbnZhciBNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDE1KE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yKGFsaWduKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQSBoaW50IHdhcyBhbHJlYWR5IGRlY2xhcmVkIGZvciAnYWxpZ249XFxcIlwiICsgYWxpZ24gKyBcIlxcXCInLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yO1xufShNZEVycm9yKSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xudmFyIE1kSW5wdXRDb250YWluZXJNaXNzaW5nTWRJbnB1dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTUoTWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdtZC1pbnB1dC1jb250YWluZXIgbXVzdCBjb250YWluIGFuIG1kSW5wdXQgZGlyZWN0aXZlLiBEaWQgeW91IGZvcmdldCB0byBhZGQgbWRJbnB1dCAnICtcbiAgICAgICAgICAgICd0byB0aGUgbmF0aXZlIGlucHV0IG9yIHRleHRhcmVhIGVsZW1lbnQ/Jyk7XG4gICAgfVxuICAgIHJldHVybiBNZElucHV0Q29udGFpbmVyTWlzc2luZ01kSW5wdXRFcnJvcjtcbn0oTWRFcnJvcikpO1xuXG52YXIgX19kZWNvcmF0ZSQ1MSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTAgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vLyBJbnZhbGlkIGlucHV0IHR5cGUuIFVzaW5nIG9uZSBvZiB0aGVzZSB3aWxsIHRocm93IGFuIE1kSW5wdXRDb250YWluZXJVbnN1cHBvcnRlZFR5cGVFcnJvci5cbnZhciBNRF9JTlBVVF9JTlZBTElEX1RZUEVTID0gW1xuICAgICdidXR0b24nLFxuICAgICdjaGVja2JveCcsXG4gICAgJ2NvbG9yJyxcbiAgICAnZmlsZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2ltYWdlJyxcbiAgICAncmFkaW8nLFxuICAgICdyYW5nZScsXG4gICAgJ3Jlc2V0JyxcbiAgICAnc3VibWl0J1xuXTtcbnZhciBuZXh0VW5pcXVlSWQkMSA9IDA7XG4vKipcbiAqIFRoZSBwbGFjZWhvbGRlciBkaXJlY3RpdmUuIFRoZSBjb250ZW50IGNhbiBkZWNsYXJlIHRoaXMgdG8gaW1wbGVtZW50IG1vcmVcbiAqIGNvbXBsZXggcGxhY2Vob2xkZXJzLlxuICovXG52YXIgTWRQbGFjZWhvbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQbGFjZWhvbGRlcigpIHtcbiAgICB9XG4gICAgTWRQbGFjZWhvbGRlciA9IF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLXBsYWNlaG9sZGVyLCBtYXQtcGxhY2Vob2xkZXInXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFBsYWNlaG9sZGVyKTtcbiAgICByZXR1cm4gTWRQbGFjZWhvbGRlcjtcbn0oKSk7XG4vKiogVGhlIGhpbnQgZGlyZWN0aXZlLCB1c2VkIHRvIHRhZyBjb250ZW50IGFzIGhpbnQgbGFiZWxzIChnb2luZyB1bmRlciB0aGUgaW5wdXQpLiAqL1xudmFyIE1kSGludCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRIaW50KCkge1xuICAgICAgICAvLyBXaGV0aGVyIHRvIGFsaWduIHRoZSBoaW50IGxhYmVsIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgIHRoaXMuYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICAvLyBVbmlxdWUgSUQgZm9yIHRoZSBoaW50LiBVc2VkIGZvciB0aGUgYXJpYS1kZXNjcmliZWRieSBvbiB0aGUgaW5wdXQuXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLWlucHV0LWhpbnQtXCIgKyBuZXh0VW5pcXVlSWQkMSsrO1xuICAgIH1cbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRIaW50LnByb3RvdHlwZSwgXCJhbGlnblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEhpbnQucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgTWRIaW50ID0gX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtaGludCwgbWF0LWhpbnQnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWhpbnRdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXJpZ2h0XSc6ICdhbGlnbiA9PSBcImVuZFwiJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuaWRdJzogJ2lkJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kSGludCk7XG4gICAgcmV0dXJuIE1kSGludDtcbn0oKSk7XG4vKiogVGhlIGlucHV0IGRpcmVjdGl2ZSwgdXNlZCB0byBtYXJrIHRoZSBpbnB1dCB0aGF0IGBNZElucHV0Q29udGFpbmVyYCBpcyB3cmFwcGluZy4gKi9cbnZhciBNZElucHV0RGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElucHV0RGlyZWN0aXZlKF9lbGVtZW50UmVmLCBfcmVuZGVyZXIsIF9uZ0NvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fbmdDb250cm9sID0gX25nQ29udHJvbDtcbiAgICAgICAgLyoqIFZhcmlhYmxlcyB1c2VkIGFzIGNhY2hlIGZvciBnZXR0ZXJzIGFuZCBzZXR0ZXJzLiAqL1xuICAgICAgICB0aGlzLl90eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgZWxlbWVudCBpcyBmb2N1c2VkIG9yIG5vdC4gKi9cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBwbGFjZWhvbGRlciBjaGFuZ2VzIHNvIHRoYXQgdGhlIGBtZC1pbnB1dC1jb250YWluZXJgIGNhbiByZS12YWxpZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyQ2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX25ldmVyRW1wdHlJbnB1dFR5cGVzID0gW1xuICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJyxcbiAgICAgICAgICAgICdkYXRldGltZS1sb2NhbCcsXG4gICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgJ3RpbWUnLFxuICAgICAgICAgICAgJ3dlZWsnXG4gICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiBnZXRTdXBwb3J0ZWRJbnB1dFR5cGVzKCkuaGFzKHQpOyB9KTtcbiAgICAgICAgLy8gRm9yY2Ugc2V0dGVyIHRvIGJlIGNhbGxlZCBpbiBjYXNlIGlkIHdhcyBub3Qgc3BlY2lmaWVkLlxuICAgICAgICB0aGlzLmlkID0gdGhpcy5pZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25nQ29udHJvbCA/IHRoaXMuX25nQ29udHJvbC5kaXNhYmxlZCA6IHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICAvKiogVW5pcXVlIGlkIG9mIHRoZSBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9pZCA9IHZhbHVlIHx8IHRoaXMuX3VpZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHtcbiAgICAgICAgLyoqIFBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvZiB0aGUgZWxlbWVudC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGFjZWhvbGRlcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlciAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyQ2hhbmdlLmVtaXQodGhpcy5fcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgZWxlbWVudCBpcyByZXF1aXJlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fcmVxdWlyZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIC8qKiBJbnB1dCB0eXBlIG9mIHRoZSBlbGVtZW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3R5cGU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gdmFsdWUgfHwgJ3RleHQnO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVUeXBlKCk7XG4gICAgICAgICAgICAvLyBXaGVuIHVzaW5nIEFuZ3VsYXIgaW5wdXRzLCBkZXZlbG9wZXJzIGFyZSBubyBsb25nZXIgYWJsZSB0byBzZXQgdGhlIHByb3BlcnRpZXMgb24gdGhlIG5hdGl2ZVxuICAgICAgICAgICAgLy8gaW5wdXQgZWxlbWVudC4gVG8gZW5zdXJlIHRoYXQgYmluZGluZ3MgZm9yIGB0eXBlYCB3b3JrLCB3ZSBuZWVkIHRvIHN5bmMgdGhlIHNldHRlclxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgbmF0aXZlIHByb3BlcnR5LiBUZXh0YXJlYSBlbGVtZW50cyBkb24ndCBzdXBwb3J0IHRoZSB0eXBlIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNUZXh0YXJlYSgpICYmIGdldFN1cHBvcnRlZElucHV0VHlwZXMoKS5oYXModGhpcy5fdHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndHlwZScsIHRoaXMuX3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogVGhlIGlucHV0IGVsZW1lbnQncyB2YWx1ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZW1wdHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5faXNOZXZlckVtcHR5KCkgJiZcbiAgICAgICAgICAgICAgICAodGhpcy52YWx1ZSA9PSBudWxsIHx8IHRoaXMudmFsdWUgPT09ICcnKSAmJlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbnB1dCBjb250YWlucyBiYWQgaW5wdXQuIElmIHNvLCB3ZSBrbm93IHRoYXQgaXQgb25seSBhcHBlYXJzIGVtcHR5IGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWUgZmFpbGVkIHRvIHBhcnNlLiBGcm9tIHRoZSB1c2VyJ3MgcGVyc3BlY3RpdmUgaXQgaXMgbm90IGVtcHR5LlxuICAgICAgICAgICAgICAgIC8vIFRPRE8obW1hbGVyYmEpOiBBZGQgZTJlIHRlc3QgZm9yIGJhZCBpbnB1dCBjYXNlLlxuICAgICAgICAgICAgICAgICF0aGlzLl9pc0JhZElucHV0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJfdWlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jYWNoZWRVaWQgPSB0aGlzLl9jYWNoZWRVaWQgfHwgXCJtZC1pbnB1dC1cIiArIG5leHRVbmlxdWVJZCQxKys7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBGb2N1c2VzIHRoZSBpbnB1dCBlbGVtZW50LiAqL1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7IH07XG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9jdXNlZCA9IHRydWU7IH07XG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb2N1c2VkID0gZmFsc2U7IH07XG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX29uSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBub29wIGZ1bmN0aW9uIGFuZCBpcyB1c2VkIHRvIGxldCBBbmd1bGFyIGtub3cgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgIC8vIEFuZ3VsYXIgd2lsbCBydW4gYSBuZXcgY2hhbmdlIGRldGVjdGlvbiBlYWNoIHRpbWUgdGhlIGBpbnB1dGAgZXZlbnQgaGFzIGJlZW4gZGlzcGF0Y2hlZC5cbiAgICAgICAgLy8gSXQncyBuZWNlc3NhcnkgdGhhdCBBbmd1bGFyIHJlY29nbml6ZXMgdGhlIHZhbHVlIGNoYW5nZSwgYmVjYXVzZSB3aGVuIGZsb2F0aW5nTGFiZWxcbiAgICAgICAgLy8gaXMgc2V0IHRvIGZhbHNlIGFuZCBBbmd1bGFyIGZvcm1zIGFyZW4ndCB1c2VkLCB0aGUgcGxhY2Vob2xkZXIgd29uJ3QgcmVjb2duaXplIHRoZVxuICAgICAgICAvLyB2YWx1ZSBjaGFuZ2VzIGFuZCB3aWxsIG5vdCBkaXNhcHBlYXIuXG4gICAgICAgIC8vIExpc3RlbmluZyB0byB0aGUgaW5wdXQgZXZlbnQgd291bGRuJ3QgYmUgbmVjZXNzYXJ5IHdoZW4gdGhlIGlucHV0IGlzIHVzaW5nIHRoZVxuICAgICAgICAvLyBGb3Jtc01vZHVsZSBvciBSZWFjdGl2ZUZvcm1zTW9kdWxlLCBiZWNhdXNlIEFuZ3VsYXIgZm9ybXMgYWxzbyBsaXN0ZW5zIHRvIGlucHV0IGV2ZW50cy5cbiAgICB9O1xuICAgIC8qKiBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3VwcG9ydGVkIHR5cGUuICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX3ZhbGlkYXRlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKE1EX0lOUFVUX0lOVkFMSURfVFlQRVMuaW5kZXhPZih0aGlzLl90eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZElucHV0Q29udGFpbmVyVW5zdXBwb3J0ZWRUeXBlRXJyb3IodGhpcy5fdHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLl9pc05ldmVyRW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uZXZlckVtcHR5SW5wdXRUeXBlcy5pbmRleE9mKHRoaXMuX3R5cGUpICE9PSAtMTsgfTtcbiAgICBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZS5faXNCYWRJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWxpZGl0eS5iYWRJbnB1dDtcbiAgICB9O1xuICAgIC8qKiBEZXRlcm1pbmVzIGlmIHRoZSBjb21wb25lbnQgaG9zdCBpcyBhIHRleHRhcmVhLiBJZiBub3QgcmVjb2duaXphYmxlIGl0IHJldHVybnMgZmFsc2UuICovXG4gICAgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUuX2lzVGV4dGFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYXRpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gbmF0aXZlRWxlbWVudCA/IG5hdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJyA6IGZhbHNlO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0eXBlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiX3BsYWNlaG9sZGVyQ2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgTWRJbnB1dERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogXCJpbnB1dFttZElucHV0XSwgdGV4dGFyZWFbbWRJbnB1dF0sIGlucHV0W21hdElucHV0XSwgdGV4dGFyZWFbbWF0SW5wdXRdXCIsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtaW5wdXQtZWxlbWVudF0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgLy8gTmF0aXZlIGlucHV0IHByb3BlcnRpZXMgdGhhdCBhcmUgb3ZlcndyaXR0ZW4gYnkgQW5ndWxhciBpbnB1dHMgbmVlZCB0byBiZSBzeW5jZWQgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudC4gT3RoZXJ3aXNlIHByb3BlcnR5IGJpbmRpbmdzIGZvciB0aG9zZSBkb24ndCB3b3JrLlxuICAgICAgICAgICAgICAgICdbaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICAnW3BsYWNlaG9sZGVyXSc6ICdwbGFjZWhvbGRlcicsXG4gICAgICAgICAgICAgICAgJ1tkaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbcmVxdWlyZWRdJzogJ3JlcXVpcmVkJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kZXNjcmliZWRieV0nOiAnYXJpYURlc2NyaWJlZGJ5JyxcbiAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19vbkJsdXIoKScsXG4gICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnX29uRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnX29uSW5wdXQoKScsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDEwKDIsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2Zvcm1zLk5nQ29udHJvbF0pXG4gICAgXSwgTWRJbnB1dERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIE1kSW5wdXREaXJlY3RpdmU7XG59KCkpO1xuLyoqXG4gKiBDb21wb25lbnQgdGhhdCByZXByZXNlbnRzIGEgdGV4dCBpbnB1dC4gSXQgZW5jYXBzdWxhdGVzIHRoZSA8aW5wdXQ+IEhUTUxFbGVtZW50IGFuZFxuICogaW1wcm92ZSBvbiBpdHMgYmVoYXZpb3VyLCBhbG9uZyB3aXRoIHN0eWxpbmcgaXQgYWNjb3JkaW5nIHRvIHRoZSBNYXRlcmlhbCBEZXNpZ24uXG4gKi9cbnZhciBNZElucHV0Q29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElucHV0Q29udGFpbmVyKCkge1xuICAgICAgICAvKiogQWxpZ25tZW50IG9mIHRoZSBpbnB1dCBjb250YWluZXIncyBjb250ZW50LiAqL1xuICAgICAgICB0aGlzLmFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqIENvbG9yIG9mIHRoZSBpbnB1dCBkaXZpZGVyLCBiYXNlZCBvbiB0aGUgdGhlbWUuICovXG4gICAgICAgIHRoaXMuZGl2aWRlckNvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICB0aGlzLl9oaW50TGFiZWwgPSAnJztcbiAgICAgICAgLy8gVW5pcXVlIGlkIGZvciB0aGUgaGludCBsYWJlbC5cbiAgICAgICAgdGhpcy5faGludExhYmVsSWQgPSBcIm1kLWlucHV0LWhpbnQtXCIgKyBuZXh0VW5pcXVlSWQkMSsrO1xuICAgICAgICB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyID0gJ2F1dG8nO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiX3Nob3VsZEFsd2F5c0Zsb2F0XCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGZsb2F0aW5nIGxhYmVsIHNob3VsZCBhbHdheXMgZmxvYXQgb3Igbm90LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIgPT09ICdhbHdheXMnOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiX2NhblBsYWNlaG9sZGVyRmxvYXRcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcGxhY2Vob2xkZXIgY2FuIGZsb2F0IG9yIG5vdC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyICE9PSAnbmV2ZXInOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaGludExhYmVsXCIsIHtcbiAgICAgICAgLyoqIFRleHQgZm9yIHRoZSBpbnB1dCBoaW50LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hpbnRMYWJlbDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpbnRMYWJlbCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0hpbnRzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJmbG9hdFBsYWNlaG9sZGVyXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBhbHdheXMgZmxvYXQsIG5ldmVyIGZsb2F0IG9yIGZsb2F0IGFzIHRoZSB1c2VyIHR5cGVzLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXI7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mbG9hdFBsYWNlaG9sZGVyID0gdmFsdWUgfHwgJ2F1dG8nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fbWRJbnB1dENoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcm9jZXNzSGludHMoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVQbGFjZWhvbGRlcnMoKTtcbiAgICAgICAgLy8gUmUtdmFsaWRhdGUgd2hlbiB0aGluZ3MgY2hhbmdlLlxuICAgICAgICB0aGlzLl9oaW50Q2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3Byb2Nlc3NIaW50cygpOyB9KTtcbiAgICAgICAgdGhpcy5fbWRJbnB1dENoaWxkLl9wbGFjZWhvbGRlckNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZhbGlkYXRlUGxhY2Vob2xkZXJzKCk7IH0pO1xuICAgIH07XG4gICAgLyoqIERldGVybWluZXMgd2hldGhlciBhIGNsYXNzIGZyb20gdGhlIE5nQ29udHJvbCBzaG91bGQgYmUgZm9yd2FyZGVkIHRvIHRoZSBob3N0IGVsZW1lbnQuICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3Nob3VsZEZvcndhcmQgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICB2YXIgY29udHJvbCA9IHRoaXMuX21kSW5wdXRDaGlsZCA/IHRoaXMuX21kSW5wdXRDaGlsZC5fbmdDb250cm9sIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wgJiYgY29udHJvbFtwcm9wXTtcbiAgICB9O1xuICAgIC8qKiBXaGV0aGVyIHRoZSBpbnB1dCBoYXMgYSBwbGFjZWhvbGRlci4gKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5faGFzUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhISh0aGlzLl9tZElucHV0Q2hpbGQucGxhY2Vob2xkZXIgfHwgdGhpcy5fcGxhY2Vob2xkZXJDaGlsZCk7IH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIHVuZGVybHlpbmcgaW5wdXQuICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX2ZvY3VzSW5wdXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21kSW5wdXRDaGlsZC5mb2N1cygpOyB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIHBsYWNlaG9sZGVyIChlaXRoZXIgYGlucHV0YCBhdHRyaWJ1dGUgb3IgY2hpbGQgZWxlbWVudCB3aXRoIHRoZVxuICAgICAqIGBtZC1wbGFjZWhvbGRlcmAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLl92YWxpZGF0ZVBsYWNlaG9sZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21kSW5wdXRDaGlsZC5wbGFjZWhvbGRlciAmJiB0aGlzLl9wbGFjZWhvbGRlckNoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRJbnB1dENvbnRhaW5lclBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb2VzIGFueSBleHRyYSBwcm9jZXNzaW5nIHRoYXQgaXMgcmVxdWlyZWQgd2hlbiBoYW5kbGluZyB0aGUgaGludHMuXG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3Byb2Nlc3NIaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVIaW50cygpO1xuICAgICAgICB0aGlzLl9zeW5jQXJpYURlc2NyaWJlZGJ5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhIG1heGltdW0gb2Ygb25lIG9mIGVhY2ggYDxtZC1oaW50PmAgYWxpZ25tZW50IHNwZWNpZmllZCwgd2l0aCB0aGVcbiAgICAgKiBhdHRyaWJ1dGUgYmVpbmcgY29uc2lkZXJlZCBhcyBgYWxpZ249XCJzdGFydFwiYC5cbiAgICAgKi9cbiAgICBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZS5fdmFsaWRhdGVIaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2hpbnRDaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0SGludF8xID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBlbmRIaW50XzEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGludC5hbGlnbiA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEhpbnRfMSB8fCBfdGhpcy5oaW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZElucHV0Q29udGFpbmVyRHVwbGljYXRlZEhpbnRFcnJvcignc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydEhpbnRfMSA9IGhpbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhpbnQuYWxpZ24gPT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEhpbnRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yKCdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmRIaW50XzEgPSBoaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjaGlsZCBpbnB1dCdzIGBhcmlhLWRlc2NyaWJlZGJ5YCB0byBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBpZHNcbiAgICAgKiBvZiB0aGUgY3VycmVudGx5LXNwZWNpZmllZCBoaW50cywgYXMgd2VsbCBhcyBhIGdlbmVyYXRlZCBpZCBmb3IgdGhlIGhpbnQgbGFiZWwuXG4gICAgICovXG4gICAgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUuX3N5bmNBcmlhRGVzY3JpYmVkYnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0SGludCA9IHRoaXMuX2hpbnRDaGlsZHJlbiA/XG4gICAgICAgICAgICB0aGlzLl9oaW50Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAoaGludCkgeyByZXR1cm4gaGludC5hbGlnbiA9PT0gJ3N0YXJ0JzsgfSkgOiBudWxsO1xuICAgICAgICB2YXIgZW5kSGludCA9IHRoaXMuX2hpbnRDaGlsZHJlbiA/XG4gICAgICAgICAgICB0aGlzLl9oaW50Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAoaGludCkgeyByZXR1cm4gaGludC5hbGlnbiA9PT0gJ2VuZCc7IH0pIDogbnVsbDtcbiAgICAgICAgaWYgKHN0YXJ0SGludCkge1xuICAgICAgICAgICAgaWRzLnB1c2goc3RhcnRIaW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9oaW50TGFiZWwpIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKHRoaXMuX2hpbnRMYWJlbElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kSGludCkge1xuICAgICAgICAgICAgaWRzLnB1c2goZW5kSGludC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWRJbnB1dENoaWxkLmFyaWFEZXNjcmliZWRieSA9IGlkcy5qb2luKCcgJyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiYWxpZ25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiZGl2aWRlckNvbG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1MShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kSW5wdXRDb250YWluZXIucHJvdG90eXBlLCBcImhpbnRMYWJlbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiZmxvYXRQbGFjZWhvbGRlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDUxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGQoTWRJbnB1dERpcmVjdGl2ZSksIFxuICAgICAgICBfX21ldGFkYXRhJDUxKCdkZXNpZ246dHlwZScsIE1kSW5wdXREaXJlY3RpdmUpXG4gICAgXSwgTWRJbnB1dENvbnRhaW5lci5wcm90b3R5cGUsIFwiX21kSW5wdXRDaGlsZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZChNZFBsYWNlaG9sZGVyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTEoJ2Rlc2lnbjp0eXBlJywgTWRQbGFjZWhvbGRlcilcbiAgICBdLCBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJfcGxhY2Vob2xkZXJDaGlsZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZEhpbnQpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZElucHV0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJfaGludENoaWxkcmVuXCIsIHZvaWQgMCk7XG4gICAgTWRJbnB1dENvbnRhaW5lciA9IF9fZGVjb3JhdGUkNTEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1pbnB1dC1jb250YWluZXIsIG1hdC1pbnB1dC1jb250YWluZXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LXdyYXBwZXJcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1pbnB1dC10YWJsZVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LXByZWZpeFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWRQcmVmaXhdLCBbbWF0UHJlZml4XSwgW21kLXByZWZpeF1cXFwiPjwvbmctY29udGVudD48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtaW5maXhcXFwiIFtjbGFzcy5tYXQtZW5kXT1cXFwiYWxpZ24gPT0gJ2VuZCdcXFwiPjxuZy1jb250ZW50IHNlbGVjdG9yPVxcXCJpbnB1dCwgdGV4dGFyZWFcXFwiPjwvbmctY29udGVudD48c3BhbiBjbGFzcz1cXFwibWF0LWlucHV0LXBsYWNlaG9sZGVyLXdyYXBwZXJcXFwiPjxsYWJlbCBjbGFzcz1cXFwibWF0LWlucHV0LXBsYWNlaG9sZGVyXFxcIiBbYXR0ci5mb3JdPVxcXCJfbWRJbnB1dENoaWxkLmlkXFxcIiBbY2xhc3MubWF0LWVtcHR5XT1cXFwiX21kSW5wdXRDaGlsZC5lbXB0eSAmJiAhX3Nob3VsZEFsd2F5c0Zsb2F0XFxcIiBbY2xhc3MubWF0LWZvY3VzZWRdPVxcXCJfbWRJbnB1dENoaWxkLmZvY3VzZWRcXFwiIFtjbGFzcy5tYXQtZmxvYXRdPVxcXCJfY2FuUGxhY2Vob2xkZXJGbG9hdFxcXCIgW2NsYXNzLm1hdC1hY2NlbnRdPVxcXCJkaXZpZGVyQ29sb3IgPT0gJ2FjY2VudCdcXFwiIFtjbGFzcy5tYXQtd2Fybl09XFxcImRpdmlkZXJDb2xvciA9PSAnd2FybidcXFwiICpuZ0lmPVxcXCJfaGFzUGxhY2Vob2xkZXIoKVxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1wbGFjZWhvbGRlciwgbWF0LXBsYWNlaG9sZGVyXFxcIj48L25nLWNvbnRlbnQ+e3tfbWRJbnB1dENoaWxkLnBsYWNlaG9sZGVyfX0gPHNwYW4gY2xhc3M9XFxcIm1hdC1wbGFjZWhvbGRlci1yZXF1aXJlZFxcXCIgKm5nSWY9XFxcIl9tZElucHV0Q2hpbGQucmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD48L3NwYW4+PC9kaXY+PGRpdiBjbGFzcz1cXFwibWF0LWlucHV0LXN1ZmZpeFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWRTdWZmaXhdLCBbbWF0U3VmZml4XSwgW21kLXN1ZmZpeF1cXFwiPjwvbmctY29udGVudD48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtaW5wdXQtdW5kZXJsaW5lXFxcIiBbY2xhc3MubWF0LWRpc2FibGVkXT1cXFwiX21kSW5wdXRDaGlsZC5kaXNhYmxlZFxcXCI+PHNwYW4gY2xhc3M9XFxcIm1hdC1pbnB1dC1yaXBwbGVcXFwiIFtjbGFzcy5tYXQtZm9jdXNlZF09XFxcIl9tZElucHV0Q2hpbGQuZm9jdXNlZFxcXCIgW2NsYXNzLm1hdC1hY2NlbnRdPVxcXCJkaXZpZGVyQ29sb3IgPT0gJ2FjY2VudCdcXFwiIFtjbGFzcy5tYXQtd2Fybl09XFxcImRpdmlkZXJDb2xvciA9PSAnd2FybidcXFwiPjwvc3Bhbj48L2Rpdj48ZGl2ICpuZ0lmPVxcXCJoaW50TGFiZWwgIT0gJydcXFwiIFthdHRyLmlkXT1cXFwiX2hpbnRMYWJlbElkXFxcIiBjbGFzcz1cXFwibWF0LWhpbnRcXFwiPnt7aGludExhYmVsfX08L2Rpdj48bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWhpbnQsIG1hdC1oaW50XFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtaW5wdXQtY29udGFpbmVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7bGluZS1oZWlnaHQ6bm9ybWFsO3RleHQtYWxpZ246bGVmdH0ubWF0LWVuZCAubWF0LWlucHV0LWVsZW1lbnQsW2Rpcj1ydGxdIC5tYXQtaW5wdXQtY29udGFpbmVye3RleHQtYWxpZ246cmlnaHR9Lm1hdC1pbnB1dC13cmFwcGVye21hcmdpbjoxZW0gMDtwYWRkaW5nLWJvdHRvbTo2cHh9Lm1hdC1pbnB1dC10YWJsZXtkaXNwbGF5OmlubGluZS10YWJsZTtmbGV4LWZsb3c6Y29sdW1uO3ZlcnRpY2FsLWFsaWduOmJvdHRvbTt3aWR0aDoxMDAlfS5tYXQtaW5wdXQtdGFibGU+KntkaXNwbGF5OnRhYmxlLWNlbGx9Lm1hdC1pbnB1dC1pbmZpeHtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LWlucHV0LWVsZW1lbnR7Zm9udDppbmhlcml0O2JhY2tncm91bmQ6MCAwO2NvbG9yOmN1cnJlbnRDb2xvcjtib3JkZXI6bm9uZTtvdXRsaW5lOjA7cGFkZGluZzowO3dpZHRoOjEwMCV9Lm1hdC1pbnB1dC1wbGFjZWhvbGRlciwubWF0LWlucHV0LXBsYWNlaG9sZGVyLXdyYXBwZXJ7cGFkZGluZy10b3A6MWVtO3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246YWJzb2x1dGV9W2Rpcj1ydGxdIC5tYXQtZW5kIC5tYXQtaW5wdXQtZWxlbWVudHt0ZXh0LWFsaWduOmxlZnR9Lm1hdC1pbnB1dC1lbGVtZW50Oi1tb3otdWktaW52YWxpZHtib3gtc2hhZG93Om5vbmV9Lm1hdC1pbnB1dC1lbGVtZW50Oi13ZWJraXQtYXV0b2ZpbGwrLm1hdC1pbnB1dC1wbGFjZWhvbGRlci5tYXQtZmxvYXR7ZGlzcGxheTpibG9jazt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMS4zNWVtKSBzY2FsZSguNzUpO3dpZHRoOjEzMy4zMzMzMyV9Lm1hdC1pbnB1dC1lbGVtZW50OjpwbGFjZWhvbGRlcntjb2xvcjp0cmFuc3BhcmVudH0ubWF0LWlucHV0LWVsZW1lbnQ6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6dHJhbnNwYXJlbnR9Lm1hdC1pbnB1dC1lbGVtZW50Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOnRyYW5zcGFyZW50fS5tYXQtaW5wdXQtZWxlbWVudDotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6dHJhbnNwYXJlbnR9Lm1hdC1pbnB1dC1wbGFjZWhvbGRlcntsZWZ0OjA7dG9wOjA7Zm9udC1zaXplOjEwMCU7ei1pbmRleDoxO3dpZHRoOjEwMCU7ZGlzcGxheTpub25lO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93LXg6aGlkZGVuO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybS1vcmlnaW46Ym90dG9tIGxlZnQ7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGN1YmljLWJlemllciguMjUsLjgsLjI1LDEpLGNvbG9yIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSx3aWR0aCAuNHMgY3ViaWMtYmV6aWVyKC4yNSwuOCwuMjUsMSl9Lm1hdC1pbnB1dC1wbGFjZWhvbGRlci5tYXQtZW1wdHl7ZGlzcGxheTpibG9jaztjdXJzb3I6dGV4dH0ubWF0LWlucHV0LXBsYWNlaG9sZGVyLm1hdC1mbG9hdC5tYXQtZm9jdXNlZCwubWF0LWlucHV0LXBsYWNlaG9sZGVyLm1hdC1mbG9hdDpub3QoLm1hdC1lbXB0eSl7ZGlzcGxheTpibG9jazt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMS4zNWVtKSBzY2FsZSguNzUpO3dpZHRoOjEzMy4zMzMzMyV9W2Rpcj1ydGxdIC5tYXQtaW5wdXQtcGxhY2Vob2xkZXJ7dHJhbnNmb3JtLW9yaWdpbjpib3R0b20gcmlnaHQ7bGVmdDphdXRvO3JpZ2h0OjB9Lm1hdC1pbnB1dC1wbGFjZWhvbGRlci13cmFwcGVye2xlZnQ6MDt0b3A6LTFlbTt3aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbn0ubWF0LWlucHV0LXBsYWNlaG9sZGVyLXdyYXBwZXI6OmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTppbmxpbmUtdGFibGV9Lm1hdC1pbnB1dC11bmRlcmxpbmV7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjFweDt3aWR0aDoxMDAlO21hcmdpbi10b3A6NHB4O2JvcmRlci10b3Atd2lkdGg6MXB4O2JvcmRlci10b3Atc3R5bGU6c29saWR9Lm1hdC1pbnB1dC11bmRlcmxpbmUubWF0LWRpc2FibGVke2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LHJnYmEoMCwwLDAsLjI2KSAwLHJnYmEoMCwwLDAsLjI2KSAzMyUsdHJhbnNwYXJlbnQgMCk7YmFja2dyb3VuZC1zaXplOjRweCAxcHg7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7Ym9yZGVyLXRvcDowO2JhY2tncm91bmQtcG9zaXRpb246MH0ubWF0LWlucHV0LXVuZGVybGluZSAubWF0LWlucHV0LXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MnB4O3otaW5kZXg6MTt0b3A6LTFweDt3aWR0aDoxMDAlO3RyYW5zZm9ybS1vcmlnaW46dG9wO29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGVZKDApO3RyYW5zaXRpb246dHJhbnNmb3JtIC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKSxvcGFjaXR5IC40cyBjdWJpYy1iZXppZXIoLjI1LC44LC4yNSwxKX0ubWF0LWlucHV0LXVuZGVybGluZSAubWF0LWlucHV0LXJpcHBsZS5tYXQtZm9jdXNlZHtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlWSgxKX0ubWF0LWhpbnR7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtmb250LXNpemU6NzUlO2JvdHRvbTowfS5tYXQtaGludC5tYXQtcmlnaHR7cmlnaHQ6MH1bZGlyPXJ0bF0gLm1hdC1oaW50e3JpZ2h0OjA7bGVmdDphdXRvfVtkaXI9cnRsXSAubWF0LWhpbnQubWF0LXJpZ2h0e3JpZ2h0OmF1dG87bGVmdDowfS5tYXQtaW5wdXQtcHJlZml4LC5tYXQtaW5wdXQtc3VmZml4e3dpZHRoOi4xcHg7d2hpdGUtc3BhY2U6bm93cmFwfVwiXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1pbnB1dC1jb250YWluZXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGlnbiBhdHRyaWJ1dGUgdG8gcHJldmVudCBpdCBmcm9tIGludGVyZmVyaW5nIHdpdGggbGF5b3V0LlxuICAgICAgICAgICAgICAgICdbYXR0ci5hbGlnbl0nOiAnbnVsbCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy11bnRvdWNoZWRdJzogJ19zaG91bGRGb3J3YXJkKFwidW50b3VjaGVkXCIpJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm5nLXRvdWNoZWRdJzogJ19zaG91bGRGb3J3YXJkKFwidG91Y2hlZFwiKScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnX3Nob3VsZEZvcndhcmQoXCJwcmlzdGluZVwiKScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1kaXJ0eV0nOiAnX3Nob3VsZEZvcndhcmQoXCJkaXJ0eVwiKScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy12YWxpZF0nOiAnX3Nob3VsZEZvcndhcmQoXCJ2YWxpZFwiKScsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICdfc2hvdWxkRm9yd2FyZChcImludmFsaWRcIiknLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubmctcGVuZGluZ10nOiAnX3Nob3VsZEZvcndhcmQoXCJwZW5kaW5nXCIpJyxcbiAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfZm9jdXNJbnB1dCgpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZElucHV0Q29udGFpbmVyKTtcbiAgICByZXR1cm4gTWRJbnB1dENvbnRhaW5lcjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDUyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDUyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIERpcmVjdGl2ZSB0byBhdXRvbWF0aWNhbGx5IHJlc2l6ZSBhIHRleHRhcmVhIHRvIGZpdCBpdHMgY29udGVudC5cbiAqL1xudmFyIE1kVGV4dGFyZWFBdXRvc2l6ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUZXh0YXJlYUF1dG9zaXplKF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwibWRBdXRvc2l6ZU1pblJvd3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pblJvd3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm1pblJvd3MgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwibWRBdXRvc2l6ZU1heFJvd3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heFJvd3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm1heFJvd3MgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwiX21pbkhlaWdodFwiLCB7XG4gICAgICAgIC8qKiBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHRleHRhcmVhIGFzIGRldGVybWluZWQgYnkgbWluUm93cy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5Sb3dzID8gdGhpcy5taW5Sb3dzICogdGhpcy5fY2FjaGVkTGluZUhlaWdodCArIFwicHhcIiA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLCBcIl9tYXhIZWlnaHRcIiwge1xuICAgICAgICAvKiogVGhlIG1heGltdW0gaGVpZ2h0IG9mIHRoZSB0ZXh0YXJlYSBhcyBkZXRlcm1pbmVkIGJ5IG1heFJvd3MuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4Um93cyA/IHRoaXMubWF4Um93cyAqIHRoaXMuX2NhY2hlZExpbmVIZWlnaHQgKyBcInB4XCIgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYWNoZVRleHRhcmVhTGluZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVRvRml0Q29udGVudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FjaGUgdGhlIGhlaWdodCBvZiBhIHNpbmdsZS1yb3cgdGV4dGFyZWEuXG4gICAgICpcbiAgICAgKiBXZSBuZWVkIHRvIGtub3cgaG93IGxhcmdlIGEgc2luZ2xlIFwicm93XCIgb2YgYSB0ZXh0YXJlYSBpcyBpbiBvcmRlciB0byBhcHBseSBtaW5Sb3dzIGFuZFxuICAgICAqIG1heFJvd3MuIEZvciB0aGUgaW5pdGlhbCB2ZXJzaW9uLCB3ZSB3aWxsIGFzc3VtZSB0aGF0IHRoZSBoZWlnaHQgb2YgYSBzaW5nbGUgbGluZSBpbiB0aGVcbiAgICAgKiB0ZXh0YXJlYSBkb2VzIG5vdCBldmVyIGNoYW5nZS5cbiAgICAgKi9cbiAgICBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLl9jYWNoZVRleHRhcmVhTGluZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRleHRhcmVhID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBVc2UgYSBjbG9uZSBlbGVtZW50IGJlY2F1c2Ugd2UgaGF2ZSB0byBvdmVycmlkZSBzb21lIHN0eWxlcy5cbiAgICAgICAgdmFyIHRleHRhcmVhQ2xvbmUgPSB0ZXh0YXJlYS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnJvd3MgPSAxO1xuICAgICAgICAvLyBVc2UgYHBvc2l0aW9uOiBhYnNvbHV0ZWAgc28gdGhhdCB0aGlzIGRvZXNuJ3QgY2F1c2UgYSBicm93c2VyIGxheW91dCBhbmQgdXNlXG4gICAgICAgIC8vIGB2aXNpYmlsaXR5OiBoaWRkZW5gIHNvIHRoYXQgbm90aGluZyBpcyByZW5kZXJlZC4gQ2xlYXIgYW55IG90aGVyIHN0eWxlcyB0aGF0XG4gICAgICAgIC8vIHdvdWxkIGFmZmVjdCB0aGUgaGVpZ2h0LlxuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHRleHRhcmVhQ2xvbmUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICAgICAgICB0ZXh0YXJlYUNsb25lLnN0eWxlLnBhZGRpbmcgPSAnJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5taW5IZWlnaHQgPSAnJztcbiAgICAgICAgdGV4dGFyZWFDbG9uZS5zdHlsZS5tYXhIZWlnaHQgPSAnJztcbiAgICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0ZXh0YXJlYUNsb25lKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkTGluZUhlaWdodCA9IHRleHRhcmVhQ2xvbmUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHRhcmVhQ2xvbmUpO1xuICAgIH07XG4gICAgLyoqIFJlc2l6ZSB0aGUgdGV4dGFyZWEgdG8gZml0IGl0cyBjb250ZW50LiAqL1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUucmVzaXplVG9GaXRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0ZXh0YXJlYSBoZWlnaHQgdG8gYXV0byBpbiBvcmRlciB0byBzaHJpbmsgYmFjayB0byBpdHMgZGVmYXVsdCBzaXplLlxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIC8vIFVzZSB0aGUgc2Nyb2xsSGVpZ2h0IHRvIGtub3cgaG93IGxhcmdlIHRoZSB0ZXh0YXJlYSAqd291bGQqIGJlIGlmIGZpdCBpdHMgZW50aXJlIHZhbHVlLlxuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSB0ZXh0YXJlYS5zY3JvbGxIZWlnaHQgKyBcInB4XCI7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDUyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MignZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRUZXh0YXJlYUF1dG9zaXplLnByb3RvdHlwZSwgXCJtaW5Sb3dzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ1MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTIoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwibWRBdXRvc2l6ZU1pblJvd3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTIoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kVGV4dGFyZWFBdXRvc2l6ZS5wcm90b3R5cGUsIFwibWF4Um93c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUyKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZFRleHRhcmVhQXV0b3NpemUucHJvdG90eXBlLCBcIm1kQXV0b3NpemVNYXhSb3dzXCIsIG51bGwpO1xuICAgIE1kVGV4dGFyZWFBdXRvc2l6ZSA9IF9fZGVjb3JhdGUkNTIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ3RleHRhcmVhW21kLWF1dG9zaXplXSwgdGV4dGFyZWFbbWRUZXh0YXJlYUF1dG9zaXplXSwnICtcbiAgICAgICAgICAgICAgICAndGV4dGFyZWFbbWF0LWF1dG9zaXplXSwgdGV4dGFyZWFbbWF0VGV4dGFyZWFBdXRvc2l6ZV0nLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZFRleHRhcmVhQXV0b3NpemUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ3Jlc2l6ZVRvRml0Q29udGVudCgpJyxcbiAgICAgICAgICAgICAgICAnW3N0eWxlLm1pbi1oZWlnaHRdJzogJ19taW5IZWlnaHQnLFxuICAgICAgICAgICAgICAgICdbc3R5bGUubWF4LWhlaWdodF0nOiAnX21heEhlaWdodCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRUZXh0YXJlYUF1dG9zaXplKTtcbiAgICByZXR1cm4gTWRUZXh0YXJlYUF1dG9zaXplO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNTAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZElucHV0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElucHV0TW9kdWxlKCkge1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBNZElucHV0TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRJbnB1dE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZElucHV0TW9kdWxlID0gX19kZWNvcmF0ZSQ1MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgTWRQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBNZElucHV0Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgIE1kSGludCxcbiAgICAgICAgICAgICAgICBNZFRleHRhcmVhQXV0b3NpemUsXG4gICAgICAgICAgICAgICAgTWRJbnB1dERpcmVjdGl2ZVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF9hbmd1bGFyX2Zvcm1zLkZvcm1zTW9kdWxlLFxuICAgICAgICAgICAgICAgIFBsYXRmb3JtTW9kdWxlLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICBNZFBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIE1kSW5wdXRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgTWRIaW50LFxuICAgICAgICAgICAgICAgIE1kVGV4dGFyZWFBdXRvc2l6ZSxcbiAgICAgICAgICAgICAgICBNZElucHV0RGlyZWN0aXZlXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRJbnB1dE1vZHVsZSk7XG4gICAgcmV0dXJuIE1kSW5wdXRNb2R1bGU7XG59KCkpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gdXNlZCB3aGVuIG9wZW5pbmcgYSBzbmFjay1iYXIuXG4gKi9cbnZhciBNZFNuYWNrQmFyQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyQ29uZmlnKCkge1xuICAgICAgICAvKiogVGhlIHBvbGl0ZW5lc3MgbGV2ZWwgZm9yIHRoZSBNZEFyaWFMaXZlQW5ub3VuY2VyIGFubm91bmNlbWVudC4gKi9cbiAgICAgICAgdGhpcy5wb2xpdGVuZXNzID0gJ2Fzc2VydGl2ZSc7XG4gICAgICAgIC8qKiBNZXNzYWdlIHRvIGJlIGFubm91bmNlZCBieSB0aGUgTWRBcmlhTGl2ZUFubm91bmNlciAqL1xuICAgICAgICB0aGlzLmFubm91bmNlbWVudE1lc3NhZ2UgPSAnJztcbiAgICAgICAgLyoqIFRoZSB2aWV3IGNvbnRhaW5lciB0byBwbGFjZSB0aGUgb3ZlcmxheSBmb3IgdGhlIHNuYWNrIGJhciBpbnRvLiAqL1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGxlbmd0aCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhdXRvbWF0aWNhbGx5IGRpc21pc3NpbmcgdGhlIHNuYWNrIGJhci4gKi9cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBNZFNuYWNrQmFyQ29uZmlnO1xufSgpKTtcblxuLy8gVE9ETyhqb3NlcGhwZXJyb3R0KTogSW1wbGVtZW50IG9uQWN0aW9uIG9ic2VydmFibGUuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIHNuYWNrIGJhciBkaXNwYXRjaGVkIGZyb20gdGhlIHNuYWNrIGJhciBzZXJ2aWNlLlxuICovXG52YXIgTWRTbmFja0JhclJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbmFja0JhclJlZihpbnN0YW5jZSwgY29udGFpbmVySW5zdGFuY2UsIF9vdmVybGF5UmVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBfb3ZlcmxheVJlZjtcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IHRoZSBzbmFjayBiYXIgaGFzIGNsb3NlZC4gKi9cbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQgPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IHRoZSBzbmFjayBiYXIgYWN0aW9uIHdhcyBjYWxsZWQuICovXG4gICAgICAgIHRoaXMuX29uQWN0aW9uID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIC8vIFNldHMgdGhlIHJlYWRvbmx5IGluc3RhbmNlIG9mIHRoZSBzbmFjayBiYXIgY29udGVudCBjb21wb25lbnQuXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuY29udGFpbmVySW5zdGFuY2UgPSBjb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgLy8gRGlzbWlzcyBzbmFja2JhciBvbiBhY3Rpb24uXG4gICAgICAgIHRoaXMub25BY3Rpb24oKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGlzbWlzcygpOyB9KTtcbiAgICAgICAgY29udGFpbmVySW5zdGFuY2UuX29uRXhpdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZmluaXNoRGlzbWlzcygpOyB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU25hY2tCYXJSZWYucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgLyoqIFRoZSBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IG1ha2luZyB1cCB0aGUgY29udGVudCBvZiB0aGUgc25hY2sgYmFyLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIERpc21pc3NlcyB0aGUgc25hY2sgYmFyLiAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWZ0ZXJDbG9zZWQuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckluc3RhbmNlLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIE1hcmtzIHRoZSBzbmFja2JhciBhY3Rpb24gY2xpY2tlZC4gKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5fYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX29uQWN0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5fb25BY3Rpb24ubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5fb25BY3Rpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIE1hcmtzIHRoZSBzbmFja2JhciBhcyBvcGVuZWQgKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hZnRlck9wZW5lZC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FmdGVyT3BlbmVkLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuX2FmdGVyT3BlbmVkLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBDbGVhbnMgdXAgdGhlIERPTSBhZnRlciBjbG9zaW5nLiAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLl9maW5pc2hEaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQubmV4dCgpO1xuICAgICAgICB0aGlzLl9hZnRlckNsb3NlZC5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgLyoqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gdGhlIHNuYWNrIGJhciBpcyBmaW5pc2hlZCBjbG9zaW5nLiAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLmFmdGVyRGlzbWlzc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWZ0ZXJDbG9zZWQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKiogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgc25hY2sgYmFyIGhhcyBvcGVuZWQgYW5kIGFwcGVhcmVkLiAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLmFmdGVyT3BlbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJJbnN0YW5jZS5fb25FbnRlcigpO1xuICAgIH07XG4gICAgLyoqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gdGhlIHNuYWNrIGJhciBhY3Rpb24gaXMgY2FsbGVkLiAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLm9uQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25BY3Rpb24uYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWRTbmFja0JhclJlZjtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMTcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBFcnJvciB0aGF0IGlzIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgc25hY2sgYmFyIHRoYXQgaXMgYWxyZWFkeSBhdHRhY2hlZC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kU25hY2tCYXJDb250ZW50QWxyZWFkeUF0dGFjaGVkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTcoTWRTbmFja0JhckNvbnRlbnRBbHJlYWR5QXR0YWNoZWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRTbmFja0JhckNvbnRlbnRBbHJlYWR5QXR0YWNoZWQoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdBdHRlbXB0aW5nIHRvIGF0dGFjaCBzbmFjayBiYXIgY29udGVudCBhZnRlciBjb250ZW50IGlzIGFscmVhZHkgYXR0YWNoZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kU25hY2tCYXJDb250ZW50QWxyZWFkeUF0dGFjaGVkO1xufShNZEVycm9yKSk7XG5cbnZhciBfX2V4dGVuZHMkMTYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkNTUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8vIFRPRE8oamVsYm91cm4pOiB3ZSBjYW4ndCB1c2UgY29uc3RhbnRzIGZyb20gYW5pbWF0aW9uLnRzIGhlcmUgYmVjYXVzZSB5b3UgY2FuJ3QgdXNlXG4vLyBhIHRleHQgaW50ZXJwb2xhdGlvbiBpbiBhbnl0aGluZyB0aGF0IGlzIGFuYWx5emVkIHN0YXRpY2FsbHkgd2l0aCBuZ2MgKGZvciBBb1QgY29tcGlsZSkuXG52YXIgU0hPV19BTklNQVRJT04gPSAnMjI1bXMgY3ViaWMtYmV6aWVyKDAuNCwwLjAsMSwxKSc7XG52YXIgSElERV9BTklNQVRJT04gPSAnMTk1bXMgY3ViaWMtYmV6aWVyKDAuMCwwLjAsMC4yLDEpJztcbi8qKlxuICogSW50ZXJuYWwgY29tcG9uZW50IHRoYXQgd3JhcHMgdXNlci1wcm92aWRlZCBzbmFjayBiYXIgY29udGVudC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kU25hY2tCYXJDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxNihNZFNuYWNrQmFyQ29udGFpbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJDb250YWluZXIoX25nWm9uZSwgX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IHRoZSBzbmFjayBiYXIgaGFzIGV4aXRlZCBmcm9tIHZpZXcuICovXG4gICAgICAgIHRoaXMub25FeGl0ID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIC8qKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhhdCB0aGUgc25hY2sgYmFyIGhhcyBmaW5pc2hlZCBlbnRlcmluZyB0aGUgdmlldy4gKi9cbiAgICAgICAgdGhpcy5vbkVudGVyID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIC8qKiBUaGUgc3RhdGUgb2YgdGhlIHNuYWNrIGJhciBhbmltYXRpb25zLiAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ2luaXRpYWwnO1xuICAgIH1cbiAgICAvKiogQXR0YWNoIGEgY29tcG9uZW50IHBvcnRhbCBhcyBjb250ZW50IHRvIHRoaXMgc25hY2sgYmFyIGNvbnRhaW5lci4gKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZFNuYWNrQmFyQ29udGVudEFscmVhZHlBdHRhY2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNuYWNrQmFyQ29uZmlnLmV4dHJhQ2xhc3Nlcykge1xuICAgICAgICAgICAgLy8gTm90IHRoZSBtb3N0IGVmZmljaWVudCB3YXkgb2YgYWRkaW5nIGNsYXNzZXMsIGJ1dCB0aGUgcmVuZGVyZXIgZG9lc24ndCBhbGxvdyB1c1xuICAgICAgICAgICAgLy8gdG8gcGFzcyBpbiBhbiBhcnJheSBvciBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0LlxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuc25hY2tCYXJDb25maWcuZXh0cmFDbGFzc2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjc3NDbGFzcyA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBjc3NDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgfTtcbiAgICAvKiogQXR0YWNoIGEgdGVtcGxhdGUgcG9ydGFsIGFzIGNvbnRlbnQgdG8gdGhpcyBzbmFjayBiYXIgY29udGFpbmVyLiAqL1xuICAgIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgLyoqIEhhbmRsZSBlbmQgb2YgYW5pbWF0aW9ucywgdXBkYXRpbmcgdGhlIHN0YXRlIG9mIHRoZSBzbmFja2Jhci4gKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5vbkFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ3ZvaWQnIHx8IGV2ZW50LnRvU3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlRXhpdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRW50ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRW50ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQmVnaW4gYW5pbWF0aW9uIG9mIHNuYWNrIGJhciBlbnRyYW5jZSBpbnRvIHZpZXcuICovXG4gICAgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSAndmlzaWJsZSc7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHJlc29sdmluZyB3aGVuIHRoZSBlbnRlciBhbmltYXRpb24gY29tcGxldGVzLiAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5fb25FbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9ICd2aXNpYmxlJztcbiAgICAgICAgcmV0dXJuIHRoaXMub25FbnRlci5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIC8qKiBCZWdpbiBhbmltYXRpb24gb2YgdGhlIHNuYWNrIGJhciBleGl0aW5nIGZyb20gdmlldy4gKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5leGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gJ2NvbXBsZXRlJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRXhpdCgpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNvbXBsZXRlcyBhZnRlciB0aGUgY2xvc2luZyBhbmltYXRpb24gaXMgZG9uZS4gKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5fb25FeGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkV4aXQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBleGl0IGNhbGxiYWNrcyBoYXZlIGJlZW4gaW52b2tlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVFeGl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIHpvbmUgdG8gc2V0dGxlIGJlZm9yZSByZW1vdmluZyB0aGUgZWxlbWVudC4gSGVscHMgcHJldmVudFxuICAgICAqIGVycm9ycyB3aGVyZSB3ZSBlbmQgdXAgcmVtb3ZpbmcgYW4gZWxlbWVudCB3aGljaCBpcyBpbiB0aGUgbWlkZGxlIG9mIGFuIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5fY29tcGxldGVFeGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9uZ1pvbmUub25NaWNyb3Rhc2tFbXB0eS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vbkV4aXQubmV4dCgpO1xuICAgICAgICAgICAgX3RoaXMub25FeGl0LmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ1NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKFBvcnRhbEhvc3REaXJlY3RpdmUpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NSgnZGVzaWduOnR5cGUnLCBQb3J0YWxIb3N0RGlyZWN0aXZlKVxuICAgIF0sIE1kU25hY2tCYXJDb250YWluZXIucHJvdG90eXBlLCBcIl9wb3J0YWxIb3N0XCIsIHZvaWQgMCk7XG4gICAgTWRTbmFja0JhckNvbnRhaW5lciA9IF9fZGVjb3JhdGUkNTUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdzbmFjay1iYXItY29udGFpbmVyJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjx0ZW1wbGF0ZSBjZGtQb3J0YWxIb3N0PjwvdGVtcGxhdGU+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2JveC1zaGFkb3c6MCAzcHggNXB4IC0xcHggcmdiYSgwLDAsMCwuMiksMCA2cHggMTBweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCAxOHB4IDAgcmdiYSgwLDAsMCwuMTIpO2JhY2tncm91bmQ6IzMyMzIzMjtib3JkZXItcmFkaXVzOjJweDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7aGVpZ2h0OjIwcHg7bWF4LXdpZHRoOjU2OHB4O21pbi13aWR0aDoyODhweDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzoxNHB4IDI0cHg7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTAwJSl9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSl7Omhvc3R7Ym9yZGVyOjFweCBzb2xpZH19XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ2FsZXJ0JyxcbiAgICAgICAgICAgICAgICAnW0BzdGF0ZV0nOiAnYW5pbWF0aW9uU3RhdGUnLFxuICAgICAgICAgICAgICAgICcoQHN0YXRlLmRvbmUpJzogJ29uQW5pbWF0aW9uRW5kKCRldmVudCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJpZ2dlcignc3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ2luaXRpYWwnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgxMDAlKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCd2aXNpYmxlJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMCUpJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ2NvbXBsZXRlJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoMTAwJSknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCd2aXNpYmxlID0+IGNvbXBsZXRlJywgX2FuZ3VsYXJfY29yZS5hbmltYXRlKEhJREVfQU5JTUFUSU9OKSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbignaW5pdGlhbCA9PiB2aXNpYmxlLCB2b2lkID0+IHZpc2libGUnLCBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoU0hPV19BTklNQVRJT04pKSxcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDU1KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLk5nWm9uZSwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZFNuYWNrQmFyQ29udGFpbmVyKTtcbiAgICByZXR1cm4gTWRTbmFja0JhckNvbnRhaW5lcjtcbn0oQmFzZVBvcnRhbEhvc3QpKTtcblxudmFyIF9fZGVjb3JhdGUkNTYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQSBjb21wb25lbnQgdXNlZCB0byBvcGVuIGFzIHRoZSBkZWZhdWx0IHNuYWNrIGJhciwgbWF0Y2hpbmcgbWF0ZXJpYWwgc3BlYy5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzbmFjayBiYXIgc2VydmljZS5cbiAqL1xudmFyIFNpbXBsZVNuYWNrQmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaW1wbGVTbmFja0JhcigpIHtcbiAgICB9XG4gICAgLyoqIERpc21pc3NlcyB0aGUgc25hY2sgYmFyLiAqL1xuICAgIFNpbXBsZVNuYWNrQmFyLnByb3RvdHlwZS5kaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNuYWNrQmFyUmVmLl9hY3Rpb24oKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVTbmFja0Jhci5wcm90b3R5cGUsIFwiaGFzQWN0aW9uXCIsIHtcbiAgICAgICAgLyoqIElmIHRoZSBhY3Rpb24gYnV0dG9uIHNob3VsZCBiZSBzaG93bi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuYWN0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTaW1wbGVTbmFja0JhciA9IF9fZGVjb3JhdGUkNTYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdzaW1wbGUtc25hY2stYmFyJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxzcGFuIGNsYXNzPVxcXCJtYXQtc2ltcGxlLXNuYWNrYmFyLW1lc3NhZ2VcXFwiPnt7bWVzc2FnZX19PC9zcGFuPiA8YnV0dG9uIGNsYXNzPVxcXCJtYXQtc2ltcGxlLXNuYWNrYmFyLWFjdGlvblxcXCIgKm5nSWY9XFxcImhhc0FjdGlvblxcXCIgKGNsaWNrKT1cXFwiZGlzbWlzcygpXFxcIj57e2FjdGlvbn19PC9idXR0b24+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjtjb2xvcjojZmZmO2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZn0ubWF0LXNpbXBsZS1zbmFja2Jhci1tZXNzYWdle3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdy14OmhpZGRlbjt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5tYXQtc2ltcGxlLXNuYWNrYmFyLWFjdGlvbntjdXJzb3I6cG9pbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7b3V0bGluZTowO2JvcmRlcjpub25lO2JhY2tncm91bmQ6MCAwO21hcmdpbjotNXB4IDAgMDtwYWRkaW5nOjVweDt0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2U7Y29sb3I6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O2ZsZXgtc2hyaW5rOjA7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtmb250LXdlaWdodDo2MDB9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXNpbXBsZS1zbmFja2Jhcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBTaW1wbGVTbmFja0Jhcik7XG4gICAgcmV0dXJuIFNpbXBsZVNuYWNrQmFyO1xufSgpKTtcblxuLyoqXG4gKiBFeHRlbmRzIGFuIG9iamVjdCB3aXRoIHRoZSAqZW51bWVyYWJsZSogYW5kICpvd24qIHByb3BlcnRpZXMgb2Ygb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMsXG4gKiBzaW1pbGFyIHRvIE9iamVjdC5hc3NpZ24uXG4gKlxuICogQHBhcmFtIGRlc3QgVGhlIG9iamVjdCB3aGljaCB3aWxsIGhhdmUgcHJvcGVydGllcyBjb3BpZWQgdG8gaXQuXG4gKiBAcGFyYW0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkLlxuICovXG5mdW5jdGlvbiBleHRlbmRPYmplY3QoZGVzdCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKGRlc3QgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfYSA9IDAsIHNvdXJjZXNfMSA9IHNvdXJjZXM7IF9hIDwgc291cmNlc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc18xW19hXTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn1cblxudmFyIF9fZGVjb3JhdGUkNTQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDExID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGRpc3BhdGNoIE1hdGVyaWFsIERlc2lnbiBzbmFjayBiYXIgbWVzc2FnZXMuXG4gKi9cbnZhciBNZFNuYWNrQmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyKF9vdmVybGF5LCBfbGl2ZSwgX3BhcmVudFNuYWNrQmFyKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fbGl2ZSA9IF9saXZlO1xuICAgICAgICB0aGlzLl9wYXJlbnRTbmFja0JhciA9IF9wYXJlbnRTbmFja0JhcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU25hY2tCYXIucHJvdG90eXBlLCBcIl9vcGVuZWRTbmFja0JhclJlZlwiLCB7XG4gICAgICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBvcGVuZWQgc25hY2tiYXIgYXQgKmFueSogbGV2ZWwuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFNuYWNrQmFyID9cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnRTbmFja0Jhci5fb3BlbmVkU25hY2tCYXJSZWYgOiB0aGlzLl9zbmFja0JhclJlZkF0VGhpc0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudFNuYWNrQmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50U25hY2tCYXIuX29wZW5lZFNuYWNrQmFyUmVmID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zbmFja0JhclJlZkF0VGhpc0xldmVsID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIGRpc3BhdGNoZXMgYSBzbmFjayBiYXIgd2l0aCBhIGN1c3RvbSBjb21wb25lbnQgZm9yIHRoZSBjb250ZW50LCByZW1vdmluZyBhbnlcbiAgICAgKiBjdXJyZW50bHkgb3BlbmVkIHNuYWNrIGJhcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCB0byBiZSBpbnN0YW50aWF0ZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZyBFeHRyYSBjb25maWd1cmF0aW9uIGZvciB0aGUgc25hY2sgYmFyLlxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLm9wZW5Gcm9tQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbmZpZyA9IF9hcHBseUNvbmZpZ0RlZmF1bHRzKGNvbmZpZyk7XG4gICAgICAgIHZhciBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB2YXIgc25hY2tCYXJDb250YWluZXIgPSB0aGlzLl9hdHRhY2hTbmFja0JhckNvbnRhaW5lcihvdmVybGF5UmVmLCBjb25maWcpO1xuICAgICAgICB2YXIgc25hY2tCYXJSZWYgPSB0aGlzLl9hdHRhY2hTbmFja2JhckNvbnRlbnQoY29tcG9uZW50LCBzbmFja0JhckNvbnRhaW5lciwgb3ZlcmxheVJlZik7XG4gICAgICAgIC8vIFdoZW4gdGhlIHNuYWNrYmFyIGlzIGRpc21pc3NlZCwgY2xlYXIgdGhlIHJlZmVyZW5jZSB0byBpdC5cbiAgICAgICAgc25hY2tCYXJSZWYuYWZ0ZXJEaXNtaXNzZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHNuYWNrYmFyIHJlZiBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlcGxhY2VkIGJ5IGEgbmV3ZXIgc25hY2tiYXIuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX29wZW5lZFNuYWNrQmFyUmVmID09IHNuYWNrQmFyUmVmKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX29wZW5lZFNuYWNrQmFyUmVmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIGEgc25hY2sgYmFyIGlzIGFscmVhZHkgaW4gdmlldywgZGlzbWlzcyBpdCBhbmQgZW50ZXIgdGhlIG5ldyBzbmFjayBiYXIgYWZ0ZXIgZXhpdFxuICAgICAgICAvLyBhbmltYXRpb24gaXMgY29tcGxldGUuXG4gICAgICAgIGlmICh0aGlzLl9vcGVuZWRTbmFja0JhclJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3BlbmVkU25hY2tCYXJSZWYuYWZ0ZXJEaXNtaXNzZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNuYWNrQmFyUmVmLmNvbnRhaW5lckluc3RhbmNlLmVudGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmLmRpc21pc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNuYWNrQmFyUmVmLmNvbnRhaW5lckluc3RhbmNlLmVudGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBkaXNtaXNzIHRpbWVvdXQgaXMgcHJvdmlkZWQsIHNldCB1cCBkaXNtaXNzIGJhc2VkIG9uIGFmdGVyIHRoZSBzbmFja2JhciBpcyBvcGVuZWQuXG4gICAgICAgIGlmIChjb25maWcuZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICBzbmFja0JhclJlZi5hZnRlck9wZW5lZCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzbmFja0JhclJlZi5kaXNtaXNzKCk7IH0sIGNvbmZpZy5kdXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saXZlLmFubm91bmNlKGNvbmZpZy5hbm5vdW5jZW1lbnRNZXNzYWdlLCBjb25maWcucG9saXRlbmVzcyk7XG4gICAgICAgIHRoaXMuX29wZW5lZFNuYWNrQmFyUmVmID0gc25hY2tCYXJSZWY7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuZWRTbmFja0JhclJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgc25hY2tiYXIgd2l0aCBhIG1lc3NhZ2UgYW5kIGFuIG9wdGlvbmFsIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzaG93IGluIHRoZSBzbmFja2Jhci5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIFRoZSBsYWJlbCBmb3IgdGhlIHNuYWNrYmFyIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gY29uZmlnIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc25hY2tiYXIuXG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBhY3Rpb24sIGNvbmZpZykge1xuICAgICAgICBpZiAoYWN0aW9uID09PSB2b2lkIDApIHsgYWN0aW9uID0gJyc7IH1cbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIGNvbmZpZy5hbm5vdW5jZW1lbnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdmFyIHNpbXBsZVNuYWNrQmFyUmVmID0gdGhpcy5vcGVuRnJvbUNvbXBvbmVudChTaW1wbGVTbmFja0JhciwgY29uZmlnKTtcbiAgICAgICAgc2ltcGxlU25hY2tCYXJSZWYuaW5zdGFuY2Uuc25hY2tCYXJSZWYgPSBzaW1wbGVTbmFja0JhclJlZjtcbiAgICAgICAgc2ltcGxlU25hY2tCYXJSZWYuaW5zdGFuY2UubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHNpbXBsZVNuYWNrQmFyUmVmLmluc3RhbmNlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgcmV0dXJuIHNpbXBsZVNuYWNrQmFyUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIHNuYWNrIGJhciBjb250YWluZXIgY29tcG9uZW50IHRvIHRoZSBvdmVybGF5LlxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9hdHRhY2hTbmFja0JhckNvbnRhaW5lciA9IGZ1bmN0aW9uIChvdmVybGF5UmVmLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoTWRTbmFja0JhckNvbnRhaW5lciwgY29uZmlnLnZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICB2YXIgY29udGFpbmVyUmVmID0gb3ZlcmxheVJlZi5hdHRhY2goY29udGFpbmVyUG9ydGFsKTtcbiAgICAgICAgY29udGFpbmVyUmVmLmluc3RhbmNlLnNuYWNrQmFyQ29uZmlnID0gY29uZmlnO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyUmVmLmluc3RhbmNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGxhY2VzIGEgbmV3IGNvbXBvbmVudCBhcyB0aGUgY29udGVudCBvZiB0aGUgc25hY2sgYmFyIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyLnByb3RvdHlwZS5fYXR0YWNoU25hY2tiYXJDb250ZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgY29udGFpbmVyLCBvdmVybGF5UmVmKSB7XG4gICAgICAgIHZhciBwb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKGNvbXBvbmVudCk7XG4gICAgICAgIHZhciBjb250ZW50UmVmID0gY29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgICAgICByZXR1cm4gbmV3IE1kU25hY2tCYXJSZWYoY29udGVudFJlZi5pbnN0YW5jZSwgY29udGFpbmVyLCBvdmVybGF5UmVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgb3ZlcmxheSBhbmQgcGxhY2VzIGl0IGluIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUkJDEgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIHN0YXRlJCQxLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuZ2xvYmFsKClcbiAgICAgICAgICAgIC5jZW50ZXJIb3Jpem9udGFsbHkoKVxuICAgICAgICAgICAgLmJvdHRvbSgnMCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5jcmVhdGUoc3RhdGUkJDEpO1xuICAgIH07XG4gICAgTWRTbmFja0JhciA9IF9fZGVjb3JhdGUkNTQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSxcbiAgICAgICAgX19wYXJhbSQxMSgyLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtJDExKDIsIF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDU0KCdkZXNpZ246cGFyYW10eXBlcycsIFtPdmVybGF5LCBMaXZlQW5ub3VuY2VyLCBNZFNuYWNrQmFyXSlcbiAgICBdLCBNZFNuYWNrQmFyKTtcbiAgICByZXR1cm4gTWRTbmFja0Jhcjtcbn0oKSk7XG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBzbmFja2JhciBjb25maWcuXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIHdoaWNoIHRoZSBkZWZhdWx0cyB3aWxsIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyBUaGUgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggZGVmYXVsdHMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gX2FwcGx5Q29uZmlnRGVmYXVsdHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGV4dGVuZE9iamVjdChuZXcgTWRTbmFja0JhckNvbmZpZygpLCBjb25maWcpO1xufVxuXG52YXIgX19kZWNvcmF0ZSQ1MyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1MyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kU25hY2tCYXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJNb2R1bGUoKSB7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIE1kU25hY2tCYXJNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFNuYWNrQmFyTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRTbmFja0Jhck1vZHVsZSA9IF9fZGVjb3JhdGUkNTMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtPdmVybGF5TW9kdWxlLCBQb3J0YWxNb2R1bGUsIF9hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kU25hY2tCYXJDb250YWluZXIsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRTbmFja0JhckNvbnRhaW5lciwgU2ltcGxlU25hY2tCYXJdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTWRTbmFja0JhckNvbnRhaW5lciwgU2ltcGxlU25hY2tCYXJdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWRTbmFja0JhciwgTElWRV9BTk5PVU5DRVJfUFJPVklERVJdXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFNuYWNrQmFyTW9kdWxlKTtcbiAgICByZXR1cm4gTWRTbmFja0Jhck1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMTggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkNTggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBVc2VkIHRvIGZsYWcgdGFiIGxhYmVscyBmb3IgdXNlIHdpdGggdGhlIHBvcnRhbCBkaXJlY3RpdmUgKi9cbnZhciBNZFRhYkxhYmVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTgoTWRUYWJMYWJlbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZFRhYkxhYmVsKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG4gICAgTWRUYWJMYWJlbCA9IF9fZGVjb3JhdGUkNTgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10YWItbGFiZWxdLCBbbWF0LXRhYi1sYWJlbF0nLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZl0pXG4gICAgXSwgTWRUYWJMYWJlbCk7XG4gICAgcmV0dXJuIE1kVGFiTGFiZWw7XG59KFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlKSk7XG5cbnZhciBfX2RlY29yYXRlJDU5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDU5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogVXNlZCBpbiB0aGUgYG1kLXRhYi1ncm91cGAgdmlldyB0byBkaXNwbGF5IHRhYiBsYWJlbHMgKi9cbnZhciBNZFRhYkxhYmVsV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJMYWJlbFdyYXBwZXIoZWxlbWVudFJlZiwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgdGFiIGxhYmVsIGlzIGRpc2FibGVkLiAgKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiTGFiZWxXcmFwcGVyLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBTZXRzIGZvY3VzIG9uIHRoZSB3cmFwcGVyIGVsZW1lbnQgKi9cbiAgICBNZFRhYkxhYmVsV3JhcHBlci5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpO1xuICAgIH07XG4gICAgTWRUYWJMYWJlbFdyYXBwZXIucHJvdG90eXBlLmdldE9mZnNldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgIH07XG4gICAgTWRUYWJMYWJlbFdyYXBwZXIucHJvdG90eXBlLmdldE9mZnNldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDU5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1OSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUYWJMYWJlbFdyYXBwZXIucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIE1kVGFiTGFiZWxXcmFwcGVyID0gX19kZWNvcmF0ZSQ1OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXRhYi1sYWJlbC13cmFwcGVyXSwgW21hdC10YWItbGFiZWwtd3JhcHBlcl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1OSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFRhYkxhYmVsV3JhcHBlcik7XG4gICAgcmV0dXJuIE1kVGFiTGFiZWxXcmFwcGVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNjEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBUaGUgaW5rLWJhciBpcyB1c2VkIHRvIGRpc3BsYXkgYW5kIGFuaW1hdGUgdGhlIGxpbmUgdW5kZXJuZWF0aCB0aGUgY3VycmVudCBhY3RpdmUgdGFiIGxhYmVsLiAqL1xudmFyIE1kSW5rQmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElua0JhcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHN0eWxlcyBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIG9yZGVyIHRvIGFsaWduIHRoZSBpbmstYmFyIHRvIHRoYXQgZWxlbWVudC5cbiAgICAgKiBTaG93cyB0aGUgaW5rIGJhciBpZiBwcmV2aW91c2x5IHNldCBhcyBoaWRkZW4uXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuYWxpZ25Ub0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2xlZnQnLCB0aGlzLl9nZXRMZWZ0UG9zaXRpb24oZWxlbWVudCkpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCB0aGlzLl9nZXRFbGVtZW50V2lkdGgoZWxlbWVudCkpO1xuICAgIH07XG4gICAgLyoqIFNob3dzIHRoZSBpbmsgYmFyLiAqL1xuICAgIE1kSW5rQmFyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgfTtcbiAgICAvKiogSGlkZXMgdGhlIGluayBiYXIuICovXG4gICAgTWRJbmtCYXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBwaXhlbCBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIHN0cmluZyBmb3JtYXQuXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuX2dldExlZnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vZmZzZXRMZWZ0ICsgJ3B4JyA6ICcwJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcGl4ZWwgd2lkdGggZnJvbSB0aGUgcHJvdmlkZWQgZWxlbWVudCBpbiBzdHJpbmcgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICovXG4gICAgTWRJbmtCYXIucHJvdG90eXBlLl9nZXRFbGVtZW50V2lkdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggKyAncHgnIDogJzAnO1xuICAgIH07XG4gICAgTWRJbmtCYXIgPSBfX2RlY29yYXRlJDYxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1pbmstYmFyLCBtYXQtaW5rLWJhcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtaW5rLWJhcl0nOiAndHJ1ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRJbmtCYXIpO1xuICAgIHJldHVybiBNZElua0Jhcjtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMTkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkNjAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogTmF2aWdhdGlvbiBjb21wb25lbnQgbWF0Y2hpbmcgdGhlIHN0eWxlcyBvZiB0aGUgdGFiIGdyb3VwIGhlYWRlci5cbiAqIFByb3ZpZGVzIGFuY2hvcmVkIG5hdmlnYXRpb24gd2l0aCBhbmltYXRlZCBpbmsgYmFyLlxuICovXG52YXIgTWRUYWJOYXZCYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFiTmF2QmFyKCkge1xuICAgIH1cbiAgICAvKiogTm90aWZpZXMgdGhlIGNvbXBvbmVudCB0aGF0IHRoZSBhY3RpdmUgbGluayBoYXMgYmVlbiBjaGFuZ2VkLiAqL1xuICAgIE1kVGFiTmF2QmFyLnByb3RvdHlwZS51cGRhdGVBY3RpdmVMaW5rID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlTGlua0NoYW5nZWQgPSB0aGlzLl9hY3RpdmVMaW5rRWxlbWVudCAhPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9hY3RpdmVMaW5rRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKiogQ2hlY2tzIGlmIHRoZSBhY3RpdmUgbGluayBoYXMgYmVlbiBjaGFuZ2VkIGFuZCwgaWYgc28sIHdpbGwgdXBkYXRlIHRoZSBpbmsgYmFyLiAqL1xuICAgIE1kVGFiTmF2QmFyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVMaW5rQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5faW5rQmFyLmFsaWduVG9FbGVtZW50KHRoaXMuX2FjdGl2ZUxpbmtFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGlua0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ2MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKE1kSW5rQmFyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjAoJ2Rlc2lnbjp0eXBlJywgTWRJbmtCYXIpXG4gICAgXSwgTWRUYWJOYXZCYXIucHJvdG90eXBlLCBcIl9pbmtCYXJcIiwgdm9pZCAwKTtcbiAgICBNZFRhYk5hdkJhciA9IF9fZGVjb3JhdGUkNjAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdbbWQtdGFiLW5hdi1iYXJdLCBbbWF0LXRhYi1uYXYtYmFyXScsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWxpbmtzXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PG1kLWluay1iYXI+PC9tZC1pbmstYmFyPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXRhYi1saW5rLC5tYXQtdGFiLW5hdi1iYXJ7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS5tYXQtdGFiLW5hdi1iYXJ7ZmxleC1zaHJpbms6MH0ubWF0LXRhYi1saW5rc3tkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmV9Lm1hdC10YWItbGlua3tsaW5lLWhlaWdodDo0OHB4O2hlaWdodDo0OHB4O3BhZGRpbmc6MCAxMnB4O2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NTAwO2N1cnNvcjpwb2ludGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveDtjb2xvcjpjdXJyZW50Q29sb3I7b3BhY2l0eTouNjttaW4td2lkdGg6MTYwcHg7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC1kZWNvcmF0aW9uOm5vbmV9Lm1hdC10YWItbGluazpmb2N1c3tvdXRsaW5lOjA7b3BhY2l0eToxfUBtZWRpYSAobWF4LXdpZHRoOjYwMHB4KXsubWF0LXRhYi1saW5re21pbi13aWR0aDo3MnB4fX0ubWF0LWluay1iYXJ7cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7aGVpZ2h0OjJweDt0cmFuc2l0aW9uOi41cyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpfS5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlciAubWF0LWluay1iYXJ7Ym90dG9tOmF1dG87dG9wOjB9XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1uYXYtYmFyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFRhYk5hdkJhcik7XG4gICAgcmV0dXJuIE1kVGFiTmF2QmFyO1xufSgpKTtcbi8qKlxuICogTGluayBpbnNpZGUgb2YgYSBgbWQtdGFiLW5hdi1iYXJgLlxuICovXG52YXIgTWRUYWJMaW5rID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYkxpbmsoX21kVGFiTmF2QmFyLCBfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9tZFRhYk5hdkJhciA9IF9tZFRhYk5hdkJhcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJMaW5rLnByb3RvdHlwZSwgXCJhY3RpdmVcIiwge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgbGluayBpcyBhY3RpdmUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faXNBY3RpdmU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWRUYWJOYXZCYXIudXBkYXRlQWN0aXZlTGluayh0aGlzLl9lbGVtZW50UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX19kZWNvcmF0ZSQ2MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjAoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFRhYkxpbmsucHJvdG90eXBlLCBcImFjdGl2ZVwiLCBudWxsKTtcbiAgICBNZFRhYkxpbmsgPSBfX2RlY29yYXRlJDYwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtdGFiLWxpbmtdLCBbbWF0LXRhYi1saW5rXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWxpbmtdJzogJ3RydWUnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW01kVGFiTmF2QmFyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kVGFiTGluayk7XG4gICAgcmV0dXJuIE1kVGFiTGluaztcbn0oKSk7XG4vKipcbiAqIFNpbXBsZSBkaXJlY3RpdmUgdGhhdCBleHRlbmRzIHRoZSByaXBwbGUgYW5kIG1hdGNoZXMgdGhlIHNlbGVjdG9yIG9mIHRoZSBNZFRhYkxpbmsuIFRoaXNcbiAqIGFkZHMgdGhlIHJpcHBsZSBiZWhhdmlvciB0byBuYXYgYmFyIGxhYmVscy5cbiAqL1xudmFyIE1kVGFiTGlua1JpcHBsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDE5KE1kVGFiTGlua1JpcHBsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZFRhYkxpbmtSaXBwbGUoZWxlbWVudFJlZiwgbmdab25lLCBydWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtZW50UmVmLCBuZ1pvbmUsIHJ1bGVyKTtcbiAgICB9XG4gICAgTWRUYWJMaW5rUmlwcGxlID0gX19kZWNvcmF0ZSQ2MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXRhYi1saW5rXSwgW21hdC10YWItbGlua10nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1saW5rXSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLk5nWm9uZSwgVmlld3BvcnRSdWxlcl0pXG4gICAgXSwgTWRUYWJMaW5rUmlwcGxlKTtcbiAgICByZXR1cm4gTWRUYWJMaW5rUmlwcGxlO1xufShNZFJpcHBsZSkpO1xuXG52YXIgX19kZWNvcmF0ZSQ2MiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2MiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kVGFiID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYihfdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIC8qKiBUaGUgcGxhaW4gdGV4dCBsYWJlbCBmb3IgdGhlIHRhYiwgdXNlZCB3aGVuIHRoZXJlIGlzIG5vIHRlbXBsYXRlIGxhYmVsLiAqL1xuICAgICAgICB0aGlzLnRleHRMYWJlbCA9ICcnO1xuICAgICAgICAvKiogVGhlIHBvcnRhbCB0aGF0IHdpbGwgYmUgdGhlIGhvc3RlZCBjb250ZW50IG9mIHRoZSB0YWIgKi9cbiAgICAgICAgdGhpcy5fY29udGVudFBvcnRhbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVsYXRpdmVseSBpbmRleGVkIHBvc2l0aW9uIHdoZXJlIDAgcmVwcmVzZW50cyB0aGUgY2VudGVyLCBuZWdhdGl2ZSBpcyBsZWZ0LCBhbmQgcG9zaXRpdmVcbiAgICAgICAgICogcmVwcmVzZW50cyB0aGUgcmlnaHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbml0aWFsIHJlbGF0aXZlbHkgaW5kZXggb3JpZ2luIG9mIHRoZSB0YWIgaWYgaXQgd2FzIGNyZWF0ZWQgYW5kIHNlbGVjdGVkIGFmdGVyIHRoZXJlXG4gICAgICAgICAqIHdhcyBhbHJlYWR5IGEgc2VsZWN0ZWQgdGFiLiBQcm92aWRlcyBjb250ZXh0IG9mIHdoYXQgcG9zaXRpb24gdGhlIHRhYiBzaG91bGQgb3JpZ2luYXRlIGZyb20uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYi5wcm90b3R5cGUsIFwiY29udGVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udGVudFBvcnRhbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7IH0sXG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0YWIgaXMgZGlzYWJsZWQgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFRhYi5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRQb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5fY29udGVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDYyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGQoTWRUYWJMYWJlbCksIFxuICAgICAgICBfX21ldGFkYXRhJDYyKCdkZXNpZ246dHlwZScsIE1kVGFiTGFiZWwpXG4gICAgXSwgTWRUYWIucHJvdG90eXBlLCBcInRlbXBsYXRlTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiksIFxuICAgICAgICBfX21ldGFkYXRhJDYyKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYpXG4gICAgXSwgTWRUYWIucHJvdG90eXBlLCBcIl9jb250ZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2xhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDYyKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFRhYi5wcm90b3R5cGUsIFwidGV4dExhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2MihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjIoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbiksIFxuICAgICAgICBfX21ldGFkYXRhJDYyKCdkZXNpZ246cGFyYW10eXBlcycsIFtCb29sZWFuXSlcbiAgICBdLCBNZFRhYi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRUYWIgPSBfX2RlY29yYXRlJDYyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdGFiLCBtYXQtdGFiJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjx0ZW1wbGF0ZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC90ZW1wbGF0ZT5cIixcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDYyKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWZdKVxuICAgIF0sIE1kVGFiKTtcbiAgICByZXR1cm4gTWRUYWI7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ2MyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2MyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTIgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFdyYXBwZXIgZm9yIHRoZSBjb250ZW50cyBvZiBhIHRhYi5cbiAqL1xudmFyIE1kVGFiQm9keSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJCb2R5KF9kaXIsIF9lbGVtZW50UmVmLCBfY2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdGFiIGJlZ2lucyB0byBhbmltYXRlIHRvd2FyZHMgdGhlIGNlbnRlciBhcyB0aGUgYWN0aXZlIHRhYi4gKi9cbiAgICAgICAgdGhpcy5vbkNlbnRlcmluZyA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSB0YWIgY29tcGxldGVzIGl0cyBhbmltYXRpb24gdG93YXJkcyB0aGUgY2VudGVyLiAqL1xuICAgICAgICB0aGlzLm9uQ2VudGVyZWQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGFsbG93ZWQgdG8gYmUgYW5pbWF0ZWQuICovXG4gICAgICAgIHRoaXMuX2NhbkJlQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiQm9keS5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCkgPT0gJ2x0cicgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAnbHRyJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJCb2R5LnByb3RvdHlwZSwgXCJvcmlnaW5cIiwge1xuICAgICAgICAvKiogVGhlIG9yaWdpbiBwb3NpdGlvbiBmcm9tIHdoaWNoIHRoaXMgdGFiIHNob3VsZCBhcHBlYXIgd2hlbiBpdCBpcyBjZW50ZXJlZCBpbnRvIHZpZXcuICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG9yaWdpbikge1xuICAgICAgICAgICAgaWYgKG9yaWdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpciA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKChkaXIgPT0gJ2x0cicgJiYgb3JpZ2luIDw9IDApIHx8IChkaXIgPT0gJ3J0bCcgJiYgb3JpZ2luID4gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSAnbGVmdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSAncmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZnRlciBpbml0aWFsaXplZCwgY2hlY2sgaWYgdGhlIGNvbnRlbnQgaXMgY2VudGVyZWQgYW5kIGhhcyBhbiBvcmlnaW4uIElmIHNvLCBzZXQgdGhlXG4gICAgICogc3BlY2lhbCBwb3NpdGlvbiBzdGF0ZXMgdGhhdCB0cmFuc2l0aW9uIHRoZSB0YWIgZnJvbSB0aGUgbGVmdCBvciByaWdodCBiZWZvcmUgY2VudGVyaW5nLlxuICAgICAqL1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbiA9PSAnY2VudGVyJyAmJiB0aGlzLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fb3JpZ2luID09ICdsZWZ0JyA/ICdsZWZ0LW9yaWdpbi1jZW50ZXInIDogJ3JpZ2h0LW9yaWdpbi1jZW50ZXInO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZnRlciB0aGUgdmlldyBoYXMgYmVlbiBzZXQsIGNoZWNrIGlmIHRoZSB0YWIgY29udGVudCBpcyBzZXQgdG8gdGhlIGNlbnRlciBhbmQgYXR0YWNoIHRoZVxuICAgICAqIGNvbnRlbnQgaWYgaXQgaXMgbm90IGFscmVhZHkgYXR0YWNoZWQuXG4gICAgICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5uZ0FmdGVyVmlld0NoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NlbnRlclBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKSAmJiAhdGhpcy5fcG9ydGFsSG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWZ0ZXIgdGhlIGNvbnRlbnQgaGFzIGJlZW4gY2hlY2tlZCwgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBiZSBhbGxvd2VkIHRvXG4gICAgICogYW5pbWF0ZS4gVGhpcyBoYXMgdG8gYmUgbGltaXRlZCwgYmVjYXVzZSB1bmRlciBhIHNwZWNpZmljIHNldCBvZiBjaXJjdW1zdGFuY2VzIChzZWUgIzIxNTEpLFxuICAgICAqIHRoZSBhbmltYXRpb25zIGNhbiBiZSB0cmlnZ2VyZWQgdG9vIGVhcmx5LCB3aGljaCBlaXRoZXIgY3Jhc2hlcyBDaHJvbWUgYnkgcHV0dGluZyBpdCBpbnRvIGFuXG4gICAgICogaW5maW5pdGUgbG9vcCAod2l0aCBBbmd1bGFyIDwgMi4zLjApIG9yIHRocm93cyBhbiBlcnJvciBiZWNhdXNlIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhXG4gICAgICogY29tcHV0ZWQgc3R5bGUgKHdpdGggQW5ndWxhciA+IDIuMy4wKS4gVGhpcyBjYW4gYWx0ZXJuYXRpdmVseSBiZSBkZXRlcm1pbmVkIGJ5IGNoZWNraW5nIHRoZVxuICAgICAqIHRyYW5zZm9ybTogY2FuQmVBbmltYXRlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkgIT09ICcnLCBob3dldmVyIGRvY3VtZW50LmNvbnRhaW5zIHNob3VsZFxuICAgICAqIGJlIGZhc3RlciBzaW5jZSBpdCBkb2Vzbid0IGNhdXNlIGEgcmVmbG93LlxuICAgICAqXG4gICAgICogVE9ETzogVGhpcyBjYW4gc2FmZWx5IGJlIHJlbW92ZWQgYWZ0ZXIgd2Ugc3RvcCBzdXBwb3J0aW5nIEFuZ3VsYXIgPCAyLjQuMi4gVGhlIGZpeCBsYW5kZWQgdmlhXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9jb21taXQvMjEwMzBlOWExY2YzMGU4MTAxMzk5ZDg1MzVlZDcyZDg0N2EyM2JhNlxuICAgICAqL1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbkJlQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbkJlQW5pbWF0ZWQgPSBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FuQmVBbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLl9vblRyYW5zbGF0ZVRhYlN0YXJ0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faXNDZW50ZXJQb3NpdGlvbihlLnRvU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2VudGVyaW5nLmVtaXQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kVGFiQm9keS5wcm90b3R5cGUuX29uVHJhbnNsYXRlVGFiQ29tcGxldGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBJZiB0aGUgZW5kIHN0YXRlIGlzIHRoYXQgdGhlIHRhYiBpcyBub3QgY2VudGVyZWQsIHRoZW4gZGV0YWNoIHRoZSBjb250ZW50LlxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2VudGVyUG9zaXRpb24oZS50b1N0YXRlKSAmJiAhdGhpcy5faXNDZW50ZXJQb3NpdGlvbih0aGlzLl9wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnRhbEhvc3QuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHRyYW5zaXRpb24gdG8gdGhlIGNlbnRlciBpcyBjb21wbGV0ZSwgZW1pdCBhbiBldmVudC5cbiAgICAgICAgaWYgKHRoaXMuX2lzQ2VudGVyUG9zaXRpb24oZS50b1N0YXRlKSAmJiB0aGlzLl9pc0NlbnRlclBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5vbkNlbnRlcmVkLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXG4gICAgTWRUYWJCb2R5LnByb3RvdHlwZS5fZ2V0TGF5b3V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xuICAgIH07XG4gICAgLyoqIFdoZXRoZXIgdGhlIHByb3ZpZGVkIHBvc2l0aW9uIHN0YXRlIGlzIGNvbnNpZGVyZWQgY2VudGVyLCByZWdhcmRsZXNzIG9mIG9yaWdpbi4gKi9cbiAgICBNZFRhYkJvZHkucHJvdG90eXBlLl9pc0NlbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbiA9PSAnY2VudGVyJyB8fFxuICAgICAgICAgICAgcG9zaXRpb24gPT0gJ2xlZnQtb3JpZ2luLWNlbnRlcicgfHxcbiAgICAgICAgICAgIHBvc2l0aW9uID09ICdyaWdodC1vcmlnaW4tY2VudGVyJztcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZChQb3J0YWxIb3N0RGlyZWN0aXZlKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjMoJ2Rlc2lnbjp0eXBlJywgUG9ydGFsSG9zdERpcmVjdGl2ZSlcbiAgICBdLCBNZFRhYkJvZHkucHJvdG90eXBlLCBcIl9wb3J0YWxIb3N0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDYzKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKVxuICAgIF0sIE1kVGFiQm9keS5wcm90b3R5cGUsIFwib25DZW50ZXJpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDYzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjMoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgTWRUYWJCb2R5LnByb3RvdHlwZSwgXCJvbkNlbnRlcmVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2NvbnRlbnQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjMoJ2Rlc2lnbjp0eXBlJywgVGVtcGxhdGVQb3J0YWwpXG4gICAgXSwgTWRUYWJCb2R5LnByb3RvdHlwZSwgXCJfY29udGVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdwb3NpdGlvbicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnR5cGUnLCBOdW1iZXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbTnVtYmVyXSlcbiAgICBdLCBNZFRhYkJvZHkucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdvcmlnaW4nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjMoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW051bWJlcl0pXG4gICAgXSwgTWRUYWJCb2R5LnByb3RvdHlwZSwgXCJvcmlnaW5cIiwgbnVsbCk7XG4gICAgTWRUYWJCb2R5ID0gX19kZWNvcmF0ZSQ2MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXRhYi1ib2R5LCBtYXQtdGFiLWJvZHknLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRhYi1ib2R5LWNvbnRlbnRcXFwiICNjb250ZW50IFtAdHJhbnNsYXRlVGFiXT1cXFwiX2NhbkJlQW5pbWF0ZWQgPyBfcG9zaXRpb24gOiBudWxsXFxcIiAoQHRyYW5zbGF0ZVRhYi5zdGFydCk9XFxcIl9vblRyYW5zbGF0ZVRhYlN0YXJ0ZWQoJGV2ZW50KVxcXCIgKEB0cmFuc2xhdGVUYWIuZG9uZSk9XFxcIl9vblRyYW5zbGF0ZVRhYkNvbXBsZXRlKCRldmVudClcXFwiPjx0ZW1wbGF0ZSBjZGtQb3J0YWxIb3N0PjwvdGVtcGxhdGU+PC9kaXY+XCIsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWJvZHldJzogJ3RydWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnRyaWdnZXIoJ3RyYW5zbGF0ZVRhYicsIFtcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnbGVmdCcsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnbGVmdC1vcmlnaW4tY2VudGVyJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ3JpZ2h0LW9yaWdpbi1jZW50ZXInLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnY2VudGVyJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ3JpZ2h0JywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbignKiA9PiBsZWZ0LCAqID0+IHJpZ2h0LCBsZWZ0ID0+IGNlbnRlciwgcmlnaHQgPT4gY2VudGVyJywgX2FuZ3VsYXJfY29yZS5hbmltYXRlKCc1MDBtcyBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSknKSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbigndm9pZCA9PiBsZWZ0LW9yaWdpbi1jZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuYW5pbWF0ZSgnNTAwbXMgY3ViaWMtYmV6aWVyKDAuMzUsIDAsIDAuMjUsIDEpJylcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbigndm9pZCA9PiByaWdodC1vcmlnaW4tY2VudGVyJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuYW5pbWF0ZSgnNTAwbXMgY3ViaWMtYmV6aWVyKDAuMzUsIDAsIDAuMjUsIDEpJylcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQxMigwLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbRGlyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuICAgIF0sIE1kVGFiQm9keSk7XG4gICAgcmV0dXJuIE1kVGFiQm9keTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDY0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxMyA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogVGhlIGRpc3RhbmNlIGluIHBpeGVscyB0aGF0IHdpbGwgYmUgb3ZlcnNob3Qgd2hlbiBzY3JvbGxpbmcgYSB0YWIgbGFiZWwgaW50byB2aWV3LiBUaGlzIGhlbHBzXG4gKiBwcm92aWRlIGEgc21hbGwgYWZmb3JkYW5jZSB0byB0aGUgbGFiZWwgbmV4dCB0byBpdC5cbiAqL1xudmFyIEVYQUdHRVJBVEVEX09WRVJTQ1JPTEwgPSA2MDtcbi8qKlxuICogVGhlIGhlYWRlciBvZiB0aGUgdGFiIGdyb3VwIHdoaWNoIGRpc3BsYXlzIGEgbGlzdCBvZiBhbGwgdGhlIHRhYnMgaW4gdGhlIHRhYiBncm91cC4gSW5jbHVkZXNcbiAqIGFuIGluayBiYXIgdGhhdCBmb2xsb3dzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFiLiBXaGVuIHRoZSB0YWJzIGxpc3QncyB3aWR0aCBleGNlZWRzIHRoZVxuICogd2lkdGggb2YgdGhlIGhlYWRlciBjb250YWluZXIsIHRoZW4gYXJyb3dzIHdpbGwgYmUgZGlzcGxheWVkIHRvIGFsbG93IHRoZSB1c2VyIHRvIHNjcm9sbFxuICogbGVmdCBhbmQgcmlnaHQgYWNyb3NzIHRoZSBoZWFkZXIuXG4gKi9cbnZhciBNZFRhYkhlYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJIZWFkZXIoX3pvbmUsIF9lbGVtZW50UmVmLCBfZGlyKSB7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICAvKiogVGhlIHRhYiBpbmRleCB0aGF0IGlzIGZvY3VzZWQuICovXG4gICAgICAgIHRoaXMuX2ZvY3VzSW5kZXggPSAwO1xuICAgICAgICAvKiogVGhlIGRpc3RhbmNlIGluIHBpeGVscyB0aGF0IHRoZSB0YWIgbGFiZWxzIHNob3VsZCBiZSB0cmFuc2xhdGVkIHRvIHRoZSBsZWZ0LiAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxEaXN0YW5jZSA9IDA7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBoZWFkZXIgc2hvdWxkIHNjcm9sbCB0byB0aGUgc2VsZWN0ZWQgaW5kZXggYWZ0ZXIgdGhlIHZpZXcgaGFzIGJlZW4gY2hlY2tlZC4gKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGNvbnRyb2xzIGZvciBwYWdpbmF0aW9uIHNob3VsZCBiZSBkaXNwbGF5ZWQgKi9cbiAgICAgICAgdGhpcy5fc2hvd1BhZ2luYXRpb25Db250cm9scyA9IGZhbHNlO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgdGFiIGxpc3QgY2FuIGJlIHNjcm9sbGVkIG1vcmUgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSB0YWIgbGFiZWwgbGlzdC4gKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZVNjcm9sbEFmdGVyID0gdHJ1ZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHRhYiBsaXN0IGNhbiBiZSBzY3JvbGxlZCBtb3JlIHRvd2FyZHMgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGFiIGxhYmVsIGxpc3QuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVTY3JvbGxCZWZvcmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkLiAqL1xuICAgICAgICB0aGlzLnNlbGVjdEZvY3VzZWRJbmRleCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIGEgbGFiZWwgaXMgZm9jdXNlZC4gKi9cbiAgICAgICAgdGhpcy5pbmRleEZvY3VzZWQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4OyB9LFxuICAgICAgICAvKiogVGhlIGluZGV4IG9mIHRoZSBhY3RpdmUgdGFiLiAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQgPSB0aGlzLl9zZWxlY3RlZEluZGV4ICE9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNJbmRleCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiB0aGUgbnVtYmVyIG9mIHRhYiBsYWJlbHMgaGF2ZSBjaGFuZ2VkLCBjaGVjayBpZiBzY3JvbGxpbmcgc2hvdWxkIGJlIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuX3RhYkxhYmVsQ291bnQgIT0gdGhpcy5fbGFiZWxXcmFwcGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2luYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX3RhYkxhYmVsQ291bnQgPSB0aGlzLl9sYWJlbFdyYXBwZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0ZWQgaW5kZXggaGFzIGNoYW5nZWQsIHNjcm9sbCB0byB0aGUgbGFiZWwgYW5kIGNoZWNrIGlmIHRoZSBzY3JvbGxpbmcgY29udHJvbHNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGRpc2FibGVkLlxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvTGFiZWwodGhpcy5fc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Njcm9sbGluZ0NvbnRyb2xzKCk7XG4gICAgICAgICAgICB0aGlzLl9hbGlnbklua0JhclRvU2VsZWN0ZWRUYWIoKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXhDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNjcm9sbCBkaXN0YW5jZSBoYXMgYmVlbiBjaGFuZ2VkICh0YWIgc2VsZWN0ZWQsIGZvY3VzZWQsIHNjcm9sbCBjb250cm9scyBhY3RpdmF0ZWQpLFxuICAgICAgICAvLyB0aGVuIHRyYW5zbGF0ZSB0aGUgaGVhZGVyIHRvIHJlZmxlY3QgdGhpcy5cbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbERpc3RhbmNlQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGFiU2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzTmV4dFRhYigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzUHJldmlvdXNUYWIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRU5URVI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RGb2N1c2VkSW5kZXguZW1pdCh0aGlzLmZvY3VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGlnbnMgdGhlIGluayBiYXIgdG8gdGhlIHNlbGVjdGVkIHRhYiBvbiBsb2FkLlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FsaWduSW5rQmFyVG9TZWxlY3RlZFRhYigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIE11dGF0aW9uT2JzZXJ2ZXIgZGV0ZWN0cyB0aGF0IHRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fb25Db250ZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpO1xuICAgICAgICB0aGlzLl9hbGlnbklua0JhclRvU2VsZWN0ZWRUYWIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0aW5nIHRoZSB2aWV3IHdoZXRoZXIgcGFnaW5hdGlvbiBzaG91bGQgYmUgZW5hYmxlZCBvciBub3RcbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX3VwZGF0ZVBhZ2luYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUGFnaW5hdGlvbkVuYWJsZWQoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tTY3JvbGxpbmdDb250cm9scygpO1xuICAgICAgICB0aGlzLl91cGRhdGVUYWJTY3JvbGxQb3NpdGlvbigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJmb2N1c0luZGV4XCIsIHtcbiAgICAgICAgLyoqIFRyYWNrcyB3aGljaCBlbGVtZW50IGhhcyBmb2N1czsgdXNlZCBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvbiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2ZvY3VzSW5kZXg7IH0sXG4gICAgICAgIC8qKiBXaGVuIHRoZSBmb2N1cyBpbmRleCBpcyBzZXQsIHdlIG11c3QgbWFudWFsbHkgc2VuZCBmb2N1cyB0byB0aGUgY29ycmVjdCBsYWJlbCAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkSW5kZXgodmFsdWUpIHx8IHRoaXMuX2ZvY3VzSW5kZXggPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0luZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmluZGV4Rm9jdXNlZC5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRhYkZvY3VzKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBpbmRleCBpcyB2YWxpZC4gIElmIHRoZSB0YWJzIGFyZSBub3QgcmVhZHkgeWV0LCB3ZSBhc3N1bWUgdGhhdCB0aGUgdXNlciBpc1xuICAgICAqIHByb3ZpZGluZyBhIHZhbGlkIGluZGV4IGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2lzVmFsaWRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhYmVsV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWIgPSB0aGlzLl9sYWJlbFdyYXBwZXJzID8gdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRhYiAmJiAhdGFiLmRpc2FibGVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBmb2N1cyBvbiB0aGUgSFRNTCBlbGVtZW50IGZvciB0aGUgbGFiZWwgd3JhcHBlciBhbmQgc2Nyb2xscyBpdCBpbnRvIHRoZSB2aWV3IGlmXG4gICAgICogc2Nyb2xsaW5nIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9zZXRUYWJGb2N1cyA9IGZ1bmN0aW9uICh0YWJJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5fc2hvd1BhZ2luYXRpb25Db250cm9scykge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9MYWJlbCh0YWJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsV3JhcHBlcnMgJiYgdGhpcy5fbGFiZWxXcmFwcGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsV3JhcHBlcnMudG9BcnJheSgpW3RhYkluZGV4XS5mb2N1cygpO1xuICAgICAgICAgICAgLy8gRG8gbm90IGxldCB0aGUgYnJvd3NlciBtYW5hZ2Ugc2Nyb2xsaW5nIHRvIGZvY3VzIHRoZSBlbGVtZW50LCB0aGlzIHdpbGwgYmUgaGFuZGxlZFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgdHJhbnNsYXRpb24uIEluIExUUiwgdGhlIHNjcm9sbCBsZWZ0IHNob3VsZCBiZSAwLiBJbiBSVEwsIHRoZSBzY3JvbGwgd2lkdGhcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSB0aGUgZnVsbCB3aWR0aCBtaW51cyB0aGUgb2Zmc2V0IHdpZHRoLlxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckVsID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgdmFyIGRpciA9IHRoaXMuX2dldExheW91dERpcmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGRpciA9PSAnbHRyJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLnNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwuc2Nyb2xsTGVmdCA9IGNvbnRhaW5lckVsLnNjcm9sbFdpZHRoIC0gY29udGFpbmVyRWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBmb2N1cyB0b3dhcmRzIHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZCBvZiB0aGUgbGlzdCBkZXBlbmRpbmcgb24gdGhlIG9mZnNldCBwcm92aWRlZC5cbiAgICAgKiBWYWxpZCBvZmZzZXRzIGFyZSAxIGFuZCAtMS5cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX21vdmVGb2N1cyA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhYmVsV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHZhciB0YWJzID0gdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5mb2N1c0luZGV4ICsgb2Zmc2V0OyBpIDwgdGFicy5sZW5ndGggJiYgaSA+PSAwOyBpICs9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1c0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEluY3JlbWVudCB0aGUgZm9jdXMgaW5kZXggYnkgMSB1bnRpbCBhIHZhbGlkIHRhYiBpcyBmb3VuZC4gKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2ZvY3VzTmV4dFRhYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW92ZUZvY3VzKHRoaXMuX2dldExheW91dERpcmVjdGlvbigpID09ICdsdHInID8gMSA6IC0xKTtcbiAgICB9O1xuICAgIC8qKiBEZWNyZW1lbnQgdGhlIGZvY3VzIGluZGV4IGJ5IDEgdW50aWwgYSB2YWxpZCB0YWIgaXMgZm91bmQuICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9mb2N1c1ByZXZpb3VzVGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3ZlRm9jdXModGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCkgPT0gJ2x0cicgPyAtMSA6IDEpO1xuICAgIH07XG4gICAgLyoqIFRoZSBsYXlvdXQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC4gKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2dldExheW91dERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpciAmJiB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9O1xuICAgIC8qKiBQZXJmb3JtcyB0aGUgQ1NTIHRyYW5zZm9ybWF0aW9uIG9uIHRoZSB0YWIgbGlzdCB0aGF0IHdpbGwgY2F1c2UgdGhlIGxpc3QgdG8gc2Nyb2xsLiAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fdXBkYXRlVGFiU2Nyb2xsUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGVYID0gdGhpcy5zY3JvbGxEaXN0YW5jZSArICdweCc7XG4gICAgICAgIGlmICh0aGlzLl9nZXRMYXlvdXREaXJlY3Rpb24oKSA9PSAnbHRyJykge1xuICAgICAgICAgICAgdHJhbnNsYXRlWCA9ICctJyArIHRyYW5zbGF0ZVg7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlDc3NUcmFuc2Zvcm0odGhpcy5fdGFiTGlzdC5uYXRpdmVFbGVtZW50LCBcInRyYW5zbGF0ZTNkKFwiICsgdHJhbnNsYXRlWCArIFwiLCAwLCAwKVwiKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkhlYWRlci5wcm90b3R5cGUsIFwic2Nyb2xsRGlzdGFuY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Njcm9sbERpc3RhbmNlOyB9LFxuICAgICAgICAvKiogU2V0cyB0aGUgZGlzdGFuY2UgaW4gcGl4ZWxzIHRoYXQgdGhlIHRhYiBoZWFkZXIgc2hvdWxkIGJlIHRyYW5zZm9ybWVkIGluIHRoZSBYLWF4aXMuICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fZ2V0TWF4U2Nyb2xsRGlzdGFuY2UoKSwgdikpO1xuICAgICAgICAgICAgLy8gTWFyayB0aGF0IHRoZSBzY3JvbGwgZGlzdGFuY2UgaGFzIGNoYW5nZWQgc28gdGhhdCBhZnRlciB0aGUgdmlldyBpcyBjaGVja2VkLCB0aGUgQ1NTXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm1hdGlvbiBjYW4gbW92ZSB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2VDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHRhYiBsaXN0IGluIHRoZSAnYmVmb3JlJyBvciAnYWZ0ZXInIGRpcmVjdGlvbiAodG93YXJkcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0IG9yXG4gICAgICogdGhlIGVuZCBvZiB0aGUgbGlzdCwgcmVzcGVjdGl2ZWx5KS4gVGhlIGRpc3RhbmNlIHRvIHNjcm9sbCBpcyBjb21wdXRlZCB0byBiZSBhIHRoaXJkIG9mIHRoZVxuICAgICAqIGxlbmd0aCBvZiB0aGUgdGFiIGxpc3QgdmlldyB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBjYWxsIHRoYXQgZm9yY2VzIGEgbGF5b3V0IHJlZmxvdyB0byBjb21wdXRlIGJveCBhbmQgc2Nyb2xsIG1ldHJpY3MgYW5kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBzcGFyaW5nbHkuXG4gICAgICovXG4gICAgTWRUYWJIZWFkZXIucHJvdG90eXBlLl9zY3JvbGxIZWFkZXIgPSBmdW5jdGlvbiAoc2Nyb2xsRGlyKSB7XG4gICAgICAgIHZhciB2aWV3TGVuZ3RoID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAvLyBNb3ZlIHRoZSBzY3JvbGwgZGlzdGFuY2Ugb25lLXRoaXJkIHRoZSBsZW5ndGggb2YgdGhlIHRhYiBsaXN0J3Mgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuc2Nyb2xsRGlzdGFuY2UgKz0gKHNjcm9sbERpciA9PSAnYmVmb3JlJyA/IC0xIDogMSkgKiB2aWV3TGVuZ3RoIC8gMztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSB0YWIgbGlzdCBzdWNoIHRoYXQgdGhlIGRlc2lyZWQgdGFiIGxhYmVsIChtYXJrZWQgYnkgaW5kZXgpIGlzIG1vdmVkIGludG8gdmlldy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZXhwZW5zaXZlIGNhbGwgdGhhdCBmb3JjZXMgYSBsYXlvdXQgcmVmbG93IHRvIGNvbXB1dGUgYm94IGFuZCBzY3JvbGwgbWV0cmljcyBhbmRcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIHNwYXJpbmdseS5cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX3Njcm9sbFRvTGFiZWwgPSBmdW5jdGlvbiAobGFiZWxJbmRleCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRMYWJlbCA9IHRoaXMuX2xhYmVsV3JhcHBlcnNcbiAgICAgICAgICAgID8gdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbbGFiZWxJbmRleF1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKCFzZWxlY3RlZExhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHZpZXcgbGVuZ3RoIGlzIHRoZSB2aXNpYmxlIHdpZHRoIG9mIHRoZSB0YWIgbGFiZWxzLlxuICAgICAgICB2YXIgdmlld0xlbmd0aCA9IHRoaXMuX3RhYkxpc3RDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIGxhYmVsQmVmb3JlUG9zLCBsYWJlbEFmdGVyUG9zO1xuICAgICAgICBpZiAodGhpcy5fZ2V0TGF5b3V0RGlyZWN0aW9uKCkgPT0gJ2x0cicpIHtcbiAgICAgICAgICAgIGxhYmVsQmVmb3JlUG9zID0gc2VsZWN0ZWRMYWJlbC5nZXRPZmZzZXRMZWZ0KCk7XG4gICAgICAgICAgICBsYWJlbEFmdGVyUG9zID0gbGFiZWxCZWZvcmVQb3MgKyBzZWxlY3RlZExhYmVsLmdldE9mZnNldFdpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbEFmdGVyUG9zID0gdGhpcy5fdGFiTGlzdC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC0gc2VsZWN0ZWRMYWJlbC5nZXRPZmZzZXRMZWZ0KCk7XG4gICAgICAgICAgICBsYWJlbEJlZm9yZVBvcyA9IGxhYmVsQWZ0ZXJQb3MgLSBzZWxlY3RlZExhYmVsLmdldE9mZnNldFdpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZm9yZVZpc2libGVQb3MgPSB0aGlzLnNjcm9sbERpc3RhbmNlO1xuICAgICAgICB2YXIgYWZ0ZXJWaXNpYmxlUG9zID0gdGhpcy5zY3JvbGxEaXN0YW5jZSArIHZpZXdMZW5ndGg7XG4gICAgICAgIGlmIChsYWJlbEJlZm9yZVBvcyA8IGJlZm9yZVZpc2libGVQb3MpIHtcbiAgICAgICAgICAgIC8vIFNjcm9sbCBoZWFkZXIgdG8gbW92ZSBsYWJlbCB0byB0aGUgYmVmb3JlIGRpcmVjdGlvblxuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXN0YW5jZSAtPSBiZWZvcmVWaXNpYmxlUG9zIC0gbGFiZWxCZWZvcmVQb3MgKyBFWEFHR0VSQVRFRF9PVkVSU0NST0xMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhYmVsQWZ0ZXJQb3MgPiBhZnRlclZpc2libGVQb3MpIHtcbiAgICAgICAgICAgIC8vIFNjcm9sbCBoZWFkZXIgdG8gbW92ZSBsYWJlbCB0byB0aGUgYWZ0ZXIgZGlyZWN0aW9uXG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpc3RhbmNlICs9IGxhYmVsQWZ0ZXJQb3MgLSBhZnRlclZpc2libGVQb3MgKyBFWEFHR0VSQVRFRF9PVkVSU0NST0xMO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB3aGV0aGVyIHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIHNob3VsZCBiZSBkaXNwbGF5ZWQuIElmIHRoZSBzY3JvbGwgd2lkdGggb2YgdGhlXG4gICAgICogdGFiIGxpc3QgaXMgd2lkZXIgdGhhbiB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyIGNvbnRhaW5lciwgdGhlbiB0aGUgcGFnaW5hdGlvbiBjb250cm9scyBzaG91bGRcbiAgICAgKiBiZSBzaG93bi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZXhwZW5zaXZlIGNhbGwgdGhhdCBmb3JjZXMgYSBsYXlvdXQgcmVmbG93IHRvIGNvbXB1dGUgYm94IGFuZCBzY3JvbGwgbWV0cmljcyBhbmRcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIHNwYXJpbmdseS5cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2NoZWNrUGFnaW5hdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Nob3dQYWdpbmF0aW9uQ29udHJvbHMgPVxuICAgICAgICAgICAgdGhpcy5fdGFiTGlzdC5uYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoID4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBpZiAoIXRoaXMuX3Nob3dQYWdpbmF0aW9uQ29udHJvbHMpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlzdGFuY2UgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSB3aGV0aGVyIHRoZSBiZWZvcmUgYW5kIGFmdGVyIGNvbnRyb2xzIHNob3VsZCBiZSBlbmFibGVkIG9yIGRpc2FibGVkLlxuICAgICAqIElmIHRoZSBoZWFkZXIgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdCAoc2Nyb2xsIGRpc3RhbmNlIGlzIGVxdWFsIHRvIDApIHRoZW4gZGlzYWJsZSB0aGVcbiAgICAgKiBiZWZvcmUgYnV0dG9uLiBJZiB0aGUgaGVhZGVyIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgKHNjcm9sbCBkaXN0YW5jZSBpcyBlcXVhbCB0byB0aGVcbiAgICAgKiBtYXhpbXVtIGRpc3RhbmNlIHdlIGNhbiBzY3JvbGwpLCB0aGVuIGRpc2FibGUgdGhlIGFmdGVyIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZXhwZW5zaXZlIGNhbGwgdGhhdCBmb3JjZXMgYSBsYXlvdXQgcmVmbG93IHRvIGNvbXB1dGUgYm94IGFuZCBzY3JvbGwgbWV0cmljcyBhbmRcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIHNwYXJpbmdseS5cbiAgICAgKi9cbiAgICBNZFRhYkhlYWRlci5wcm90b3R5cGUuX2NoZWNrU2Nyb2xsaW5nQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwYWdpbmF0aW9uIGFycm93cyBzaG91bGQgYmUgYWN0aXZhdGVkLlxuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQmVmb3JlID0gdGhpcy5zY3JvbGxEaXN0YW5jZSA9PSAwO1xuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsQWZ0ZXIgPSB0aGlzLnNjcm9sbERpc3RhbmNlID09IHRoaXMuX2dldE1heFNjcm9sbERpc3RhbmNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoYXQgaXMgdGhlIG1heGltdW0gbGVuZ3RoIGluIHBpeGVscyB0aGF0IGNhbiBiZSBzZXQgZm9yIHRoZSBzY3JvbGwgZGlzdGFuY2UuIFRoaXNcbiAgICAgKiBpcyBlcXVhbCB0byB0aGUgZGlmZmVyZW5jZSBpbiB3aWR0aCBiZXR3ZWVuIHRoZSB0YWIgbGlzdCBjb250YWluZXIgYW5kIHRhYiBoZWFkZXIgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBleHBlbnNpdmUgY2FsbCB0aGF0IGZvcmNlcyBhIGxheW91dCByZWZsb3cgdG8gY29tcHV0ZSBib3ggYW5kIHNjcm9sbCBtZXRyaWNzIGFuZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgc3BhcmluZ2x5LlxuICAgICAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fZ2V0TWF4U2Nyb2xsRGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW5ndGhPZlRhYkxpc3QgPSB0aGlzLl90YWJMaXN0Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgICAgIHZhciB2aWV3TGVuZ3RoID0gdGhpcy5fdGFiTGlzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoT2ZUYWJMaXN0IC0gdmlld0xlbmd0aDtcbiAgICB9O1xuICAgIC8qKiBUZWxscyB0aGUgaW5rLWJhciB0byBhbGlnbiBpdHNlbGYgdG8gdGhlIGN1cnJlbnQgbGFiZWwgd3JhcHBlciAqL1xuICAgIE1kVGFiSGVhZGVyLnByb3RvdHlwZS5fYWxpZ25JbmtCYXJUb1NlbGVjdGVkVGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZWN0ZWRMYWJlbFdyYXBwZXIgPSB0aGlzLl9sYWJlbFdyYXBwZXJzICYmIHRoaXMuX2xhYmVsV3JhcHBlcnMubGVuZ3RoXG4gICAgICAgICAgICA/IHRoaXMuX2xhYmVsV3JhcHBlcnMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF0uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50XG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5rQmFyLmFsaWduVG9FbGVtZW50KHNlbGVjdGVkTGFiZWxXcmFwcGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZFRhYkxhYmVsV3JhcHBlciksIFxuICAgICAgICBfX21ldGFkYXRhJDY0KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJfbGFiZWxXcmFwcGVyc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZChNZElua0JhciksIFxuICAgICAgICBfX21ldGFkYXRhJDY0KCdkZXNpZ246dHlwZScsIE1kSW5rQmFyKVxuICAgIF0sIE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJfaW5rQmFyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ2NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKCd0YWJMaXN0Q29udGFpbmVyJyksIFxuICAgICAgICBfX21ldGFkYXRhJDY0KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZilcbiAgICBdLCBNZFRhYkhlYWRlci5wcm90b3R5cGUsIFwiX3RhYkxpc3RDb250YWluZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDY0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoJ3RhYkxpc3QnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjQoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJfdGFiTGlzdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDY0KCdkZXNpZ246dHlwZScsIE51bWJlciksIFxuICAgICAgICBfX21ldGFkYXRhJDY0KCdkZXNpZ246cGFyYW10eXBlcycsIFtOdW1iZXJdKVxuICAgIF0sIE1kVGFiSGVhZGVyLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcInNlbGVjdEZvY3VzZWRJbmRleFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUYWJIZWFkZXIucHJvdG90eXBlLCBcImluZGV4Rm9jdXNlZFwiLCB2b2lkIDApO1xuICAgIE1kVGFiSGVhZGVyID0gX19kZWNvcmF0ZSQ2NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXRhYi1oZWFkZXIsIG1hdC10YWItaGVhZGVyJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24gbWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmUgbWF0LWVsZXZhdGlvbi16NFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIG1kLXJpcHBsZSBbbWRSaXBwbGVEaXNhYmxlZF09XFxcIl9kaXNhYmxlU2Nyb2xsQmVmb3JlXFxcIiBbY2xhc3MubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1kaXNhYmxlZF09XFxcIl9kaXNhYmxlU2Nyb2xsQmVmb3JlXFxcIiAoY2xpY2spPVxcXCJfc2Nyb2xsSGVhZGVyKCdiZWZvcmUnKVxcXCI+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9uXFxcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWxhYmVsLWNvbnRhaW5lclxcXCIgI3RhYkxpc3RDb250YWluZXIgKGtleWRvd24pPVxcXCJfaGFuZGxlS2V5ZG93bigkZXZlbnQpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWxpc3RcXFwiICN0YWJMaXN0IHJvbGU9XFxcInRhYmxpc3RcXFwiIChjZGtPYnNlcnZlQ29udGVudCk9XFxcIl9vbkNvbnRlbnRDaGFuZ2VzKClcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGFiZWxzXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PG1kLWluay1iYXI+PC9tZC1pbmstYmFyPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XFxcIm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24gbWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlciBtYXQtZWxldmF0aW9uLXo0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgbWQtcmlwcGxlIFttZFJpcHBsZURpc2FibGVkXT1cXFwiX2Rpc2FibGVTY3JvbGxBZnRlclxcXCIgW2NsYXNzLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tZGlzYWJsZWRdPVxcXCJfZGlzYWJsZVNjcm9sbEFmdGVyXFxcIiAoY2xpY2spPVxcXCJfc2Nyb2xsSGVhZGVyKCdhZnRlcicpXFxcIj48ZGl2IGNsYXNzPVxcXCJtYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb25cXFwiPjwvZGl2PjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LXRhYi1oZWFkZXJ7ZGlzcGxheTpmbGV4O292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTtmbGV4LXNocmluazowfS5tYXQtdGFiLWxhYmVse2xpbmUtaGVpZ2h0OjQ4cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDEycHg7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yOmN1cnJlbnRDb2xvcjtvcGFjaXR5Oi42O21pbi13aWR0aDoxNjBweDt0ZXh0LWFsaWduOmNlbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LXRhYi1sYWJlbDpmb2N1c3tvdXRsaW5lOjA7b3BhY2l0eToxfUBtZWRpYSAobWF4LXdpZHRoOjYwMHB4KXsubWF0LXRhYi1sYWJlbHttaW4td2lkdGg6NzJweH19Lm1hdC1pbmstYmFye3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO2hlaWdodDoycHg7dHJhbnNpdGlvbjouNXMgY3ViaWMtYmV6aWVyKC4zNSwwLC4yNSwxKX0ubWF0LXRhYi1ncm91cC1pbnZlcnRlZC1oZWFkZXIgLm1hdC1pbmstYmFye2JvdHRvbTphdXRvO3RvcDowfS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6bm9uZTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjttaW4td2lkdGg6MzJweDtjdXJzb3I6cG9pbnRlcjt6LWluZGV4OjJ9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY29udHJvbHMtZW5hYmxlZCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbiwubWF0LXRhYi1sYWJlbHN7ZGlzcGxheTpmbGV4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZSwubWF0LXRhYi1oZWFkZXItcnRsIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWFmdGVye3BhZGRpbmctbGVmdDo0cHh9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYmVmb3JlIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb24sLm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1hZnRlciAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9ue3RyYW5zZm9ybTpyb3RhdGUoLTEzNWRlZyl9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYWZ0ZXIsLm1hdC10YWItaGVhZGVyLXJ0bCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1iZWZvcmV7cGFkZGluZy1yaWdodDo0cHh9Lm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tYWZ0ZXIgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbiwubWF0LXRhYi1oZWFkZXItcnRsIC5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWJlZm9yZSAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9ue3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWNoZXZyb257Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci13aWR0aDoycHggMnB4IDAgMDtjb250ZW50OicnO2hlaWdodDo4cHg7d2lkdGg6OHB4fS5tYXQtdGFiLWhlYWRlci1wYWdpbmF0aW9uLWRpc2FibGVke2JveC1zaGFkb3c6bm9uZTtjdXJzb3I6ZGVmYXVsdH0ubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1kaXNhYmxlZCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9ue2JvcmRlci1jb2xvcjojY2NjfS5tYXQtdGFiLWxhYmVsLWNvbnRhaW5lcntkaXNwbGF5OmZsZXg7ZmxleC1ncm93OjE7b3ZlcmZsb3c6aGlkZGVuO3otaW5kZXg6MX0ubWF0LXRhYi1saXN0e2ZsZXgtZ3JvdzoxO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zaXRpb246dHJhbnNmb3JtIC41cyBjdWJpYy1iZXppZXIoLjM1LDAsLjI1LDEpfVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXRhYi1oZWFkZXInLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jb250cm9scy1lbmFibGVkXSc6ICdfc2hvd1BhZ2luYXRpb25Db250cm9scycsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtdGFiLWhlYWRlci1ydGxdJzogXCJfZ2V0TGF5b3V0RGlyZWN0aW9uKCkgPT0gJ3J0bCdcIixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMTMoMiwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuTmdab25lLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIERpcl0pXG4gICAgXSwgTWRUYWJIZWFkZXIpO1xuICAgIHJldHVybiBNZFRhYkhlYWRlcjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDU3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDU3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSUQncyBmb3IgZWFjaCB0YWIgY29tcG9uZW50ICovXG52YXIgbmV4dElkJDIgPSAwO1xuLyoqIEEgc2ltcGxlIGNoYW5nZSBldmVudCBlbWl0dGVkIG9uIGZvY3VzIG9yIHNlbGVjdGlvbiBjaGFuZ2VzLiAqL1xudmFyIE1kVGFiQ2hhbmdlRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFiQ2hhbmdlRXZlbnQoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFRhYkNoYW5nZUV2ZW50O1xufSgpKTtcbi8qKlxuICogTWF0ZXJpYWwgZGVzaWduIHRhYi1ncm91cCBjb21wb25lbnQuICBTdXBwb3J0cyBiYXNpYyB0YWIgcGFpcnMgKGxhYmVsICsgY29udGVudCkgYW5kIGluY2x1ZGVzXG4gKiBhbmltYXRlZCBpbmstYmFyLCBrZXlib2FyZCBuYXZpZ2F0aW9uLCBhbmQgc2NyZWVuIHJlYWRlci5cbiAqIFNlZTogaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL3RhYnMuaHRtbFxuICovXG52YXIgTWRUYWJHcm91cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJHcm91cChfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoaXMgY29tcG9uZW50IGhhcyBiZWVuIGluaXRpYWxpemVkLiAqL1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgdGFiIGluZGV4IHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkIGFmdGVyIHRoZSBjb250ZW50IGhhcyBiZWVuIGNoZWNrZWQuICovXG4gICAgICAgIHRoaXMuX2luZGV4VG9TZWxlY3QgPSAwO1xuICAgICAgICAvKiogU25hcHNob3Qgb2YgdGhlIGhlaWdodCBvZiB0aGUgdGFiIGJvZHkgd3JhcHBlciBiZWZvcmUgYW5vdGhlciB0YWIgaXMgYWN0aXZhdGVkLiAqL1xuICAgICAgICB0aGlzLl90YWJCb2R5V3JhcHBlckhlaWdodCA9IG51bGw7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB0YWIgZ3JvdXAgc2hvdWxkIGdyb3cgdG8gdGhlIHNpemUgb2YgdGhlIGFjdGl2ZSB0YWIgKi9cbiAgICAgICAgdGhpcy5fZHluYW1pY0hlaWdodCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gbnVsbDtcbiAgICAgICAgLyoqIFBvc2l0aW9uIG9mIHRoZSB0YWIgaGVhZGVyLiAqL1xuICAgICAgICB0aGlzLmhlYWRlclBvc2l0aW9uID0gJ2Fib3ZlJztcbiAgICAgICAgdGhpcy5fb25Gb2N1c0NoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9vblNlbGVjdENoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICAgICAgdGhpcy5fZ3JvdXBJZCA9IG5leHRJZCQyKys7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJkeW5hbWljSGVpZ2h0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9keW5hbWljSGVpZ2h0OyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9keW5hbWljSGVpZ2h0ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl9keW5hbWljSGVpZ2h0RGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2R5bmFtaWNIZWlnaHQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2R5bmFtaWNIZWlnaHQgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7IH0sXG4gICAgICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0YWIuICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2luZGV4VG9TZWxlY3QgPSB2YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhDaGFuZ2VcIiwge1xuICAgICAgICAvKiogT3V0cHV0IHRvIGVuYWJsZSBzdXBwb3J0IGZvciB0d28td2F5IGJpbmRpbmcgb24gYHNlbGVjdGVkSW5kZXhgLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdENoYW5nZS5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5pbmRleDsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJmb2N1c0NoYW5nZVwiLCB7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gZm9jdXMgaGFzIGNoYW5nZWQgd2l0aGluIGEgdGFiIGdyb3VwLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbkZvY3VzQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0Q2hhbmdlXCIsIHtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdGFiIHNlbGVjdGlvbiBoYXMgY2hhbmdlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25TZWxlY3RDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFmdGVyIHRoZSBjb250ZW50IGlzIGNoZWNrZWQsIHRoaXMgY29tcG9uZW50IGtub3dzIHdoYXQgdGFicyBoYXZlIGJlZW4gZGVmaW5lZFxuICAgICAqIGFuZCB3aGF0IHRoZSBzZWxlY3RlZCBpbmRleCBzaG91bGQgYmUuIFRoaXMgaXMgd2hlcmUgd2UgY2FuIGtub3cgZXhhY3RseSB3aGF0IHBvc2l0aW9uXG4gICAgICogZWFjaCB0YWIgc2hvdWxkIGJlIGluIGFjY29yZGluZyB0byB0aGUgbmV3IHNlbGVjdGVkIGluZGV4LCBhbmQgYWRkaXRpb25hbGx5IHdlIGtub3cgaG93XG4gICAgICogYSBuZXcgc2VsZWN0ZWQgdGFiIHNob3VsZCB0cmFuc2l0aW9uIGluIChmcm9tIHRoZSBsZWZ0IG9yIHJpZ2h0KS5cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIENsYW1wIHRoZSBuZXh0IHNlbGVjdGVkIGluZGV4IHRvIHRoZSBib3VuZHMgb2YgMCBhbmQgdGhlIHRhYnMgbGVuZ3RoLiBOb3RlIHRoZSBgfHwgMGAsIHdoaWNoXG4gICAgICAgIC8vIGVuc3VyZXMgdGhhdCB2YWx1ZXMgbGlrZSBOYU4gY2FuJ3QgZ2V0IHRocm91Z2ggYW5kIHdoaWNoIHdvdWxkIG90aGVyd2lzZSB0aHJvdyB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IGludG8gYW4gaW5maW5pdGUgbG9vcCAoc2luY2UgTWF0aC5tYXgoTmFOLCAwKSA9PT0gTmFOKS5cbiAgICAgICAgdGhpcy5faW5kZXhUb1NlbGVjdCA9XG4gICAgICAgICAgICBNYXRoLm1pbih0aGlzLl90YWJzLmxlbmd0aCAtIDEsIE1hdGgubWF4KHRoaXMuX2luZGV4VG9TZWxlY3QgfHwgMCwgMCkpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGNoYW5nZSBpbiBzZWxlY3RlZCBpbmRleCwgZW1pdCBhIGNoYW5nZSBldmVudC4gU2hvdWxkIG5vdCB0cmlnZ2VyIGlmXG4gICAgICAgIC8vIHRoZSBzZWxlY3RlZCBpbmRleCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCAhPSB0aGlzLl9pbmRleFRvU2VsZWN0ICYmIHRoaXMuX3NlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fb25TZWxlY3RDaGFuZ2UuZW1pdCh0aGlzLl9jcmVhdGVDaGFuZ2VFdmVudCh0aGlzLl9pbmRleFRvU2VsZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dXAgdGhlIHBvc2l0aW9uIGZvciBlYWNoIHRhYiBhbmQgb3B0aW9uYWxseSBzZXR1cCBhbiBvcmlnaW4gb24gdGhlIG5leHQgc2VsZWN0ZWQgdGFiLlxuICAgICAgICB0aGlzLl90YWJzLmZvckVhY2goZnVuY3Rpb24gKHRhYiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRhYi5wb3NpdGlvbiA9IGluZGV4IC0gX3RoaXMuX2luZGV4VG9TZWxlY3Q7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgc2VsZWN0ZWQgdGFiLCB0aGVuIHNldCB1cCBhbiBvcmlnaW4gZm9yIHRoZSBuZXh0IHNlbGVjdGVkIHRhYlxuICAgICAgICAgICAgLy8gaWYgaXQgZG9lc24ndCBoYXZlIG9uZSBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKF90aGlzLl9zZWxlY3RlZEluZGV4ICE9IG51bGwgJiYgdGFiLnBvc2l0aW9uID09IDAgJiYgIXRhYi5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICB0YWIub3JpZ2luID0gX3RoaXMuX2luZGV4VG9TZWxlY3QgLSBfdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSB0aGlzLl9pbmRleFRvU2VsZWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2FpdHMgb25lIGZyYW1lIGZvciB0aGUgdmlldyB0byB1cGRhdGUsIHRoZW4gdXBkYXRlcyB0aGUgaW5rIGJhclxuICAgICAqIE5vdGU6IFRoaXMgbXVzdCBiZSBydW4gb3V0c2lkZSBvZiB0aGUgem9uZSBvciBpdCB3aWxsIGNyZWF0ZSBhbiBpbmZpbml0ZSBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3AuXG4gICAgICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9mb2N1c0NoYW5nZWQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fb25Gb2N1c0NoYW5nZS5lbWl0KHRoaXMuX2NyZWF0ZUNoYW5nZUV2ZW50KGluZGV4KSk7XG4gICAgfTtcbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5fY3JlYXRlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kVGFiQ2hhbmdlRXZlbnQ7XG4gICAgICAgIGV2ZW50LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLl90YWJzICYmIHRoaXMuX3RhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBldmVudC50YWIgPSB0aGlzLl90YWJzLnRvQXJyYXkoKVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGxhYmVsIGVsZW1lbnQgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5fZ2V0VGFiTGFiZWxJZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcIm1kLXRhYi1sYWJlbC1cIiArIHRoaXMuX2dyb3VwSWQgKyBcIi1cIiArIGk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIHVuaXF1ZSBpZCBmb3IgZWFjaCB0YWIgY29udGVudCBlbGVtZW50ICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX2dldFRhYkNvbnRlbnRJZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcIm1kLXRhYi1jb250ZW50LVwiICsgdGhpcy5fZ3JvdXBJZCArIFwiLVwiICsgaTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgYm9keSB3cmFwcGVyIHRvIHRoZSBoZWlnaHQgb2YgdGhlIGFjdGl2YXRpbmcgdGFiIGlmIGR5bmFtaWNcbiAgICAgKiBoZWlnaHQgcHJvcGVydHkgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5fc2V0VGFiQm9keVdyYXBwZXJIZWlnaHQgPSBmdW5jdGlvbiAodGFiSGVpZ2h0KSB7XG4gICAgICAgIGlmICghdGhpcy5fZHluYW1pY0hlaWdodCB8fCAhdGhpcy5fdGFiQm9keVdyYXBwZXJIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIHRoaXMuX3RhYkJvZHlXcmFwcGVySGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgIC8vIFRoaXMgY29uZGl0aW9uYWwgZm9yY2VzIHRoZSBicm93c2VyIHRvIHBhaW50IHRoZSBoZWlnaHQgc28gdGhhdFxuICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHRvIHRoZSBuZXcgaGVpZ2h0IGNhbiBoYXZlIGFuIG9yaWdpbi5cbiAgICAgICAgaWYgKHRoaXMuX3RhYkJvZHlXcmFwcGVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fdGFiQm9keVdyYXBwZXIubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIHRhYkhlaWdodCArICdweCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogUmVtb3ZlcyB0aGUgaGVpZ2h0IG9mIHRoZSB0YWIgYm9keSB3cmFwcGVyLiAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLl9yZW1vdmVUYWJCb2R5V3JhcHBlckhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFiQm9keVdyYXBwZXJIZWlnaHQgPSB0aGlzLl90YWJCb2R5V3JhcHBlci5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX3RhYkJvZHlXcmFwcGVyLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCAnJyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRUYWIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJfdGFic1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgndGFiQm9keVdyYXBwZXInKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl90YWJCb2R5V3JhcHBlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDU3KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiZHluYW1pY0hlaWdodFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWQtZHluYW1pYy1oZWlnaHQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJfZHluYW1pY0hlaWdodERlcHJlY2F0ZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW051bWJlcl0pXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1NygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiaGVhZGVyUG9zaXRpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleENoYW5nZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDU3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiZm9jdXNDaGFuZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ1NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDU3KCdkZXNpZ246dHlwZScsIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKVxuICAgIF0sIE1kVGFiR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdENoYW5nZVwiLCBudWxsKTtcbiAgICBNZFRhYkdyb3VwID0gX19kZWNvcmF0ZSQ1NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXRhYi1ncm91cCwgbWF0LXRhYi1ncm91cCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bWQtdGFiLWhlYWRlciBbc2VsZWN0ZWRJbmRleF09XFxcInNlbGVjdGVkSW5kZXhcXFwiICN0YWJIZWFkZXIgKGluZGV4Rm9jdXNlZCk9XFxcIl9mb2N1c0NoYW5nZWQoJGV2ZW50KVxcXCIgKHNlbGVjdEZvY3VzZWRJbmRleCk9XFxcInNlbGVjdGVkSW5kZXggPSAkZXZlbnRcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC10YWItbGFiZWxcXFwiIHJvbGU9XFxcInRhYlxcXCIgbWQtdGFiLWxhYmVsLXdyYXBwZXIgbWQtcmlwcGxlICpuZ0Zvcj1cXFwibGV0IHRhYiBvZiBfdGFiczsgbGV0IGkgPSBpbmRleFxcXCIgW2lkXT1cXFwiX2dldFRhYkxhYmVsSWQoaSlcXFwiIFt0YWJJbmRleF09XFxcInNlbGVjdGVkSW5kZXggPT0gaSA/IDAgOiAtMVxcXCIgW2F0dHIuYXJpYS1jb250cm9sc109XFxcIl9nZXRUYWJDb250ZW50SWQoaSlcXFwiIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVxcXCJzZWxlY3RlZEluZGV4ID09IGlcXFwiIFtjbGFzcy5tYXQtdGFiLWxhYmVsLWFjdGl2ZV09XFxcInNlbGVjdGVkSW5kZXggPT0gaVxcXCIgW2Rpc2FibGVkXT1cXFwidGFiLmRpc2FibGVkXFxcIiAoY2xpY2spPVxcXCJ0YWJIZWFkZXIuZm9jdXNJbmRleCA9IHNlbGVjdGVkSW5kZXggPSBpXFxcIj48dGVtcGxhdGUgW25nSWZdPVxcXCJ0YWIudGVtcGxhdGVMYWJlbFxcXCI+PHRlbXBsYXRlIFtjZGtQb3J0YWxIb3N0XT1cXFwidGFiLnRlbXBsYXRlTGFiZWxcXFwiPjwvdGVtcGxhdGU+PC90ZW1wbGF0ZT48dGVtcGxhdGUgW25nSWZdPVxcXCIhdGFiLnRlbXBsYXRlTGFiZWxcXFwiPnt7dGFiLnRleHRMYWJlbH19PC90ZW1wbGF0ZT48L2Rpdj48L21kLXRhYi1oZWFkZXI+PGRpdiBjbGFzcz1cXFwibWF0LXRhYi1ib2R5LXdyYXBwZXJcXFwiICN0YWJCb2R5V3JhcHBlcj48bWQtdGFiLWJvZHkgcm9sZT1cXFwidGFicGFuZWxcXFwiICpuZ0Zvcj1cXFwibGV0IHRhYiBvZiBfdGFiczsgbGV0IGkgPSBpbmRleFxcXCIgW2lkXT1cXFwiX2dldFRhYkNvbnRlbnRJZChpKVxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiX2dldFRhYkxhYmVsSWQoaSlcXFwiIFtjbGFzcy5tYXQtdGFiLWJvZHktYWN0aXZlXT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpXFxcIiBbY29udGVudF09XFxcInRhYi5jb250ZW50XFxcIiBbcG9zaXRpb25dPVxcXCJ0YWIucG9zaXRpb25cXFwiIFtvcmlnaW5dPVxcXCJ0YWIub3JpZ2luXFxcIiAob25DZW50ZXJlZCk9XFxcIl9yZW1vdmVUYWJCb2R5V3JhcHBlckhlaWdodCgpXFxcIiAob25DZW50ZXJpbmcpPVxcXCJfc2V0VGFiQm9keVdyYXBwZXJIZWlnaHQoJGV2ZW50KVxcXCI+PC9tZC10YWItYm9keT48L2Rpdj5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmfTpob3N0Lm1hdC10YWItZ3JvdXAtaW52ZXJ0ZWQtaGVhZGVye2ZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlfS5tYXQtdGFiLWxhYmVse2xpbmUtaGVpZ2h0OjQ4cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDEycHg7Zm9udC1zaXplOjE0cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yOmN1cnJlbnRDb2xvcjtvcGFjaXR5Oi42O21pbi13aWR0aDoxNjBweDt0ZXh0LWFsaWduOmNlbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZX0ubWF0LXRhYi1sYWJlbDpmb2N1c3tvdXRsaW5lOjA7b3BhY2l0eToxfUBtZWRpYSAobWF4LXdpZHRoOjYwMHB4KXsubWF0LXRhYi1sYWJlbHttaW4td2lkdGg6NzJweH19Omhvc3RbbWF0LXN0cmV0Y2gtdGFic10gLm1hdC10YWItbGFiZWwsOmhvc3RbbWQtc3RyZXRjaC10YWJzXSAubWF0LXRhYi1sYWJlbHtmbGV4LWJhc2lzOjA7ZmxleC1ncm93OjF9Lm1hdC10YWItYm9keS13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbjtkaXNwbGF5OmZsZXg7dHJhbnNpdGlvbjpoZWlnaHQgLjVzIGN1YmljLWJlemllciguMzUsMCwuMjUsMSl9Lm1hdC10YWItYm9keXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDtkaXNwbGF5OmJsb2NrO292ZXJmbG93OmhpZGRlbn0ubWF0LXRhYi1ib2R5Lm1hdC10YWItYm9keS1hY3RpdmV7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvO3otaW5kZXg6MTtmbGV4LWdyb3c6MX06aG9zdC5tYXQtdGFiLWdyb3VwLWR5bmFtaWMtaGVpZ2h0IC5tYXQtdGFiLWJvZHkubWF0LXRhYi1ib2R5LWFjdGl2ZXtvdmVyZmxvdy15OmhpZGRlbn0ubWF0LXRhYi1kaXNhYmxlZHtjdXJzb3I6ZGVmYXVsdDtwb2ludGVyLWV2ZW50czpub25lfVwiXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC10YWItZ3JvdXAtZHluYW1pYy1oZWlnaHRdJzogJ2R5bmFtaWNIZWlnaHQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRhYi1ncm91cC1pbnZlcnRlZC1oZWFkZXJdJzogJ2hlYWRlclBvc2l0aW9uID09PSBcImJlbG93XCInLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNTcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kVGFiR3JvdXApO1xuICAgIHJldHVybiBNZFRhYkdyb3VwO1xufSgpKTtcbnZhciBNZFRhYnNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFic01vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRUYWJzTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRUYWJzTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRUYWJzTW9kdWxlID0gX19kZWNvcmF0ZSQ1NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIFBvcnRhbE1vZHVsZSwgTWRSaXBwbGVNb2R1bGUsIE9ic2VydmVDb250ZW50TW9kdWxlXSxcbiAgICAgICAgICAgIC8vIERvbid0IGV4cG9ydCBhbGwgY29tcG9uZW50cyBiZWNhdXNlIHNvbWUgYXJlIG9ubHkgdG8gYmUgdXNlZCBpbnRlcm5hbGx5LlxuICAgICAgICAgICAgZXhwb3J0czogW01kVGFiR3JvdXAsIE1kVGFiTGFiZWwsIE1kVGFiLCBNZFRhYk5hdkJhciwgTWRUYWJMaW5rLCBNZFRhYkxpbmtSaXBwbGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRUYWJHcm91cCwgTWRUYWJMYWJlbCwgTWRUYWIsIE1kSW5rQmFyLCBNZFRhYkxhYmVsV3JhcHBlcixcbiAgICAgICAgICAgICAgICBNZFRhYk5hdkJhciwgTWRUYWJMaW5rLCBNZFRhYkJvZHksIE1kVGFiTGlua1JpcHBsZSwgTWRUYWJIZWFkZXJdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbVklFV1BPUlRfUlVMRVJfUFJPVklERVIsIFNDUk9MTF9ESVNQQVRDSEVSX1BST1ZJREVSXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDU3KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kVGFic01vZHVsZSk7XG4gICAgcmV0dXJuIE1kVGFic01vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDY1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRUb29sYmFyUm93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRvb2xiYXJSb3coKSB7XG4gICAgfVxuICAgIE1kVG9vbGJhclJvdyA9IF9fZGVjb3JhdGUkNjUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLXRvb2xiYXItcm93LCBtYXQtdG9vbGJhci1yb3cnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRvb2xiYXItcm93XSc6ICd0cnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFRvb2xiYXJSb3cpO1xuICAgIHJldHVybiBNZFRvb2xiYXJSb3c7XG59KCkpO1xudmFyIE1kVG9vbGJhciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sYmFyKGVsZW1lbnRSZWYsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbGJhci5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSB0b29sYmFyLiBDYW4gYmUgcHJpbWFyeSwgYWNjZW50LCBvciB3YXJuLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRUb29sYmFyLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICBNZFRvb2xiYXIucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtYXQtXCIgKyBjb2xvciwgaXNBZGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDY1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRUb29sYmFyLnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBNZFRvb2xiYXIgPSBfX2RlY29yYXRlJDY1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdG9vbGJhciwgbWF0LXRvb2xiYXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRvb2xiYXItbGF5b3V0XFxcIj48bWQtdG9vbGJhci1yb3c+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvbWQtdG9vbGJhci1yb3c+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC10b29sYmFyLXJvdywgbWF0LXRvb2xiYXItcm93XFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5tYXQtdG9vbGJhciwubWF0LXRvb2xiYXIgLm1hdC10b29sYmFyLXJvd3tkaXNwbGF5OmZsZXg7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjEwMCV9Lm1hdC10b29sYmFye2ZvbnQtc2l6ZToyMHB4O2ZvbnQtd2VpZ2h0OjUwMDtmb250LWZhbWlseTpSb2JvdG8sXFxcIkhlbHZldGljYSBOZXVlXFxcIixzYW5zLXNlcmlmO3BhZGRpbmc6MCAxNnB4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttaW4taGVpZ2h0OjY0cHh9Lm1hdC10b29sYmFyIC5tYXQtdG9vbGJhci1yb3d7ZmxleC1kaXJlY3Rpb246cm93O2FsaWduLWl0ZW1zOmNlbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXB9Lm1hdC10b29sYmFyLXJvd3toZWlnaHQ6NjRweH1AbWVkaWEgKG1heC13aWR0aDo2MDBweCkgYW5kIChvcmllbnRhdGlvbjpwb3J0cmFpdCl7Lm1hdC10b29sYmFye21pbi1oZWlnaHQ6NTZweH0ubWF0LXRvb2xiYXItcm93e2hlaWdodDo1NnB4fX1AbWVkaWEgKG1heC13aWR0aDo5NjBweCkgYW5kIChvcmllbnRhdGlvbjpsYW5kc2NhcGUpey5tYXQtdG9vbGJhcnttaW4taGVpZ2h0OjQ4cHh9Lm1hdC10b29sYmFyLXJvd3toZWlnaHQ6NDhweH19XCJdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXRvb2xiYXJdJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICdyb2xlJzogJ3Rvb2xiYXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlcl0pXG4gICAgXSwgTWRUb29sYmFyKTtcbiAgICByZXR1cm4gTWRUb29sYmFyO1xufSgpKTtcbnZhciBNZFRvb2xiYXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVG9vbGJhck1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRUb29sYmFyTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRUb29sYmFyTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRUb29sYmFyTW9kdWxlID0gX19kZWNvcmF0ZSQ2NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW0NvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kVG9vbGJhciwgTWRUb29sYmFyUm93LCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kVG9vbGJhciwgTWRUb29sYmFyUm93XSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDY1KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kVG9vbGJhck1vZHVsZSk7XG4gICAgcmV0dXJuIE1kVG9vbGJhck1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMjAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYSB0b29sdGlwIGhhcyBhbiBpbnZhbGlkIHBvc2l0aW9uLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWRUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyMChNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcihwb3NpdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIlRvb2x0aXAgcG9zaXRpb24gXFxcIlwiICsgcG9zaXRpb24gKyBcIlxcXCIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBNZFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcjtcbn0oTWRFcnJvcikpO1xuXG52YXIgX19kZWNvcmF0ZSQ2NiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2NiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTQgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKiogVGltZSBpbiBtcyB0byBkZWxheSBiZWZvcmUgY2hhbmdpbmcgdGhlIHRvb2x0aXAgdmlzaWJpbGl0eSB0byBoaWRkZW4gKi9cbnZhciBUT1VDSEVORF9ISURFX0RFTEFZID0gMTUwMDtcbi8qKiBUaW1lIGluIG1zIHRvIHRocm90dGxlIHJlcG9zaXRpb25pbmcgYWZ0ZXIgc2Nyb2xsIGV2ZW50cy4gKi9cbnZhciBTQ1JPTExfVEhST1RUTEVfTVMgPSAyMDtcbi8qKlxuICogRGlyZWN0aXZlIHRoYXQgYXR0YWNoZXMgYSBtYXRlcmlhbCBkZXNpZ24gdG9vbHRpcCB0byB0aGUgaG9zdCBlbGVtZW50LiBBbmltYXRlcyB0aGUgc2hvd2luZyBhbmRcbiAqIGhpZGluZyBvZiBhIHRvb2x0aXAgcHJvdmlkZWQgcG9zaXRpb24gKGRlZmF1bHRzIHRvIGJlbG93IHRoZSBlbGVtZW50KS5cbiAqXG4gKiBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vY29tcG9uZW50cy90b29sdGlwcy5odG1sXG4gKi9cbnZhciBNZFRvb2x0aXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVG9vbHRpcChfb3ZlcmxheSwgX3Njcm9sbERpc3BhdGNoZXIsIF9lbGVtZW50UmVmLCBfdmlld0NvbnRhaW5lclJlZiwgX25nWm9uZSwgX2Rpcikge1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3BhdGNoZXIgPSBfc2Nyb2xsRGlzcGF0Y2hlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ2JlbG93JztcbiAgICAgICAgLyoqIFRoZSBkZWZhdWx0IGRlbGF5IGluIG1zIGJlZm9yZSBzaG93aW5nIHRoZSB0b29sdGlwIGFmdGVyIHNob3cgaXMgY2FsbGVkICovXG4gICAgICAgIHRoaXMuc2hvd0RlbGF5ID0gMDtcbiAgICAgICAgLyoqIFRoZSBkZWZhdWx0IGRlbGF5IGluIG1zIGJlZm9yZSBoaWRpbmcgdGhlIHRvb2x0aXAgYWZ0ZXIgaGlkZSBpcyBjYWxsZWQgKi9cbiAgICAgICAgdGhpcy5oaWRlRGVsYXkgPSAwO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB7XG4gICAgICAgIC8qKiBBbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IGVsZW1lbnQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvbjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5kcmV3anMpOiBXaGVuIHRoZSBvdmVybGF5J3MgcG9zaXRpb24gY2FuIGJlIGR5bmFtaWNhbGx5IGNoYW5nZWQsIGRvIG5vdCBkZXN0cm95XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRvb2x0aXAuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX3Bvc2l0aW9uRGVwcmVjYXRlZFwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9wb3NpdGlvbiA9IHZhbHVlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgLyoqIFRoZSBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2U7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VG9vbHRpcE1lc3NhZ2UodGhpcy5fbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9kZXByZWNhdGVkTWVzc2FnZVwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVzc2FnZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lc3NhZ2UgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0TWVzc2FnZVwiLCB7XG4gICAgICAgIC8vIFByb3BlcnRpZXMgd2l0aCBgbWF0LWAgcHJlZml4IGZvciBub2NvbmZsaWN0IG1vZGUuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tZXNzYWdlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7IHRoaXMubWVzc2FnZSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9tYXRQb3NpdGlvblwiLCB7XG4gICAgICAgIC8vIFByb3BlcnRpZXMgd2l0aCBgbWF0LWAgcHJlZml4IGZvciBub2NvbmZsaWN0IG1vZGUuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wb3NpdGlvbjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLnBvc2l0aW9uID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX21hdEhpZGVEZWxheVwiLCB7XG4gICAgICAgIC8vIFByb3BlcnRpZXMgd2l0aCBgbWF0LWAgcHJlZml4IGZvciBub2NvbmZsaWN0IG1vZGUuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5oaWRlRGVsYXk7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5oaWRlRGVsYXkgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0U2hvd0RlbGF5XCIsIHtcbiAgICAgICAgLy8gUHJvcGVydGllcyB3aXRoIGBtYXQtYCBwcmVmaXggZm9yIG5vY29uZmxpY3QgbW9kZS5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNob3dEZWxheTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLnNob3dEZWxheSA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdoZW4gYSBzY3JvbGwgb24gdGhlIHBhZ2Ugb2NjdXJzLCB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIGNhc2UgdGhpcyB0b29sdGlwIG5lZWRzXG4gICAgICAgIC8vIHRvIGJlIHJlcG9zaXRpb25lZC5cbiAgICAgICAgdGhpcy5zY3JvbGxTdWJzY3JpcHRpb24gPSB0aGlzLl9zY3JvbGxEaXNwYXRjaGVyLnNjcm9sbGVkKFNDUk9MTF9USFJPVFRMRV9NUykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgdG9vbHRpcCB3aGVuIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwb3NlVG9vbHRpcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICAvKiogU2hvd3MgdGhlIHRvb2x0aXAgYWZ0ZXIgdGhlIGRlbGF5IGluIG1zLCBkZWZhdWx0cyB0byB0b29sdGlwLWRlbGF5LXNob3cgb3IgMG1zIGlmIG5vIGlucHV0ICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gdGhpcy5zaG93RGVsYXk7IH1cbiAgICAgICAgaWYgKCF0aGlzLl9tZXNzYWdlIHx8ICF0aGlzLl9tZXNzYWdlLnRyaW0oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0VG9vbHRpcE1lc3NhZ2UodGhpcy5fbWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5zaG93KHRoaXMuX3Bvc2l0aW9uLCBkZWxheSk7XG4gICAgfTtcbiAgICAvKiogSGlkZXMgdGhlIHRvb2x0aXAgYWZ0ZXIgdGhlIGRlbGF5IGluIG1zLCBkZWZhdWx0cyB0byB0b29sdGlwLWRlbGF5LWhpZGUgb3IgMG1zIGlmIG5vIGlucHV0ICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gdGhpcy5oaWRlRGVsYXk7IH1cbiAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLmhpZGUoZGVsYXkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogU2hvd3MvaGlkZXMgdGhlIHRvb2x0aXAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNUb29sdGlwVmlzaWJsZSgpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRvb2x0aXAgaXMgY3VycmVudGx5IHZpc2libGUgdG8gdGhlIHVzZXIgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9pc1Rvb2x0aXBWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9vbHRpcEluc3RhbmNlICYmIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5pc1Zpc2libGUoKTtcbiAgICB9O1xuICAgIC8qKiBDcmVhdGUgdGhlIHRvb2x0aXAgdG8gZGlzcGxheSAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2NyZWF0ZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgdmFyIHBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoVG9vbHRpcENvbXBvbmVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSA9IHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHBvcnRhbCkuaW5zdGFuY2U7XG4gICAgICAgIC8vIERpc3Bvc2UgdGhlIG92ZXJsYXkgd2hlbiBmaW5pc2hlZCB0aGUgc2hvd24gdG9vbHRpcC5cbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLmFmdGVySGlkZGVuKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGlmIHRoZSB0b29sdGlwIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZCB0aHJvdWdoIHRoaXMgY29tcG9uZW50cyBkZXN0cm95LlxuICAgICAgICAgICAgaWYgKF90aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZGlzcG9zZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQ3JlYXRlIHRoZSBvdmVybGF5IGNvbmZpZyBhbmQgcG9zaXRpb24gc3RyYXRlZ3kgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luKCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldE92ZXJsYXlQb3NpdGlvbigpO1xuICAgICAgICAvLyBDcmVhdGUgY29ubmVjdGVkIHBvc2l0aW9uIHN0cmF0ZWd5IHRoYXQgbGlzdGVucyBmb3Igc2Nyb2xsIGV2ZW50cyB0byByZXBvc2l0aW9uLlxuICAgICAgICAvLyBBZnRlciBwb3NpdGlvbiBjaGFuZ2VzIG9jY3VyIGFuZCB0aGUgb3ZlcmxheSBpcyBjbGlwcGVkIGJ5IGEgcGFyZW50IHNjcm9sbGFibGUgdGhlblxuICAgICAgICAvLyBjbG9zZSB0aGUgdG9vbHRpcC5cbiAgICAgICAgdmFyIHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnRSZWYsIG9yaWdpbiwgcG9zaXRpb24pO1xuICAgICAgICBzdHJhdGVneS53aXRoU2Nyb2xsYWJsZUNvbnRhaW5lcnModGhpcy5fc2Nyb2xsRGlzcGF0Y2hlci5nZXRTY3JvbGxDb250YWluZXJzKHRoaXMuX2VsZW1lbnRSZWYpKTtcbiAgICAgICAgc3RyYXRlZ3kub25Qb3NpdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5zY3JvbGxhYmxlVmlld1Byb3BlcnRpZXMuaXNPdmVybGF5Q2xpcHBlZCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLl90b29sdGlwSW5zdGFuY2UgJiYgX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZS5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBjb25maWcucG9zaXRpb25TdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoY29uZmlnKTtcbiAgICB9O1xuICAgIC8qKiBEaXNwb3NlcyB0aGUgY3VycmVudCB0b29sdGlwIGFuZCB0aGUgb3ZlcmxheSBpdCBpcyBhdHRhY2hlZCB0byAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2Rpc3Bvc2VUb29sdGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSA9IG51bGw7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgb3JpZ2luIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB1c2VyJ3MgcG9zaXRpb24gcHJlZmVyZW5jZSAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX2dldE9yaWdpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2Fib3ZlJyB8fCB0aGlzLnBvc2l0aW9uID09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiB0aGlzLnBvc2l0aW9uID09ICdhYm92ZScgPyAndG9wJyA6ICdib3R0b20nIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzRGlyZWN0aW9uTHRyID0gIXRoaXMuX2RpciB8fCB0aGlzLl9kaXIudmFsdWUgPT0gJ2x0cic7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdsZWZ0JyB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYmVmb3JlJyAmJiBpc0RpcmVjdGlvbkx0ciB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYWZ0ZXInICYmICFpc0RpcmVjdGlvbkx0cikge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSAncmlnaHQnIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdhZnRlcicgJiYgaXNEaXJlY3Rpb25MdHIgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2JlZm9yZScgJiYgIWlzRGlyZWN0aW9uTHRyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnZW5kJywgb3JpZ2luWTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTWRUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IodGhpcy5wb3NpdGlvbik7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgb3ZlcmxheSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdXNlcidzIHByZWZlcmVuY2UgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9nZXRPdmVybGF5UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdhYm92ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICdib3R0b20nIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2JlbG93Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ3RvcCcgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNMdHIgPSAhdGhpcy5fZGlyIHx8IHRoaXMuX2Rpci52YWx1ZSA9PSAnbHRyJztcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gJ2xlZnQnIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdiZWZvcmUnICYmIGlzTHRyIHx8XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID09ICdhZnRlcicgJiYgIWlzTHRyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09ICdyaWdodCcgfHxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPT0gJ2FmdGVyJyAmJiBpc0x0ciB8fFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9PSAnYmVmb3JlJyAmJiAhaXNMdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTWRUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IodGhpcy5wb3NpdGlvbik7XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgdG9vbHRpcCBtZXNzYWdlIGFuZCByZXBvc2l0aW9ucyB0aGUgb3ZlcmxheSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBtZXNzYWdlIGxlbmd0aCAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuX3NldFRvb2x0aXBNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTXVzdCB3YWl0IGZvciB0aGUgbWVzc2FnZSB0byBiZSBwYWludGVkIHRvIHRoZSB0b29sdGlwIHNvIHRoYXQgdGhlIG92ZXJsYXkgY2FuIHByb3Blcmx5XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCBwb3NpdGlvbmluZyBiYXNlZCBvbiB0aGUgc2l6ZSBvZiB0aGUgdGV4dC5cbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLl9uZ1pvbmUub25NaWNyb3Rhc2tFbXB0eS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kVG9vbHRpcFBvc2l0aW9uJyksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCd0b29sdGlwLXBvc2l0aW9uJyksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcIl9wb3NpdGlvbkRlcHJlY2F0ZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kVG9vbHRpcFNob3dEZWxheScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUb29sdGlwLnByb3RvdHlwZSwgXCJzaG93RGVsYXlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWRUb29sdGlwSGlkZURlbGF5JyksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcImhpZGVEZWxheVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZFRvb2x0aXAnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kVG9vbHRpcC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWQtdG9vbHRpcCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZE1lc3NhZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21hdFRvb2x0aXAnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX21hdE1lc3NhZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21hdFRvb2x0aXBQb3NpdGlvbicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0UG9zaXRpb25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21hdFRvb2x0aXBIaWRlRGVsYXknKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kVG9vbHRpcC5wcm90b3R5cGUsIFwiX21hdEhpZGVEZWxheVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDY2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWF0VG9vbHRpcFNob3dEZWxheScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRUb29sdGlwLnByb3RvdHlwZSwgXCJfbWF0U2hvd0RlbGF5XCIsIG51bGwpO1xuICAgIE1kVG9vbHRpcCA9IF9fZGVjb3JhdGUkNjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10b29sdGlwXSwgW21kVG9vbHRpcF0sIFttYXQtdG9vbHRpcF0sIFttYXRUb29sdGlwXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJyhsb25ncHJlc3MpJzogJ3Nob3coKScsXG4gICAgICAgICAgICAgICAgJyh0b3VjaGVuZCknOiAnaGlkZSgnICsgVE9VQ0hFTkRfSElERV9ERUxBWSArICcpJyxcbiAgICAgICAgICAgICAgICAnKG1vdXNlZW50ZXIpJzogJ3Nob3coKScsXG4gICAgICAgICAgICAgICAgJyhtb3VzZWxlYXZlKSc6ICdoaWRlKCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRUb29sdGlwJyxcbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMTQoNSwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXksIFNjcm9sbERpc3BhdGNoZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCBfYW5ndWxhcl9jb3JlLk5nWm9uZSwgRGlyXSlcbiAgICBdLCBNZFRvb2x0aXApO1xuICAgIHJldHVybiBNZFRvb2x0aXA7XG59KCkpO1xuLyoqXG4gKiBJbnRlcm5hbCBjb21wb25lbnQgdGhhdCB3cmFwcyB0aGUgdG9vbHRpcCdzIGNvbnRlbnQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBUb29sdGlwQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwQ29tcG9uZW50KF9kaXIsIF9jaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgLyoqIFByb3BlcnR5IHdhdGNoZWQgYnkgdGhlIGFuaW1hdGlvbiBmcmFtZXdvcmsgdG8gc2hvdyBvciBoaWRlIHRoZSB0b29sdGlwICovXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSAnaW5pdGlhbCc7XG4gICAgICAgIC8qKiBXaGV0aGVyIGludGVyYWN0aW9ucyBvbiB0aGUgcGFnZSBzaG91bGQgY2xvc2UgdGhlIHRvb2x0aXAgKi9cbiAgICAgICAgdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgdHJhbnNmb3JtIG9yaWdpbiB1c2VkIGluIHRoZSBhbmltYXRpb24gZm9yIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgdG9vbHRpcCAqL1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1PcmlnaW4gPSAnYm90dG9tJztcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGF0IHRoZSB0b29sdGlwIGhhcyBiZWVuIGhpZGRlbiBmcm9tIHRoZSB2aWV3ICovXG4gICAgICAgIHRoaXMuX29uSGlkZSA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgdG9vbHRpcCB3aXRoIGFuIGFuaW1hdGlvbiBvcmlnaW5hdGluZyBmcm9tIHRoZSBwcm92aWRlZCBvcmlnaW5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gUG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuXG4gICAgICogQHBhcmFtIGRlbGF5IEFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGRlbGF5IHNob3dpbmcgdGhlIHRvb2x0aXAuXG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZGVsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWxheWVkIGhpZGUgaWYgaXQgaXMgc2NoZWR1bGVkXG4gICAgICAgIGlmICh0aGlzLl9oaWRlVGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm9keSBpbnRlcmFjdGlvbnMgc2hvdWxkIGNhbmNlbCB0aGUgdG9vbHRpcCBpZiB0aGVyZSBpcyBhIGRlbGF5IGluIHNob3dpbmcuXG4gICAgICAgIHRoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NldFRyYW5zZm9ybU9yaWdpbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl92aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgc2V0IHRvIHRydWUgaW1tZWRpYXRlbHksIHRoZW4gYSBib2R5IGNsaWNrIHRoYXQgdHJpZ2dlcnMgc2hvdygpIHdvdWxkXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGludGVyYWN0aW9uIGFuZCBjbG9zZSB0aGUgdG9vbHRpcCByaWdodCBhZnRlciBpdCB3YXMgZGlzcGxheWVkLlxuICAgICAgICAgICAgX3RoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gTWFyayBmb3IgY2hlY2sgc28gaWYgYW55IHBhcmVudCBjb21wb25lbnQgaGFzIHNldCB0aGVcbiAgICAgICAgICAgIC8vIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IHRvIE9uUHVzaCBpdCB3aWxsIGJlIGNoZWNrZWQgYW55d2F5c1xuICAgICAgICAgICAgX3RoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IF90aGlzLl9jbG9zZU9uSW50ZXJhY3Rpb24gPSB0cnVlOyB9LCAwKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmVnaW5zIHRoZSBhbmltYXRpb24gdG8gaGlkZSB0aGUgdG9vbHRpcCBhZnRlciB0aGUgcHJvdmlkZWQgZGVsYXkgaW4gbXMuXG4gICAgICogQHBhcmFtIGRlbGF5IEFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgc2hvd2luZyB0aGUgdG9vbHRpcC5cbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVsYXllZCBzaG93IGlmIGl0IGlzIHNjaGVkdWxlZFxuICAgICAgICBpZiAodGhpcy5fc2hvd1RpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl92aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBfdGhpcy5fY2xvc2VPbkludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBNYXJrIGZvciBjaGVjayBzbyBpZiBhbnkgcGFyZW50IGNvbXBvbmVudCBoYXMgc2V0IHRoZVxuICAgICAgICAgICAgLy8gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgdG8gT25QdXNoIGl0IHdpbGwgYmUgY2hlY2tlZCBhbnl3YXlzXG4gICAgICAgICAgICBfdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IG5vdGlmaWVzIHdoZW4gdGhlIHRvb2x0aXAgaGFzIGJlZW4gaGlkZGVuIGZyb20gdmlld1xuICAgICAqL1xuICAgIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLmFmdGVySGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25IaWRlLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgdG9vbHRpcCBpcyBiZWluZyBkaXNwbGF5ZWRcbiAgICAgKi9cbiAgICBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmlsaXR5ID09PSAndmlzaWJsZSc7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgdG9vbHRpcCB0cmFuc2Zvcm0gb3JpZ2luIGFjY29yZGluZyB0byB0aGUgdG9vbHRpcCBwb3NpdGlvbiAqL1xuICAgIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLl9zZXRUcmFuc2Zvcm1PcmlnaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGlzTHRyID0gIXRoaXMuX2RpciB8fCB0aGlzLl9kaXIudmFsdWUgPT0gJ2x0cic7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gaXNMdHIgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9IGlzTHRyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWJvdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmVsb3cnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybU9yaWdpbiA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IE1kVG9vbHRpcEludmFsaWRQb3NpdGlvbkVycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuX2FmdGVyVmlzaWJpbGl0eUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RhdGUgPT09ICdoaWRkZW4nICYmICF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkhpZGUubmV4dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcmFjdGlvbnMgb24gdGhlIEhUTUwgYm9keSBzaG91bGQgY2xvc2UgdGhlIHRvb2x0aXAgaW1tZWRpYXRlbHkgYXMgZGVmaW5lZCBpbiB0aGVcbiAgICAgKiBtYXRlcmlhbCBkZXNpZ24gc3BlYy5cbiAgICAgKiBodHRwczovL21hdGVyaWFsLmdvb2dsZS5jb20vY29tcG9uZW50cy90b29sdGlwcy5odG1sI3Rvb2x0aXBzLWludGVyYWN0aW9uXG4gICAgICovXG4gICAgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUuX2hhbmRsZUJvZHlJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlT25JbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5oaWRlKDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXRvb2x0aXAtY29tcG9uZW50LCBtYXQtdG9vbHRpcC1jb21wb25lbnQnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWF0LXRvb2x0aXBcXFwiIFtzdHlsZS50cmFuc2Zvcm0tb3JpZ2luXT1cXFwiX3RyYW5zZm9ybU9yaWdpblxcXCIgW0BzdGF0ZV09XFxcIl92aXNpYmlsaXR5XFxcIiAoQHN0YXRlLmRvbmUpPVxcXCJfYWZ0ZXJWaXNpYmlsaXR5QW5pbWF0aW9uKCRldmVudClcXFwiPnt7bWVzc2FnZX19PC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e3BvaW50ZXItZXZlbnRzOm5vbmV9Lm1hdC10b29sdGlwe2NvbG9yOiNmZmY7cGFkZGluZzo2cHggOHB4O2JvcmRlci1yYWRpdXM6MnB4O2ZvbnQtZmFtaWx5OlJvYm90byxcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEwcHg7bWFyZ2luOjE0cHg7bWF4LXdpZHRoOjI1MHB4fUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtdG9vbHRpcHtvdXRsaW5lOnNvbGlkIDFweH19XCJdLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUudHJpZ2dlcignc3RhdGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ3ZvaWQnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgX2FuZ3VsYXJfY29yZS5zdGF0ZSgnaW5pdGlhbCcsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCd2aXNpYmxlJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDEpJyB9KSksXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ2hpZGRlbicsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJyogPT4gdmlzaWJsZScsIF9hbmd1bGFyX2NvcmUuYW5pbWF0ZSgnMTUwbXMgY3ViaWMtYmV6aWVyKDAuMCwgMC4wLCAwLjIsIDEpJykpLFxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJyogPT4gaGlkZGVuJywgX2FuZ3VsYXJfY29yZS5hbmltYXRlKCcxNTBtcyBjdWJpYy1iZXppZXIoMC40LCAwLjAsIDEsIDEpJykpLFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICcoYm9keTpjbGljayknOiAndGhpcy5faGFuZGxlQm9keUludGVyYWN0aW9uKCknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDE0KDAsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDY2KCdkZXNpZ246cGFyYW10eXBlcycsIFtEaXIsIF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuICAgIF0sIFRvb2x0aXBDb21wb25lbnQpO1xuICAgIHJldHVybiBUb29sdGlwQ29tcG9uZW50O1xufSgpKTtcbnZhciBNZFRvb2x0aXBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVG9vbHRpcE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRUb29sdGlwTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRUb29sdGlwTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRUb29sdGlwTW9kdWxlID0gX19kZWNvcmF0ZSQ2NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW092ZXJsYXlNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kVG9vbHRpcCwgVG9vbHRpcENvbXBvbmVudCwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFRvb2x0aXAsIFRvb2x0aXBDb21wb25lbnRdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbVG9vbHRpcENvbXBvbmVudF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFRvb2x0aXBNb2R1bGUpO1xuICAgIHJldHVybiBNZFRvb2x0aXBNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDIxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIG1lbnUgdHJpZ2dlciBkb2Vzbid0IGhhdmUgYSB2YWxpZCBtZC1tZW51IGluc3RhbmNlXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZE1lbnVNaXNzaW5nRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyMShNZE1lbnVNaXNzaW5nRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRNZW51TWlzc2luZ0Vycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIm1kLW1lbnUtdHJpZ2dlcjogbXVzdCBwYXNzIGluIGFuIG1kLW1lbnUgaW5zdGFuY2UuXFxuXFxuICAgIEV4YW1wbGU6XFxuICAgICAgPG1kLW1lbnUgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlxcbiAgICAgIDxidXR0b24gW21kTWVudVRyaWdnZXJGb3JdPVxcXCJtZW51XFxcIj48L2J1dHRvbj5cXG4gICAgXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRNZW51TWlzc2luZ0Vycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBtZW51J3MgeC1wb3NpdGlvbiB2YWx1ZSBpc24ndCB2YWxpZC5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdiZWZvcmUnIG9yICdhZnRlcicuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbnZhciBNZE1lbnVJbnZhbGlkUG9zaXRpb25YID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMjEoTWRNZW51SW52YWxpZFBvc2l0aW9uWCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZE1lbnVJbnZhbGlkUG9zaXRpb25YKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIngtcG9zaXRpb24gdmFsdWUgbXVzdCBiZSBlaXRoZXIgJ2JlZm9yZScgb3IgYWZ0ZXInLlxcbiAgICAgIEV4YW1wbGU6IDxtZC1tZW51IHgtcG9zaXRpb249XFxcImJlZm9yZVxcXCIgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlxcbiAgICBcIik7XG4gICAgfVxuICAgIHJldHVybiBNZE1lbnVJbnZhbGlkUG9zaXRpb25YO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBtZW51J3MgeS1wb3NpdGlvbiB2YWx1ZSBpc24ndCB2YWxpZC5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdhYm92ZScgb3IgJ2JlbG93Jy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1kTWVudUludmFsaWRQb3NpdGlvblkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyMShNZE1lbnVJbnZhbGlkUG9zaXRpb25ZLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kTWVudUludmFsaWRQb3NpdGlvblkoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwieS1wb3NpdGlvbiB2YWx1ZSBtdXN0IGJlIGVpdGhlciAnYWJvdmUnIG9yIGJlbG93Jy5cXG4gICAgICBFeGFtcGxlOiA8bWQtbWVudSB5LXBvc2l0aW9uPVxcXCJhYm92ZVxcXCIgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlxcbiAgICBcIik7XG4gICAgfVxuICAgIHJldHVybiBNZE1lbnVJbnZhbGlkUG9zaXRpb25ZO1xufShNZEVycm9yKSk7XG5cbnZhciBfX2RlY29yYXRlJDY5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW5zaWRlIGFuIG1kLW1lbnUgdGFnLlxuICogSXQgZXhpc3RzIG1vc3RseSB0byBzZXQgdGhlIHJvbGUgYXR0cmlidXRlLlxuICovXG52YXIgTWRNZW51SXRlbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRNZW51SXRlbShfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIE1kTWVudUl0ZW0ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51SXRlbS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0IGFuY2hvcnNcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIG1lbnUgaXRlbSBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXNhYmxlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51SXRlbS5wcm90b3R5cGUsIFwiaXNBcmlhRGlzYWJsZWRcIiwge1xuICAgICAgICAvKiogU2V0cyB0aGUgYXJpYS1kaXNhYmxlZCBwcm9wZXJ0eSBvbiB0aGUgbWVudSBpdGVtLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0cmluZyghIXRoaXMuZGlzYWJsZWQpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51SXRlbS5wcm90b3R5cGUsIFwiX3RhYmluZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc2FibGVkID8gJy0xJyA6ICcwJzsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRNZW51SXRlbS5wcm90b3R5cGUuX2dldEhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH07XG4gICAgTWRNZW51SXRlbS5wcm90b3R5cGUuX2NoZWNrRGlzYWJsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ2OShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuZGlzYWJsZWQnKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kTWVudUl0ZW0ucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNjkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZGlzYWJsZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjkoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kTWVudUl0ZW0ucHJvdG90eXBlLCBcImlzQXJpYURpc2FibGVkXCIsIG51bGwpO1xuICAgIE1kTWVudUl0ZW0gPSBfX2RlY29yYXRlJDY5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnW21kLW1lbnUtaXRlbV0sIFttYXQtbWVudS1pdGVtXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnbWVudWl0ZW0nLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LW1lbnUtaXRlbV0nOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgJyhjbGljayknOiAnX2NoZWNrRGlzYWJsZWQoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfdGFiaW5kZXgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjxkaXYgY2xhc3M9XFxcIm1hdC1tZW51LXJpcHBsZVxcXCIgKm5nSWY9XFxcIiFkaXNhYmxlZFxcXCIgbWQtcmlwcGxlIFttZFJpcHBsZVRyaWdnZXJdPVxcXCJfZ2V0SG9zdEVsZW1lbnQoKVxcXCI+PC9kaXY+XCIsXG4gICAgICAgICAgICBleHBvcnRBczogJ21kTWVudUl0ZW0nXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZE1lbnVJdGVtKTtcbiAgICByZXR1cm4gTWRNZW51SXRlbTtcbn0oKSk7XG5cbi8qKlxuICogQmVsb3cgYXJlIGFsbCB0aGUgYW5pbWF0aW9ucyBmb3IgdGhlIG1kLW1lbnUgY29tcG9uZW50LlxuICogQW5pbWF0aW9uIGR1cmF0aW9uIGFuZCB0aW1pbmcgdmFsdWVzIGFyZSBiYXNlZCBvbiBBbmd1bGFySlMgTWF0ZXJpYWwuXG4gKi9cbi8qKlxuICogVGhpcyBhbmltYXRpb24gY29udHJvbHMgdGhlIG1lbnUgcGFuZWwncyBlbnRyeSBhbmQgZXhpdCBmcm9tIHRoZSBwYWdlLlxuICpcbiAqIFdoZW4gdGhlIG1lbnUgcGFuZWwgaXMgYWRkZWQgdG8gdGhlIERPTSwgaXQgc2NhbGVzIGluIGFuZCBmYWRlcyBpbiBpdHMgYm9yZGVyLlxuICpcbiAqIFdoZW4gdGhlIG1lbnUgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIGl0IHNpbXBseSBmYWRlcyBvdXQgYWZ0ZXIgYSBicmllZlxuICogZGVsYXkgdG8gZGlzcGxheSB0aGUgcmlwcGxlLlxuICovXG4vLyBUT0RPKGthcmEpOiBzd2l0Y2ggdG8gOmVudGVyIGFuZCA6bGVhdmUgb25jZSBNb2JpbGUgU2FmYXJpIGlzIHNvcnRlZCBvdXQuXG52YXIgdHJhbnNmb3JtTWVudSA9IF9hbmd1bGFyX2NvcmUudHJpZ2dlcigndHJhbnNmb3JtTWVudScsIFtcbiAgICBfYW5ndWxhcl9jb3JlLnN0YXRlKCdzaG93aW5nJywgX2FuZ3VsYXJfY29yZS5zdHlsZSh7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZSgxKVwiXG4gICAgfSkpLFxuICAgIF9hbmd1bGFyX2NvcmUudHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLnN0eWxlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMClcIlxuICAgICAgICB9KSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5hbmltYXRlKFwiMjAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSlcIilcbiAgICBdKSxcbiAgICBfYW5ndWxhcl9jb3JlLnRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5hbmltYXRlKCc1MG1zIDEwMG1zIGxpbmVhcicsIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxuICAgIF0pXG5dKTtcbi8qKlxuICogVGhpcyBhbmltYXRpb24gZmFkZXMgaW4gdGhlIGJhY2tncm91bmQgY29sb3IgYW5kIGNvbnRlbnQgb2YgdGhlIG1lbnUgcGFuZWxcbiAqIGFmdGVyIGl0cyBjb250YWluaW5nIGVsZW1lbnQgaXMgc2NhbGVkIGluLlxuICovXG52YXIgZmFkZUluSXRlbXMgPSBfYW5ndWxhcl9jb3JlLnRyaWdnZXIoJ2ZhZGVJbkl0ZW1zJywgW1xuICAgIF9hbmd1bGFyX2NvcmUuc3RhdGUoJ3Nob3dpbmcnLCBfYW5ndWxhcl9jb3JlLnN0eWxlKHsgb3BhY2l0eTogMSB9KSksXG4gICAgX2FuZ3VsYXJfY29yZS50cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLmFuaW1hdGUoXCIyMDBtcyAxMDBtcyBjdWJpYy1iZXppZXIoMC41NSwgMCwgMC41NSwgMC4yKVwiKVxuICAgIF0pXG5dKTtcblxuLy8gVE9ETyhrYXJhKTogcHJldmVudC1jbG9zZSBmdW5jdGlvbmFsaXR5XG52YXIgX19kZWNvcmF0ZSQ2OCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2OCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTUgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgTWRNZW51ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE1lbnUocG9zWCwgcG9zWSkge1xuICAgICAgICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgbWVudSdzIG5nQ2xhc3MgKi9cbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0ID0ge307XG4gICAgICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgbWVudSBpbiB0aGUgWCBheGlzLiAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uWCA9ICdhZnRlcic7XG4gICAgICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgbWVudSBpbiB0aGUgWSBheGlzLiAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uWSA9ICdiZWxvdyc7XG4gICAgICAgIHRoaXMub3ZlcmxhcFRyaWdnZXIgPSB0cnVlO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBtZW51IGlzIGNsb3NlZC4gKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICBpZiAocG9zWCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb25YKHBvc1gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NZKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvblkocG9zWSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXModGhpcy5wb3NpdGlvblgsIHRoaXMucG9zaXRpb25ZKTtcbiAgICB9XG4gICAgTWRNZW51LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIgPSBuZXcgRm9jdXNLZXlNYW5hZ2VyKHRoaXMuaXRlbXMpLndpdGhXcmFwKCk7XG4gICAgICAgIHRoaXMuX3RhYlN1YnNjcmlwdGlvbiA9IHRoaXMuX2tleU1hbmFnZXIudGFiT3V0LnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZE1lbnUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YWJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnUucHJvdG90eXBlLCBcImNsYXNzTGlzdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjbGFzc2VzIHNldCBvbiB0aGUgaG9zdCBtZC1tZW51IGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSBvbiB0aGVcbiAgICAgICAgICogbWVudSB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcbiAgICAgICAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgbWVudSBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQHBhcmFtIGNsYXNzZXMgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5fY2xhc3NMaXN0ID0gY2xhc3Nlcy5zcGxpdCgnICcpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBvYmpbY2xhc3NOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKHRoaXMucG9zaXRpb25YLCB0aGlzLnBvc2l0aW9uWSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZvY3VzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBtZW51LiBUaGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHRoZSBtZW51IHRyaWdnZXJcbiAgICAgKiB0byBmb2N1cyB0aGUgZmlyc3QgaXRlbSB3aGVuIHRoZSBtZW51IGlzIG9wZW5lZCBieSB0aGUgRU5URVIga2V5LlxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUuZm9jdXNGaXJzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcbiAgICAgKiB0cmlnZ2VyIHdpbGwgY2xvc2UgdGhlIG1lbnUuXG4gICAgICovXG4gICAgTWRNZW51LnByb3RvdHlwZS5fZW1pdENsb3NlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICAgIH07XG4gICAgTWRNZW51LnByb3RvdHlwZS5fc2V0UG9zaXRpb25YID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAocG9zICE9PSAnYmVmb3JlJyAmJiBwb3MgIT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZE1lbnVJbnZhbGlkUG9zaXRpb25YKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3NpdGlvblggPSBwb3M7XG4gICAgfTtcbiAgICBNZE1lbnUucHJvdG90eXBlLl9zZXRQb3NpdGlvblkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgIT09ICdhYm92ZScgJiYgcG9zICE9PSAnYmVsb3cnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRNZW51SW52YWxpZFBvc2l0aW9uWSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zaXRpb25ZID0gcG9zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXQncyBuZWNlc3NhcnkgdG8gc2V0IHBvc2l0aW9uLWJhc2VkIGNsYXNzZXMgdG8gZW5zdXJlIHRoZSBtZW51IHBhbmVsIGFuaW1hdGlvblxuICAgICAqIGZvbGRzIG91dCBmcm9tIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLnNldFBvc2l0aW9uQ2xhc3NlcyA9IGZ1bmN0aW9uIChwb3NYLCBwb3NZKSB7XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnbWF0LW1lbnUtYmVmb3JlJ10gPSBwb3NYID09ICdiZWZvcmUnO1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ21hdC1tZW51LWFmdGVyJ10gPSBwb3NYID09ICdhZnRlcic7XG4gICAgICAgIHRoaXMuX2NsYXNzTGlzdFsnbWF0LW1lbnUtYWJvdmUnXSA9IHBvc1kgPT0gJ2Fib3ZlJztcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydtYXQtbWVudS1iZWxvdyddID0gcG9zWSA9PSAnYmVsb3cnO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ2OChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OCgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmKVxuICAgIF0sIE1kTWVudS5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDY4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRNZW51SXRlbSksIFxuICAgICAgICBfX21ldGFkYXRhJDY4KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kTWVudS5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDY4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51LnByb3RvdHlwZSwgXCJvdmVybGFwVHJpZ2dlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNjgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdjbGFzcycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OCgnZGVzaWduOnR5cGUnLCBTdHJpbmcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2OCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbU3RyaW5nXSlcbiAgICBdLCBNZE1lbnUucHJvdG90eXBlLCBcImNsYXNzTGlzdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDY4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kTWVudS5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbiAgICBNZE1lbnUgPSBfX2RlY29yYXRlJDY4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtbWVudSwgbWF0LW1lbnUnLFxuICAgICAgICAgICAgaG9zdDogeyAncm9sZSc6ICdtZW51JyB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRlbXBsYXRlPjxkaXYgY2xhc3M9XFxcIm1hdC1tZW51LXBhbmVsXFxcIiBbbmdDbGFzc109XFxcIl9jbGFzc0xpc3RcXFwiIChrZXlkb3duKT1cXFwiX2tleU1hbmFnZXIub25LZXlkb3duKCRldmVudClcXFwiIChjbGljayk9XFxcIl9lbWl0Q2xvc2VFdmVudCgpXFxcIiBbQHRyYW5zZm9ybU1lbnVdPVxcXCInc2hvd2luZydcXFwiPjxkaXYgY2xhc3M9XFxcIm1hdC1tZW51LWNvbnRlbnRcXFwiIFtAZmFkZUluSXRlbXNdPVxcXCInc2hvd2luZydcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2Rpdj48L2Rpdj48L3RlbXBsYXRlPlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWF0LW1lbnUtcGFuZWx7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDoxMTJweDttYXgtd2lkdGg6MjgwcHg7b3ZlcmZsb3c6YXV0bzstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDttYXgtaGVpZ2h0OmNhbGMoMTAwdmggKyA0OHB4KX0ubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYWZ0ZXIubWF0LW1lbnUtYmVsb3d7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IHRvcH0ubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYWZ0ZXIubWF0LW1lbnUtYWJvdmV7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IGJvdHRvbX0ubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYmVmb3JlLm1hdC1tZW51LWJlbG93e3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgdG9wfS5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1iZWZvcmUubWF0LW1lbnUtYWJvdmV7dHJhbnNmb3JtLW9yaWdpbjpyaWdodCBib3R0b219W2Rpcj1ydGxdIC5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1hZnRlci5tYXQtbWVudS1iZWxvd3t0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0IHRvcH1bZGlyPXJ0bF0gLm1hdC1tZW51LXBhbmVsLm1hdC1tZW51LWFmdGVyLm1hdC1tZW51LWFib3Zle3RyYW5zZm9ybS1vcmlnaW46cmlnaHQgYm90dG9tfVtkaXI9cnRsXSAubWF0LW1lbnUtcGFuZWwubWF0LW1lbnUtYmVmb3JlLm1hdC1tZW51LWJlbG93e3RyYW5zZm9ybS1vcmlnaW46bGVmdCB0b3B9W2Rpcj1ydGxdIC5tYXQtbWVudS1wYW5lbC5tYXQtbWVudS1iZWZvcmUubWF0LW1lbnUtYWJvdmV7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0IGJvdHRvbX1AbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6YWN0aXZlKXsubWF0LW1lbnUtcGFuZWx7b3V0bGluZTpzb2xpZCAxcHh9fS5tYXQtbWVudS1jb250ZW50e3BhZGRpbmctdG9wOjhweDtwYWRkaW5nLWJvdHRvbTo4cHh9Lm1hdC1tZW51LWl0ZW17Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO291dGxpbmU6MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3cteDpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpcztkaXNwbGF5OmJsb2NrO2xpbmUtaGVpZ2h0OjQ4cHg7aGVpZ2h0OjQ4cHg7cGFkZGluZzowIDE2cHg7Zm9udC1zaXplOjE2cHg7Zm9udC1mYW1pbHk6Um9ib3RvLFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsc2Fucy1zZXJpZjt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtbWVudS1pdGVtW2Rpc2FibGVkXXtjdXJzb3I6ZGVmYXVsdH0ubWF0LW1lbnUtaXRlbSAubWF0LWljb257bWFyZ2luLXJpZ2h0OjE2cHh9W2Rpcj1ydGxdIC5tYXQtbWVudS1pdGVtIC5tYXQtaWNvbnttYXJnaW4tbGVmdDoxNnB4fWJ1dHRvbi5tYXQtbWVudS1pdGVte3dpZHRoOjEwMCV9Lm1hdC1tZW51LXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MH1cIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtTWVudSxcbiAgICAgICAgICAgICAgICBmYWRlSW5JdGVtc1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRNZW51J1xuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQxNSgwLCBfYW5ndWxhcl9jb3JlLkF0dHJpYnV0ZSgneC1wb3NpdGlvbicpKSxcbiAgICAgICAgX19wYXJhbSQxNSgxLCBfYW5ndWxhcl9jb3JlLkF0dHJpYnV0ZSgneS1wb3NpdGlvbicpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNjgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZywgU3RyaW5nXSlcbiAgICBdLCBNZE1lbnUpO1xuICAgIHJldHVybiBNZE1lbnU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ3MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3MCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTYgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhbiBtZC1tZW51IHRhZy4gIEl0IGlzXG4gKiByZXNwb25zaWJsZSBmb3IgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIHByb3ZpZGVkIG1lbnUgaW5zdGFuY2UuXG4gKiBUT0RPKGFuZHJld3NlZ3Vpbik6IFJlbW92ZSB0aGUga2ViYWIgdmVyc2lvbnMgaW4gZmF2b3Igb2YgY2FtZWxDYXNlZCBhdHRyaWJ1dGUgc2VsZWN0b3JzXG4gKi9cbnZhciBNZE1lbnVUcmlnZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE1lbnVUcmlnZ2VyKF9vdmVybGF5LCBfZWxlbWVudCwgX3ZpZXdDb250YWluZXJSZWYsIF9yZW5kZXJlciwgX2Rpcikge1xuICAgICAgICB0aGlzLl9vdmVybGF5ID0gX292ZXJsYXk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZGlyID0gX2RpcjtcbiAgICAgICAgdGhpcy5fbWVudU9wZW4gPSBmYWxzZTtcbiAgICAgICAgLy8gdHJhY2tpbmcgaW5wdXQgdHlwZSBpcyBuZWNlc3Nhcnkgc28gaXQncyBwb3NzaWJsZSB0byBvbmx5IGF1dG8tZm9jdXNcbiAgICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIGxpc3Qgd2hlbiB0aGUgbWVudSBpcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZFxuICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gZmFsc2U7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgbWVudSBpcyBvcGVuZWQuICovXG4gICAgICAgIHRoaXMub25NZW51T3BlbiA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIG1lbnUgaXMgY2xvc2VkLiAqL1xuICAgICAgICB0aGlzLm9uTWVudUNsb3NlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZSwgXCJfZGVwcmVjYXRlZE1kTWVudVRyaWdnZXJGb3JcIiwge1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lbnU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5tZW51ID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIl9kZXByZWNhdGVkTWF0TWVudVRyaWdnZXJGb3JcIiwge1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm1lbnU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5tZW51ID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIl9tYXRNZW51VHJpZ2dlckZvclwiLCB7XG4gICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWVudTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLm1lbnUgPSB2OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NoZWNrTWVudSgpO1xuICAgICAgICB0aGlzLm1lbnUuY2xvc2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb3NlTWVudSgpOyB9KTtcbiAgICB9O1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRlc3Ryb3lNZW51KCk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIm1lbnVPcGVuXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIG1lbnUgaXMgb3Blbi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tZW51T3BlbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFRvZ2dsZXMgdGhlIG1lbnUgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS50b2dnbGVNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVudU9wZW4gPyB0aGlzLmNsb3NlTWVudSgpIDogdGhpcy5vcGVuTWVudSgpO1xuICAgIH07XG4gICAgLyoqIE9wZW5zIHRoZSBtZW51LiAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLm9wZW5NZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21lbnVPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9wb3J0YWwpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcCgpO1xuICAgICAgICAgICAgdGhpcy5faW5pdE1lbnUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENsb3NlcyB0aGUgbWVudS4gKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5jbG9zZU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0TWVudSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogUmVtb3ZlcyB0aGUgbWVudSBmcm9tIHRoZSBET00uICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuZGVzdHJveU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEZvY3VzZXMgdGhlIG1lbnUgdHJpZ2dlci4gKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZCh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdmb2N1cycpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgICAgIC8qKiBUaGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgbWVudSBjbG9zZXMgd2hlbiB0aGUgb3ZlcmxheSBiYWNrZHJvcCBpcyBjbGlja2VkLlxuICAgICAqIFdlIGRvIG5vdCB1c2UgZmlyc3QoKSBoZXJlIGJlY2F1c2UgZG9pbmcgc28gd291bGQgbm90IGNhdGNoIGNsaWNrcyBmcm9tIHdpdGhpblxuICAgICAqIHRoZSBtZW51LCBhbmQgaXQgd291bGQgZmFpbCB0byB1bnN1YnNjcmliZSBwcm9wZXJseS4gSW5zdGVhZCwgd2UgdW5zdWJzY3JpYmVcbiAgICAgKiBleHBsaWNpdGx5IHdoZW4gdGhlIG1lbnUgaXMgY2xvc2VkIG9yIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fc3Vic2NyaWJlVG9CYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24gPSB0aGlzLl9vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgbWVudSBzdGF0ZSB0byBvcGVuIGFuZCBmb2N1c2VzIHRoZSBmaXJzdCBpdGVtIGlmXG4gICAgICogdGhlIG1lbnUgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9pbml0TWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0SXNNZW51T3Blbih0cnVlKTtcbiAgICAgICAgLy8gU2hvdWxkIG9ubHkgc2V0IGZvY3VzIGlmIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLCBzbyBrZXlib2FyZCB1c2VycyBjYW5cbiAgICAgICAgLy8gY2FuIGVhc2lseSBuYXZpZ2F0ZSBtZW51IGl0ZW1zLiBBY2NvcmRpbmcgdG8gc3BlYywgbW91c2UgdXNlcnMgc2hvdWxkIG5vdFxuICAgICAgICAvLyBzZWUgdGhlIGZvY3VzIHN0eWxlLlxuICAgICAgICBpZiAoIXRoaXMuX29wZW5lZEJ5TW91c2UpIHtcbiAgICAgICAgICAgIHRoaXMubWVudS5mb2N1c0ZpcnN0SXRlbSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIG1lbnUgd2hlbiBpdCdzIGNsb3NlZCwgbW9zdCBpbXBvcnRhbnRseSByZXN0b3JpbmdcbiAgICAgKiBmb2N1cyB0byB0aGUgbWVudSB0cmlnZ2VyIGlmIHRoZSBtZW51IHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fcmVzZXRNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zZXRJc01lbnVPcGVuKGZhbHNlKTtcbiAgICAgICAgLy8gRm9jdXMgb25seSBuZWVkcyB0byBiZSByZXNldCB0byB0aGUgaG9zdCBlbGVtZW50IGlmIHRoZSBtZW51IHdhcyBvcGVuZWRcbiAgICAgICAgLy8gYnkgdGhlIGtleWJvYXJkIGFuZCBtYW51YWxseSBzaGlmdGVkIHRvIHRoZSBmaXJzdCBtZW51IGl0ZW0uXG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkQnlNb3VzZSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8vIHNldCBzdGF0ZSByYXRoZXIgdGhhbiB0b2dnbGUgdG8gc3VwcG9ydCB0cmlnZ2VycyBzaGFyaW5nIGEgbWVudVxuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9zZXRJc01lbnVPcGVuID0gZnVuY3Rpb24gKGlzT3Blbikge1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5fbWVudU9wZW4gPyB0aGlzLm9uTWVudU9wZW4uZW1pdCgpIDogdGhpcy5vbk1lbnVDbG9zZS5lbWl0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAgVGhpcyBtZXRob2QgY2hlY2tzIHRoYXQgYSB2YWxpZCBpbnN0YW5jZSBvZiBNZE1lbnUgaGFzIGJlZW4gcGFzc2VkIGludG9cbiAgICAgKiAgbWRNZW51VHJpZ2dlckZvci4gSWYgbm90LCBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9jaGVja01lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5tZW51KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRNZW51TWlzc2luZ0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBvdmVybGF5IGZyb20gdGhlIHByb3ZpZGVkIG1lbnUncyB0ZW1wbGF0ZSBhbmQgc2F2ZXMgaXRzXG4gICAgICogIE92ZXJsYXlSZWYgc28gdGhhdCBpdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSB3aGVuIG9wZW5NZW51IGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5tZW51LnRlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKCk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb1Bvc2l0aW9ucyhjb25maWcucG9zaXRpb25TdHJhdGVneSk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBuZWVkZWQgdG8gY3JlYXRlIHRoZSBvdmVybGF5LCB0aGUgT3ZlcmxheVN0YXRlLlxuICAgICAqIEByZXR1cm5zIE92ZXJsYXlTdGF0ZVxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9nZXRPdmVybGF5Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX2dldFBvc2l0aW9uKClcbiAgICAgICAgICAgIC53aXRoRGlyZWN0aW9uKHRoaXMuZGlyKTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLmJhY2tkcm9wQ2xhc3MgPSAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnO1xuICAgICAgICBvdmVybGF5U3RhdGUuZGlyZWN0aW9uID0gdGhpcy5kaXI7XG4gICAgICAgIHJldHVybiBvdmVybGF5U3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW5zIHRvIGNoYW5nZXMgaW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IGFuZCBzZXRzIHRoZSBjb3JyZWN0IGNsYXNzZXNcbiAgICAgKiBvbiB0aGUgbWVudSBiYXNlZCBvbiB0aGUgbmV3IHBvc2l0aW9uLiBUaGlzIGVuc3VyZXMgdGhlIGFuaW1hdGlvbiBvcmlnaW4gaXMgYWx3YXlzXG4gICAgICogY29ycmVjdCwgZXZlbiBpZiBhIGZhbGxiYWNrIHBvc2l0aW9uIGlzIHVzZWQgZm9yIHRoZSBvdmVybGF5LlxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9zdWJzY3JpYmVUb1Bvc2l0aW9ucyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbiA9IHBvc2l0aW9uLm9uUG9zaXRpb25DaGFuZ2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBwb3NYID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm9yaWdpblggPT09ICdzdGFydCcgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XG4gICAgICAgICAgICB2YXIgcG9zWSA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vcmlnaW5ZID09PSAndG9wJyA/ICdiZWxvdycgOiAnYWJvdmUnO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5tZW51Lm92ZXJsYXBUcmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgcG9zWSA9IHBvc1kgPT09ICdiZWxvdycgPyAnYWJvdmUnIDogJ2JlbG93JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm1lbnUuc2V0UG9zaXRpb25DbGFzc2VzKHBvc1gsIHBvc1kpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgZm9yIHRoZSBvdmVybGF5LCBzbyB0aGUgbWVudSBpcyBwcm9wZXJseSBjb25uZWN0ZWRcbiAgICAgKiB0byB0aGUgdHJpZ2dlci5cbiAgICAgKiBAcmV0dXJucyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm1lbnUucG9zaXRpb25YID09PSAnYmVmb3JlJyA/IFsnZW5kJywgJ3N0YXJ0J10gOiBbJ3N0YXJ0JywgJ2VuZCddLCBwb3NYID0gX2FbMF0sIGZhbGxiYWNrWCA9IF9hWzFdO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLm1lbnUucG9zaXRpb25ZID09PSAnYWJvdmUnID8gWydib3R0b20nLCAndG9wJ10gOiBbJ3RvcCcsICdib3R0b20nXSwgb3ZlcmxheVkgPSBfYlswXSwgZmFsbGJhY2tPdmVybGF5WSA9IF9iWzFdO1xuICAgICAgICB2YXIgb3JpZ2luWSA9IG92ZXJsYXlZO1xuICAgICAgICB2YXIgZmFsbGJhY2tPcmlnaW5ZID0gZmFsbGJhY2tPdmVybGF5WTtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnUub3ZlcmxhcFRyaWdnZXIpIHtcbiAgICAgICAgICAgIG9yaWdpblkgPSBvdmVybGF5WSA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICAgICAgZmFsbGJhY2tPcmlnaW5ZID0gZmFsbGJhY2tPdmVybGF5WSA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgICAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50LCB7IG9yaWdpblg6IHBvc1gsIG9yaWdpblk6IG9yaWdpblkgfSwgeyBvdmVybGF5WDogcG9zWCwgb3ZlcmxheVk6IG92ZXJsYXlZIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiBmYWxsYmFja1gsIG9yaWdpblk6IG9yaWdpblkgfSwgeyBvdmVybGF5WDogZmFsbGJhY2tYLCBvdmVybGF5WTogb3ZlcmxheVkgfSlcbiAgICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbih7IG9yaWdpblg6IHBvc1gsIG9yaWdpblk6IGZhbGxiYWNrT3JpZ2luWSB9LCB7IG92ZXJsYXlYOiBwb3NYLCBvdmVybGF5WTogZmFsbGJhY2tPdmVybGF5WSB9KVxuICAgICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKHsgb3JpZ2luWDogZmFsbGJhY2tYLCBvcmlnaW5ZOiBmYWxsYmFja09yaWdpblkgfSwgeyBvdmVybGF5WDogZmFsbGJhY2tYLCBvdmVybGF5WTogZmFsbGJhY2tPdmVybGF5WSB9KTtcbiAgICB9O1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9jbGVhblVwU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2hhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ3MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kLW1lbnUtdHJpZ2dlci1mb3InKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIl9kZXByZWNhdGVkTWRNZW51VHJpZ2dlckZvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDcwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWF0LW1lbnUtdHJpZ2dlci1mb3InKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIl9kZXByZWNhdGVkTWF0TWVudVRyaWdnZXJGb3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ3MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21hdE1lbnVUcmlnZ2VyRm9yJyksIFxuICAgICAgICBfX21ldGFkYXRhJDcwKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZSwgXCJfbWF0TWVudVRyaWdnZXJGb3JcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ3MChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kTWVudVRyaWdnZXJGb3InKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIm1lbnVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDcwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIm9uTWVudU9wZW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDcwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzAoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIm9uTWVudUNsb3NlXCIsIHZvaWQgMCk7XG4gICAgTWRNZW51VHJpZ2dlciA9IF9fZGVjb3JhdGUkNzAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogXCJbbWQtbWVudS10cmlnZ2VyLWZvcl0sIFttYXQtbWVudS10cmlnZ2VyLWZvcl0sIFxcbiAgICAgICAgICAgICBbbWRNZW51VHJpZ2dlckZvcl0sIFttYXRNZW51VHJpZ2dlckZvcl1cIixcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnKG1vdXNlZG93biknOiAnX2hhbmRsZU1vdXNlZG93bigkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICd0b2dnbGVNZW51KCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRNZW51VHJpZ2dlcidcbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMTYoNCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXksIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBEaXJdKVxuICAgIF0sIE1kTWVudVRyaWdnZXIpO1xuICAgIHJldHVybiBNZE1lbnVUcmlnZ2VyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNjcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZE1lbnVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWVudU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRNZW51TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRNZW51TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kTWVudU1vZHVsZSA9IF9fZGVjb3JhdGUkNjcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtPdmVybGF5TW9kdWxlLCBfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBNZFJpcHBsZU1vZHVsZSwgQ29tcGF0aWJpbGl0eU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRNZW51LCBNZE1lbnVJdGVtLCBNZE1lbnVUcmlnZ2VyLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kTWVudSwgTWRNZW51SXRlbSwgTWRNZW51VHJpZ2dlcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ2NygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZE1lbnVNb2R1bGUpO1xuICAgIHJldHVybiBNZE1lbnVNb2R1bGU7XG59KCkpO1xuXG4vLyBUT0RPKGplbGJvdXJuKTogcmVzaXppbmdcbi8vIFRPRE8oamVsYm91cm4pOiBhZnRlck9wZW4gYW5kIGJlZm9yZUNsb3NlXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGRpYWxvZyBvcGVuZWQgdmlhIHRoZSBNZERpYWxvZyBzZXJ2aWNlLlxuICovXG52YXIgTWREaWFsb2dSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nUmVmKF9vdmVybGF5UmVmLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IF9vdmVybGF5UmVmO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IHRoZSBkaWFsb2cgaGFzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIGRpYWxvZ1Jlc3VsdCBPcHRpb25hbCByZXN1bHQgdG8gcmV0dXJuIHRvIHRoZSBkaWFsb2cgb3BlbmVyLlxuICAgICAqL1xuICAgIE1kRGlhbG9nUmVmLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChkaWFsb2dSZXN1bHQpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkLm5leHQoZGlhbG9nUmVzdWx0KTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gb2JzZXJ2YWJsZSB0aGF0IGlzIG5vdGlmaWVkIHdoZW4gdGhlIGRpYWxvZyBpcyBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAqL1xuICAgIE1kRGlhbG9nUmVmLnByb3RvdHlwZS5hZnRlckNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FmdGVyQ2xvc2VkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kRGlhbG9nUmVmO1xufSgpKTtcblxudmFyIE1EX0RJQUxPR19EQVRBID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ01kRGlhbG9nRGF0YScpO1xuLyoqIEN1c3RvbSBpbmplY3RvciB0eXBlIHNwZWNpZmljYWxseSBmb3IgaW5zdGFudGlhdGluZyBjb21wb25lbnRzIHdpdGggYSBkaWFsb2cuICovXG52YXIgRGlhbG9nSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpYWxvZ0luamVjdG9yKF9wYXJlbnRJbmplY3RvciwgX2RpYWxvZ1JlZiwgX2RhdGEpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50SW5qZWN0b3IgPSBfcGFyZW50SW5qZWN0b3I7XG4gICAgICAgIHRoaXMuX2RpYWxvZ1JlZiA9IF9kaWFsb2dSZWY7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBfZGF0YTtcbiAgICB9XG4gICAgRGlhbG9nSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICBpZiAodG9rZW4gPT09IE1kRGlhbG9nUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlhbG9nUmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gTURfRElBTE9HX0RBVEEgJiYgdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudEluamVjdG9yLmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbG9nSW5qZWN0b3I7XG59KCkpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIG9wZW5pbmcgYSBtb2RhbCBkaWFsb2cgd2l0aCB0aGUgTWREaWFsb2cgc2VydmljZS5cbiAqL1xudmFyIE1kRGlhbG9nQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0NvbmZpZygpIHtcbiAgICAgICAgLyoqIFRoZSBBUklBIHJvbGUgb2YgdGhlIGRpYWxvZyBlbGVtZW50LiAqL1xuICAgICAgICB0aGlzLnJvbGUgPSAnZGlhbG9nJztcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHVzZXIgY2FuIHVzZSBlc2NhcGUgb3IgY2xpY2tpbmcgb3V0c2lkZSB0byBjbG9zZSBhIG1vZGFsLiAqL1xuICAgICAgICB0aGlzLmRpc2FibGVDbG9zZSA9IGZhbHNlO1xuICAgICAgICAvKiogV2lkdGggb2YgdGhlIGRpYWxvZy4gKi9cbiAgICAgICAgdGhpcy53aWR0aCA9ICcnO1xuICAgICAgICAvKiogSGVpZ2h0IG9mIHRoZSBkaWFsb2cuICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gJyc7XG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ0NvbmZpZztcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMjMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYSBDb21wb25lbnRQb3J0YWwgaXMgYXR0YWNoZWQgdG8gYSBEb21Qb3J0YWxIb3N0IHdpdGhvdXQgYW4gb3JpZ2luLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyMyhNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIGRpYWxvZyBjb250ZW50IGFmdGVyIGNvbnRlbnQgaXMgYWxyZWFkeSBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gTWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3I7XG59KE1kRXJyb3IpKTtcblxudmFyIF9fZXh0ZW5kcyQyMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ3MyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3MyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBJbnRlcm5hbCBjb21wb25lbnQgdGhhdCB3cmFwcyB1c2VyLXByb3ZpZGVkIGRpYWxvZyBjb250ZW50LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG52YXIgTWREaWFsb2dDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyMihNZERpYWxvZ0NvbnRhaW5lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0NvbnRhaW5lcihfbmdab25lLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAvKiogRWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgZGlhbG9nIHdhcyBvcGVuZWQuIFNhdmUgdGhpcyB0byByZXN0b3JlIHVwb24gY2xvc2UuICovXG4gICAgICAgIHRoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlRGlhbG9nV2FzT3BlbmVkID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgQ29tcG9uZW50UG9ydGFsIGFzIGNvbnRlbnQgdG8gdGhpcyBkaWFsb2cgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSBwb3J0YWwgUG9ydGFsIHRvIGJlIGF0dGFjaGVkIGFzIHRoZSBkaWFsb2cgY29udGVudC5cbiAgICAgKi9cbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuYXR0YWNoQ29tcG9uZW50UG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBpZiAodGhpcy5fcG9ydGFsSG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoUmVzdWx0ID0gdGhpcy5fcG9ydGFsSG9zdC5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgdGhpcy5fdHJhcEZvY3VzKCk7XG4gICAgICAgIHJldHVybiBhdHRhY2hSZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYSBUZW1wbGF0ZVBvcnRhbCBhcyBjb250ZW50IHRvIHRoaXMgZGlhbG9nIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gcG9ydGFsIFBvcnRhbCB0byBiZSBhdHRhY2hlZCBhcyB0aGUgZGlhbG9nIGNvbnRlbnQuXG4gICAgICovXG4gICAgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBpZiAodGhpcy5fcG9ydGFsSG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoZWRSZXN1bHQgPSB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIHRoaXMuX3RyYXBGb2N1cygpO1xuICAgICAgICByZXR1cm4gYXR0YWNoZWRSZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlcyB0aGUgZm9jdXMgaW5zaWRlIHRoZSBmb2N1cyB0cmFwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLl90cmFwRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHdlcmUgdG8gYXR0ZW1wdCB0byBmb2N1cyBpbW1lZGlhdGVseSwgdGhlbiB0aGUgY29udGVudCBvZiB0aGUgZGlhbG9nIHdvdWxkIG5vdCB5ZXQgYmVcbiAgICAgICAgLy8gcmVhZHkgaW4gaW5zdGFuY2VzIHdoZXJlIGNoYW5nZSBkZXRlY3Rpb24gaGFzIHRvIHJ1biBmaXJzdC4gVG8gZGVhbCB3aXRoIHRoaXMsIHdlIHNpbXBseVxuICAgICAgICAvLyB3YWl0IGZvciB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGVtcHR5LlxuICAgICAgICB0aGlzLl9uZ1pvbmUub25NaWNyb3Rhc2tFbXB0eS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVEaWFsb2dXYXNPcGVuZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgX3RoaXMuX2ZvY3VzVHJhcC5mb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWREaWFsb2dDb250YWluZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXaGVuIHRoZSBkaWFsb2cgaXMgZGVzdHJveWVkLCByZXR1cm4gZm9jdXMgdG8gdGhlIGVsZW1lbnQgdGhhdCBvcmlnaW5hbGx5IGhhZCBpdCBiZWZvcmVcbiAgICAgICAgLy8gdGhlIGRpYWxvZyB3YXMgb3BlbmVkLiBXYWl0IGZvciB0aGUgRE9NIHRvIGZpbmlzaCBzZXR0bGluZyBiZWZvcmUgY2hhbmdpbmcgdGhlIGZvY3VzIHNvXG4gICAgICAgIC8vIHRoYXQgaXQgZG9lc24ndCBlbmQgdXAgYmFjayBvbiB0aGUgPGJvZHk+LiBBbHNvIG5vdGUgdGhhdCB3ZSBuZWVkIHRoZSBleHRyYSBjaGVjaywgYmVjYXVzZVxuICAgICAgICAvLyBJRSBjYW4gc2V0IHRoZSBgYWN0aXZlRWxlbWVudGAgdG8gbnVsbCBpbiBzb21lIGNhc2VzLlxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVEaWFsb2dXYXNPcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVuZGVyZXIuaW52b2tlRWxlbWVudE1ldGhvZChfdGhpcy5fZWxlbWVudEZvY3VzZWRCZWZvcmVEaWFsb2dXYXNPcGVuZWQsICdmb2N1cycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZChQb3J0YWxIb3N0RGlyZWN0aXZlKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzMoJ2Rlc2lnbjp0eXBlJywgUG9ydGFsSG9zdERpcmVjdGl2ZSlcbiAgICBdLCBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUsIFwiX3BvcnRhbEhvc3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDczKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoRm9jdXNUcmFwKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzMoJ2Rlc2lnbjp0eXBlJywgRm9jdXNUcmFwKVxuICAgIF0sIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZSwgXCJfZm9jdXNUcmFwXCIsIHZvaWQgMCk7XG4gICAgTWREaWFsb2dDb250YWluZXIgPSBfX2RlY29yYXRlJDczKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtZGlhbG9nLWNvbnRhaW5lciwgbWF0LWRpYWxvZy1jb250YWluZXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGNkay1mb2N1cy10cmFwPjx0ZW1wbGF0ZSBjZGtQb3J0YWxIb3N0PjwvdGVtcGxhdGU+PC9jZGstZm9jdXMtdHJhcD5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1kaWFsb2ctY29udGFpbmVye2JveC1zaGFkb3c6MCAxMXB4IDE1cHggLTdweCByZ2JhKDAsMCwwLC4yKSwwIDI0cHggMzhweCAzcHggcmdiYSgwLDAsMCwuMTQpLDAgOXB4IDQ2cHggOHB4IHJnYmEoMCwwLDAsLjEyKTtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MjRweDtib3JkZXItcmFkaXVzOjJweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6YXV0bzttYXgtd2lkdGg6ODB2dzt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfUBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDphY3RpdmUpey5tYXQtZGlhbG9nLWNvbnRhaW5lcntvdXRsaW5lOnNvbGlkIDFweH19Lm1hdC1kaWFsb2ctY29udGVudHtkaXNwbGF5OmJsb2NrO21hcmdpbjowIC0yNHB4O3BhZGRpbmc6MCAyNHB4O21heC1oZWlnaHQ6NjV2aDtvdmVyZmxvdzphdXRvfS5tYXQtZGlhbG9nLXRpdGxle2ZvbnQtc2l6ZToyMHB4O2ZvbnQtd2VpZ2h0OjcwMDttYXJnaW46MCAwIDIwcHg7ZGlzcGxheTpibG9ja30ubWF0LWRpYWxvZy1hY3Rpb25ze3BhZGRpbmc6MTJweCAwO2Rpc3BsYXk6ZmxleH0ubWF0LWRpYWxvZy1hY3Rpb25zOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTotMjRweH0ubWF0LWRpYWxvZy1hY3Rpb25zW2FsaWduPWVuZF17anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS5tYXQtZGlhbG9nLWFjdGlvbnNbYWxpZ249Y2VudGVyXXtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfVwiXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kaWFsb2ctY29udGFpbmVyXSc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIucm9sZV0nOiAnZGlhbG9nQ29uZmlnPy5yb2xlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kRGlhbG9nQ29udGFpbmVyKTtcbiAgICByZXR1cm4gTWREaWFsb2dDb250YWluZXI7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG5cbnZhciBfX2RlY29yYXRlJDcyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxNyA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8vIFRPRE8oamVsYm91cm4pOiBhbmltYXRpb25zXG4vKipcbiAqIFNlcnZpY2UgdG8gb3BlbiBNYXRlcmlhbCBEZXNpZ24gbW9kYWwgZGlhbG9ncy5cbiAqL1xudmFyIE1kRGlhbG9nID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZyhfb3ZlcmxheSwgX2luamVjdG9yLCBfcGFyZW50RGlhbG9nKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuX3BhcmVudERpYWxvZyA9IF9wYXJlbnREaWFsb2c7XG4gICAgICAgIHRoaXMuX29wZW5EaWFsb2dzQXRUaGlzTGV2ZWwgPSBbXTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJBbGxDbG9zZWRBdFRoaXNMZXZlbCA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9hZnRlck9wZW5BdFRoaXNMZXZlbCA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9ib3VuZEtleWRvd24gPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICAgIC8qKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIGEgZGlhbG9nIGhhcyBiZWVuIG9wZW5lZC4gKi9cbiAgICAgICAgdGhpcy5hZnRlck9wZW4gPSB0aGlzLl9hZnRlck9wZW4uYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIC8qKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIGFsbCBvcGVuIGRpYWxvZyBoYXZlIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gICAgICAgIHRoaXMuYWZ0ZXJBbGxDbG9zZWQgPSB0aGlzLl9hZnRlckFsbENsb3NlZC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kRGlhbG9nLnByb3RvdHlwZSwgXCJfb3BlbkRpYWxvZ3NcIiwge1xuICAgICAgICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnRseS1vcGVuIGRpYWxvZ3MuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudERpYWxvZyA/IHRoaXMuX3BhcmVudERpYWxvZy5fb3BlbkRpYWxvZ3MgOiB0aGlzLl9vcGVuRGlhbG9nc0F0VGhpc0xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWREaWFsb2cucHJvdG90eXBlLCBcIl9hZnRlck9wZW5cIiwge1xuICAgICAgICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgYWxsIG9wZW4gZGlhbG9ncyBoYXZlIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudERpYWxvZyA/IHRoaXMuX3BhcmVudERpYWxvZy5fYWZ0ZXJPcGVuIDogdGhpcy5fYWZ0ZXJPcGVuQXRUaGlzTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZERpYWxvZy5wcm90b3R5cGUsIFwiX2FmdGVyQWxsQ2xvc2VkXCIsIHtcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IGEgZGlhbG9nIGhhcyBvcGVuZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudERpYWxvZyA/XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50RGlhbG9nLl9hZnRlckFsbENsb3NlZCA6IHRoaXMuX2FmdGVyQWxsQ2xvc2VkQXRUaGlzTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgbW9kYWwgZGlhbG9nIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50T3JUZW1wbGF0ZVJlZiBUeXBlIG9mIHRoZSBjb21wb25lbnQgdG8gbG9hZCBpbnRvIHRoZSBkaWFsb2csXG4gICAgICogICAgIG9yIGEgVGVtcGxhdGVSZWYgdG8gaW5zdGFudGlhdGUgYXMgdGhlIGRpYWxvZyBjb250ZW50LlxuICAgICAqIEBwYXJhbSBjb25maWcgRXh0cmEgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIFJlZmVyZW5jZSB0byB0aGUgbmV3bHktb3BlbmVkIGRpYWxvZy5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChjb21wb25lbnRPclRlbXBsYXRlUmVmLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uZmlnID0gX2FwcGx5Q29uZmlnRGVmYXVsdHMkMShjb25maWcpO1xuICAgICAgICB2YXIgb3ZlcmxheVJlZiA9IHRoaXMuX2NyZWF0ZU92ZXJsYXkoY29uZmlnKTtcbiAgICAgICAgdmFyIGRpYWxvZ0NvbnRhaW5lciA9IHRoaXMuX2F0dGFjaERpYWxvZ0NvbnRhaW5lcihvdmVybGF5UmVmLCBjb25maWcpO1xuICAgICAgICB2YXIgZGlhbG9nUmVmID0gdGhpcy5fYXR0YWNoRGlhbG9nQ29udGVudChjb21wb25lbnRPclRlbXBsYXRlUmVmLCBkaWFsb2dDb250YWluZXIsIG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIGlmICghdGhpcy5fb3BlbkRpYWxvZ3MubGVuZ3RoICYmICF0aGlzLl9wYXJlbnREaWFsb2cpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEtleWRvd24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5EaWFsb2dzLnB1c2goZGlhbG9nUmVmKTtcbiAgICAgICAgZGlhbG9nUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9yZW1vdmVPcGVuRGlhbG9nKGRpYWxvZ1JlZik7IH0pO1xuICAgICAgICB0aGlzLl9hZnRlck9wZW4ubmV4dChkaWFsb2dSZWYpO1xuICAgICAgICByZXR1cm4gZGlhbG9nUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBvZiB0aGUgY3VycmVudGx5LW9wZW4gZGlhbG9ncy5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuY2xvc2VBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fb3BlbkRpYWxvZ3MubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAvLyBUaGUgYF9vcGVuRGlhbG9nc2AgcHJvcGVydHkgaXNuJ3QgdXBkYXRlZCBhZnRlciBjbG9zZSB1bnRpbCB0aGUgcnhqcyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHJ1bnMgb24gdGhlIG5leHQgbWljcm90YXNrLCBpbiBhZGRpdGlvbiB0byBtb2RpZnlpbmcgdGhlIGFycmF5IGFzIHdlJ3JlIGdvaW5nXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0LiBXZSBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW0gYW5kIGNhbGwgY2xvc2Ugd2l0aG91dCBhc3N1bWluZyB0aGF0XG4gICAgICAgICAgICAvLyB0aGV5J2xsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCBpbnN0YW50YW5lb3VzbHkuXG4gICAgICAgICAgICB0aGlzLl9vcGVuRGlhbG9nc1tpXS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBvdmVybGF5IGludG8gd2hpY2ggdGhlIGRpYWxvZyB3aWxsIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gZGlhbG9nQ29uZmlnIFRoZSBkaWFsb2cgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBPdmVybGF5UmVmIGZvciB0aGUgY3JlYXRlZCBvdmVybGF5LlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uIChkaWFsb2dDb25maWcpIHtcbiAgICAgICAgdmFyIG92ZXJsYXlTdGF0ZSA9IHRoaXMuX2dldE92ZXJsYXlTdGF0ZShkaWFsb2dDb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheVN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuIE1kRGlhbG9nQ29udGFpbmVyIHRvIGEgZGlhbG9nJ3MgYWxyZWFkeS1jcmVhdGVkIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIG92ZXJsYXkgUmVmZXJlbmNlIHRvIHRoZSBkaWFsb2cncyB1bmRlcmx5aW5nIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgZGlhbG9nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byBhIENvbXBvbmVudFJlZiBmb3IgdGhlIGF0dGFjaGVkIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2F0dGFjaERpYWxvZ0NvbnRhaW5lciA9IGZ1bmN0aW9uIChvdmVybGF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZpZXdDb250YWluZXIgPSBjb25maWcgPyBjb25maWcudmlld0NvbnRhaW5lclJlZiA6IG51bGw7XG4gICAgICAgIHZhciBjb250YWluZXJQb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKE1kRGlhbG9nQ29udGFpbmVyLCB2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlZiA9IG92ZXJsYXkuYXR0YWNoKGNvbnRhaW5lclBvcnRhbCk7XG4gICAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5kaWFsb2dDb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuaW5zdGFuY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgdXNlci1wcm92aWRlZCBjb21wb25lbnQgdG8gdGhlIGFscmVhZHktY3JlYXRlZCBNZERpYWxvZ0NvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50T3JUZW1wbGF0ZVJlZiBUaGUgdHlwZSBvZiBjb21wb25lbnQgYmVpbmcgbG9hZGVkIGludG8gdGhlIGRpYWxvZyxcbiAgICAgKiAgICAgb3IgYSBUZW1wbGF0ZVJlZiB0byBpbnN0YW50aWF0ZSBhcyB0aGUgY29udGVudC5cbiAgICAgKiBAcGFyYW0gZGlhbG9nQ29udGFpbmVyIFJlZmVyZW5jZSB0byB0aGUgd3JhcHBpbmcgTWREaWFsb2dDb250YWluZXIuXG4gICAgICogQHBhcmFtIG92ZXJsYXlSZWYgUmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IGluIHdoaWNoIHRoZSBkaWFsb2cgcmVzaWRlcy5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBkaWFsb2cgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBNZERpYWxvZ1JlZiB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2F0dGFjaERpYWxvZ0NvbnRlbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgZGlhbG9nQ29udGFpbmVyLCBvdmVybGF5UmVmLCBjb25maWcpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIHRoZSBkaWFsb2cgd2UncmUgY3JlYXRpbmcgaW4gb3JkZXIgdG8gZ2l2ZSB0aGUgdXNlciBhIGhhbmRsZVxuICAgICAgICAvLyB0byBtb2RpZnkgYW5kIGNsb3NlIGl0LlxuICAgICAgICB2YXIgZGlhbG9nUmVmID0gbmV3IE1kRGlhbG9nUmVmKG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIGlmICghY29uZmlnLmRpc2FibGVDbG9zZSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgZGlhbG9nIGJhY2tkcm9wIGlzIGNsaWNrZWQsIHdlIHdhbnQgdG8gY2xvc2UgaXQuXG4gICAgICAgICAgICBvdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5maXJzdCgpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBkaWFsb2dSZWYuY2xvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBkaWFsb2dSZWYgdG8gdGhlIGNvbnRhaW5lciBzbyB0aGF0IGl0IGNhbiB1c2UgdGhlIHJlZiB0byBjbG9zZSB0aGUgZGlhbG9nLlxuICAgICAgICBkaWFsb2dDb250YWluZXIuZGlhbG9nUmVmID0gZGlhbG9nUmVmO1xuICAgICAgICAvLyBXZSBjcmVhdGUgYW4gaW5qZWN0b3Igc3BlY2lmaWNhbGx5IGZvciB0aGUgY29tcG9uZW50IHdlJ3JlIGluc3RhbnRpYXRpbmcgc28gdGhhdCBpdCBjYW5cbiAgICAgICAgLy8gaW5qZWN0IHRoZSBNZERpYWxvZ1JlZi4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgbG9hZGVkIGluc2lkZSBvZiBhIGRpYWxvZyB0byBjbG9zZSBpdHNlbGZcbiAgICAgICAgLy8gYW5kLCBvcHRpb25hbGx5LCB0byByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgdmFyIHVzZXJJbmplY3RvciA9IGNvbmZpZyAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZiAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZi5pbmplY3RvcjtcbiAgICAgICAgdmFyIGRpYWxvZ0luamVjdG9yID0gbmV3IERpYWxvZ0luamVjdG9yKHVzZXJJbmplY3RvciB8fCB0aGlzLl9pbmplY3RvciwgZGlhbG9nUmVmLCBjb25maWcuZGF0YSk7XG4gICAgICAgIGlmIChjb21wb25lbnRPclRlbXBsYXRlUmVmIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgZGlhbG9nQ29udGFpbmVyLmF0dGFjaFRlbXBsYXRlUG9ydGFsKG5ldyBUZW1wbGF0ZVBvcnRhbChjb21wb25lbnRPclRlbXBsYXRlUmVmLCBudWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFJlZiA9IGRpYWxvZ0NvbnRhaW5lci5hdHRhY2hDb21wb25lbnRQb3J0YWwobmV3IENvbXBvbmVudFBvcnRhbChjb21wb25lbnRPclRlbXBsYXRlUmVmLCBudWxsLCBkaWFsb2dJbmplY3RvcikpO1xuICAgICAgICAgICAgZGlhbG9nUmVmLmNvbXBvbmVudEluc3RhbmNlID0gY29udGVudFJlZi5pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlhbG9nUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvdmVybGF5IHN0YXRlIGZyb20gYSBkaWFsb2cgY29uZmlnLlxuICAgICAqIEBwYXJhbSBkaWFsb2dDb25maWcgVGhlIGRpYWxvZyBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBvdmVybGF5IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9nZXRPdmVybGF5U3RhdGUgPSBmdW5jdGlvbiAoZGlhbG9nQ29uZmlnKSB7XG4gICAgICAgIHZhciBzdGF0ZSQkMSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbiAgICAgICAgdmFyIHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmdsb2JhbCgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBkaWFsb2dDb25maWcucG9zaXRpb247XG4gICAgICAgIHN0YXRlJCQxLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUkJDEucG9zaXRpb25TdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAocG9zaXRpb24gJiYgKHBvc2l0aW9uLmxlZnQgfHwgcG9zaXRpb24ucmlnaHQpKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ID8gc3RyYXRlZ3kubGVmdChwb3NpdGlvbi5sZWZ0KSA6IHN0cmF0ZWd5LnJpZ2h0KHBvc2l0aW9uLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmF0ZWd5LmNlbnRlckhvcml6b250YWxseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiAocG9zaXRpb24udG9wIHx8IHBvc2l0aW9uLmJvdHRvbSkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA/IHN0cmF0ZWd5LnRvcChwb3NpdGlvbi50b3ApIDogc3RyYXRlZ3kuYm90dG9tKHBvc2l0aW9uLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJhdGVneS5jZW50ZXJWZXJ0aWNhbGx5KCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyYXRlZ3kud2lkdGgoZGlhbG9nQ29uZmlnLndpZHRoKS5oZWlnaHQoZGlhbG9nQ29uZmlnLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBzdGF0ZSQkMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkaWFsb2cgZnJvbSB0aGUgYXJyYXkgb2Ygb3BlbiBkaWFsb2dzLlxuICAgICAqIEBwYXJhbSBkaWFsb2dSZWYgRGlhbG9nIHRvIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9yZW1vdmVPcGVuRGlhbG9nID0gZnVuY3Rpb24gKGRpYWxvZ1JlZikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9vcGVuRGlhbG9ncy5pbmRleE9mKGRpYWxvZ1JlZik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuRGlhbG9ncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgLy8gbm8gb3BlbiBkaWFsb2dzIGFyZSBsZWZ0LCBjYWxsIG5leHQgb24gYWZ0ZXJBbGxDbG9zZWQgU3ViamVjdFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcGVuRGlhbG9ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZnRlckFsbENsb3NlZC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kS2V5ZG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgZ2xvYmFsIGtleSBwcmVzc2VzIHdoaWxlIHRoZXJlIGFyZSBvcGVuIGRpYWxvZ3MuIENsb3NlcyB0aGVcbiAgICAgKiB0b3AgZGlhbG9nIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBlc2NhcGUuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0b3BEaWFsb2cgPSB0aGlzLl9vcGVuRGlhbG9nc1t0aGlzLl9vcGVuRGlhbG9ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiB0b3BEaWFsb2cgJiYgIXRvcERpYWxvZy5jb25maWcuZGlzYWJsZUNsb3NlKSB7XG4gICAgICAgICAgICB0b3BEaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWREaWFsb2cgPSBfX2RlY29yYXRlJDcyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksXG4gICAgICAgIF9fcGFyYW0kMTcoMiwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSQxNygyLCBfYW5ndWxhcl9jb3JlLlNraXBTZWxmKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3MignZGVzaWduOnBhcmFtdHlwZXMnLCBbT3ZlcmxheSwgX2FuZ3VsYXJfY29yZS5JbmplY3RvciwgTWREaWFsb2ddKVxuICAgIF0sIE1kRGlhbG9nKTtcbiAgICByZXR1cm4gTWREaWFsb2c7XG59KCkpO1xuLyoqXG4gKiBBcHBsaWVzIGRlZmF1bHQgb3B0aW9ucyB0byB0aGUgZGlhbG9nIGNvbmZpZy5cbiAqIEBwYXJhbSBkaWFsb2dDb25maWcgQ29uZmlnIHRvIGJlIG1vZGlmaWVkLlxuICogQHJldHVybnMgVGhlIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2FwcGx5Q29uZmlnRGVmYXVsdHMkMShkaWFsb2dDb25maWcpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JqZWN0KG5ldyBNZERpYWxvZ0NvbmZpZygpLCBkaWFsb2dDb25maWcpO1xufVxuXG52YXIgX19kZWNvcmF0ZSQ3NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3NCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBCdXR0b24gdGhhdCB3aWxsIGNsb3NlIHRoZSBjdXJyZW50IGRpYWxvZy5cbiAqL1xudmFyIE1kRGlhbG9nQ2xvc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ2xvc2UoZGlhbG9nUmVmKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nUmVmID0gZGlhbG9nUmVmO1xuICAgICAgICAvKiogU2NyZWVucmVhZGVyIGxhYmVsIGZvciB0aGUgYnV0dG9uLiAqL1xuICAgICAgICB0aGlzLmFyaWFMYWJlbCA9ICdDbG9zZSBkaWFsb2cnO1xuICAgIH1cbiAgICBfX2RlY29yYXRlJDc0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NCgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWREaWFsb2dDbG9zZS5wcm90b3R5cGUsIFwiYXJpYUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgTWREaWFsb2dDbG9zZSA9IF9fZGVjb3JhdGUkNzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvblttZC1kaWFsb2ctY2xvc2VdLCBidXR0b25bbWF0LWRpYWxvZy1jbG9zZV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ2RpYWxvZ1JlZi5jbG9zZSgpJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbF0nOiAnYXJpYUxhYmVsJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdidXR0b24nLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW01kRGlhbG9nUmVmXSlcbiAgICBdLCBNZERpYWxvZ0Nsb3NlKTtcbiAgICByZXR1cm4gTWREaWFsb2dDbG9zZTtcbn0oKSk7XG4vKipcbiAqIFRpdGxlIG9mIGEgZGlhbG9nIGVsZW1lbnQuIFN0YXlzIGZpeGVkIHRvIHRoZSB0b3Agb2YgdGhlIGRpYWxvZyB3aGVuIHNjcm9sbGluZy5cbiAqL1xudmFyIE1kRGlhbG9nVGl0bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nVGl0bGUoKSB7XG4gICAgfVxuICAgIE1kRGlhbG9nVGl0bGUgPSBfX2RlY29yYXRlJDc0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtZGlhbG9nLXRpdGxlXSwgW21hdC1kaWFsb2ctdGl0bGVdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1kaWFsb2ctdGl0bGVdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZERpYWxvZ1RpdGxlKTtcbiAgICByZXR1cm4gTWREaWFsb2dUaXRsZTtcbn0oKSk7XG4vKipcbiAqIFNjcm9sbGFibGUgY29udGVudCBjb250YWluZXIgb2YgYSBkaWFsb2cuXG4gKi9cbnZhciBNZERpYWxvZ0NvbnRlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nQ29udGVudCgpIHtcbiAgICB9XG4gICAgTWREaWFsb2dDb250ZW50ID0gX19kZWNvcmF0ZSQ3NChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLWRpYWxvZy1jb250ZW50XSwgbWQtZGlhbG9nLWNvbnRlbnQsIFttYXQtZGlhbG9nLWNvbnRlbnRdLCBtYXQtZGlhbG9nLWNvbnRlbnQnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWRpYWxvZy1jb250ZW50XSc6ICd0cnVlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWREaWFsb2dDb250ZW50KTtcbiAgICByZXR1cm4gTWREaWFsb2dDb250ZW50O1xufSgpKTtcbi8qKlxuICogQ29udGFpbmVyIGZvciB0aGUgYm90dG9tIGFjdGlvbiBidXR0b25zIGluIGEgZGlhbG9nLlxuICogU3RheXMgZml4ZWQgdG8gdGhlIGJvdHRvbSB3aGVuIHNjcm9sbGluZy5cbiAqL1xudmFyIE1kRGlhbG9nQWN0aW9ucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dBY3Rpb25zKCkge1xuICAgIH1cbiAgICBNZERpYWxvZ0FjdGlvbnMgPSBfX2RlY29yYXRlJDc0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtZGlhbG9nLWFjdGlvbnNdLCBtZC1kaWFsb2ctYWN0aW9ucywgW21hdC1kaWFsb2ctYWN0aW9uc10sIG1hdC1kaWFsb2ctYWN0aW9ucycsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtZGlhbG9nLWFjdGlvbnNdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZERpYWxvZ0FjdGlvbnMpO1xuICAgIHJldHVybiBNZERpYWxvZ0FjdGlvbnM7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ3MSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kRGlhbG9nTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ01vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWREaWFsb2dNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZERpYWxvZ01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZERpYWxvZ01vZHVsZSA9IF9fZGVjb3JhdGUkNzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICBPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgICAgIFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgICAgICBBMTF5TW9kdWxlLFxuICAgICAgICAgICAgICAgIENvbXBhdGliaWxpdHlNb2R1bGUsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kRGlhbG9nQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIE1kRGlhbG9nQ2xvc2UsXG4gICAgICAgICAgICAgICAgTWREaWFsb2dUaXRsZSxcbiAgICAgICAgICAgICAgICBNZERpYWxvZ0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgTWREaWFsb2dBY3Rpb25zLFxuICAgICAgICAgICAgICAgIENvbXBhdGliaWxpdHlNb2R1bGUsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgTWREaWFsb2dDb250YWluZXIsXG4gICAgICAgICAgICAgICAgTWREaWFsb2dDbG9zZSxcbiAgICAgICAgICAgICAgICBNZERpYWxvZ1RpdGxlLFxuICAgICAgICAgICAgICAgIE1kRGlhbG9nQWN0aW9ucyxcbiAgICAgICAgICAgICAgICBNZERpYWxvZ0NvbnRlbnQsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTWREaWFsb2csXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTWREaWFsb2dDb250YWluZXJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWREaWFsb2dNb2R1bGUpO1xuICAgIHJldHVybiBNZERpYWxvZ01vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDc2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDc2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEF1dG9jb21wbGV0ZSBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG52YXIgX3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlciA9IDA7XG52YXIgTWRBdXRvY29tcGxldGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQXV0b2NvbXBsZXRlKCkge1xuICAgICAgICAvKiogV2hldGhlciB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsIGRpc3BsYXlzIGFib3ZlIG9yIGJlbG93IGl0cyB0cmlnZ2VyLiAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uWSA9ICdiZWxvdyc7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgc2hvdWxkIGJlIHZpc2libGUsIGRlcGVuZGluZyBvbiBvcHRpb24gbGVuZ3RoLiAqL1xuICAgICAgICB0aGlzLnNob3dQYW5lbCA9IGZhbHNlO1xuICAgICAgICAvKiogVW5pcXVlIElEIHRvIGJlIHVzZWQgYnkgYXV0b2NvbXBsZXRlIHRyaWdnZXIncyBcImFyaWEtb3duc1wiIHByb3BlcnR5LiAqL1xuICAgICAgICB0aGlzLmlkID0gXCJtZC1hdXRvY29tcGxldGUtXCIgKyBfdW5pcXVlQXV0b2NvbXBsZXRlSWRDb3VudGVyKys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBhbmVsIHNjcm9sbFRvcC4gVGhpcyBhbGxvd3MgdXMgdG8gbWFudWFsbHkgc2Nyb2xsIHRvIGRpc3BsYXlcbiAgICAgKiBvcHRpb25zIGJlbG93IHRoZSBmb2xkLCBhcyB0aGV5IGFyZSBub3QgYWN0dWFsbHkgYmVpbmcgZm9jdXNlZCB3aGVuIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuX3NldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChzY3JvbGxUb3ApIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWwpIHtcbiAgICAgICAgICAgIHRoaXMucGFuZWwubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBQYW5lbCBzaG91bGQgaGlkZSBpdHNlbGYgd2hlbiB0aGUgb3B0aW9uIGxpc3QgaXMgZW1wdHkuICovXG4gICAgTWRBdXRvY29tcGxldGUucHJvdG90eXBlLl9zZXRWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNob3dQYW5lbCA9ICEhX3RoaXMub3B0aW9ucy5sZW5ndGg7IH0pO1xuICAgIH07XG4gICAgLyoqIFNldHMgYSBjbGFzcyBvbiB0aGUgcGFuZWwgYmFzZWQgb24gaXRzIHBvc2l0aW9uICh1c2VkIHRvIHNldCB5LW9mZnNldCkuICovXG4gICAgTWRBdXRvY29tcGxldGUucHJvdG90eXBlLl9nZXRDbGFzc0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnbWF0LWF1dG9jb21wbGV0ZS1wYW5lbC1iZWxvdyc6IHRoaXMucG9zaXRpb25ZID09PSAnYmVsb3cnLFxuICAgICAgICAgICAgJ21hdC1hdXRvY29tcGxldGUtcGFuZWwtYWJvdmUnOiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2Fib3ZlJyxcbiAgICAgICAgICAgICdtYXQtYXV0b2NvbXBsZXRlLXZpc2libGUnOiB0aGlzLnNob3dQYW5lbCxcbiAgICAgICAgICAgICdtYXQtYXV0b2NvbXBsZXRlLWhpZGRlbic6ICF0aGlzLnNob3dQYW5lbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ3NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NignZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmKVxuICAgIF0sIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgncGFuZWwnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzYoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZSwgXCJwYW5lbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZE9wdGlvbiksIFxuICAgICAgICBfX21ldGFkYXRhJDc2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kQXV0b2NvbXBsZXRlLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQ3NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzYoJ2Rlc2lnbjp0eXBlJywgRnVuY3Rpb24pXG4gICAgXSwgTWRBdXRvY29tcGxldGUucHJvdG90eXBlLCBcImRpc3BsYXlXaXRoXCIsIHZvaWQgMCk7XG4gICAgTWRBdXRvY29tcGxldGUgPSBfX2RlY29yYXRlJDc2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtYXV0b2NvbXBsZXRlLCBtYXQtYXV0b2NvbXBsZXRlJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjx0ZW1wbGF0ZT48ZGl2IGNsYXNzPVxcXCJtYXQtYXV0b2NvbXBsZXRlLXBhbmVsXFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIiBbaWRdPVxcXCJpZFxcXCIgW25nQ2xhc3NdPVxcXCJfZ2V0Q2xhc3NMaXN0KClcXFwiICNwYW5lbD48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+PC90ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm1hdC1hdXRvY29tcGxldGUtcGFuZWx7Ym94LXNoYWRvdzowIDVweCA1cHggLTNweCByZ2JhKDAsMCwwLC4yKSwwIDhweCAxMHB4IDFweCByZ2JhKDAsMCwwLC4xNCksMCAzcHggMTRweCAycHggcmdiYSgwLDAsMCwuMTIpO21pbi13aWR0aDoxMTJweDttYXgtd2lkdGg6MjgwcHg7b3ZlcmZsb3c6YXV0bzstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDt2aXNpYmlsaXR5OmhpZGRlbjttYXgtaGVpZ2h0OjI1NnB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLm1hdC1hdXRvY29tcGxldGUtcGFuZWwtYmVsb3d7dG9wOjZweH0ubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLWFib3Zle3RvcDotMjRweH0ubWF0LWF1dG9jb21wbGV0ZS1wYW5lbC5tYXQtYXV0b2NvbXBsZXRlLXZpc2libGV7dmlzaWJpbGl0eTp2aXNpYmxlfS5tYXQtYXV0b2NvbXBsZXRlLXBhbmVsLm1hdC1hdXRvY29tcGxldGUtaGlkZGVue3Zpc2liaWxpdHk6aGlkZGVufVwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRBdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LWF1dG9jb21wbGV0ZV0nOiAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDc2KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQXV0b2NvbXBsZXRlKTtcbiAgICByZXR1cm4gTWRBdXRvY29tcGxldGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDI0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDI0KEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyKGl0ZW1zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGl0ZW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBJdCBhbHNvIGFkZHMgYWN0aXZlIHN0eWxlcyB0byB0aGUgbmV3bHkgYWN0aXZlIGl0ZW0gYW5kIHJlbW92ZXMgYWN0aXZlXG4gICAgICogc3R5bGVzIGZyb20gdGhlIHByZXZpb3VzbHkgYWN0aXZlIGl0ZW0uXG4gICAgICovXG4gICAgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIucHJvdG90eXBlLnNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtLnNldEluYWN0aXZlU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRBY3RpdmVJdGVtLmNhbGwodGhpcywgaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0uc2V0QWN0aXZlU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcjtcbn0oTGlzdEtleU1hbmFnZXIpKTtcblxudmFyIF9fZGVjb3JhdGUkNzcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDE4ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHN0eWxlIGNvbnN0YW50cyBhcmUgbmVjZXNzYXJ5IHRvIHNhdmUgaGVyZSBpbiBvcmRlclxuICogdG8gcHJvcGVybHkgY2FsY3VsYXRlIHRoZSBzY3JvbGxUb3Agb2YgdGhlIHBhbmVsLiBCZWNhdXNlIHdlIGFyZSBub3RcbiAqIGFjdHVhbGx5IGZvY3VzaW5nIHRoZSBhY3RpdmUgaXRlbSwgc2Nyb2xsIG11c3QgYmUgaGFuZGxlZCBtYW51YWxseS5cbiAqL1xuLyoqIFRoZSBoZWlnaHQgb2YgZWFjaCBhdXRvY29tcGxldGUgb3B0aW9uLiAqL1xudmFyIEFVVE9DT01QTEVURV9PUFRJT05fSEVJR0hUID0gNDg7XG4vKiogVGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLiAqL1xudmFyIEFVVE9DT01QTEVURV9QQU5FTF9IRUlHSFQgPSAyNTY7XG4vKipcbiAqIFByb3ZpZGVyIHRoYXQgYWxsb3dzIHRoZSBhdXRvY29tcGxldGUgdG8gcmVnaXN0ZXIgYXMgYSBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xudmFyIE1EX0FVVE9DT01QTEVURV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBfYW5ndWxhcl9mb3Jtcy5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kQXV0b2NvbXBsZXRlVHJpZ2dlcjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgTWRBdXRvY29tcGxldGVUcmlnZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEF1dG9jb21wbGV0ZVRyaWdnZXIoX2VsZW1lbnQsIF9vdmVybGF5LCBfdmlld0NvbnRhaW5lclJlZiwgX2RpciwgX3pvbmUsIF9pbnB1dENvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX2lucHV0Q29udGFpbmVyID0gX2lucHV0Q29udGFpbmVyO1xuICAgICAgICB0aGlzLl9wYW5lbE9wZW4gPSBmYWxzZTtcbiAgICAgICAgLyoqIFN0cmVhbSBvZiBibHVyIGV2ZW50cyB0aGF0IHNob3VsZCBjbG9zZSB0aGUgcGFuZWwuICovXG4gICAgICAgIHRoaXMuX2JsdXJTdHJlYW0gPSBuZXcgcnhqc19TdWJqZWN0LlN1YmplY3QoKTtcbiAgICAgICAgLyoqIFZpZXcgLT4gbW9kZWwgY2FsbGJhY2sgY2FsbGVkIHdoZW4gdmFsdWUgY2hhbmdlcyAqL1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgICAgICAvKiogVmlldyAtPiBtb2RlbCBjYWxsYmFjayBjYWxsZWQgd2hlbiBhdXRvY29tcGxldGUgaGFzIGJlZW4gdG91Y2hlZCAqL1xuICAgICAgICB0aGlzLl9vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcIl9tYXRBdXRvY29tcGxldGVcIiwge1xuICAgICAgICAvKiogUHJvcGVydHkgd2l0aCBtYXQtIHByZWZpeCBmb3Igbm8tY29uZmxpY3QgbW9kZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvY29tcGxldGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGF1dG9jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUgPSBhdXRvY29tcGxldGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyID0gbmV3IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyKHRoaXMuYXV0b2NvbXBsZXRlLm9wdGlvbnMpLndpdGhXcmFwKCk7XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGFuZWxQb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcGFuZWxQb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lQYW5lbCgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUsIFwicGFuZWxPcGVuXCIsIHtcbiAgICAgICAgLyogV2hldGhlciBvciBub3QgdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCBpcyBvcGVuLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYW5lbE9wZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBPcGVucyB0aGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb24gcGFuZWwuICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5vcGVuUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9wb3J0YWwpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9DbG9zaW5nQWN0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhbmVsT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIoJ2Fsd2F5cycpO1xuICAgIH07XG4gICAgLyoqIENsb3NlcyB0aGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb24gcGFuZWwuICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5jbG9zZVBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZiAmJiB0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFuZWxPcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Zsb2F0UGxhY2Vob2xkZXIoJ2F1dG8nKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcInBhbmVsQ2xvc2luZ0FjdGlvbnNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJlYW0gb2YgYWN0aW9ucyB0aGF0IHNob3VsZCBjbG9zZSB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLCBpbmNsdWRpbmdcbiAgICAgICAgICogd2hlbiBhbiBvcHRpb24gaXMgc2VsZWN0ZWQsIG9uIGJsdXIsIGFuZCB3aGVuIFRBQiBpcyBwcmVzc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUubWVyZ2UuYXBwbHkocnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUsIHRoaXMub3B0aW9uU2VsZWN0aW9ucy5jb25jYXQoW3RoaXMuX2JsdXJTdHJlYW0uYXNPYnNlcnZhYmxlKCksIHRoaXMuX2tleU1hbmFnZXIudGFiT3V0XSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZSwgXCJvcHRpb25TZWxlY3Rpb25zXCIsIHtcbiAgICAgICAgLyoqIFN0cmVhbSBvZiBhdXRvY29tcGxldGUgb3B0aW9uIHNlbGVjdGlvbnMuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXV0b2NvbXBsZXRlLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRpb24pIHsgcmV0dXJuIG9wdGlvbi5vblNlbGVjdDsgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcImFjdGl2ZU9wdGlvblwiLCB7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBvcHRpb24sIGNvZXJjZWQgdG8gTWRPcHRpb24gdHlwZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5TWFuYWdlci5hY3RpdmVJdGVtO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhdXRvY29tcGxldGUncyB2YWx1ZS4gUGFydCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlXG4gICAgICogcmVxdWlyZWQgdG8gaW50ZWdyYXRlIHdpdGggQW5ndWxhcidzIGNvcmUgZm9ybXMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSB0byBiZSB3cml0dGVuIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldFRyaWdnZXJWYWx1ZSh2YWx1ZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2F2ZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGF1dG9jb21wbGV0ZSdzIHZhbHVlXG4gICAgICogY2hhbmdlcyBmcm9tIHVzZXIgaW5wdXQuIFBhcnQgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZVxuICAgICAqIHJlcXVpcmVkIHRvIGludGVncmF0ZSB3aXRoIEFuZ3VsYXIncyBjb3JlIGZvcm1zIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiBDYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBhdXRvY29tcGxldGUgaXMgYmx1cnJlZFxuICAgICAqIGJ5IHRoZSB1c2VyLiBQYXJ0IG9mIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgcmVxdWlyZWRcbiAgICAgKiB0byBpbnRlZ3JhdGUgd2l0aCBBbmd1bGFyJ3MgY29yZSBmb3JtcyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB0b3VjaGVkLlxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9oYW5kbGVLZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU9wdGlvbiAmJiBldmVudC5rZXlDb2RlID09PSBFTlRFUikge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVPcHRpb24uX3NlbGVjdFZpYUludGVyYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVVBfQVJST1cgfHwgZXZlbnQua2V5Q29kZSA9PT0gRE9XTl9BUlJPVykge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlblBhbmVsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG9PcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5faGFuZGxlSW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICB0aGlzLm9wZW5QYW5lbCgpO1xuICAgIH07XG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5faGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChuZXdseUZvY3VzZWRUYWcpIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkKCk7XG4gICAgICAgIC8vIE9ubHkgZW1pdCBibHVyIGV2ZW50IGlmIHRoZSBuZXcgZm9jdXMgaXMgKm5vdCogb24gYW4gb3B0aW9uLlxuICAgICAgICBpZiAobmV3bHlGb2N1c2VkVGFnICE9PSAnTUQtT1BUSU9OJykge1xuICAgICAgICAgICAgdGhpcy5fYmx1clN0cmVhbS5uZXh0KG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbiBcImF1dG9cIiBtb2RlLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBhbmltYXRlIGRvd24gYXMgc29vbiBhcyBmb2N1cyBpcyBsb3N0LlxuICAgICAqIFRoaXMgY2F1c2VzIHRoZSB2YWx1ZSB0byBqdW1wIHdoZW4gc2VsZWN0aW5nIGFuIG9wdGlvbiB3aXRoIHRoZSBtb3VzZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBtYW51YWxseSBmbG9hdHMgdGhlIHBsYWNlaG9sZGVyIHVudGlsIHRoZSBwYW5lbCBjYW4gYmUgY2xvc2VkLlxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2Zsb2F0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoc3RhdGUkJDEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dENvbnRhaW5lci5mbG9hdFBsYWNlaG9sZGVyID0gc3RhdGUkJDE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoYXQgd2UgYXJlIG5vdCBhY3R1YWxseSBmb2N1c2luZyBhY3RpdmUgb3B0aW9ucywgd2UgbXVzdCBtYW51YWxseSBhZGp1c3Qgc2Nyb2xsXG4gICAgICogdG8gcmV2ZWFsIG9wdGlvbnMgYmVsb3cgdGhlIGZvbGQuIEZpcnN0LCB3ZSBmaW5kIHRoZSBvZmZzZXQgb2YgdGhlIG9wdGlvbiBmcm9tIHRoZSB0b3BcbiAgICAgKiBvZiB0aGUgcGFuZWwuIFRoZSBuZXcgc2Nyb2xsVG9wIHdpbGwgYmUgdGhhdCBvZmZzZXQgLSB0aGUgcGFuZWwgaGVpZ2h0ICsgdGhlIG9wdGlvblxuICAgICAqIGhlaWdodCwgc28gdGhlIGFjdGl2ZSBvcHRpb24gd2lsbCBiZSBqdXN0IHZpc2libGUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFuZWwuXG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fc2Nyb2xsVG9PcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25PZmZzZXQgPSB0aGlzLl9rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleCAqIEFVVE9DT01QTEVURV9PUFRJT05fSEVJR0hUO1xuICAgICAgICB2YXIgbmV3U2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgb3B0aW9uT2Zmc2V0IC0gQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVCArIEFVVE9DT01QTEVURV9PUFRJT05fSEVJR0hUKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX3NldFNjcm9sbFRvcChuZXdTY3JvbGxUb3ApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBhIHN0cmVhbSBvZiBwYW5lbCBjbG9zaW5nIGFjdGlvbnMgYW5kIHJlc2V0cyB0aGVcbiAgICAgKiBzdHJlYW0gZXZlcnkgdGltZSB0aGUgb3B0aW9uIGxpc3QgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9zdWJzY3JpYmVUb0Nsb3NpbmdBY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXaGVuIHRoZSB6b25lIGlzIHN0YWJsZSBpbml0aWFsbHksIGFuZCB3aGVuIHRoZSBvcHRpb24gbGlzdCBjaGFuZ2VzLi4uXG4gICAgICAgIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLm1lcmdlKHRoaXMuX3pvbmUub25TdGFibGUuZmlyc3QoKSwgdGhpcy5hdXRvY29tcGxldGUub3B0aW9ucy5jaGFuZ2VzKVxuICAgICAgICAgICAgLnN3aXRjaE1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzZXRQYW5lbCgpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBhbmVsQ2xvc2luZ0FjdGlvbnM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlyc3QoKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLl9zZXRWYWx1ZUFuZENsb3NlKGV2ZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKiogRGVzdHJveXMgdGhlIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uIHBhbmVsLiAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2Rlc3Ryb3lQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fc2V0VHJpZ2dlclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC52YWx1ZSA9XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5kaXNwbGF5V2l0aCA/IHRoaXMuYXV0b2NvbXBsZXRlLmRpc3BsYXlXaXRoKHZhbHVlKSA6IHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBUaGlzIG1ldGhvZCBjbG9zZXMgdGhlIHBhbmVsLCBhbmQgaWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQsIGFsc28gc2V0cyB0aGUgYXNzb2NpYXRlZFxuICAgICogY29udHJvbCB0byB0aGF0IHZhbHVlLiBJdCB3aWxsIGFsc28gbWFyayB0aGUgY29udHJvbCBhcyBkaXJ0eSBpZiB0aGlzIGludGVyYWN0aW9uXG4gICAgKiBzdGVtbWVkIGZyb20gdGhlIHVzZXIuXG4gICAgKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9zZXRWYWx1ZUFuZENsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VHJpZ2dlclZhbHVlKGV2ZW50LnNvdXJjZS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZShldmVudC5zb3VyY2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VQYW5lbCgpO1xuICAgIH07XG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuYXV0b2NvbXBsZXRlLnRlbXBsYXRlLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKHRoaXMuX2dldE92ZXJsYXlDb25maWcoKSk7XG4gICAgfTtcbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9nZXRPdmVybGF5Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX2dldE92ZXJsYXlQb3NpdGlvbigpO1xuICAgICAgICBvdmVybGF5U3RhdGUud2lkdGggPSB0aGlzLl9nZXRIb3N0V2lkdGgoKTtcbiAgICAgICAgb3ZlcmxheVN0YXRlLmRpcmVjdGlvbiA9IHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA6ICdsdHInO1xuICAgICAgICByZXR1cm4gb3ZlcmxheVN0YXRlO1xuICAgIH07XG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fZ2V0T3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnQsIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2JvdHRvbScgfSwgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH0pXG4gICAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oeyBvcmlnaW5YOiAnc3RhcnQnLCBvcmlnaW5ZOiAndG9wJyB9LCB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzKHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25TdHJhdGVneTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHN1YnNjcmliZXMgdG8gcG9zaXRpb24gY2hhbmdlcyBpbiB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsLCBzbyB0aGUgcGFuZWwnc1xuICAgICAqIHktb2Zmc2V0IGNhbiBiZSBhZGp1c3RlZCB0byBtYXRjaCB0aGUgbmV3IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX3N1YnNjcmliZVRvUG9zaXRpb25DaGFuZ2VzID0gZnVuY3Rpb24gKHN0cmF0ZWd5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BhbmVsUG9zaXRpb25TdWJzY3JpcHRpb24gPSBzdHJhdGVneS5vblBvc2l0aW9uQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICBfdGhpcy5hdXRvY29tcGxldGUucG9zaXRpb25ZID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm9yaWdpblkgPT09ICd0b3AnID8gJ2Fib3ZlJyA6ICdiZWxvdyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBpbnB1dCBlbGVtZW50LCBzbyB0aGUgcGFuZWwgd2lkdGggY2FuIG1hdGNoIGl0LiAqL1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlci5wcm90b3R5cGUuX2dldEhvc3RXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICB9O1xuICAgIC8qKiBSZXNldCBhY3RpdmUgaXRlbSB0byBudWxsIHNvIGFycm93IGV2ZW50cyB3aWxsIGFjdGl2YXRlIHRoZSBjb3JyZWN0IG9wdGlvbnMuKi9cbiAgICBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLl9yZXNldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYWN0aXZlIGl0ZW0gYW5kIHJlLWNhbGN1bGF0ZXMgYWxpZ25tZW50IG9mIHRoZSBwYW5lbCBpbiBjYXNlIGl0cyBzaXplXG4gICAgICogaGFzIGNoYW5nZWQgZHVlIHRvIGZld2VyIG9yIGdyZWF0ZXIgbnVtYmVyIG9mIG9wdGlvbnMuXG4gICAgICovXG4gICAgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZS5fcmVzZXRQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRBY3RpdmVJdGVtKCk7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kucmVjYWxjdWxhdGVMYXN0UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuX3NldFZpc2liaWxpdHkoKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZEF1dG9jb21wbGV0ZScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ3NygnZGVzaWduOnR5cGUnLCBNZEF1dG9jb21wbGV0ZSlcbiAgICBdLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXIucHJvdG90eXBlLCBcImF1dG9jb21wbGV0ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtYXRBdXRvY29tcGxldGUnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzcoJ2Rlc2lnbjp0eXBlJywgTWRBdXRvY29tcGxldGUpXG4gICAgXSwgTWRBdXRvY29tcGxldGVUcmlnZ2VyLnByb3RvdHlwZSwgXCJfbWF0QXV0b2NvbXBsZXRlXCIsIG51bGwpO1xuICAgIE1kQXV0b2NvbXBsZXRlVHJpZ2dlciA9IF9fZGVjb3JhdGUkNzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W21kQXV0b2NvbXBsZXRlXSwgaW5wdXRbbWF0QXV0b2NvbXBsZXRlXScsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnY29tYm9ib3gnLFxuICAgICAgICAgICAgICAgICdhdXRvY29tcGxldGUnOiAnb2ZmJyxcbiAgICAgICAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgJ2FyaWEtbXVsdGlsaW5lJzogJ2ZhbHNlJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XSc6ICdhY3RpdmVPcHRpb24/LmlkJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAncGFuZWxPcGVuLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLW93bnNdJzogJ2F1dG9jb21wbGV0ZT8uaWQnLFxuICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ29wZW5QYW5lbCgpJyxcbiAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ19oYW5kbGVCbHVyKCRldmVudC5yZWxhdGVkVGFyZ2V0Py50YWdOYW1lKScsXG4gICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnX2hhbmRsZUlucHV0KCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01EX0FVVE9DT01QTEVURV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMTgoMywgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSQxOCg1LCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtJDE4KDUsIF9hbmd1bGFyX2NvcmUuSG9zdCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgT3ZlcmxheSwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCBEaXIsIF9hbmd1bGFyX2NvcmUuTmdab25lLCBNZElucHV0Q29udGFpbmVyXSlcbiAgICBdLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXIpO1xuICAgIHJldHVybiBNZEF1dG9jb21wbGV0ZVRyaWdnZXI7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ3NSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3NSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kQXV0b2NvbXBsZXRlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEF1dG9jb21wbGV0ZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWRBdXRvY29tcGxldGVNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZEF1dG9jb21wbGV0ZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW09WRVJMQVlfUFJPVklERVJTXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRBdXRvY29tcGxldGVNb2R1bGUgPSBfX2RlY29yYXRlJDc1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbTWRPcHRpb25Nb2R1bGUsIE92ZXJsYXlNb2R1bGUsIENvbXBhdGliaWxpdHlNb2R1bGUsIF9hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kQXV0b2NvbXBsZXRlLCBNZE9wdGlvbk1vZHVsZSwgTWRBdXRvY29tcGxldGVUcmlnZ2VyLCBDb21wYXRpYmlsaXR5TW9kdWxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kQXV0b2NvbXBsZXRlLCBNZEF1dG9jb21wbGV0ZVRyaWdnZXJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNzUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRBdXRvY29tcGxldGVNb2R1bGUpO1xuICAgIHJldHVybiBNZEF1dG9jb21wbGV0ZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDMwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDMwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTUFURVJJQUxfTU9EVUxFUyA9IFtcbiAgICBNZEF1dG9jb21wbGV0ZU1vZHVsZSxcbiAgICBNZEJ1dHRvbk1vZHVsZSxcbiAgICBNZEJ1dHRvblRvZ2dsZU1vZHVsZSxcbiAgICBNZENhcmRNb2R1bGUsXG4gICAgTWRDaGlwc01vZHVsZSxcbiAgICBNZENoZWNrYm94TW9kdWxlLFxuICAgIE1kRGlhbG9nTW9kdWxlLFxuICAgIE1kR3JpZExpc3RNb2R1bGUsXG4gICAgTWRJY29uTW9kdWxlLFxuICAgIE1kSW5wdXRNb2R1bGUsXG4gICAgTWRMaXN0TW9kdWxlLFxuICAgIE1kTWVudU1vZHVsZSxcbiAgICBNZFByb2dyZXNzQmFyTW9kdWxlLFxuICAgIE1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlLFxuICAgIE1kUmFkaW9Nb2R1bGUsXG4gICAgTWRSaXBwbGVNb2R1bGUsXG4gICAgTWRTZWxlY3RNb2R1bGUsXG4gICAgTWRTaWRlbmF2TW9kdWxlLFxuICAgIE1kU2xpZGVyTW9kdWxlLFxuICAgIE1kU2xpZGVUb2dnbGVNb2R1bGUsXG4gICAgTWRTbmFja0Jhck1vZHVsZSxcbiAgICBNZFRhYnNNb2R1bGUsXG4gICAgTWRUb29sYmFyTW9kdWxlLFxuICAgIE1kVG9vbHRpcE1vZHVsZSxcbiAgICBPdmVybGF5TW9kdWxlLFxuICAgIFBvcnRhbE1vZHVsZSxcbiAgICBSdGxNb2R1bGUsXG4gICAgU3R5bGVNb2R1bGUsXG4gICAgQTExeU1vZHVsZSxcbiAgICBQbGF0Zm9ybU1vZHVsZSxcbiAgICBQcm9qZWN0aW9uTW9kdWxlLFxuICAgIENvbXBhdGliaWxpdHlNb2R1bGUsXG4gICAgT2JzZXJ2ZUNvbnRlbnRNb2R1bGVcbl07XG52YXIgTWF0ZXJpYWxSb290TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbFJvb3RNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1hdGVyaWFsUm9vdE1vZHVsZSA9IF9fZGVjb3JhdGUkMzAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICBNZEF1dG9jb21wbGV0ZU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRCdXR0b25Nb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kQ2FyZE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRDaGlwc01vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRDaGVja2JveE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRHcmlkTGlzdE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRJbnB1dE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRMaXN0TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFByb2dyZXNzQmFyTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFByb2dyZXNzU3Bpbm5lck1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRSaXBwbGVNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kU2VsZWN0TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFNpZGVuYXZNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kVGFic01vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRUb29sYmFyTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBQb3J0YWxNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIFByb2plY3Rpb25Nb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIFJ0bE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgT2JzZXJ2ZUNvbnRlbnRNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIG1vZHVsZXMgaW5jbHVkZSBwcm92aWRlcnMuXG4gICAgICAgICAgICAgICAgQTExeU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRCdXR0b25Ub2dnbGVNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kRGlhbG9nTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZEljb25Nb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kTWVudU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRSYWRpb01vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRTbGlkZXJNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kU2xpZGVUb2dnbGVNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kU25hY2tCYXJNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kVG9vbHRpcE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgUGxhdGZvcm1Nb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE92ZXJsYXlNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIENvbXBhdGliaWxpdHlNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IE1BVEVSSUFMX01PRFVMRVMsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNYXRlcmlhbFJvb3RNb2R1bGUpO1xuICAgIHJldHVybiBNYXRlcmlhbFJvb3RNb2R1bGU7XG59KCkpO1xudmFyIE1hdGVyaWFsTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRlcmlhbE1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgTWF0ZXJpYWxNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgbmdNb2R1bGU6IE1hdGVyaWFsUm9vdE1vZHVsZSB9O1xuICAgIH07XG4gICAgTWF0ZXJpYWxNb2R1bGUgPSBfX2RlY29yYXRlJDMwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBNQVRFUklBTF9NT0RVTEVTLFxuICAgICAgICAgICAgZXhwb3J0czogTUFURVJJQUxfTU9EVUxFUyxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMwKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1hdGVyaWFsTW9kdWxlKTtcbiAgICByZXR1cm4gTWF0ZXJpYWxNb2R1bGU7XG59KCkpO1xuXG5leHBvcnRzLk1kQ29yZU1vZHVsZSA9IE1kQ29yZU1vZHVsZTtcbmV4cG9ydHMuRGlyID0gRGlyO1xuZXhwb3J0cy5SdGxNb2R1bGUgPSBSdGxNb2R1bGU7XG5leHBvcnRzLk9ic2VydmVDb250ZW50TW9kdWxlID0gT2JzZXJ2ZUNvbnRlbnRNb2R1bGU7XG5leHBvcnRzLk9ic2VydmVDb250ZW50ID0gT2JzZXJ2ZUNvbnRlbnQ7XG5leHBvcnRzLk1kT3B0aW9uTW9kdWxlID0gTWRPcHRpb25Nb2R1bGU7XG5leHBvcnRzLk1kT3B0aW9uID0gTWRPcHRpb247XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuQmFzZVBvcnRhbEhvc3QgPSBCYXNlUG9ydGFsSG9zdDtcbmV4cG9ydHMuQ29tcG9uZW50UG9ydGFsID0gQ29tcG9uZW50UG9ydGFsO1xuZXhwb3J0cy5UZW1wbGF0ZVBvcnRhbCA9IFRlbXBsYXRlUG9ydGFsO1xuZXhwb3J0cy5Qb3J0YWxIb3N0RGlyZWN0aXZlID0gUG9ydGFsSG9zdERpcmVjdGl2ZTtcbmV4cG9ydHMuVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUgPSBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZTtcbmV4cG9ydHMuUG9ydGFsTW9kdWxlID0gUG9ydGFsTW9kdWxlO1xuZXhwb3J0cy5Eb21Qb3J0YWxIb3N0ID0gRG9tUG9ydGFsSG9zdDtcbmV4cG9ydHMuTWRQbGF0Zm9ybSA9IFBsYXRmb3JtO1xuZXhwb3J0cy5PdmVybGF5ID0gT3ZlcmxheTtcbmV4cG9ydHMuT1ZFUkxBWV9QUk9WSURFUlMgPSBPVkVSTEFZX1BST1ZJREVSUztcbmV4cG9ydHMuT3ZlcmxheUNvbnRhaW5lciA9IE92ZXJsYXlDb250YWluZXI7XG5leHBvcnRzLkZ1bGxzY3JlZW5PdmVybGF5Q29udGFpbmVyID0gRnVsbHNjcmVlbk92ZXJsYXlDb250YWluZXI7XG5leHBvcnRzLk92ZXJsYXlSZWYgPSBPdmVybGF5UmVmO1xuZXhwb3J0cy5PdmVybGF5U3RhdGUgPSBPdmVybGF5U3RhdGU7XG5leHBvcnRzLkNvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUgPSBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlO1xuZXhwb3J0cy5PdmVybGF5T3JpZ2luID0gT3ZlcmxheU9yaWdpbjtcbmV4cG9ydHMuT3ZlcmxheU1vZHVsZSA9IE92ZXJsYXlNb2R1bGU7XG5leHBvcnRzLlNjcm9sbERpc3BhdGNoZXIgPSBTY3JvbGxEaXNwYXRjaGVyO1xuZXhwb3J0cy5HZXN0dXJlQ29uZmlnID0gR2VzdHVyZUNvbmZpZztcbmV4cG9ydHMuTWRSaXBwbGUgPSBNZFJpcHBsZTtcbmV4cG9ydHMuTWRSaXBwbGVNb2R1bGUgPSBNZFJpcHBsZU1vZHVsZTtcbmV4cG9ydHMuTGl2ZUFubm91bmNlciA9IExpdmVBbm5vdW5jZXI7XG5leHBvcnRzLkxJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4gPSBMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOO1xuZXhwb3J0cy5MSVZFX0FOTk9VTkNFUl9QUk9WSURFUiA9IExJVkVfQU5OT1VOQ0VSX1BST1ZJREVSO1xuZXhwb3J0cy5NZExpdmVBbm5vdW5jZXIgPSBMaXZlQW5ub3VuY2VyO1xuZXhwb3J0cy5Gb2N1c1RyYXAgPSBGb2N1c1RyYXA7XG5leHBvcnRzLkludGVyYWN0aXZpdHlDaGVja2VyID0gSW50ZXJhY3Rpdml0eUNoZWNrZXI7XG5leHBvcnRzLmlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIgPSBpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyO1xuZXhwb3J0cy5BMTF5TW9kdWxlID0gQTExeU1vZHVsZTtcbmV4cG9ydHMuVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlciA9IFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXI7XG5leHBvcnRzLlVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUiA9IFVOSVFVRV9TRUxFQ1RJT05fRElTUEFUQ0hFUl9QUk9WSURFUjtcbmV4cG9ydHMuTWRVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyID0gVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcjtcbmV4cG9ydHMuTWRMaW5lTW9kdWxlID0gTWRMaW5lTW9kdWxlO1xuZXhwb3J0cy5NZExpbmUgPSBNZExpbmU7XG5leHBvcnRzLk1kTGluZVNldHRlciA9IE1kTGluZVNldHRlcjtcbmV4cG9ydHMuTWRFcnJvciA9IE1kRXJyb3I7XG5leHBvcnRzLmNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eTtcbmV4cG9ydHMuY29lcmNlTnVtYmVyUHJvcGVydHkgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eTtcbmV4cG9ydHMuQ29tcGF0aWJpbGl0eU1vZHVsZSA9IENvbXBhdGliaWxpdHlNb2R1bGU7XG5leHBvcnRzLk5vQ29uZmxpY3RTdHlsZUNvbXBhdGliaWxpdHlNb2RlID0gTm9Db25mbGljdFN0eWxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLkRvbVByb2plY3Rpb25Ib3N0ID0gRG9tUHJvamVjdGlvbkhvc3Q7XG5leHBvcnRzLkRvbVByb2plY3Rpb24gPSBEb21Qcm9qZWN0aW9uO1xuZXhwb3J0cy5Qcm9qZWN0aW9uTW9kdWxlID0gUHJvamVjdGlvbk1vZHVsZTtcbmV4cG9ydHMuUGxhdGZvcm1Nb2R1bGUgPSBQbGF0Zm9ybU1vZHVsZTtcbmV4cG9ydHMuUGxhdGZvcm0gPSBQbGF0Zm9ybTtcbmV4cG9ydHMuZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcyA9IGdldFN1cHBvcnRlZElucHV0VHlwZXM7XG5leHBvcnRzLkNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kgPSBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xuZXhwb3J0cy5Db25uZWN0aW9uUG9zaXRpb25QYWlyID0gQ29ubmVjdGlvblBvc2l0aW9uUGFpcjtcbmV4cG9ydHMuU2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzID0gU2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzO1xuZXhwb3J0cy5Db25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2UgPSBDb25uZWN0ZWRPdmVybGF5UG9zaXRpb25DaGFuZ2U7XG5leHBvcnRzLlNlbGVjdGlvbk1vZGVsID0gU2VsZWN0aW9uTW9kZWw7XG5leHBvcnRzLlNlbGVjdGlvbkNoYW5nZSA9IFNlbGVjdGlvbkNoYW5nZTtcbmV4cG9ydHMuU3R5bGVNb2R1bGUgPSBTdHlsZU1vZHVsZTtcbmV4cG9ydHMuVE9VQ0hfQlVGRkVSX01TID0gVE9VQ0hfQlVGRkVSX01TO1xuZXhwb3J0cy5Gb2N1c09yaWdpbk1vbml0b3IgPSBGb2N1c09yaWdpbk1vbml0b3I7XG5leHBvcnRzLkNka0ZvY3VzQ2xhc3NlcyA9IENka0ZvY3VzQ2xhc3NlcztcbmV4cG9ydHMuRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVJfRkFDVE9SWSA9IEZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSX0ZBQ1RPUlk7XG5leHBvcnRzLkZPQ1VTX09SSUdJTl9NT05JVE9SX1BST1ZJREVSID0gRk9DVVNfT1JJR0lOX01PTklUT1JfUFJPVklERVI7XG5leHBvcnRzLmFwcGx5Q3NzVHJhbnNmb3JtID0gYXBwbHlDc3NUcmFuc2Zvcm07XG5leHBvcnRzLlVQX0FSUk9XID0gVVBfQVJST1c7XG5leHBvcnRzLkRPV05fQVJST1cgPSBET1dOX0FSUk9XO1xuZXhwb3J0cy5SSUdIVF9BUlJPVyA9IFJJR0hUX0FSUk9XO1xuZXhwb3J0cy5MRUZUX0FSUk9XID0gTEVGVF9BUlJPVztcbmV4cG9ydHMuUEFHRV9VUCA9IFBBR0VfVVA7XG5leHBvcnRzLlBBR0VfRE9XTiA9IFBBR0VfRE9XTjtcbmV4cG9ydHMuSE9NRSA9IEhPTUU7XG5leHBvcnRzLkVORCA9IEVORDtcbmV4cG9ydHMuRU5URVIgPSBFTlRFUjtcbmV4cG9ydHMuU1BBQ0UgPSBTUEFDRTtcbmV4cG9ydHMuVEFCID0gVEFCO1xuZXhwb3J0cy5FU0NBUEUgPSBFU0NBUEU7XG5leHBvcnRzLkJBQ0tTUEFDRSA9IEJBQ0tTUEFDRTtcbmV4cG9ydHMuREVMRVRFID0gREVMRVRFO1xuZXhwb3J0cy5NQVRFUklBTF9DT01QQVRJQklMSVRZX01PREUgPSBNQVRFUklBTF9DT01QQVRJQklMSVRZX01PREU7XG5leHBvcnRzLk1BVF9FTEVNRU5UU19TRUxFQ1RPUiA9IE1BVF9FTEVNRU5UU19TRUxFQ1RPUjtcbmV4cG9ydHMuTURfRUxFTUVOVFNfU0VMRUNUT1IgPSBNRF9FTEVNRU5UU19TRUxFQ1RPUjtcbmV4cG9ydHMuTWF0UHJlZml4UmVqZWN0b3IgPSBNYXRQcmVmaXhSZWplY3RvcjtcbmV4cG9ydHMuTWRQcmVmaXhSZWplY3RvciA9IE1kUHJlZml4UmVqZWN0b3I7XG5leHBvcnRzLkFuaW1hdGlvbkN1cnZlcyA9IEFuaW1hdGlvbkN1cnZlcztcbmV4cG9ydHMuQW5pbWF0aW9uRHVyYXRpb25zID0gQW5pbWF0aW9uRHVyYXRpb25zO1xuZXhwb3J0cy5NZFNlbGVjdGlvbk1vZHVsZSA9IE1kU2VsZWN0aW9uTW9kdWxlO1xuZXhwb3J0cy5NZFBzZXVkb0NoZWNrYm94ID0gTWRQc2V1ZG9DaGVja2JveDtcbmV4cG9ydHMuTWF0ZXJpYWxSb290TW9kdWxlID0gTWF0ZXJpYWxSb290TW9kdWxlO1xuZXhwb3J0cy5NYXRlcmlhbE1vZHVsZSA9IE1hdGVyaWFsTW9kdWxlO1xuZXhwb3J0cy5NZEF1dG9jb21wbGV0ZU1vZHVsZSA9IE1kQXV0b2NvbXBsZXRlTW9kdWxlO1xuZXhwb3J0cy5NZEF1dG9jb21wbGV0ZSA9IE1kQXV0b2NvbXBsZXRlO1xuZXhwb3J0cy5BVVRPQ09NUExFVEVfT1BUSU9OX0hFSUdIVCA9IEFVVE9DT01QTEVURV9PUFRJT05fSEVJR0hUO1xuZXhwb3J0cy5BVVRPQ09NUExFVEVfUEFORUxfSEVJR0hUID0gQVVUT0NPTVBMRVRFX1BBTkVMX0hFSUdIVDtcbmV4cG9ydHMuTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SID0gTURfQVVUT0NPTVBMRVRFX1ZBTFVFX0FDQ0VTU09SO1xuZXhwb3J0cy5NZEF1dG9jb21wbGV0ZVRyaWdnZXIgPSBNZEF1dG9jb21wbGV0ZVRyaWdnZXI7XG5leHBvcnRzLk1kQnV0dG9uQ3NzTWF0U3R5bGVyID0gTWRCdXR0b25Dc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kUmFpc2VkQnV0dG9uQ3NzTWF0U3R5bGVyID0gTWRSYWlzZWRCdXR0b25Dc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlciA9IE1kSWNvbkJ1dHRvbkNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRGYWJDc3NNYXRTdHlsZXIgPSBNZEZhYkNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRNaW5pRmFiQ3NzTWF0U3R5bGVyID0gTWRNaW5pRmFiQ3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZEJ1dHRvbiA9IE1kQnV0dG9uO1xuZXhwb3J0cy5NZEFuY2hvciA9IE1kQW5jaG9yO1xuZXhwb3J0cy5NZEJ1dHRvbk1vZHVsZSA9IE1kQnV0dG9uTW9kdWxlO1xuZXhwb3J0cy5NRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SID0gTURfQlVUVE9OX1RPR0dMRV9HUk9VUF9WQUxVRV9BQ0NFU1NPUjtcbmV4cG9ydHMuTWRCdXR0b25Ub2dnbGVDaGFuZ2UgPSBNZEJ1dHRvblRvZ2dsZUNoYW5nZTtcbmV4cG9ydHMuTWRCdXR0b25Ub2dnbGVHcm91cCA9IE1kQnV0dG9uVG9nZ2xlR3JvdXA7XG5leHBvcnRzLk1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSA9IE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZTtcbmV4cG9ydHMuTWRCdXR0b25Ub2dnbGUgPSBNZEJ1dHRvblRvZ2dsZTtcbmV4cG9ydHMuTWRCdXR0b25Ub2dnbGVNb2R1bGUgPSBNZEJ1dHRvblRvZ2dsZU1vZHVsZTtcbmV4cG9ydHMuTWRDYXJkQ29udGVudCA9IE1kQ2FyZENvbnRlbnQ7XG5leHBvcnRzLk1kQ2FyZFRpdGxlID0gTWRDYXJkVGl0bGU7XG5leHBvcnRzLk1kQ2FyZFN1YnRpdGxlID0gTWRDYXJkU3VidGl0bGU7XG5leHBvcnRzLk1kQ2FyZEFjdGlvbnMgPSBNZENhcmRBY3Rpb25zO1xuZXhwb3J0cy5NZENhcmRGb290ZXIgPSBNZENhcmRGb290ZXI7XG5leHBvcnRzLk1kQ2FyZFNtSW1hZ2UgPSBNZENhcmRTbUltYWdlO1xuZXhwb3J0cy5NZENhcmRNZEltYWdlID0gTWRDYXJkTWRJbWFnZTtcbmV4cG9ydHMuTWRDYXJkTGdJbWFnZSA9IE1kQ2FyZExnSW1hZ2U7XG5leHBvcnRzLk1kQ2FyZEltYWdlID0gTWRDYXJkSW1hZ2U7XG5leHBvcnRzLk1kQ2FyZFhsSW1hZ2UgPSBNZENhcmRYbEltYWdlO1xuZXhwb3J0cy5NZENhcmRBdmF0YXIgPSBNZENhcmRBdmF0YXI7XG5leHBvcnRzLk1kQ2FyZCA9IE1kQ2FyZDtcbmV4cG9ydHMuTWRDYXJkSGVhZGVyID0gTWRDYXJkSGVhZGVyO1xuZXhwb3J0cy5NZENhcmRUaXRsZUdyb3VwID0gTWRDYXJkVGl0bGVHcm91cDtcbmV4cG9ydHMuTWRDYXJkTW9kdWxlID0gTWRDYXJkTW9kdWxlO1xuZXhwb3J0cy5NZENoaXBMaXN0ID0gTWRDaGlwTGlzdDtcbmV4cG9ydHMuTWRDaGlwc01vZHVsZSA9IE1kQ2hpcHNNb2R1bGU7XG5leHBvcnRzLk1kQ2hpcCA9IE1kQ2hpcDtcbmV4cG9ydHMuTURfQ0hFQ0tCT1hfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUiA9IE1EX0NIRUNLQk9YX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I7XG5leHBvcnRzLk1kQ2hlY2tib3hDaGFuZ2UgPSBNZENoZWNrYm94Q2hhbmdlO1xuZXhwb3J0cy5NZENoZWNrYm94ID0gTWRDaGVja2JveDtcbmV4cG9ydHMuTWRDaGVja2JveE1vZHVsZSA9IE1kQ2hlY2tib3hNb2R1bGU7XG5leHBvcnRzLk1kRGlhbG9nTW9kdWxlID0gTWREaWFsb2dNb2R1bGU7XG5leHBvcnRzLk1EX0RJQUxPR19EQVRBID0gTURfRElBTE9HX0RBVEE7XG5leHBvcnRzLk1kRGlhbG9nID0gTWREaWFsb2c7XG5leHBvcnRzLk1kRGlhbG9nQ29udGFpbmVyID0gTWREaWFsb2dDb250YWluZXI7XG5leHBvcnRzLk1kRGlhbG9nQ2xvc2UgPSBNZERpYWxvZ0Nsb3NlO1xuZXhwb3J0cy5NZERpYWxvZ1RpdGxlID0gTWREaWFsb2dUaXRsZTtcbmV4cG9ydHMuTWREaWFsb2dDb250ZW50ID0gTWREaWFsb2dDb250ZW50O1xuZXhwb3J0cy5NZERpYWxvZ0FjdGlvbnMgPSBNZERpYWxvZ0FjdGlvbnM7XG5leHBvcnRzLk1kRGlhbG9nQ29uZmlnID0gTWREaWFsb2dDb25maWc7XG5leHBvcnRzLk1kRGlhbG9nUmVmID0gTWREaWFsb2dSZWY7XG5leHBvcnRzLk1kR3JpZExpc3QgPSBNZEdyaWRMaXN0O1xuZXhwb3J0cy5NZEdyaWRMaXN0TW9kdWxlID0gTWRHcmlkTGlzdE1vZHVsZTtcbmV4cG9ydHMuTWRJY29uSW52YWxpZE5hbWVFcnJvciA9IE1kSWNvbkludmFsaWROYW1lRXJyb3I7XG5leHBvcnRzLk1kSWNvbiA9IE1kSWNvbjtcbmV4cG9ydHMuSUNPTl9SRUdJU1RSWV9QUk9WSURFUl9GQUNUT1JZID0gSUNPTl9SRUdJU1RSWV9QUk9WSURFUl9GQUNUT1JZO1xuZXhwb3J0cy5JQ09OX1JFR0lTVFJZX1BST1ZJREVSID0gSUNPTl9SRUdJU1RSWV9QUk9WSURFUjtcbmV4cG9ydHMuTWRJY29uTW9kdWxlID0gTWRJY29uTW9kdWxlO1xuZXhwb3J0cy5NZEljb25SZWdpc3RyeSA9IE1kSWNvblJlZ2lzdHJ5O1xuZXhwb3J0cy5NZElucHV0TW9kdWxlID0gTWRJbnB1dE1vZHVsZTtcbmV4cG9ydHMuTWRUZXh0YXJlYUF1dG9zaXplID0gTWRUZXh0YXJlYUF1dG9zaXplO1xuZXhwb3J0cy5NZFBsYWNlaG9sZGVyID0gTWRQbGFjZWhvbGRlcjtcbmV4cG9ydHMuTWRIaW50ID0gTWRIaW50O1xuZXhwb3J0cy5NZElucHV0RGlyZWN0aXZlID0gTWRJbnB1dERpcmVjdGl2ZTtcbmV4cG9ydHMuTWRJbnB1dENvbnRhaW5lciA9IE1kSW5wdXRDb250YWluZXI7XG5leHBvcnRzLk1kSW5wdXRDb250YWluZXJQbGFjZWhvbGRlckNvbmZsaWN0RXJyb3IgPSBNZElucHV0Q29udGFpbmVyUGxhY2Vob2xkZXJDb25mbGljdEVycm9yO1xuZXhwb3J0cy5NZElucHV0Q29udGFpbmVyVW5zdXBwb3J0ZWRUeXBlRXJyb3IgPSBNZElucHV0Q29udGFpbmVyVW5zdXBwb3J0ZWRUeXBlRXJyb3I7XG5leHBvcnRzLk1kSW5wdXRDb250YWluZXJEdXBsaWNhdGVkSGludEVycm9yID0gTWRJbnB1dENvbnRhaW5lckR1cGxpY2F0ZWRIaW50RXJyb3I7XG5leHBvcnRzLk1kSW5wdXRDb250YWluZXJNaXNzaW5nTWRJbnB1dEVycm9yID0gTWRJbnB1dENvbnRhaW5lck1pc3NpbmdNZElucHV0RXJyb3I7XG5leHBvcnRzLk1kTGlzdERpdmlkZXIgPSBNZExpc3REaXZpZGVyO1xuZXhwb3J0cy5NZExpc3QgPSBNZExpc3Q7XG5leHBvcnRzLk1kTGlzdENzc01hdFN0eWxlciA9IE1kTGlzdENzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWROYXZMaXN0Q3NzTWF0U3R5bGVyID0gTWROYXZMaXN0Q3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZERpdmlkZXJDc3NNYXRTdHlsZXIgPSBNZERpdmlkZXJDc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kTGlzdEF2YXRhckNzc01hdFN0eWxlciA9IE1kTGlzdEF2YXRhckNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRMaXN0SWNvbkNzc01hdFN0eWxlciA9IE1kTGlzdEljb25Dc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlciA9IE1kTGlzdFN1YmhlYWRlckNzc01hdFN0eWxlcjtcbmV4cG9ydHMuTWRMaXN0SXRlbSA9IE1kTGlzdEl0ZW07XG5leHBvcnRzLk1kTGlzdE1vZHVsZSA9IE1kTGlzdE1vZHVsZTtcbmV4cG9ydHMuTWRNZW51VHJpZ2dlciA9IE1kTWVudVRyaWdnZXI7XG5leHBvcnRzLmZhZGVJbkl0ZW1zID0gZmFkZUluSXRlbXM7XG5leHBvcnRzLnRyYW5zZm9ybU1lbnUgPSB0cmFuc2Zvcm1NZW51O1xuZXhwb3J0cy5NZE1lbnUgPSBNZE1lbnU7XG5leHBvcnRzLk1kTWVudUl0ZW0gPSBNZE1lbnVJdGVtO1xuZXhwb3J0cy5NZE1lbnVNb2R1bGUgPSBNZE1lbnVNb2R1bGU7XG5leHBvcnRzLk1kUHJvZ3Jlc3NCYXIgPSBNZFByb2dyZXNzQmFyO1xuZXhwb3J0cy5NZFByb2dyZXNzQmFyTW9kdWxlID0gTWRQcm9ncmVzc0Jhck1vZHVsZTtcbmV4cG9ydHMuTWRQcm9ncmVzc0NpcmNsZSA9IE1kUHJvZ3Jlc3NTcGlubmVyO1xuZXhwb3J0cy5NZFByb2dyZXNzQ2lyY2xlTW9kdWxlID0gTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGU7XG5leHBvcnRzLk1kUHJvZ3Jlc3NTcGlubmVyQ3NzTWF0U3R5bGVyID0gTWRQcm9ncmVzc1NwaW5uZXJDc3NNYXRTdHlsZXI7XG5leHBvcnRzLk1kUHJvZ3Jlc3NDaXJjbGVDc3NNYXRTdHlsZXIgPSBNZFByb2dyZXNzQ2lyY2xlQ3NzTWF0U3R5bGVyO1xuZXhwb3J0cy5NZFByb2dyZXNzU3Bpbm5lciA9IE1kUHJvZ3Jlc3NTcGlubmVyO1xuZXhwb3J0cy5NZFNwaW5uZXIgPSBNZFNwaW5uZXI7XG5leHBvcnRzLk1kUHJvZ3Jlc3NTcGlubmVyTW9kdWxlID0gTWRQcm9ncmVzc1NwaW5uZXJNb2R1bGU7XG5leHBvcnRzLk1EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IgPSBNRF9SQURJT19HUk9VUF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SO1xuZXhwb3J0cy5NZFJhZGlvQ2hhbmdlID0gTWRSYWRpb0NoYW5nZTtcbmV4cG9ydHMuTWRSYWRpb0dyb3VwID0gTWRSYWRpb0dyb3VwO1xuZXhwb3J0cy5NZFJhZGlvQnV0dG9uID0gTWRSYWRpb0J1dHRvbjtcbmV4cG9ydHMuTWRSYWRpb01vZHVsZSA9IE1kUmFkaW9Nb2R1bGU7XG5leHBvcnRzLk1kU2VsZWN0TW9kdWxlID0gTWRTZWxlY3RNb2R1bGU7XG5leHBvcnRzLmZhZGVJbkNvbnRlbnQgPSBmYWRlSW5Db250ZW50O1xuZXhwb3J0cy50cmFuc2Zvcm1QYW5lbCA9IHRyYW5zZm9ybVBhbmVsO1xuZXhwb3J0cy50cmFuc2Zvcm1QbGFjZWhvbGRlciA9IHRyYW5zZm9ybVBsYWNlaG9sZGVyO1xuZXhwb3J0cy5TRUxFQ1RfT1BUSU9OX0hFSUdIVCA9IFNFTEVDVF9PUFRJT05fSEVJR0hUO1xuZXhwb3J0cy5TRUxFQ1RfUEFORUxfTUFYX0hFSUdIVCA9IFNFTEVDVF9QQU5FTF9NQVhfSEVJR0hUO1xuZXhwb3J0cy5TRUxFQ1RfTUFYX09QVElPTlNfRElTUExBWUVEID0gU0VMRUNUX01BWF9PUFRJT05TX0RJU1BMQVlFRDtcbmV4cG9ydHMuU0VMRUNUX1RSSUdHRVJfSEVJR0hUID0gU0VMRUNUX1RSSUdHRVJfSEVJR0hUO1xuZXhwb3J0cy5TRUxFQ1RfT1BUSU9OX0hFSUdIVF9BREpVU1RNRU5UID0gU0VMRUNUX09QVElPTl9IRUlHSFRfQURKVVNUTUVOVDtcbmV4cG9ydHMuU0VMRUNUX1BBTkVMX1BBRERJTkdfWCA9IFNFTEVDVF9QQU5FTF9QQURESU5HX1g7XG5leHBvcnRzLlNFTEVDVF9QQU5FTF9QQURESU5HX1kgPSBTRUxFQ1RfUEFORUxfUEFERElOR19ZO1xuZXhwb3J0cy5TRUxFQ1RfUEFORUxfVklFV1BPUlRfUEFERElORyA9IFNFTEVDVF9QQU5FTF9WSUVXUE9SVF9QQURESU5HO1xuZXhwb3J0cy5NZFNlbGVjdENoYW5nZSA9IE1kU2VsZWN0Q2hhbmdlO1xuZXhwb3J0cy5NZFNlbGVjdCA9IE1kU2VsZWN0O1xuZXhwb3J0cy5NZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IgPSBNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3I7XG5leHBvcnRzLk1kU2lkZW5hdlRvZ2dsZVJlc3VsdCA9IE1kU2lkZW5hdlRvZ2dsZVJlc3VsdDtcbmV4cG9ydHMuTWRTaWRlbmF2ID0gTWRTaWRlbmF2O1xuZXhwb3J0cy5NZFNpZGVuYXZDb250YWluZXIgPSBNZFNpZGVuYXZDb250YWluZXI7XG5leHBvcnRzLk1kU2lkZW5hdk1vZHVsZSA9IE1kU2lkZW5hdk1vZHVsZTtcbmV4cG9ydHMuTURfU0xJREVSX1ZBTFVFX0FDQ0VTU09SID0gTURfU0xJREVSX1ZBTFVFX0FDQ0VTU09SO1xuZXhwb3J0cy5NZFNsaWRlckNoYW5nZSA9IE1kU2xpZGVyQ2hhbmdlO1xuZXhwb3J0cy5NZFNsaWRlciA9IE1kU2xpZGVyO1xuZXhwb3J0cy5TbGlkZXJSZW5kZXJlciA9IFNsaWRlclJlbmRlcmVyO1xuZXhwb3J0cy5NZFNsaWRlck1vZHVsZSA9IE1kU2xpZGVyTW9kdWxlO1xuZXhwb3J0cy5NRF9TTElERV9UT0dHTEVfVkFMVUVfQUNDRVNTT1IgPSBNRF9TTElERV9UT0dHTEVfVkFMVUVfQUNDRVNTT1I7XG5leHBvcnRzLk1kU2xpZGVUb2dnbGVDaGFuZ2UgPSBNZFNsaWRlVG9nZ2xlQ2hhbmdlO1xuZXhwb3J0cy5NZFNsaWRlVG9nZ2xlID0gTWRTbGlkZVRvZ2dsZTtcbmV4cG9ydHMuTWRTbGlkZVRvZ2dsZU1vZHVsZSA9IE1kU2xpZGVUb2dnbGVNb2R1bGU7XG5leHBvcnRzLk1kU25hY2tCYXJNb2R1bGUgPSBNZFNuYWNrQmFyTW9kdWxlO1xuZXhwb3J0cy5NZFNuYWNrQmFyID0gTWRTbmFja0JhcjtcbmV4cG9ydHMuU0hPV19BTklNQVRJT04gPSBTSE9XX0FOSU1BVElPTjtcbmV4cG9ydHMuSElERV9BTklNQVRJT04gPSBISURFX0FOSU1BVElPTjtcbmV4cG9ydHMuTWRTbmFja0JhckNvbnRhaW5lciA9IE1kU25hY2tCYXJDb250YWluZXI7XG5leHBvcnRzLk1kU25hY2tCYXJDb25maWcgPSBNZFNuYWNrQmFyQ29uZmlnO1xuZXhwb3J0cy5NZFNuYWNrQmFyUmVmID0gTWRTbmFja0JhclJlZjtcbmV4cG9ydHMuU2ltcGxlU25hY2tCYXIgPSBTaW1wbGVTbmFja0JhcjtcbmV4cG9ydHMuTWRJbmtCYXIgPSBNZElua0JhcjtcbmV4cG9ydHMuTWRUYWJCb2R5ID0gTWRUYWJCb2R5O1xuZXhwb3J0cy5NZFRhYkhlYWRlciA9IE1kVGFiSGVhZGVyO1xuZXhwb3J0cy5NZFRhYkxhYmVsV3JhcHBlciA9IE1kVGFiTGFiZWxXcmFwcGVyO1xuZXhwb3J0cy5NZFRhYiA9IE1kVGFiO1xuZXhwb3J0cy5NZFRhYkxhYmVsID0gTWRUYWJMYWJlbDtcbmV4cG9ydHMuTWRUYWJDaGFuZ2VFdmVudCA9IE1kVGFiQ2hhbmdlRXZlbnQ7XG5leHBvcnRzLk1kVGFiR3JvdXAgPSBNZFRhYkdyb3VwO1xuZXhwb3J0cy5NZFRhYnNNb2R1bGUgPSBNZFRhYnNNb2R1bGU7XG5leHBvcnRzLk1kVGFiTmF2QmFyID0gTWRUYWJOYXZCYXI7XG5leHBvcnRzLk1kVGFiTGluayA9IE1kVGFiTGluaztcbmV4cG9ydHMuTWRUYWJMaW5rUmlwcGxlID0gTWRUYWJMaW5rUmlwcGxlO1xuZXhwb3J0cy5NZFRvb2xiYXJSb3cgPSBNZFRvb2xiYXJSb3c7XG5leHBvcnRzLk1kVG9vbGJhciA9IE1kVG9vbGJhcjtcbmV4cG9ydHMuTWRUb29sYmFyTW9kdWxlID0gTWRUb29sYmFyTW9kdWxlO1xuZXhwb3J0cy5UT1VDSEVORF9ISURFX0RFTEFZID0gVE9VQ0hFTkRfSElERV9ERUxBWTtcbmV4cG9ydHMuU0NST0xMX1RIUk9UVExFX01TID0gU0NST0xMX1RIUk9UVExFX01TO1xuZXhwb3J0cy5NZFRvb2x0aXAgPSBNZFRvb2x0aXA7XG5leHBvcnRzLlRvb2x0aXBDb21wb25lbnQgPSBUb29sdGlwQ29tcG9uZW50O1xuZXhwb3J0cy5NZFRvb2x0aXBNb2R1bGUgPSBNZFRvb2x0aXBNb2R1bGU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvbWF0ZXJpYWwvYnVuZGxlcy9tYXRlcmlhbC51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IE5nTW9kdWxlIH0gICAgICAgICAgICAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUsIFJvdXRlcyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbmltcG9ydCB7YXBwTG9naW5Nb2R1bGV9IGZyb20gJy4uL2FwcExvZ2luTW9kdWxlL2xvZ2luLm1vZHVsZSc7XG5pbXBvcnQge0xvZ2luMUNvbXBvbmVudH0gZnJvbSAnLi4vYXBwTG9naW5Nb2R1bGUvbG9naW4xLmNvbXBvbmVudCdcbmNvbnN0IGFwcFJvdXRlczogUm91dGVzID0gW1xuXG4gICAgeyBwYXRoOiAnbG9naW4nLCBjb21wb25lbnQ6IExvZ2luMUNvbXBvbmVudCB9LFxuICAgIHsgcGF0aDogJycsIGNvbXBvbmVudDogTG9naW4xQ29tcG9uZW50IH0sXG5cbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBSb3V0ZXJNb2R1bGUuZm9yUm9vdChhcHBSb3V0ZXMseyB1c2VIYXNoOiB0cnVlIH0pLFxuICAgIGFwcExvZ2luTW9kdWxlLCBcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBSb3V0ZXJNb2R1bGVcbiAgXSxcblxufSlcbmV4cG9ydCBjbGFzcyBBcHBSb3V0aW5nTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwUm91dGVyTW9kdWxlL2FwcFJvdXRlci5tb2R1bGUudHMiLCJpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdsb2dpbjEtZm9ybScsXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2xvZ2luMS5odG1sJyksXG4gIC8vIGRpcmVjdGl2ZXM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBMb2dpbjFDb21wb25lbnQge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL3NyYy9hcHBMb2dpbk1vZHVsZS9sb2dpbjEuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxtZC1pbnB1dC1jb250YWluZXI+XFxuICA8aW5wdXQgbWRJbnB1dCBwbGFjZWhvbGRlcj1cXFwiRmF2b3JpdGUgZm9vZFxcXCIgdmFsdWU9XFxcIlN1c2hpXFxcIj5cXG48L21kLWlucHV0LWNvbnRhaW5lcj5cXG5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9zcmMvYXBwTG9naW5Nb2R1bGUvbG9naW4xLmh0bWxcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7Q29tcG9uZW50fSAgICAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICB0ZW1wbGF0ZTogIGA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+YCxcbn0pXG5cbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9zcmMvYXBwLmNvbXBvbmVudC50cyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAvc3JjL2Fzc2V0cy9zdHlsZS9zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtMb2dpbjFDb21wb25lbnR9IGZyb20gJy4vbG9naW4xLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbkBOZ01vZHVsZSh7XG5cdGltcG9ydHM6IFtcblx0XHRNYXRlcmlhbE1vZHVsZS5mb3JSb290KCksXG5cdF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIExvZ2luMUNvbXBvbmVudCxcbiAgICAgICBcbiAgICBdLFxuICAgIGV4cG9ydHM6W1xuICAgICAgICBMb2dpbjFDb21wb25lbnRcbiAgICBdLFxufSlcbmV4cG9ydCBjbGFzcyBhcHBMb2dpbk1vZHVsZSB7fVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvc3JjL2FwcExvZ2luTW9kdWxlL2xvZ2luLm1vZHVsZS50cyJdLCJzb3VyY2VSb290IjoiIn0=